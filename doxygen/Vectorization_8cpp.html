<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Linalg/Transforms/Vectorization.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">20.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_8edb792440615361a0811a7329611599.html">Linalg</a></li><li class="navelem"><a class="el" href="dir_7e2f808e77498894ca0efbd745da2201.html">Transforms</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Vectorization.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Dialect_2Affine_2Utils_8h_source.html">mlir/Dialect/Affine/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SliceAnalysis_8h_source.html">mlir/Analysis/SliceAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Arith_2IR_2Arith_8h_source.html">mlir/Dialect/Arith/IR/Arith.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="FuncOps_8h_source.html">mlir/Dialect/Func/IR/FuncOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Linalg_2IR_2Linalg_8h_source.html">mlir/Dialect/Linalg/IR/Linalg.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">mlir/Dialect/Linalg/Transforms/Transforms.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">mlir/Dialect/Linalg/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Tensor_2IR_2Tensor_8h_source.html">mlir/Dialect/Tensor/IR/Tensor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Tensor_2Utils_2Utils_8h_source.html">mlir/Dialect/Tensor/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IndexingUtils_8h_source.html">mlir/Dialect/Utils/IndexingUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="StructuredOpsUtils_8h_source.html">mlir/Dialect/Utils/StructuredOpsUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="VectorOps_8h_source.html">mlir/Dialect/Vector/IR/VectorOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MaskableOpInterface_8h_source.html">mlir/Dialect/Vector/Interfaces/MaskableOpInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="VectorUtils_8h_source.html">mlir/Dialect/Vector/Utils/VectorUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">mlir/IR/AffineExpr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Builders_8h_source.html">mlir/IR/Builders.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="BuiltinTypeInterfaces_8h_source.html">mlir/IR/BuiltinTypeInterfaces.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html">mlir/IR/BuiltinTypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="OpDefinition_8h_source.html">mlir/IR/OpDefinition.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">mlir/IR/PatternMatch.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Support_2LLVM_8h_source.html">mlir/Support/LLVM.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="RegionUtils_8h_source.html">mlir/Transforms/RegionUtils.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
<code>#include &quot;llvm/ADT/Sequence.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallVector.h&quot;</code><br />
<code>#include &quot;llvm/ADT/TypeSwitch.h&quot;</code><br />
<code>#include &quot;llvm/ADT/iterator_range.h&quot;</code><br />
<code>#include &quot;llvm/Support/Debug.h&quot;</code><br />
<code>#include &quot;llvm/Support/MathExtras.h&quot;</code><br />
<code>#include &quot;llvm/Support/raw_ostream.h&quot;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
</div>
<p><a href="Vectorization_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVectorizationState.html">VectorizationState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the vectorization state and related methods used across the vectorization process of a given operation.  <a href="structVectorizationState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVectorizationResult.html">VectorizationResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGenericPadOpVectorizationPattern.html">GenericPadOpVectorizationPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a tensor::PadOp into a sequence of EmptyOp, FillOp and InsertSliceOp.  <a href="structGenericPadOpVectorizationPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVectorizePadOpUserPattern.html">VectorizePadOpUserPattern&lt; OpTy &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base pattern for rewriting tensor::PadOps whose result is consumed by a given operation type OpTy.  <a href="structVectorizePadOpUserPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPadOpVectorizationWithTransferReadPattern.html">PadOpVectorizationWithTransferReadPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite use of tensor::PadOp result in TransferReadOp.  <a href="structPadOpVectorizationWithTransferReadPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPadOpVectorizationWithTransferWritePattern.html">PadOpVectorizationWithTransferWritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite use of tensor::PadOp result in TransferWriteOp.  <a href="structPadOpVectorizationWithTransferWritePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPadOpVectorizationWithInsertSlicePattern.html">PadOpVectorizationWithInsertSlicePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite use of tensor::PadOp result in InsertSliceOp.  <a href="structPadOpVectorizationWithInsertSlicePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVectorizeConvolution.html">VectorizeConvolution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;linalg-vectorization&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0bb487c37194ac844a13205a7edcefc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#ae0bb487c37194ac844a13205a7edcefc">DBGS</a>()&#160;&#160;&#160;(llvm::dbgs() &lt;&lt; '[' &lt;&lt; <a class="el" href="LoopInvariantCodeMotionUtils_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a> &lt;&lt; &quot;] &quot;)</td></tr>
<tr class="separator:ae0bb487c37194ac844a13205a7edcefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb7bbd2151d1599f0a2a4dd7be89253"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#aebb7bbd2151d1599f0a2a4dd7be89253">LDBG</a>(X)&#160;&#160;&#160;LLVM_DEBUG(<a class="el" href="XeGPUFoldAliasOps_8cpp.html#ae0bb487c37194ac844a13205a7edcefc">DBGS</a>() &lt;&lt; X &lt;&lt; &quot;\n&quot;)</td></tr>
<tr class="separator:aebb7bbd2151d1599f0a2a4dd7be89253"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9b7d2592a2bad4ef2be89bf0d7efd19a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a9b7d2592a2bad4ef2be89bf0d7efd19a">CustomVectorizationPrecondition</a> = std::function&lt; LogicalResult(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, bool)&gt;</td></tr>
<tr class="separator:a9b7d2592a2bad4ef2be89bf0d7efd19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8443b89e0fe829933ac02916251ce4f3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a8443b89e0fe829933ac02916251ce4f3">CustomVectorizationHook</a> = std::function&lt; <a class="el" href="structVectorizationResult.html">VectorizationResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;)&gt;</td></tr>
<tr class="separator:a8443b89e0fe829933ac02916251ce4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a88081210ed22e2f80c50dd07348f3fec"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a88081210ed22e2f80c50dd07348f3fec">Conv1DOpOrder</a> { <a class="el" href="Vectorization_8cpp.html#a88081210ed22e2f80c50dd07348f3feca61e9c06ea9a85a5088a499df6458d276">W</a>
, <a class="el" href="Vectorization_8cpp.html#a88081210ed22e2f80c50dd07348f3feca93d1093d4ebc345b0e2d3520c41ca741">Ncw</a>
, <a class="el" href="Vectorization_8cpp.html#a88081210ed22e2f80c50dd07348f3fecacca9538f495516027540f166e6ca3ba3">Nwc</a>
 }</td></tr>
<tr class="memdesc:a88081210ed22e2f80c50dd07348f3fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper enum to represent conv1d input traversal order.  <a href="Vectorization_8cpp.html#a88081210ed22e2f80c50dd07348f3fec">More...</a><br /></td></tr>
<tr class="separator:a88081210ed22e2f80c50dd07348f3fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad138b2ed2839f1b552ed674585cacad3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#ad138b2ed2839f1b552ed674585cacad3">VectorizationStatus</a> { <a class="el" href="Vectorization_8cpp.html#ad138b2ed2839f1b552ed674585cacad3a6fb01c5d76aa5b0825fd3c52dc5f3661">Failure</a> = 0
, <a class="el" href="Vectorization_8cpp.html#ad138b2ed2839f1b552ed674585cacad3af97b2f48071b6944652bfffb71351c8f">NoReplace</a>
, <a class="el" href="Vectorization_8cpp.html#ad138b2ed2839f1b552ed674585cacad3aaaf8d13847a58092eb64f52b2bed99c6">NewOp</a>
 }</td></tr>
<tr class="memdesc:ad138b2ed2839f1b552ed674585cacad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper data structure to represent the result of vectorization.  <a href="Vectorization_8cpp.html#ad138b2ed2839f1b552ed674585cacad3">More...</a><br /></td></tr>
<tr class="separator:ad138b2ed2839f1b552ed674585cacad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224b215237fb8401f7031f2991266dcc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a224b215237fb8401f7031f2991266dcc">VectorMemoryAccessKind</a> { <a class="el" href="Vectorization_8cpp.html#a224b215237fb8401f7031f2991266dccae08c87afc59477607178b88f356268ca">ScalarBroadcast</a>
, <a class="el" href="Vectorization_8cpp.html#a224b215237fb8401f7031f2991266dcca1910b77e1772ac1536cb49936f8c32ea">Contiguous</a>
, <a class="el" href="Vectorization_8cpp.html#a224b215237fb8401f7031f2991266dccaceba1db2e3b2f5aa1258aae0105e2a4d">Gather</a>
 }</td></tr>
<tr class="separator:a224b215237fb8401f7031f2991266dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a320b06f6c6f3905541d59f2c33ce5aea"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a320b06f6c6f3905541d59f2c33ce5aea">vectorizeConvolution</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp convOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inputVecSizes={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt; inputVecScalableFlags={}, bool flatten1DDepthwiseConv=false)</td></tr>
<tr class="memdesc:a320b06f6c6f3905541d59f2c33ce5aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to vectorize <code>convOp</code> as a convolution.  <a href="Vectorization_8cpp.html#a320b06f6c6f3905541d59f2c33ce5aea">More...</a><br /></td></tr>
<tr class="separator:a320b06f6c6f3905541d59f2c33ce5aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37ae3178304b744d6b0249a60a6e7a3"><td class="memTemplParams" colspan="2">template&lt;typename OpType &gt; </td></tr>
<tr class="memitem:ab37ae3178304b744d6b0249a60a6e7a3"><td class="memTemplItemLeft" align="right" valign="top">static OpType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#ab37ae3178304b744d6b0249a60a6e7a3">getSingleOpOfType</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> &amp;block)</td></tr>
<tr class="memdesc:ab37ae3178304b744d6b0249a60a6e7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unique instance of OpType in <code>block</code> if it is indeed unique.  <a href="Vectorization_8cpp.html#ab37ae3178304b744d6b0249a60a6e7a3">More...</a><br /></td></tr>
<tr class="separator:ab37ae3178304b744d6b0249a60a6e7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a2f2306467feacee5865c5be9c0401"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a41a2f2306467feacee5865c5be9c0401">extractConvInputSlices</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> input, int64_t nSize, int64_t wSize, int64_t cSize, int64_t kwSize, int strideW, int dilationW, int64_t wSizeStep, bool isSingleChanneled)</td></tr>
<tr class="memdesc:a41a2f2306467feacee5865c5be9c0401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to extract the input slices after filter is unrolled along kw.  <a href="Vectorization_8cpp.html#a41a2f2306467feacee5865c5be9c0401">More...</a><br /></td></tr>
<tr class="separator:a41a2f2306467feacee5865c5be9c0401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313dd728e35dcd639ff665bcc97d81ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a313dd728e35dcd639ff665bcc97d81ad">extractConvFilterSlices</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> filter, int64_t kwSize)</td></tr>
<tr class="memdesc:a313dd728e35dcd639ff665bcc97d81ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to extract the filter slices after filter is unrolled along kw.  <a href="Vectorization_8cpp.html#a313dd728e35dcd639ff665bcc97d81ad">More...</a><br /></td></tr>
<tr class="separator:a313dd728e35dcd639ff665bcc97d81ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4a6208d725462b6ab07ee8310da2f1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#abe4a6208d725462b6ab07ee8310da2f1">extractConvResultSlices</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> res, int64_t nSize, int64_t wSize, int64_t fSize, int64_t wSizeStep, bool isSingleChanneled)</td></tr>
<tr class="memdesc:abe4a6208d725462b6ab07ee8310da2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to extract the result slices after filter is unrolled along kw.  <a href="Vectorization_8cpp.html#abe4a6208d725462b6ab07ee8310da2f1">More...</a><br /></td></tr>
<tr class="separator:abe4a6208d725462b6ab07ee8310da2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110d1ed6891097419f0358bd63e974c8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a110d1ed6891097419f0358bd63e974c8">insertConvResultSlices</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> res, int64_t wSize, int64_t wSizeStep, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;resVals, bool isSingleChanneled)</td></tr>
<tr class="memdesc:a110d1ed6891097419f0358bd63e974c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to insert the computed result slices.  <a href="Vectorization_8cpp.html#a110d1ed6891097419f0358bd63e974c8">More...</a><br /></td></tr>
<tr class="separator:a110d1ed6891097419f0358bd63e974c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2ca9537983c711e37b040688830950"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#ace2ca9537983c711e37b040688830950">reindexIndexingMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:ace2ca9537983c711e37b040688830950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an indexing <code>map</code> coming from a LinalgOp indexing, restricted to a projectedPermutation, compress the unused dimensions to serve as a permutation_map for a vector transfer operation.  <a href="Vectorization_8cpp.html#ace2ca9537983c711e37b040688830950">More...</a><br /></td></tr>
<tr class="separator:ace2ca9537983c711e37b040688830950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cbb7a1a1669d28a2e2f4b221a2132f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a69cbb7a1a1669d28a2e2f4b221a2132f">matchLinalgReduction</a> (<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *outputOperand)</td></tr>
<tr class="memdesc:a69cbb7a1a1669d28a2e2f4b221a2132f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether <code>outputOperand</code> is a reduction with a single combiner operation.  <a href="Vectorization_8cpp.html#a69cbb7a1a1669d28a2e2f4b221a2132f">More...</a><br /></td></tr>
<tr class="separator:a69cbb7a1a1669d28a2e2f4b221a2132f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a45e985a37cbb4db1c7c23ce0d9e9f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#ae3a45e985a37cbb4db1c7c23ce0d9e9f">broadcastIfNeeded</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classmlir_1_1Type.html">Type</a> dstType)</td></tr>
<tr class="memdesc:ae3a45e985a37cbb4db1c7c23ce0d9e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast <code>value</code> to a vector of <code>shape</code> if possible.  <a href="Vectorization_8cpp.html#ae3a45e985a37cbb4db1c7c23ce0d9e9f">More...</a><br /></td></tr>
<tr class="separator:ae3a45e985a37cbb4db1c7c23ce0d9e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786634b3fadeefcfe74e0c22f18312f1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a786634b3fadeefcfe74e0c22f18312f1">buildMultiDimReduce</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *reduceOp, <a class="el" href="classmlir_1_1Value.html">Value</a> valueToReduce, <a class="el" href="classmlir_1_1Value.html">Value</a> acc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt; dimsToMask)</td></tr>
<tr class="memdesc:a786634b3fadeefcfe74e0c22f18312f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create MultiDimReductionOp to compute the reduction for <code>reductionOp</code>.  <a href="Vectorization_8cpp.html#a786634b3fadeefcfe74e0c22f18312f1">More...</a><br /></td></tr>
<tr class="separator:a786634b3fadeefcfe74e0c22f18312f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26a024dfac331ddb29bc4a78271b9d0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#ae26a024dfac331ddb29bc4a78271b9d0">getDimsToReduce</a> (LinalgOp linalgOp)</td></tr>
<tr class="separator:ae26a024dfac331ddb29bc4a78271b9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66021212cd375df8f87b79b0f01b7e19"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a66021212cd375df8f87b79b0f01b7e19">hasReductionIterator</a> (LinalgOp &amp;op)</td></tr>
<tr class="memdesc:a66021212cd375df8f87b79b0f01b7e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>op</code> is a linalg.reduce or a linalg.generic that has at least one reduction iterator.  <a href="Vectorization_8cpp.html#a66021212cd375df8f87b79b0f01b7e19">More...</a><br /></td></tr>
<tr class="separator:a66021212cd375df8f87b79b0f01b7e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffeefd6b3cba67afe11ecdc2b48fcef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a4ffeefd6b3cba67afe11ecdc2b48fcef">buildVectorWrite</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *outputOperand, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state)</td></tr>
<tr class="memdesc:a4ffeefd6b3cba67afe11ecdc2b48fcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a vector.transfer_write of <code>value</code> into <code>outputOperand</code> at indices set to all <code>0</code>; where <code>outputOperand</code> is an output operand of the LinalgOp currently being vectorized.  <a href="Vectorization_8cpp.html#a4ffeefd6b3cba67afe11ecdc2b48fcef">More...</a><br /></td></tr>
<tr class="separator:a4ffeefd6b3cba67afe11ecdc2b48fcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9560e3a36a7bb7bc493da9c6ef26c1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structVectorizationResult.html">VectorizationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a3b9560e3a36a7bb7bc493da9c6ef26c1">vectorizeLinalgYield</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;bvm, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state, LinalgOp linalgOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;newResults)</td></tr>
<tr class="memdesc:a3b9560e3a36a7bb7bc493da9c6ef26c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to vectorize the terminator of a <code>linalgOp</code>.  <a href="Vectorization_8cpp.html#a3b9560e3a36a7bb7bc493da9c6ef26c1">More...</a><br /></td></tr>
<tr class="separator:a3b9560e3a36a7bb7bc493da9c6ef26c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b07daffcd1b5a090273117573bf751b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structVectorizationResult.html">VectorizationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a9b07daffcd1b5a090273117573bf751b">vectorizeLinalgIndex</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a9b07daffcd1b5a090273117573bf751b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to vectorize the index operations of a <code>linalgOp</code>.  <a href="Vectorization_8cpp.html#a9b07daffcd1b5a090273117573bf751b">More...</a><br /></td></tr>
<tr class="separator:a9b07daffcd1b5a090273117573bf751b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09df73d48432e3de8291c7076164ba7"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#ad09df73d48432e3de8291c7076164ba7">tensorExtractVectorizationPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, bool vectorizeNDExtract)</td></tr>
<tr class="memdesc:ad09df73d48432e3de8291c7076164ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to check if the tensor.extract can be vectorized by the custom hook vectorizeTensorExtract.  <a href="Vectorization_8cpp.html#ad09df73d48432e3de8291c7076164ba7">More...</a><br /></td></tr>
<tr class="separator:ad09df73d48432e3de8291c7076164ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4411a5d89520c86474035493a7da7c1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#ae4411a5d89520c86474035493a7da7c1">calculateGatherOffset</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state, tensor::ExtractOp extractOp, const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;bvm)</td></tr>
<tr class="memdesc:ae4411a5d89520c86474035493a7da7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the offsets (<code>$index_vec</code>) for <code>vector.gather</code> operations generated from <code>tensor.extract</code>.  <a href="Vectorization_8cpp.html#ae4411a5d89520c86474035493a7da7c1">More...</a><br /></td></tr>
<tr class="separator:ae4411a5d89520c86474035493a7da7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9ce28bca426dd4de93ad09392b4ec1"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a7e9ce28bca426dd4de93ad09392b4ec1">getTrailingNonUnitLoopDimIdx</a> (LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a7e9ce28bca426dd4de93ad09392b4ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index of the trailing non-unit dim in linalgOp.  <a href="Vectorization_8cpp.html#a7e9ce28bca426dd4de93ad09392b4ec1">More...</a><br /></td></tr>
<tr class="separator:a7e9ce28bca426dd4de93ad09392b4ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcdc4b64d42010b23b271435831cb39"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a0bcdc4b64d42010b23b271435831cb39">isLoopInvariantIdx</a> (LinalgOp &amp;linalgOp, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;val, VectorType resType)</td></tr>
<tr class="memdesc:a0bcdc4b64d42010b23b271435831cb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>val</code> can be used for calculating a loop invariant index.  <a href="Vectorization_8cpp.html#a0bcdc4b64d42010b23b271435831cb39">More...</a><br /></td></tr>
<tr class="separator:a0bcdc4b64d42010b23b271435831cb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f7690c564bae0d01129c661bfcb1f3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#af2f7690c564bae0d01129c661bfcb1f3">isContiguousLoadIdx</a> (LinalgOp &amp;linalgOp, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;val, bool &amp;foundIndexOp, VectorType resType)</td></tr>
<tr class="memdesc:af2f7690c564bae0d01129c661bfcb1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether <code>val</code> could be used for calculating the trailing index for a contiguous load operation.  <a href="Vectorization_8cpp.html#af2f7690c564bae0d01129c661bfcb1f3">More...</a><br /></td></tr>
<tr class="separator:af2f7690c564bae0d01129c661bfcb1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172594be3a7384cb03a833aed99dc03c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="Vectorization_8cpp.html#a224b215237fb8401f7031f2991266dcc">VectorMemoryAccessKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a172594be3a7384cb03a833aed99dc03c">getTensorExtractMemoryAccessPattern</a> (tensor::ExtractOp extractOp, LinalgOp &amp;linalgOp, VectorType resType)</td></tr>
<tr class="memdesc:a172594be3a7384cb03a833aed99dc03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the memory access pattern for the input ExtractOp.  <a href="Vectorization_8cpp.html#a172594be3a7384cb03a833aed99dc03c">More...</a><br /></td></tr>
<tr class="separator:a172594be3a7384cb03a833aed99dc03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701e5d65843787d297c79a5a7304ad7d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structVectorizationResult.html">VectorizationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a701e5d65843787d297c79a5a7304ad7d">vectorizeTensorExtract</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, LinalgOp linalgOp, const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;bvm)</td></tr>
<tr class="memdesc:a701e5d65843787d297c79a5a7304ad7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to vectorize the tensor.extract operations.  <a href="Vectorization_8cpp.html#a701e5d65843787d297c79a5a7304ad7d">More...</a><br /></td></tr>
<tr class="separator:a701e5d65843787d297c79a5a7304ad7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b9b71ed8f443a028671c1eb661054d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a53b9b71ed8f443a028671c1eb661054d">reduceIfNeeded</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp linalgOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Value.html">Value</a> reduceValue, <a class="el" href="classmlir_1_1Value.html">Value</a> initialValue, const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;bvm)</td></tr>
<tr class="memdesc:a53b9b71ed8f443a028671c1eb661054d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit reduction operations if the shapes of the value to reduce is different that the result shape.  <a href="Vectorization_8cpp.html#a53b9b71ed8f443a028671c1eb661054d">More...</a><br /></td></tr>
<tr class="separator:a53b9b71ed8f443a028671c1eb661054d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f622d98314b8edb8f6623408939e81c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structVectorizationResult.html">VectorizationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a1f622d98314b8edb8f6623408939e81c">vectorizeOneOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state, LinalgOp linalgOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;bvm, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="Vectorization_8cpp.html#a8443b89e0fe829933ac02916251ce4f3">CustomVectorizationHook</a> &gt; customVectorizationHooks)</td></tr>
<tr class="memdesc:a1f622d98314b8edb8f6623408939e81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic vectorization for a single operation <code>op</code>, given already vectorized operands carried by <code>bvm</code>.  <a href="Vectorization_8cpp.html#a1f622d98314b8edb8f6623408939e81c">More...</a><br /></td></tr>
<tr class="separator:a1f622d98314b8edb8f6623408939e81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e1ec347850959af0bc7cbdf61b9da3"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a35e1ec347850959af0bc7cbdf61b9da3">vectorizeAsLinalgGeneric</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state, LinalgOp linalgOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;newResults)</td></tr>
<tr class="memdesc:a35e1ec347850959af0bc7cbdf61b9da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic vectorization function that rewrites the body of a <code>linalgOp</code> into vector form.  <a href="Vectorization_8cpp.html#a35e1ec347850959af0bc7cbdf61b9da3">More...</a><br /></td></tr>
<tr class="separator:a35e1ec347850959af0bc7cbdf61b9da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c04606a4567ce9f7e1041b8147f9ba"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a42c04606a4567ce9f7e1041b8147f9ba">getTiledPackShape</a> (tensor::PackOp packOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; destShape)</td></tr>
<tr class="memdesc:a42c04606a4567ce9f7e1041b8147f9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a tensor::PackOp, return the <code>dest</code> shape before any packing permutations.  <a href="Vectorization_8cpp.html#a42c04606a4567ce9f7e1041b8147f9ba">More...</a><br /></td></tr>
<tr class="separator:a42c04606a4567ce9f7e1041b8147f9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205af1d73acfcfa85403a7ec3e5bf471"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a205af1d73acfcfa85403a7ec3e5bf471">createWriteOrMaskedWrite</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> input, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; destSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inputVectorSizes, bool useInBoundsInsteadOfMasking)</td></tr>
<tr class="memdesc:a205af1d73acfcfa85403a7ec3e5bf471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input, the mixed destSizes, and the vector sizes for vectorization, create an empty destination tensor and create a TransferWriteOp from the input to the empty tensor.  <a href="Vectorization_8cpp.html#a205af1d73acfcfa85403a7ec3e5bf471">More...</a><br /></td></tr>
<tr class="separator:a205af1d73acfcfa85403a7ec3e5bf471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab952d864e63af3ebc5fad26dab689ffc"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#ab952d864e63af3ebc5fad26dab689ffc">vectorizeAsTensorPackOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::PackOp packOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inputVectorSizes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;newResults)</td></tr>
<tr class="memdesc:ab952d864e63af3ebc5fad26dab689ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorize tensor::PackOp with (1) static innerTiles (2) constant padding value and (3) input vector sizes into: masked_transfer_read-&gt;shape_cast-&gt;transpose-&gt;transfer_write_in_bounds As in the following example: pack = tensor.pack src inner_dims_pos = [2, 1] inner_tiles = [16, 2] into dst : tensor&lt;32x8x16xf32&gt; -&gt; tensor&lt;32x4x1x16x2xf32&gt;  <a href="Vectorization_8cpp.html#ab952d864e63af3ebc5fad26dab689ffc">More...</a><br /></td></tr>
<tr class="separator:ab952d864e63af3ebc5fad26dab689ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ec13821576a9a6422b100ab9bc69e3"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#aa7ec13821576a9a6422b100ab9bc69e3">vectorizeAsTensorUnpackOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::UnPackOp unpackOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inputVectorSizes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;newResults)</td></tr>
<tr class="memdesc:aa7ec13821576a9a6422b100ab9bc69e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorize a <code>tensor::UnPackOp</code> to these 4 Ops: Vector::TransferReadOp - Reads a vector from the source tensor vector::TransposeOp - Transpose the Source tensor ShapeCastOp - Reshape the data based on the target.  <a href="Vectorization_8cpp.html#aa7ec13821576a9a6422b100ab9bc69e3">More...</a><br /></td></tr>
<tr class="separator:aa7ec13821576a9a6422b100ab9bc69e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d343eff4117b4738a97dea5eb4d4bd"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#af8d343eff4117b4738a97dea5eb4d4bd">vectorizeAsTensorPadOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::PadOp padOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inputVectorSizes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;newResults)</td></tr>
<tr class="memdesc:af8d343eff4117b4738a97dea5eb4d4bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorize a <code>padOp</code> with (1) static result type, (2) constant padding value and (3) all-zero lowPad to <code>transfer_write_in_bounds(transfer_read_masked(pad_source, pad_value))</code>.  <a href="Vectorization_8cpp.html#af8d343eff4117b4738a97dea5eb4d4bd">More...</a><br /></td></tr>
<tr class="separator:af8d343eff4117b4738a97dea5eb4d4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee50532663d56946548afe0ff92509c"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a1ee50532663d56946548afe0ff92509c">reductionPreconditions</a> (LinalgOp op)</td></tr>
<tr class="separator:a1ee50532663d56946548afe0ff92509c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ef02407dc9f6a46da43369638fbbe8"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#ad6ef02407dc9f6a46da43369638fbbe8">vectorizeDynamicConvOpPrecondition</a> (linalg::LinalgOp conv, bool flatten1DDepthwiseConv)</td></tr>
<tr class="separator:ad6ef02407dc9f6a46da43369638fbbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9361ccf3f87080ceace5da1af0d2e522"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a9361ccf3f87080ceace5da1af0d2e522">vectorizeDynamicLinalgOpPrecondition</a> (linalg::LinalgOp op, bool flatten1DDepthwiseConv)</td></tr>
<tr class="separator:a9361ccf3f87080ceace5da1af0d2e522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b5ead78da7e0e4b5b39dc1e236d0d6"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#ad9b5ead78da7e0e4b5b39dc1e236d0d6">vectorizeUnPackOpPrecondition</a> (tensor::UnPackOp unpackOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inputVectorSizes)</td></tr>
<tr class="memdesc:ad9b5ead78da7e0e4b5b39dc1e236d0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Need to check if the inner-tiles are static/constant.  <a href="Vectorization_8cpp.html#ad9b5ead78da7e0e4b5b39dc1e236d0d6">More...</a><br /></td></tr>
<tr class="separator:ad9b5ead78da7e0e4b5b39dc1e236d0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd38e6c601b328398794c7d9d092b43"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#acdd38e6c601b328398794c7d9d092b43">vectorizeLinalgOpPrecondition</a> (LinalgOp linalgOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inputVectorSizes, bool vectorizeNDExtract, bool flatten1DDepthwiseConv)</td></tr>
<tr class="separator:acdd38e6c601b328398794c7d9d092b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531e61d51c1ecce5e08726e38f6add88"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a531e61d51c1ecce5e08726e38f6add88">vectorizePackOpPrecondition</a> (tensor::PackOp packOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inputVectorSizes)</td></tr>
<tr class="separator:a531e61d51c1ecce5e08726e38f6add88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2260cd7405010dc09da594212af829"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a2d2260cd7405010dc09da594212af829">vectorizePadOpPrecondition</a> (tensor::PadOp padOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inputVectorSizes)</td></tr>
<tr class="separator:a2d2260cd7405010dc09da594212af829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed76d5bbb8b5413dcba7a1b210d50f7c"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#aed76d5bbb8b5413dcba7a1b210d50f7c">vectorizeScalableVectorPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inputVectorSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt; inputScalableVecDims)</td></tr>
<tr class="memdesc:aed76d5bbb8b5413dcba7a1b210d50f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preconditions for scalable vectors.  <a href="Vectorization_8cpp.html#aed76d5bbb8b5413dcba7a1b210d50f7c">More...</a><br /></td></tr>
<tr class="separator:aed76d5bbb8b5413dcba7a1b210d50f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab700681cb96772dbfd106a67ec408af"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#aab700681cb96772dbfd106a67ec408af">convertAffineApply</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:aab700681cb96772dbfd106a67ec408af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts affine.apply Ops to arithmetic operations.  <a href="Vectorization_8cpp.html#aab700681cb96772dbfd106a67ec408af">More...</a><br /></td></tr>
<tr class="separator:aab700681cb96772dbfd106a67ec408af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7032281b63b095fca6221acc1e63c50"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#ae7032281b63b095fca6221acc1e63c50">getIntFromAttr</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:ae7032281b63b095fca6221acc1e63c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that retrieves the value of an IntegerAttr.  <a href="Vectorization_8cpp.html#ae7032281b63b095fca6221acc1e63c50">More...</a><br /></td></tr>
<tr class="separator:ae7032281b63b095fca6221acc1e63c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18489393ec5b4e72d0cb6c990d72376"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#ac18489393ec5b4e72d0cb6c990d72376">ofrToIndexValues</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ofrs)</td></tr>
<tr class="memdesc:ac18489393ec5b4e72d0cb6c990d72376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an ArrayRef of OpFoldResults, return a vector of Values.  <a href="Vectorization_8cpp.html#ac18489393ec5b4e72d0cb6c990d72376">More...</a><br /></td></tr>
<tr class="separator:ac18489393ec5b4e72d0cb6c990d72376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69be050ec61bb7c731b8666ca80f832f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a69be050ec61bb7c731b8666ca80f832f">mayExistInterleavedUses</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *firstOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *secondOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values)</td></tr>
<tr class="memdesc:a69be050ec61bb7c731b8666ca80f832f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether there is any interleaved use of any <code>values</code> between <code>firstOp</code> and <code>secondOp</code>.  <a href="Vectorization_8cpp.html#a69be050ec61bb7c731b8666ca80f832f">More...</a><br /></td></tr>
<tr class="separator:a69be050ec61bb7c731b8666ca80f832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035a7bd3b44d215db6d50b32318822c0"><td class="memItemLeft" align="right" valign="top">static memref::SubViewOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a035a7bd3b44d215db6d50b32318822c0">getSubViewUseIfUnique</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> v)</td></tr>
<tr class="memdesc:a035a7bd3b44d215db6d50b32318822c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unique subview use of <code>v</code> if it is indeed unique, null otherwise.  <a href="Vectorization_8cpp.html#a035a7bd3b44d215db6d50b32318822c0">More...</a><br /></td></tr>
<tr class="separator:a035a7bd3b44d215db6d50b32318822c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1d008a71edcf988a6fa4575a1c0266"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a5d1d008a71edcf988a6fa4575a1c0266"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a5d1d008a71edcf988a6fa4575a1c0266">bindShapeDims</a> (ShapedType shapedType)</td></tr>
<tr class="separator:a5d1d008a71edcf988a6fa4575a1c0266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733cad761b049560f9c8e85ff51e722e"><td class="memTemplParams" colspan="2">template&lt;int N, typename IntTy , typename... IntTy2&gt; </td></tr>
<tr class="memitem:a733cad761b049560f9c8e85ff51e722e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a733cad761b049560f9c8e85ff51e722e">bindShapeDims</a> (ShapedType shapedType, IntTy &amp;val, IntTy2 &amp;...vals)</td></tr>
<tr class="separator:a733cad761b049560f9c8e85ff51e722e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc8c9f4f7a24f5ad59b3df2eaf2b949"><td class="memTemplParams" colspan="2">template&lt;typename... IntTy&gt; </td></tr>
<tr class="memitem:a3dc8c9f4f7a24f5ad59b3df2eaf2b949"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="Vectorization_8cpp.html#a3dc8c9f4f7a24f5ad59b3df2eaf2b949">bindShapeDims</a> (ShapedType shapedType, IntTy &amp;...vals)</td></tr>
<tr class="memdesc:a3dc8c9f4f7a24f5ad59b3df2eaf2b949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a pack of int&amp; to the leading dimensions of shapedType.getShape().  <a href="Vectorization_8cpp.html#a3dc8c9f4f7a24f5ad59b3df2eaf2b949">More...</a><br /></td></tr>
<tr class="separator:a3dc8c9f4f7a24f5ad59b3df2eaf2b949"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ae0bb487c37194ac844a13205a7edcefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0bb487c37194ac844a13205a7edcefc">&#9670;&nbsp;</a></span>DBGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DBGS</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(llvm::dbgs() &lt;&lt; '[' &lt;&lt; <a class="el" href="LoopInvariantCodeMotionUtils_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a> &lt;&lt; &quot;] &quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00052">52</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&nbsp;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;linalg-vectorization&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00050">50</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="aebb7bbd2151d1599f0a2a4dd7be89253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb7bbd2151d1599f0a2a4dd7be89253">&#9670;&nbsp;</a></span>LDBG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDBG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">X</td><td>)</td>
          <td>&#160;&#160;&#160;LLVM_DEBUG(<a class="el" href="XeGPUFoldAliasOps_8cpp.html#ae0bb487c37194ac844a13205a7edcefc">DBGS</a>() &lt;&lt; X &lt;&lt; &quot;\n&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00053">53</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a8443b89e0fe829933ac02916251ce4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8443b89e0fe829933ac02916251ce4f3">&#9670;&nbsp;</a></span>CustomVectorizationHook</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="Vectorization_8cpp.html#a8443b89e0fe829933ac02916251ce4f3">CustomVectorizationHook</a> =  std::function&lt;<a class="el" href="structVectorizationResult.html">VectorizationResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00680">680</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="a9b7d2592a2bad4ef2be89bf0d7efd19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7d2592a2bad4ef2be89bf0d7efd19a">&#9670;&nbsp;</a></span>CustomVectorizationPrecondition</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="Vectorization_8cpp.html#a9b7d2592a2bad4ef2be89bf0d7efd19a">CustomVectorizationPrecondition</a> =  std::function&lt;LogicalResult(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, bool)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00674">674</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a88081210ed22e2f80c50dd07348f3fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88081210ed22e2f80c50dd07348f3fec">&#9670;&nbsp;</a></span>Conv1DOpOrder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="Vectorization_8cpp.html#a88081210ed22e2f80c50dd07348f3fec">Conv1DOpOrder</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper enum to represent conv1d input traversal order. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a88081210ed22e2f80c50dd07348f3feca61e9c06ea9a85a5088a499df6458d276"></a>W&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a88081210ed22e2f80c50dd07348f3feca93d1093d4ebc345b0e2d3520c41ca741"></a>Ncw&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a88081210ed22e2f80c50dd07348f3fecacca9538f495516027540f166e6ca3ba3"></a>Nwc&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00498">498</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="ad138b2ed2839f1b552ed674585cacad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad138b2ed2839f1b552ed674585cacad3">&#9670;&nbsp;</a></span>VectorizationStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="Vectorization_8cpp.html#ad138b2ed2839f1b552ed674585cacad3">VectorizationStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper data structure to represent the result of vectorization. </p>
<p>In certain specific cases, like terminators, we do not want to propagate/ </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad138b2ed2839f1b552ed674585cacad3a6fb01c5d76aa5b0825fd3c52dc5f3661"></a>Failure&#160;</td><td class="fielddoc"><p>Op failed to vectorize. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad138b2ed2839f1b552ed674585cacad3af97b2f48071b6944652bfffb71351c8f"></a>NoReplace&#160;</td><td class="fielddoc"><p>Op vectorized and custom function took care of replacement logic. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad138b2ed2839f1b552ed674585cacad3aaaf8d13847a58092eb64f52b2bed99c6"></a>NewOp&#160;</td><td class="fielddoc"><p>Op vectorized into a new Op whose results will replace original Op's results. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00506">506</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="a224b215237fb8401f7031f2991266dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224b215237fb8401f7031f2991266dcc">&#9670;&nbsp;</a></span>VectorMemoryAccessKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="Vectorization_8cpp.html#a224b215237fb8401f7031f2991266dcc">VectorMemoryAccessKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a224b215237fb8401f7031f2991266dccae08c87afc59477607178b88f356268ca"></a>ScalarBroadcast&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a224b215237fb8401f7031f2991266dcca1910b77e1772ac1536cb49936f8c32ea"></a>Contiguous&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a224b215237fb8401f7031f2991266dccaceba1db2e3b2f5aa1258aae0105e2a4d"></a>Gather&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00824">824</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5d1d008a71edcf988a6fa4575a1c0266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1d008a71edcf988a6fa4575a1c0266">&#9670;&nbsp;</a></span>bindShapeDims() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void bindShapeDims </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>shapedType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l02891">2891</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l02894">bindShapeDims()</a>.</p>

</div>
</div>
<a id="a3dc8c9f4f7a24f5ad59b3df2eaf2b949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc8c9f4f7a24f5ad59b3df2eaf2b949">&#9670;&nbsp;</a></span>bindShapeDims() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... IntTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void bindShapeDims </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>shapedType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntTy &amp;...&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a pack of int&amp; to the leading dimensions of shapedType.getShape(). </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l02901">2901</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="a733cad761b049560f9c8e85ff51e722e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733cad761b049560f9c8e85ff51e722e">&#9670;&nbsp;</a></span>bindShapeDims() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename IntTy , typename... IntTy2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void bindShapeDims </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>shapedType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntTy &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntTy2 &amp;...&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l02894">2894</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Vectorization_8cpp_source.html#l02891">bindShapeDims()</a>.</p>

</div>
</div>
<a id="ae3a45e985a37cbb4db1c7c23ce0d9e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a45e985a37cbb4db1c7c23ce0d9e9f">&#9670;&nbsp;</a></span>broadcastIfNeeded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> broadcastIfNeeded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>dstType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast <code>value</code> to a vector of <code>shape</code> if possible. </p>
<p>Return value otherwise. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00573">573</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00528">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Builders_8h_source.html#l00453">mlir::OpBuilder::getInsertionPoint()</a>, <a class="el" href="Value_8h_source.html#l00129">mlir::Value::getType()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02390">mlir::vector::isBroadcastableTo()</a>, and <a class="el" href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50a505a83f220c02df2f85c3810cd9ceb38">mlir::vector::Success</a>.</p>

</div>
</div>
<a id="a786634b3fadeefcfe74e0c22f18312f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786634b3fadeefcfe74e0c22f18312f1">&#9670;&nbsp;</a></span>buildMultiDimReduce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Operation.html">Operation</a>* buildMultiDimReduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>reduceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>valueToReduce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>dimsToMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create MultiDimReductionOp to compute the reduction for <code>reductionOp</code>. </p>
<p>This assumes that <code>reductionOp</code> has two operands and one of them is the reduction initial value.buildMultiDimReduce </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00590">590</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00526">mlir::linalg::getCombinerOpKind()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>.</p>

</div>
</div>
<a id="a4ffeefd6b3cba67afe11ecdc2b48fcef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ffeefd6b3cba67afe11ecdc2b48fcef">&#9670;&nbsp;</a></span>buildVectorWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> buildVectorWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&#160;</td>
          <td class="paramname"><em>outputOperand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a vector.transfer_write of <code>value</code> into <code>outputOperand</code> at indices set to all <code>0</code>; where <code>outputOperand</code> is an output operand of the LinalgOp currently being vectorized. </p>
<p>If <code>dest</code> has null rank, build an memref.store. Return the produced value or null if no value is produced. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00618">618</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="ae4411a5d89520c86474035493a7da7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4411a5d89520c86474035493a7da7c1">&#9670;&nbsp;</a></span>calculateGatherOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> calculateGatherOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::ExtractOp&#160;</td>
          <td class="paramname"><em>extractOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>bvm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the offsets (<code>$index_vec</code>) for <code>vector.gather</code> operations generated from <code>tensor.extract</code>. </p>
<p>The offset is calculated as follows (example using scalar values):</p>
<p>offset = extractOp.indices[0] for (i = 1; i &lt; numIndices; i++) offset = extractOp.dimSize[i] * offset + extractOp.indices[i];</p>
<p>For tensor&lt;45 x 80 x 15 x f32&gt; and index [1, 2, 3], this leads to: offset = ( ( 1 ) * 80 + 2 ) * 15 + 3 </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00793">793</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="aab700681cb96772dbfd106a67ec408af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab700681cb96772dbfd106a67ec408af">&#9670;&nbsp;</a></span>convertAffineApply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void convertAffineApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts affine.apply Ops to arithmetic operations. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l02113">2113</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="a205af1d73acfcfa85403a7ec3e5bf471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205af1d73acfcfa85403a7ec3e5bf471">&#9670;&nbsp;</a></span>createWriteOrMaskedWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Operation.html">Operation</a>* createWriteOrMaskedWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>destSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>inputVectorSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useInBoundsInsteadOfMasking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an input, the mixed destSizes, and the vector sizes for vectorization, create an empty destination tensor and create a TransferWriteOp from the input to the empty tensor. </p>
<p>If the destination shape is not the same as the inputVectorSizes for the first rank(inputVectorSizes) dims, then create a mask for the write. If <code>useInBoundsInsteadOfMasking</code> is set, then update the inBounds attribute of the transfer write op instead of masking. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01461">1461</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00097">mlir::Builder::getI1Type()</a>, <a class="el" href="Value_8h_source.html#l00129">mlir::Value::getType()</a>, and <a class="el" href="namespacemlir_1_1vector.html#a4f68d86708480673ecc59b2714973a65">mlir::vector::maskOperation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01534">vectorizeAsTensorPackOp()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01737">vectorizeAsTensorPadOp()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01609">vectorizeAsTensorUnpackOp()</a>.</p>

</div>
</div>
<a id="a313dd728e35dcd639ff665bcc97d81ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313dd728e35dcd639ff665bcc97d81ad">&#9670;&nbsp;</a></span>extractConvFilterSlices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; extractConvFilterSlices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>kwSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to extract the filter slices after filter is unrolled along kw. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00116">116</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>.</p>

</div>
</div>
<a id="a41a2f2306467feacee5865c5be9c0401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a2f2306467feacee5865c5be9c0401">&#9670;&nbsp;</a></span>extractConvInputSlices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; extractConvInputSlices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>wSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>cSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>kwSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strideW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dilationW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>wSizeStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isSingleChanneled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to extract the input slices after filter is unrolled along kw. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00081">81</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>.</p>

</div>
</div>
<a id="abe4a6208d725462b6ab07ee8310da2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4a6208d725462b6ab07ee8310da2f1">&#9670;&nbsp;</a></span>extractConvResultSlices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; extractConvResultSlices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>wSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>fSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>wSizeStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isSingleChanneled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to extract the result slices after filter is unrolled along kw. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00132">132</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>.</p>

</div>
</div>
<a id="ae26a024dfac331ddb29bc4a78271b9d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26a024dfac331ddb29bc4a78271b9d0">&#9670;&nbsp;</a></span>getDimsToReduce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;bool&gt; getDimsToReduce </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00599">599</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00188">mlir::linalg::isReductionIterator()</a>.</p>

</div>
</div>
<a id="ae7032281b63b095fca6221acc1e63c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7032281b63b095fca6221acc1e63c50">&#9670;&nbsp;</a></span>getIntFromAttr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int64_t getIntFromAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that retrieves the value of an IntegerAttr. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l02267">2267</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l02274">ofrToIndexValues()</a>.</p>

</div>
</div>
<a id="ab37ae3178304b744d6b0249a60a6e7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37ae3178304b744d6b0249a60a6e7a3">&#9670;&nbsp;</a></span>getSingleOpOfType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OpType getSingleOpOfType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the unique instance of OpType in <code>block</code> if it is indeed unique. </p>
<p>Return null if none or more than 1 instances exist. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00065">65</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00290">mlir::Block::walk()</a>.</p>

</div>
</div>
<a id="a035a7bd3b44d215db6d50b32318822c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a035a7bd3b44d215db6d50b32318822c0">&#9670;&nbsp;</a></span>getSubViewUseIfUnique()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static memref::SubViewOp getSubViewUseIfUnique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the unique subview use of <code>v</code> if it is indeed unique, null otherwise. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l02739">2739</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00212">mlir::Value::getUses()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l02753">mlir::linalg::LinalgCopyVTRForwardingPattern::matchAndRewrite()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l02831">mlir::linalg::LinalgCopyVTWForwardingPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a172594be3a7384cb03a833aed99dc03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172594be3a7384cb03a833aed99dc03c">&#9670;&nbsp;</a></span>getTensorExtractMemoryAccessPattern()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="Vectorization_8cpp.html#a224b215237fb8401f7031f2991266dcc">VectorMemoryAccessKind</a> getTensorExtractMemoryAccessPattern </td>
          <td>(</td>
          <td class="paramtype">tensor::ExtractOp&#160;</td>
          <td class="paramname"><em>extractOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp &amp;&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType&#160;</td>
          <td class="paramname"><em>resType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Infer the memory access pattern for the input ExtractOp. </p>
<p>Based on the ExtratOp result shape and the access indices, decides whether this Op corresponds to a contiguous load (including a broadcast of a scalar) or a gather load. When analysing the ExtractOp indices (to identify contiguous laods), this method looks for "loop" invariant indices (e.g. block arguments) and indices that change linearly (e.g. via <code>linalg.index</code> Op).</p>
<p>Note that it is always safe to use gather load operations for contiguous loads (albeit slow), but not vice-versa. When in doubt, bail out and assume that <code>extractOp</code> is a gather load. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00974">974</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Vectorization_8cpp_source.html#l00824">Contiguous</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00824">Gather</a>, <a class="el" href="Vectorization_8cpp_source.html#l00918">isContiguousLoadIdx()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00858">isLoopInvariantIdx()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00053">LDBG</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00824">ScalarBroadcast</a>.</p>

</div>
</div>
<a id="a42c04606a4567ce9f7e1041b8147f9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c04606a4567ce9f7e1041b8147f9ba">&#9670;&nbsp;</a></span>getTiledPackShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t&gt; getTiledPackShape </td>
          <td>(</td>
          <td class="paramtype">tensor::PackOp&#160;</td>
          <td class="paramname"><em>packOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>destShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a tensor::PackOp, return the <code>dest</code> shape before any packing permutations. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01450">1450</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00201">mlir::applyPermutation()</a>, and <a class="el" href="namespacemlir_1_1tensor.html#ac731e19fb669e00f10374b2549bfa687">mlir::tensor::getPackInverseDestPerm()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01534">vectorizeAsTensorPackOp()</a>.</p>

</div>
</div>
<a id="a7e9ce28bca426dd4de93ad09392b4ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9ce28bca426dd4de93ad09392b4ec1">&#9670;&nbsp;</a></span>getTrailingNonUnitLoopDimIdx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t getTrailingNonUnitLoopDimIdx </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the index of the trailing non-unit dim in linalgOp. </p>
<p>This hook is used when checking whether <code>tensor.extract</code> Op (within a <code>linalg.generic</code> Op) represents a contiguous load operation.</p>
<p>Note that when calling this hook, it is assumed that the output vector is effectively 1D. Other cases (i.e. reading n-D vectors) should've been labelled as a gather load before entering this method.</p>
<p>Following on from the above, it is assumed that:</p><ul>
<li>for statically shaped loops, when no masks are used, only one dim is != 1 (that's what the shape of the output vector is based on).</li>
<li>for dynamically shaped loops, there might be more non-unit dims as the output vector type is user-specified.</li>
</ul>
<p>TODO: Statically shaped loops + vector masking </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00841">841</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00918">isContiguousLoadIdx()</a>.</p>

</div>
</div>
<a id="a66021212cd375df8f87b79b0f01b7e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66021212cd375df8f87b79b0f01b7e19">&#9670;&nbsp;</a></span>hasReductionIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hasReductionIterator </td>
          <td>(</td>
          <td class="paramtype">LinalgOp &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <code>op</code> is a linalg.reduce or a linalg.generic that has at least one reduction iterator. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00606">606</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="a110d1ed6891097419f0358bd63e974c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110d1ed6891097419f0358bd63e974c8">&#9670;&nbsp;</a></span>insertConvResultSlices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> insertConvResultSlices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>wSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>wSizeStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>resVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isSingleChanneled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to insert the computed result slices. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00158">158</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>.</p>

</div>
</div>
<a id="af2f7690c564bae0d01129c661bfcb1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f7690c564bae0d01129c661bfcb1f3">&#9670;&nbsp;</a></span>isContiguousLoadIdx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isContiguousLoadIdx </td>
          <td>(</td>
          <td class="paramtype">LinalgOp &amp;&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>foundIndexOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType&#160;</td>
          <td class="paramname"><em>resType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether <code>val</code> could be used for calculating the trailing index for a contiguous load operation. </p>
<p>There are currently 3 types of values that are allowed here:</p><ol type="1">
<li>loop-invariant values,</li>
<li>values that increment by 1 with every loop iteration,</li>
<li>results of basic arithmetic operations (linear and continuous) involving 1., 2. and 3. This method returns True if indeed only such values are used in calculating <code>val.</code></li>
</ol>
<p>Additionally, the trailing index for a contiguous load operation should increment by 1 with every loop iteration, i.e. be based on:</p><ul>
<li><code>linalg.index &lt;dim&gt;</code> , where &lt;dim&gt; is the trailing non-unit dim of the iteration space (this way, <code>linalg.index &lt;dim&gt;</code> increments by 1 with every loop iteration). <code>foundIndexOp</code> is updated to <code>true</code> when such Op is found. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00918">918</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00841">getTrailingNonUnitLoopDimIdx()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00974">getTensorExtractMemoryAccessPattern()</a>.</p>

</div>
</div>
<a id="a0bcdc4b64d42010b23b271435831cb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bcdc4b64d42010b23b271435831cb39">&#9670;&nbsp;</a></span>isLoopInvariantIdx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isLoopInvariantIdx </td>
          <td>(</td>
          <td class="paramtype">LinalgOp &amp;&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType&#160;</td>
          <td class="paramname"><em>resType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether <code>val</code> can be used for calculating a loop invariant index. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00858">858</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00974">getTensorExtractMemoryAccessPattern()</a>.</p>

</div>
</div>
<a id="a69cbb7a1a1669d28a2e2f4b221a2132f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69cbb7a1a1669d28a2e2f4b221a2132f">&#9670;&nbsp;</a></span>matchLinalgReduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Operation.html">Operation</a>* matchLinalgReduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&#160;</td>
          <td class="paramname"><em>outputOperand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether <code>outputOperand</code> is a reduction with a single combiner operation. </p>
<p>Return the combiner operation of the reduction. Return nullptr otherwise. Multiple reduction operations would impose an ordering between reduction dimensions and is currently unsupported in Linalg. This limitation is motivated by the fact that e.g. min(max(X)) != max(min(X)) </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00557">557</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00216">mlir::OpOperand::getOperandNumber()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, and <a class="el" href="SliceAnalysis_8cpp_source.html#l00224">mlir::matchReduction()</a>.</p>

</div>
</div>
<a id="a69be050ec61bb7c731b8666ca80f832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69be050ec61bb7c731b8666ca80f832f">&#9670;&nbsp;</a></span>mayExistInterleavedUses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mayExistInterleavedUses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>firstOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>secondOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether there is any interleaved use of any <code>values</code> between <code>firstOp</code> and <code>secondOp</code>. </p>
<p>Conservatively return <code>true</code> if any op or value is in a different block. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l02712">2712</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00386">mlir::Operation::isBeforeInBlock()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00053">LDBG</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l02753">mlir::linalg::LinalgCopyVTRForwardingPattern::matchAndRewrite()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l02831">mlir::linalg::LinalgCopyVTWForwardingPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ac18489393ec5b4e72d0cb6c990d72376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18489393ec5b4e72d0cb6c990d72376">&#9670;&nbsp;</a></span>ofrToIndexValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; ofrToIndexValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>ofrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an ArrayRef of OpFoldResults, return a vector of Values. </p>
<p>IntegerAttrs are converted to ConstantIndexOps. Other attribute types are not supported. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l02274">2274</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l02267">getIntFromAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l02635">PadOpVectorizationWithInsertSlicePattern::rewriteUser()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l02299">GenericPadOpVectorizationPattern::tryVectorizeCopy()</a>.</p>

</div>
</div>
<a id="a53b9b71ed8f443a028671c1eb661054d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b9b71ed8f443a028671c1eb661054d">&#9670;&nbsp;</a></span>reduceIfNeeded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Operation.html">Operation</a>* reduceIfNeeded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>reduceValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>initialValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>bvm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit reduction operations if the shapes of the value to reduce is different that the result shape. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01185">1185</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="a1ee50532663d56946548afe0ff92509c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee50532663d56946548afe0ff92509c">&#9670;&nbsp;</a></span>reductionPreconditions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult reductionPreconditions </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01765">1765</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01854">vectorizeLinalgOpPrecondition()</a>.</p>

</div>
</div>
<a id="ace2ca9537983c711e37b040688830950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2ca9537983c711e37b040688830950">&#9670;&nbsp;</a></span>reindexIndexingMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> reindexIndexingMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an indexing <code>map</code> coming from a LinalgOp indexing, restricted to a projectedPermutation, compress the unused dimensions to serve as a permutation_map for a vector transfer operation. </p>
<p>For example, given a linalg op such as:</p>
<div class="fragment"><div class="line">%0 = linalg.generic {</div>
<div class="line">     indexing_maps = affine_map&lt;(d0, d1, d2, d3, d4) -&gt; (d4, d0, d2)&gt;,</div>
<div class="line">     indexing_maps = affine_map&lt;(d0, d1, d2, d3, d4) -&gt; (d1, d3)&gt;</div>
<div class="line">   }</div>
<div class="line">  ins(%0 : tensor&lt;2x3x4xf32&gt;)</div>
<div class="line"> outs(%1 : tensor&lt;5x6xf32&gt;)</div>
</div><!-- fragment --><p>the iteration domain size of the linalg op is 3x5x4x6x2. The first affine map is reindexed to <code>affine_map&lt;(d0, d1, d2) -&gt; (d2, d0, d1)&gt;</code>, the second affine map is reindexed to <code>affine_map&lt;(d0, d1) -&gt; (d0, d1)&gt;</code>. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00487">487</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00722">mlir::compressUnusedDims()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00618">mlir::AffineMap::isProjectedPermutation()</a>.</p>

</div>
</div>
<a id="ad09df73d48432e3de8291c7076164ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09df73d48432e3de8291c7076164ba7">&#9670;&nbsp;</a></span>tensorExtractVectorizationPrecondition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult tensorExtractVectorizationPrecondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>vectorizeNDExtract</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to check if the tensor.extract can be vectorized by the custom hook vectorizeTensorExtract. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00759">759</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01854">vectorizeLinalgOpPrecondition()</a>.</p>

</div>
</div>
<a id="a35e1ec347850959af0bc7cbdf61b9da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e1ec347850959af0bc7cbdf61b9da3">&#9670;&nbsp;</a></span>vectorizeAsLinalgGeneric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult vectorizeAsLinalgGeneric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newResults</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic vectorization function that rewrites the body of a <code>linalgOp</code> into vector form. </p>
<p>Generic vectorization proceeds as follows:</p><ol type="1">
<li>Verify the <code>linalgOp</code> has one non-empty region.</li>
<li>Values defined above the region are mapped to themselves and will be broadcasted on a per-need basis by their consumers.</li>
<li>Each region argument is vectorized into a vector.transfer_read (or 0-d load). TODO: Reuse opportunities for RAR dependencies. 4a. Register CustomVectorizationHook for YieldOp to capture the results. 4rewriter. Register CustomVectorizationHook for IndexOp to access the iteration indices.</li>
<li>Iteratively call vectorizeOneOp on the region operations.</li>
</ol>
<p>When <code>broadcastToMaximalCommonShape</code> is set to true, eager broadcasting is performed to the maximal common vector size implied by the <code>linalgOp</code> iteration space. This eager broadcasting is introduced in the permutation_map of the vector.transfer_read operations. The eager broadcasting makes it trivial to detrmine where broadcast, transposes and reductions should occur, without any bookkeeping. The tradeoff is that, in the absence of good canonicalizations, the amount of work increases. This is not deemed a problem as we expect canonicalizations and foldings to aggressively clean up the useless work. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01335">1335</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="ab952d864e63af3ebc5fad26dab689ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab952d864e63af3ebc5fad26dab689ffc">&#9670;&nbsp;</a></span>vectorizeAsTensorPackOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult vectorizeAsTensorPackOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PackOp&#160;</td>
          <td class="paramname"><em>packOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>inputVectorSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newResults</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vectorize tensor::PackOp with (1) static innerTiles (2) constant padding value and (3) input vector sizes into: masked_transfer_read-&gt;shape_cast-&gt;transpose-&gt;transfer_write_in_bounds As in the following example: pack = tensor.pack src inner_dims_pos = [2, 1] inner_tiles = [16, 2] into dst : tensor&lt;32x8x16xf32&gt; -&gt; tensor&lt;32x4x1x16x2xf32&gt; </p>
<p>This pack would be vectorized to:</p>
<p>load = vector.mask mask { vector.transfer_read arg0[c0, c0, c0], cst {in_bounds = [true, true, true]} : tensor&lt;32x7x16xf32&gt;, vector&lt;32x8x16xf32&gt; } : vector&lt;32x8x16xi1&gt; -&gt; vector&lt;32x8x16xf32&gt; shape_cast = vector.shape_cast load : vector&lt;32x8x16xf32&gt; to vector&lt;32x4x2x1x16xf32&gt; transpose = vector.transpose shape_cast, [0, 1, 3, 4, 2] : vector&lt;32x4x2x1x16xf32&gt; to vector&lt;32x4x1x16x2xf32&gt; write = vector.transfer_write transpose, empty[c0_0, c0_0, c0_0, c0_0, c0_0] {in_bounds = [true, true, true, true, true]} : vector&lt;32x4x1x16x2xf32&gt;, tensor&lt;32x4x1x16x2xf32&gt;</p>
<p>If the (3) input vector sizes are not provided, the vector sizes are determined by the result tensor shape. Also, we update the inBounds attribute instead of masking. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01534">1534</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00226">mlir::applyPermutationToVector()</a>, <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00329">mlir::vector::createReadOrMaskedRead()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01461">createWriteOrMaskedWrite()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="namespacemlir_1_1tensor.html#ac731e19fb669e00f10374b2549bfa687">mlir::tensor::getPackInverseDestPerm()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01450">getTiledPackShape()</a>, <a class="el" href="Builders_8cpp_source.html#l00355">mlir::Builder::getZeroAttr()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00205">mlir::invertPermutationVector()</a>, and <a class="el" href="Builders_8h_source.html#l00406">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="af8d343eff4117b4738a97dea5eb4d4bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d343eff4117b4738a97dea5eb4d4bd">&#9670;&nbsp;</a></span>vectorizeAsTensorPadOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult vectorizeAsTensorPadOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PadOp&#160;</td>
          <td class="paramname"><em>padOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>inputVectorSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newResults</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vectorize a <code>padOp</code> with (1) static result type, (2) constant padding value and (3) all-zero lowPad to <code>transfer_write_in_bounds(transfer_read_masked(pad_source, pad_value))</code>. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01737">1737</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorUtils_8cpp_source.html#l00329">mlir::vector::createReadOrMaskedRead()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01461">createWriteOrMaskedWrite()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00402">mlir::Operation::getResult()</a>, and <a class="el" href="Builders_8h_source.html#l00406">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="aa7ec13821576a9a6422b100ab9bc69e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ec13821576a9a6422b100ab9bc69e3">&#9670;&nbsp;</a></span>vectorizeAsTensorUnpackOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult vectorizeAsTensorUnpackOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::UnPackOp&#160;</td>
          <td class="paramname"><em>unpackOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>inputVectorSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newResults</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vectorize a <code>tensor::UnPackOp</code> to these 4 Ops: Vector::TransferReadOp - Reads a vector from the source tensor vector::TransposeOp - Transpose the Source tensor ShapeCastOp - Reshape the data based on the target. </p>
<p>vector::TransferWriteOp. - Write the result vector back to the destination tensor. If the vector sizes are not provided:</p><ul>
<li>the vector sizes are determined by the input operand and attributes,</li>
<li>update the inBounds attribute instead of masking. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01609">1609</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00226">mlir::applyPermutationToVector()</a>, <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00329">mlir::vector::createReadOrMaskedRead()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01461">createWriteOrMaskedWrite()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00431">mlir::detail::divideCeil()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00402">mlir::Operation::getResult()</a>, <a class="el" href="namespacemlir_1_1tensor.html#a29cab07ce0502d989d3b741f727f65f7">mlir::tensor::getUnPackInverseSrcPerm()</a>, <a class="el" href="Builders_8cpp_source.html#l00355">mlir::Builder::getZeroAttr()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00053">LDBG</a>, and <a class="el" href="Builders_8h_source.html#l00406">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="a320b06f6c6f3905541d59f2c33ce5aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320b06f6c6f3905541d59f2c33ce5aea">&#9670;&nbsp;</a></span>vectorizeConvolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; vectorizeConvolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>convOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>inputVecSizes</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>inputVecScalableFlags</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flatten1DDepthwiseConv</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to vectorize <code>convOp</code> as a convolution. </p>
<p>Helper function to vectorize a LinalgOp with convolution semantics. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l03733">3733</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="ad6ef02407dc9f6a46da43369638fbbe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ef02407dc9f6a46da43369638fbbe8">&#9670;&nbsp;</a></span>vectorizeDynamicConvOpPrecondition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult vectorizeDynamicConvOpPrecondition </td>
          <td>(</td>
          <td class="paramtype">linalg::LinalgOp&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flatten1DDepthwiseConv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01785">1785</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00129">mlir::Value::getType()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00053">LDBG</a>.</p>

</div>
</div>
<a id="a9361ccf3f87080ceace5da1af0d2e522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9361ccf3f87080ceace5da1af0d2e522">&#9670;&nbsp;</a></span>vectorizeDynamicLinalgOpPrecondition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult vectorizeDynamicLinalgOpPrecondition </td>
          <td>(</td>
          <td class="paramtype">linalg::LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flatten1DDepthwiseConv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01813">1813</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01854">vectorizeLinalgOpPrecondition()</a>.</p>

</div>
</div>
<a id="a9b07daffcd1b5a090273117573bf751b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b07daffcd1b5a090273117573bf751b">&#9670;&nbsp;</a></span>vectorizeLinalgIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structVectorizationResult.html">VectorizationResult</a> vectorizeLinalgIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to vectorize the index operations of a <code>linalgOp</code>. </p>
<p>Return VectorizationStatus::NewOp to signal the vectorization algorithm that it should map the produced operations. This function is meant to be used as a CustomVectorizationHook. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00715">715</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="acdd38e6c601b328398794c7d9d092b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd38e6c601b328398794c7d9d092b43">&#9670;&nbsp;</a></span>vectorizeLinalgOpPrecondition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult vectorizeLinalgOpPrecondition </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>inputVectorSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>vectorizeNDExtract</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flatten1DDepthwiseConv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01854">1854</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00149">mlir::linalg::allIndexingsAreProjectedPermutation()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00682">mlir::Operation::getRegion()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00169">mlir::linalg::isElementwise()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00371">mlir::vector::isValidMaskedInputVector()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00053">LDBG</a>, <a class="el" href="Vectorization_8cpp_source.html#l01765">reductionPreconditions()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00759">tensorExtractVectorizationPrecondition()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01813">vectorizeDynamicLinalgOpPrecondition()</a>.</p>

</div>
</div>
<a id="a3b9560e3a36a7bb7bc493da9c6ef26c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9560e3a36a7bb7bc493da9c6ef26c1">&#9670;&nbsp;</a></span>vectorizeLinalgYield()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structVectorizationResult.html">VectorizationResult</a> vectorizeLinalgYield </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>bvm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newResults</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to vectorize the terminator of a <code>linalgOp</code>. </p>
<p>New result vector values are appended to <code>newResults</code>. Return VectorizationStatus::NoReplace to signal the vectorization algorithm that it should not try to map produced operations and instead return the results using the <code>newResults</code> vector making them available to the vectorization algorithm for RAUW. This function is meant to be used as a CustomVectorizationHook. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00691">691</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="a1f622d98314b8edb8f6623408939e81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f622d98314b8edb8f6623408939e81c">&#9670;&nbsp;</a></span>vectorizeOneOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structVectorizationResult.html">VectorizationResult</a> vectorizeOneOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>bvm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="Vectorization_8cpp.html#a8443b89e0fe829933ac02916251ce4f3">CustomVectorizationHook</a> &gt;&#160;</td>
          <td class="paramname"><em>customVectorizationHooks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic vectorization for a single operation <code>op</code>, given already vectorized operands carried by <code>bvm</code>. </p>
<p>Vectorization occurs as follows:</p><ol type="1">
<li>Try to apply any of the <code>customVectorizationHooks</code> and return its result on success.</li>
<li>Clone any constant in the current scope without vectorization: each consumer of the constant will later determine the shape to which the constant needs to be broadcast to.</li>
<li>Fail on any remaining non <code>ElementwiseMappable</code> op. It is the purpose of the <code>customVectorizationHooks</code> to cover such cases.</li>
<li>Clone <code>op</code> in vector form to a vector of shape prescribed by the first operand of maximal rank. Other operands have smaller rank and are broadcast accordingly. It is assumed this broadcast is always legal, otherwise, it means one of the <code>customVectorizationHooks</code> is incorrect.</li>
</ol>
<p>This function assumes all operands of <code>op</code> have been vectorized and are in the <code>bvm</code> mapping. As a consequence, this function is meant to be called on a topologically-sorted list of ops. This function does not update <code>bvm</code> but returns a VectorizationStatus that instructs the caller what <code>bvm</code> update needs to occur. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01221">1221</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="a531e61d51c1ecce5e08726e38f6add88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531e61d51c1ecce5e08726e38f6add88">&#9670;&nbsp;</a></span>vectorizePackOpPrecondition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult vectorizePackOpPrecondition </td>
          <td>(</td>
          <td class="paramtype">tensor::PackOp&#160;</td>
          <td class="paramname"><em>packOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>inputVectorSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01922">1922</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorUtils_8cpp_source.html#l00371">mlir::vector::isValidMaskedInputVector()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00053">LDBG</a>, <a class="el" href="Matchers_8h_source.html#l00369">mlir::m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00485">mlir::matchPattern()</a>.</p>

</div>
</div>
<a id="a2d2260cd7405010dc09da594212af829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2260cd7405010dc09da594212af829">&#9670;&nbsp;</a></span>vectorizePadOpPrecondition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult vectorizePadOpPrecondition </td>
          <td>(</td>
          <td class="paramtype">tensor::PadOp&#160;</td>
          <td class="paramname"><em>padOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>inputVectorSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01955">1955</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorUtils_8cpp_source.html#l00371">mlir::vector::isValidMaskedInputVector()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00053">LDBG</a>.</p>

</div>
</div>
<a id="aed76d5bbb8b5413dcba7a1b210d50f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed76d5bbb8b5413dcba7a1b210d50f7c">&#9670;&nbsp;</a></span>vectorizeScalableVectorPrecondition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult vectorizeScalableVectorPrecondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>inputVectorSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>inputScalableVecDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Preconditions for scalable vectors. </p>
<p>This is quite restrictive - it models the fact that in practice we would only make selected dimensions scalable. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01982">1982</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="a701e5d65843787d297c79a5a7304ad7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701e5d65843787d297c79a5a7304ad7d">&#9670;&nbsp;</a></span>vectorizeTensorExtract()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structVectorizationResult.html">VectorizationResult</a> vectorizeTensorExtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>bvm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to vectorize the tensor.extract operations. </p>
<p>Returns VectorizationStatus::NewOp to signal the vectorization algorithm that it should map the produced operations. This function is meant to be used as a CustomVectorizationHook. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01055">1055</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="ad9b5ead78da7e0e4b5b39dc1e236d0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b5ead78da7e0e4b5b39dc1e236d0d6">&#9670;&nbsp;</a></span>vectorizeUnPackOpPrecondition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult vectorizeUnPackOpPrecondition </td>
          <td>(</td>
          <td class="paramtype">tensor::UnPackOp&#160;</td>
          <td class="paramname"><em>unpackOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>inputVectorSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Need to check if the inner-tiles are static/constant. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01834">1834</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorUtils_8cpp_source.html#l00371">mlir::vector::isValidMaskedInputVector()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00053">LDBG</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 7 2024 08:32:17 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
