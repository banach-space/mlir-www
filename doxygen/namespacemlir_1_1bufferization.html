<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::bufferization Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">20.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1bufferization.html">bufferization</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::bufferization Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1bufferization_1_1deallocation__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization_1_1deallocation__impl.html">deallocation_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1bufferization_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1bufferization_1_1func__ext"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization_1_1func__ext.html">func_ext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1ValueComparator.html">ValueComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two SSA values in a deterministic manner.  <a href="structmlir_1_1bufferization_1_1ValueComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1Ownership.html">Ownership</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to track the ownership of values.  <a href="classmlir_1_1bufferization_1_1Ownership.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1DeallocationOptions.html">DeallocationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for BufferDeallocationOpInterface-based buffer deallocation.  <a href="structmlir_1_1bufferization_1_1DeallocationOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1DeallocationState.html">DeallocationState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class collects all the state that we need to perform the buffer deallocation pass with associated helper functions such that we have easy access to it in the BufferDeallocationOpInterface implementations and the BufferDeallocation pass.  <a href="classmlir_1_1bufferization_1_1DeallocationState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1AliasingOpOperand.html">AliasingOpOperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A maybe aliasing <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a>.  <a href="structmlir_1_1bufferization_1_1AliasingOpOperand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1AliasingValue.html">AliasingValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A maybe aliasing <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="structmlir_1_1bufferization_1_1AliasingValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1AliasList.html">AliasList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1OpFilter.html">OpFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for BufferizableOpInterface-based bufferization.  <a href="structmlir_1_1bufferization_1_1BufferizationOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1TraversalConfig.html">TraversalConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traversal parameters for <code>findValueInReverseUseDefChain</code>.  <a href="structmlir_1_1bufferization_1_1TraversalConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">AnalysisState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html" title="AnalysisState provides a variety of helper functions for dealing with tensor values.">AnalysisState</a> provides a variety of helper functions for dealing with tensor values.  <a href="classmlir_1_1bufferization_1_1AnalysisState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1DstBufferizableOpInterfaceExternalModel.html">DstBufferizableOpInterfaceExternalModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferizable ops that implement the DestinationStyleOpInterface can use this external model base class.  <a href="structmlir_1_1bufferization_1_1DstBufferizableOpInterfaceExternalModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1OpWithUnstructuredControlFlowBufferizableOpInterfaceExternalModel.html">OpWithUnstructuredControlFlowBufferizableOpInterfaceExternalModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template that provides a default implementation of <code>getAliasingOpOperands</code> for ops that support unstructured control flow within their regions.  <a href="structmlir_1_1bufferization_1_1OpWithUnstructuredControlFlowBufferizableOpInterfaceExternalModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1BranchOpBufferizableOpInterfaceExternalModel.html">BranchOpBufferizableOpInterfaceExternalModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template that provides a default implementation of <code>getAliasingValues</code> for ops that implement the <code>BranchOpInterface</code>.  <a href="structmlir_1_1bufferization_1_1BranchOpBufferizableOpInterfaceExternalModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1BufferDeallocationPipelineOptions.html">BufferDeallocationPipelineOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for the buffer deallocation pipeline.  <a href="structmlir_1_1bufferization_1_1BufferDeallocationPipelineOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferization statistics for debugging.  <a href="structmlir_1_1bufferization_1_1BufferizationStatistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper type converter class that automatically populates the relevant materializations and type conversions for bufferization.  <a href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1BufferPlacementAllocs.html">BufferPlacementAllocs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple analysis that detects allocation operations.  <a href="classmlir_1_1bufferization_1_1BufferPlacementAllocs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1BufferPlacementTransformationBase.html">BufferPlacementTransformationBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for all BufferPlacement transformations.  <a href="classmlir_1_1bufferization_1_1BufferPlacementTransformationBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for analysis-enabled bufferization.  <a href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State for analysis-enabled bufferization.  <a href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1BufferResultsToOutParamsOpts.html">BufferResultsToOutParamsOpts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a976af01e3a00f974529232f7e611233c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a976af01e3a00f974529232f7e611233c">AliasingOpOperandList</a> = <a class="el" href="classmlir_1_1bufferization_1_1AliasList.html">AliasList</a>&lt; <a class="el" href="structmlir_1_1bufferization_1_1AliasingOpOperand.html">AliasingOpOperand</a> &gt;</td></tr>
<tr class="memdesc:a976af01e3a00f974529232f7e611233c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of possible aliasing OpOperands.  <a href="namespacemlir_1_1bufferization.html#a976af01e3a00f974529232f7e611233c">More...</a><br /></td></tr>
<tr class="separator:a976af01e3a00f974529232f7e611233c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4492dc8080792451e4432c4b014544"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a3d4492dc8080792451e4432c4b014544">AliasingValueList</a> = <a class="el" href="classmlir_1_1bufferization_1_1AliasList.html">AliasList</a>&lt; <a class="el" href="structmlir_1_1bufferization_1_1AliasingValue.html">AliasingValue</a> &gt;</td></tr>
<tr class="memdesc:a3d4492dc8080792451e4432c4b014544"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of possible aliasing Values.  <a href="namespacemlir_1_1bufferization.html#a3d4492dc8080792451e4432c4b014544">More...</a><br /></td></tr>
<tr class="separator:a3d4492dc8080792451e4432c4b014544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8ce1066619c9152afa16b4ec7286dc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a3f8ce1066619c9152afa16b4ec7286dc">RegisterDependenciesFn</a> = std::function&lt; void(<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;</td></tr>
<tr class="separator:a3f8ce1066619c9152afa16b4ec7286dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fe5cbf8af77269764f32ac8bf566ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a76fe5cbf8af77269764f32ac8bf566ea">DeallocHelperMap</a> = <a class="el" href="classllvm_1_1DenseMap.html">llvm::DenseMap</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, func::FuncOp &gt;</td></tr>
<tr class="memdesc:a76fe5cbf8af77269764f32ac8bf566ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps from symbol table to its corresponding dealloc helper function.  <a href="namespacemlir_1_1bufferization.html#a76fe5cbf8af77269764f32ac8bf566ea">More...</a><br /></td></tr>
<tr class="separator:a76fe5cbf8af77269764f32ac8bf566ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afbf6d54f9e3c10b9003b66b6224b28bf"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bf">BufferRelation</a> { <a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bfa88183b946cc5f0e8c96b2e66e1c74a7e">Unknown</a>
, <a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bfaafd102579f64c98e96d92a7424130605">Equivalent</a>
 }</td></tr>
<tr class="memdesc:afbf6d54f9e3c10b9003b66b6224b28bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a fine-grain relationship between buffers to enable more analysis.  <a href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bf">More...</a><br /></td></tr>
<tr class="separator:afbf6d54f9e3c10b9003b66b6224b28bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aab5f2c6412ef78600accb933077b59ec"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aab5f2c6412ef78600accb933077b59ec">allocateTensorForShapedValue</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> shapedValue, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, bool <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp.html#a6ca5ef47ce8bbced1c354e95e188f2e2">copy</a>=true)</td></tr>
<tr class="memdesc:aab5f2c6412ef78600accb933077b59ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an AllocTensorOp for the given shaped value (memref or tensor).  <a href="namespacemlir_1_1bufferization.html#aab5f2c6412ef78600accb933077b59ec">More...</a><br /></td></tr>
<tr class="separator:aab5f2c6412ef78600accb933077b59ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf241364e9dfd1def82141c75035f4b0"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#abf241364e9dfd1def82141c75035f4b0">getBuffer</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Value.html">Value</a> value, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:abf241364e9dfd1def82141c75035f4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup the buffer for the given value.  <a href="namespacemlir_1_1bufferization.html#abf241364e9dfd1def82141c75035f4b0">More...</a><br /></td></tr>
<tr class="separator:abf241364e9dfd1def82141c75035f4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc2d902756788c32c33244776d141c7"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aadc2d902756788c32c33244776d141c7">getBufferType</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:aadc2d902756788c32c33244776d141c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization without bufferizing any IR.  <a href="namespacemlir_1_1bufferization.html#aadc2d902756788c32c33244776d141c7">More...</a><br /></td></tr>
<tr class="separator:aadc2d902756788c32c33244776d141c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452bfb024f3ea3eed5dbdf9eb9a990f5"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a452bfb024f3ea3eed5dbdf9eb9a990f5">getBufferType</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;invocationStack)</td></tr>
<tr class="memdesc:a452bfb024f3ea3eed5dbdf9eb9a990f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization without bufferizing any IR.  <a href="namespacemlir_1_1bufferization.html#a452bfb024f3ea3eed5dbdf9eb9a990f5">More...</a><br /></td></tr>
<tr class="separator:a452bfb024f3ea3eed5dbdf9eb9a990f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba911c4f4c1cf1ef5cc1eed1f5cebdc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#afba911c4f4c1cf1ef5cc1eed1f5cebdc">hasTensorSemantics</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:afba911c4f4c1cf1ef5cc1eed1f5cebdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if the given op has tensor semantics and should be bufferized.  <a href="namespacemlir_1_1bufferization.html#afba911c4f4c1cf1ef5cc1eed1f5cebdc">More...</a><br /></td></tr>
<tr class="separator:afba911c4f4c1cf1ef5cc1eed1f5cebdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05561ae5b9cceea1c45832340484ad6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a05561ae5b9cceea1c45832340484ad6b">replaceOpWithBufferizedValues</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values)</td></tr>
<tr class="memdesc:a05561ae5b9cceea1c45832340484ad6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace an op with replacement values.  <a href="namespacemlir_1_1bufferization.html#a05561ae5b9cceea1c45832340484ad6b">More...</a><br /></td></tr>
<tr class="separator:a05561ae5b9cceea1c45832340484ad6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91366abfb8d491ea5701260487518959"><td class="memTemplParams" colspan="2">template&lt;typename OpTy , typename... Args&gt; </td></tr>
<tr class="memitem:a91366abfb8d491ea5701260487518959"><td class="memTemplItemLeft" align="right" valign="top">OpTy&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a91366abfb8d491ea5701260487518959">replaceOpWithNewBufferizedOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a91366abfb8d491ea5701260487518959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace an op with a new op.  <a href="namespacemlir_1_1bufferization.html#a91366abfb8d491ea5701260487518959">More...</a><br /></td></tr>
<tr class="separator:a91366abfb8d491ea5701260487518959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660fa21f93f165f53aa703efc73fa210"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a660fa21f93f165f53aa703efc73fa210">getMemRefType</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, MemRefLayoutAttrInterface layout={}, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace=nullptr)</td></tr>
<tr class="memdesc:a660fa21f93f165f53aa703efc73fa210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a MemRefType to which the type of the given value can be bufferized.  <a href="namespacemlir_1_1bufferization.html#a660fa21f93f165f53aa703efc73fa210">More...</a><br /></td></tr>
<tr class="separator:a660fa21f93f165f53aa703efc73fa210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4daaf086abd1c64e90dc9529f76e1d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#af4daaf086abd1c64e90dc9529f76e1d4">getMemRefTypeWithFullyDynamicLayout</a> (<a class="el" href="classmlir_1_1TensorType.html">TensorType</a> tensorType, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace=nullptr)</td></tr>
<tr class="memdesc:af4daaf086abd1c64e90dc9529f76e1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a MemRef type with fully dynamic layout.  <a href="namespacemlir_1_1bufferization.html#af4daaf086abd1c64e90dc9529f76e1d4">More...</a><br /></td></tr>
<tr class="separator:af4daaf086abd1c64e90dc9529f76e1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d01c9f4f43c19b51520658e24853d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a05d01c9f4f43c19b51520658e24853d6">getMemRefTypeWithStaticIdentityLayout</a> (<a class="el" href="classmlir_1_1TensorType.html">TensorType</a> tensorType, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace=nullptr)</td></tr>
<tr class="memdesc:a05d01c9f4f43c19b51520658e24853d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a MemRef type with a static identity layout (i.e., no layout map).  <a href="namespacemlir_1_1bufferization.html#a05d01c9f4f43c19b51520658e24853d6">More...</a><br /></td></tr>
<tr class="separator:a05d01c9f4f43c19b51520658e24853d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ed0ccb4e307d98675ecab129feddf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a25ed0ccb4e307d98675ecab129feddf5">getOwnerOfValue</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a25ed0ccb4e307d98675ecab129feddf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the owner of the given value.  <a href="namespacemlir_1_1bufferization.html#a25ed0ccb4e307d98675ecab129feddf5">More...</a><br /></td></tr>
<tr class="separator:a25ed0ccb4e307d98675ecab129feddf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab812aaab64b7b9fb0416797db2e146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a8ab812aaab64b7b9fb0416797db2e146">getNextEnclosingRepetitiveRegion</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> *region, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a8ab812aaab64b7b9fb0416797db2e146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that the given region is repetitive, find the next enclosing repetitive region.  <a href="namespacemlir_1_1bufferization.html#a8ab812aaab64b7b9fb0416797db2e146">More...</a><br /></td></tr>
<tr class="separator:a8ab812aaab64b7b9fb0416797db2e146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8aa5c17d21cdf7873eed41fc2c9b24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a7a8aa5c17d21cdf7873eed41fc2c9b24">getParallelRegion</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> *region, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a7a8aa5c17d21cdf7873eed41fc2c9b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>region</code> is a parallel region, return <code>region</code>.  <a href="namespacemlir_1_1bufferization.html#a7a8aa5c17d21cdf7873eed41fc2c9b24">More...</a><br /></td></tr>
<tr class="separator:a7a8aa5c17d21cdf7873eed41fc2c9b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7726e480700dfb860214b275d6a396d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#af7726e480700dfb860214b275d6a396d">populateDynamicDimSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> shapedValue, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dynamicDims)</td></tr>
<tr class="memdesc:af7726e480700dfb860214b275d6a396d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate <code>dynamicDims</code> with tensor::DimOp / memref::DimOp results for all dynamic dimensions of the given shaped value.  <a href="namespacemlir_1_1bufferization.html#af7726e480700dfb860214b275d6a396d">More...</a><br /></td></tr>
<tr class="separator:af7726e480700dfb860214b275d6a396d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d27e15fb5438e5f331ac1da1bf424c"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a15d27e15fb5438e5f331ac1da1bf424c">castOrReallocMemRefValue</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> value, MemRefType type, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a15d27e15fb5438e5f331ac1da1bf424c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to cast the given ranked MemRef-typed value to the given ranked MemRef type.  <a href="namespacemlir_1_1bufferization.html#a15d27e15fb5438e5f331ac1da1bf424c">More...</a><br /></td></tr>
<tr class="separator:a15d27e15fb5438e5f331ac1da1bf424c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c44c6ca8b0e1f2a2b2a21dad9bc4ff"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a93c44c6ca8b0e1f2a2b2a21dad9bc4ff">foldToMemrefToTensorPair</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, ToMemrefOp toMemref, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a93c44c6ca8b0e1f2a2b2a21dad9bc4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to fold to_memref(to_tensor(x)).  <a href="namespacemlir_1_1bufferization.html#a93c44c6ca8b0e1f2a2b2a21dad9bc4ff">More...</a><br /></td></tr>
<tr class="separator:a93c44c6ca8b0e1f2a2b2a21dad9bc4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046f6b3f96cd60275f3bf03f0b17cdae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a046f6b3f96cd60275f3bf03f0b17cdae">populateDeallocOpCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a046f6b3f96cd60275f3bf03f0b17cdae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the canonicalization patterns for bufferization.dealloc to the given pattern set to make them available to other passes (such as BufferDeallocationSimplification).  <a href="namespacemlir_1_1bufferization.html#a046f6b3f96cd60275f3bf03f0b17cdae">More...</a><br /></td></tr>
<tr class="separator:a046f6b3f96cd60275f3bf03f0b17cdae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49b581e6a12f245db92fa4da2d8fd9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#af49b581e6a12f245db92fa4da2d8fd9f">buildBufferDeallocationPipeline</a> (<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;pm, const <a class="el" href="structmlir_1_1bufferization_1_1BufferDeallocationPipelineOptions.html">BufferDeallocationPipelineOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:af49b581e6a12f245db92fa4da2d8fd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the buffer deallocation pipeline to the <code><a class="el" href="classmlir_1_1OpPassManager.html" title="This class represents a pass manager that runs passes on either a specific operation type,...">OpPassManager</a></code>.  <a href="namespacemlir_1_1bufferization.html#af49b581e6a12f245db92fa4da2d8fd9f">More...</a><br /></td></tr>
<tr class="separator:af49b581e6a12f245db92fa4da2d8fd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65df8ad92a46defb2d80d780f26bc12e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a65df8ad92a46defb2d80d780f26bc12e">registerBufferizationPipelines</a> ()</td></tr>
<tr class="memdesc:a65df8ad92a46defb2d80d780f26bc12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers all pipelines for the <code>bufferization</code> dialect.  <a href="namespacemlir_1_1bufferization.html#a65df8ad92a46defb2d80d780f26bc12e">More...</a><br /></td></tr>
<tr class="separator:a65df8ad92a46defb2d80d780f26bc12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2d5a6d2e5ab89ec76a879d71e32a36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a2b2d5a6d2e5ab89ec76a879d71e32a36">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a2b2d5a6d2e5ab89ec76a879d71e32a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6223871e93de2dbc611e8e54c5e4fb3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a6223871e93de2dbc611e8e54c5e4fb3b">populateBufferizeMaterializationLegality</a> (<a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a6223871e93de2dbc611e8e54c5e4fb3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks ops used by bufferization for type conversion materializations as "legal" in the given <a class="el" href="classmlir_1_1ConversionTarget.html" title="This class describes a specific conversion target.">ConversionTarget</a>.  <a href="namespacemlir_1_1bufferization.html#a6223871e93de2dbc611e8e54c5e4fb3b">More...</a><br /></td></tr>
<tr class="separator:a6223871e93de2dbc611e8e54c5e4fb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9dc13b8abd5c6ceca11cdf88ef32ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aea9dc13b8abd5c6ceca11cdf88ef32ff">populateEliminateBufferizeMaterializationsPatterns</a> (const <a class="el" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aea9dc13b8abd5c6ceca11cdf88ef32ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns to eliminate bufferize materializations.  <a href="namespacemlir_1_1bufferization.html#aea9dc13b8abd5c6ceca11cdf88ef32ff">More...</a><br /></td></tr>
<tr class="separator:aea9dc13b8abd5c6ceca11cdf88ef32ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6386e784e181c430f97843ea979015"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a6b6386e784e181c430f97843ea979015">bufferizeOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *statistics=nullptr)</td></tr>
<tr class="memdesc:a6b6386e784e181c430f97843ea979015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>.  <a href="namespacemlir_1_1bufferization.html#a6b6386e784e181c430f97843ea979015">More...</a><br /></td></tr>
<tr class="separator:a6b6386e784e181c430f97843ea979015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884913e487f39ecc7e0f69694afa9065"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a884913e487f39ecc7e0f69694afa9065">bufferizeBlockSignature</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a884913e487f39ecc7e0f69694afa9065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferize the signature of <code>block</code> and its callers (i.e., ops that have the given block as a successor).  <a href="namespacemlir_1_1bufferization.html#a884913e487f39ecc7e0f69694afa9065">More...</a><br /></td></tr>
<tr class="separator:a884913e487f39ecc7e0f69694afa9065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36c97b27b691ad7fcee01d70ca143a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ac36c97b27b691ad7fcee01d70ca143a9">getPartialBufferizationOptions</a> ()</td></tr>
<tr class="memdesc:ac36c97b27b691ad7fcee01d70ca143a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code><a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html" title="Options for BufferizableOpInterface-based bufferization.">BufferizationOptions</a></code> such that the <code>bufferizeOp</code> behaves like the old (deprecated) partial, dialect conversion-based bufferization passes.  <a href="namespacemlir_1_1bufferization.html#ac36c97b27b691ad7fcee01d70ca143a9">More...</a><br /></td></tr>
<tr class="separator:ac36c97b27b691ad7fcee01d70ca143a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8139947c1966e87061f1e4e5c184c404"><td class="memTemplParams" colspan="2">template&lt;typename DominatorT &gt; </td></tr>
<tr class="memitem:a8139947c1966e87061f1e4e5c184c404"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a8139947c1966e87061f1e4e5c184c404">findCommonDominator</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, const <a class="el" href="classmlir_1_1BufferViewFlowAnalysis.html#a1602ce2a7a7c54bea6b736faa4cfcd29">BufferViewFlowAnalysis::ValueSetT</a> &amp;values, const DominatorT &amp;doms)</td></tr>
<tr class="memdesc:a8139947c1966e87061f1e4e5c184c404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a common dominator for the given value while taking the positions of the values in the value set into account.  <a href="namespacemlir_1_1bufferization.html#a8139947c1966e87061f1e4e5c184c404">More...</a><br /></td></tr>
<tr class="separator:a8139947c1966e87061f1e4e5c184c404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac429167681d191256dad3476d862bda2"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; memref::GlobalOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ac429167681d191256dad3476d862bda2">getGlobalFor</a> (arith::ConstantOp constantOp, uint64_t alignment, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={})</td></tr>
<tr class="separator:ac429167681d191256dad3476d862bda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec3ce210ab7a2c1c1e82a266bfb9e3f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a1ec3ce210ab7a2c1c1e82a266bfb9e3f">analyzeOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;state, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *statistics=nullptr)</td></tr>
<tr class="memdesc:a1ec3ce210ab7a2c1c1e82a266bfb9e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze <code>op</code> and its nested ops.  <a href="namespacemlir_1_1bufferization.html#a1ec3ce210ab7a2c1c1e82a266bfb9e3f">More...</a><br /></td></tr>
<tr class="separator:a1ec3ce210ab7a2c1c1e82a266bfb9e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02260c2ee96b5ef6845cf31eefabb24b"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a02260c2ee96b5ef6845cf31eefabb24b">runOneShotBufferize</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *statistics=nullptr)</td></tr>
<tr class="memdesc:a02260c2ee96b5ef6845cf31eefabb24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run One-Shot Bufferize on the given op: Analysis + Bufferization.  <a href="namespacemlir_1_1bufferization.html#a02260c2ee96b5ef6845cf31eefabb24b">More...</a><br /></td></tr>
<tr class="separator:a02260c2ee96b5ef6845cf31eefabb24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a75fc3cff64d1470cbf4a50eb0261e"><td class="memItemLeft" align="right" valign="top">llvm::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a79a75fc3cff64d1470cbf4a50eb0261e">analyzeModuleOp</a> (ModuleOp moduleOp, <a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;state, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *statistics=nullptr)</td></tr>
<tr class="memdesc:a79a75fc3cff64d1470cbf4a50eb0261e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze <code>moduleOp</code> and its nested ops.  <a href="namespacemlir_1_1bufferization.html#a79a75fc3cff64d1470cbf4a50eb0261e">More...</a><br /></td></tr>
<tr class="separator:a79a75fc3cff64d1470cbf4a50eb0261e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb127f406f6c5e58ffe5ee4939037891"><td class="memItemLeft" align="right" valign="top">llvm::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#afb127f406f6c5e58ffe5ee4939037891">bufferizeModuleOp</a> (ModuleOp moduleOp, const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *statistics=nullptr)</td></tr>
<tr class="memdesc:afb127f406f6c5e58ffe5ee4939037891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>.  <a href="namespacemlir_1_1bufferization.html#afb127f406f6c5e58ffe5ee4939037891">More...</a><br /></td></tr>
<tr class="separator:afb127f406f6c5e58ffe5ee4939037891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cfedafe4d56324592c31cbe6c7ddb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ac2cfedafe4d56324592c31cbe6c7ddb1">removeBufferizationAttributesInModule</a> (ModuleOp moduleOp)</td></tr>
<tr class="memdesc:ac2cfedafe4d56324592c31cbe6c7ddb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove bufferization attributes on every FuncOp arguments in the ModuleOp.  <a href="namespacemlir_1_1bufferization.html#ac2cfedafe4d56324592c31cbe6c7ddb1">More...</a><br /></td></tr>
<tr class="separator:ac2cfedafe4d56324592c31cbe6c7ddb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b77f5324f17a99ff8b568521bfaeadd"><td class="memItemLeft" align="right" valign="top">llvm::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a3b77f5324f17a99ff8b568521bfaeadd">runOneShotModuleBufferize</a> (ModuleOp moduleOp, const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">bufferization::OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *statistics=nullptr)</td></tr>
<tr class="memdesc:a3b77f5324f17a99ff8b568521bfaeadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run One-Shot Module Bufferization on the given module.  <a href="namespacemlir_1_1bufferization.html#a3b77f5324f17a99ff8b568521bfaeadd">More...</a><br /></td></tr>
<tr class="separator:a3b77f5324f17a99ff8b568521bfaeadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbadbbffeae2eddfac65c53b2f1cadba"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#adbadbbffeae2eddfac65c53b2f1cadba">createBufferDeallocationPass</a> ()</td></tr>
<tr class="memdesc:adbadbbffeae2eddfac65c53b2f1cadba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the BufferDeallocation pass to free all allocated buffers.  <a href="namespacemlir_1_1bufferization.html#adbadbbffeae2eddfac65c53b2f1cadba">More...</a><br /></td></tr>
<tr class="separator:adbadbbffeae2eddfac65c53b2f1cadba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e57bdde231ec28efdc147d445958ac"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a31e57bdde231ec28efdc147d445958ac">createOwnershipBasedBufferDeallocationPass</a> (<a class="el" href="structmlir_1_1bufferization_1_1DeallocationOptions.html">DeallocationOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>=<a class="el" href="structmlir_1_1bufferization_1_1DeallocationOptions.html">DeallocationOptions</a>())</td></tr>
<tr class="memdesc:a31e57bdde231ec28efdc147d445958ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the OwnershipBasedBufferDeallocation pass to free all allocated buffers.  <a href="namespacemlir_1_1bufferization.html#a31e57bdde231ec28efdc147d445958ac">More...</a><br /></td></tr>
<tr class="separator:a31e57bdde231ec28efdc147d445958ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5478bc4aaa2dfcc1ca2e783dc6ba24"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#abb5478bc4aaa2dfcc1ca2e783dc6ba24">createOptimizeAllocationLivenessPass</a> ()</td></tr>
<tr class="memdesc:abb5478bc4aaa2dfcc1ca2e783dc6ba24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that finds all temporary allocations and attempts to move the deallocation after the last user/dependency of the allocation, thereby optimizing allocation liveness.  <a href="namespacemlir_1_1bufferization.html#abb5478bc4aaa2dfcc1ca2e783dc6ba24">More...</a><br /></td></tr>
<tr class="separator:abb5478bc4aaa2dfcc1ca2e783dc6ba24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ddd371af2e033662320031b07f2297"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a92ddd371af2e033662320031b07f2297">createBufferDeallocationSimplificationPass</a> ()</td></tr>
<tr class="memdesc:a92ddd371af2e033662320031b07f2297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that optimizes <code>bufferization.dealloc</code> operations.  <a href="namespacemlir_1_1bufferization.html#a92ddd371af2e033662320031b07f2297">More...</a><br /></td></tr>
<tr class="separator:a92ddd371af2e033662320031b07f2297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d5be30e19cfc77aacf19b47819a52f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a81d5be30e19cfc77aacf19b47819a52f">createLowerDeallocationsPass</a> ()</td></tr>
<tr class="memdesc:a81d5be30e19cfc77aacf19b47819a52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the LowerDeallocations pass to lower <code>bufferization.dealloc</code> operations to the <code>memref</code> dialect.  <a href="namespacemlir_1_1bufferization.html#a81d5be30e19cfc77aacf19b47819a52f">More...</a><br /></td></tr>
<tr class="separator:a81d5be30e19cfc77aacf19b47819a52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27faa0cefe57ae46dfee1e25392c0d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aa27faa0cefe57ae46dfee1e25392c0d4">populateBufferizationDeallocLoweringPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="namespacemlir_1_1bufferization.html#a76fe5cbf8af77269764f32ac8bf566ea">DeallocHelperMap</a> &amp;deallocHelperFuncMap)</td></tr>
<tr class="memdesc:aa27faa0cefe57ae46dfee1e25392c0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the conversion pattern of the <code>bufferization.dealloc</code> operation to the given pattern set for use in other transformation passes.  <a href="namespacemlir_1_1bufferization.html#aa27faa0cefe57ae46dfee1e25392c0d4">More...</a><br /></td></tr>
<tr class="separator:aa27faa0cefe57ae46dfee1e25392c0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addca2ef035b8c6b2f60fac72c2b9f7e7"><td class="memItemLeft" align="right" valign="top">func::FuncOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#addca2ef035b8c6b2f60fac72c2b9f7e7">buildDeallocationLibraryFunction</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1SymbolTable.html">SymbolTable</a> &amp;symbolTable)</td></tr>
<tr class="memdesc:addca2ef035b8c6b2f60fac72c2b9f7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the library function needed for the fully generic <code>bufferization.dealloc</code> lowering implemented in the LowerDeallocations pass.  <a href="namespacemlir_1_1bufferization.html#addca2ef035b8c6b2f60fac72c2b9f7e7">More...</a><br /></td></tr>
<tr class="separator:addca2ef035b8c6b2f60fac72c2b9f7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9fe9c9234e2d22a86553a393f074d8"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a8e9fe9c9234e2d22a86553a393f074d8">deallocateBuffers</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a8e9fe9c9234e2d22a86553a393f074d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run buffer deallocation.  <a href="namespacemlir_1_1bufferization.html#a8e9fe9c9234e2d22a86553a393f074d8">More...</a><br /></td></tr>
<tr class="separator:a8e9fe9c9234e2d22a86553a393f074d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec5dfe0550744dc49e38d66283e30e3"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aaec5dfe0550744dc49e38d66283e30e3">deallocateBuffersOwnershipBased</a> (FunctionOpInterface op, <a class="el" href="structmlir_1_1bufferization_1_1DeallocationOptions.html">DeallocationOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:aaec5dfe0550744dc49e38d66283e30e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the ownership-based buffer deallocation.  <a href="namespacemlir_1_1bufferization.html#aaec5dfe0550744dc49e38d66283e30e3">More...</a><br /></td></tr>
<tr class="separator:aaec5dfe0550744dc49e38d66283e30e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b99b019001e22f13cbb9adaf483febe"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a4b99b019001e22f13cbb9adaf483febe">createBufferHoistingPass</a> ()</td></tr>
<tr class="memdesc:a4b99b019001e22f13cbb9adaf483febe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that moves allocations upwards to reduce the number of required copies that are inserted during the BufferDeallocation pass.  <a href="namespacemlir_1_1bufferization.html#a4b99b019001e22f13cbb9adaf483febe">More...</a><br /></td></tr>
<tr class="separator:a4b99b019001e22f13cbb9adaf483febe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f24bfd4dabfbaa35cb099c0cc78480"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a94f24bfd4dabfbaa35cb099c0cc78480">createBufferLoopHoistingPass</a> ()</td></tr>
<tr class="memdesc:a94f24bfd4dabfbaa35cb099c0cc78480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that moves allocations upwards out of loops.  <a href="namespacemlir_1_1bufferization.html#a94f24bfd4dabfbaa35cb099c0cc78480">More...</a><br /></td></tr>
<tr class="separator:a94f24bfd4dabfbaa35cb099c0cc78480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701713c12ed3b4d825153984b184cc07"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a701713c12ed3b4d825153984b184cc07">createBufferResultsToOutParamsPass</a> (const <a class="el" href="structmlir_1_1bufferization_1_1BufferResultsToOutParamsOpts.html">BufferResultsToOutParamsOpts</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>={})</td></tr>
<tr class="memdesc:a701713c12ed3b4d825153984b184cc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that converts memref function results to out-params.  <a href="namespacemlir_1_1bufferization.html#a701713c12ed3b4d825153984b184cc07">More...</a><br /></td></tr>
<tr class="separator:a701713c12ed3b4d825153984b184cc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a977a84049ece28cbc92bf2c1337f7"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a67a977a84049ece28cbc92bf2c1337f7">promoteBufferResultsToOutParams</a> (ModuleOp module, const <a class="el" href="structmlir_1_1bufferization_1_1BufferResultsToOutParamsOpts.html">BufferResultsToOutParamsOpts</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a67a977a84049ece28cbc92bf2c1337f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace buffers that are returned from a function with an out parameter.  <a href="namespacemlir_1_1bufferization.html#a67a977a84049ece28cbc92bf2c1337f7">More...</a><br /></td></tr>
<tr class="separator:a67a977a84049ece28cbc92bf2c1337f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef2e0a39b0ed448dd072072ac76c68e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a1ef2e0a39b0ed448dd072072ac76c68e">createDropEquivalentBufferResultsPass</a> ()</td></tr>
<tr class="memdesc:a1ef2e0a39b0ed448dd072072ac76c68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that drops memref function results that are equivalent to a function argument.  <a href="namespacemlir_1_1bufferization.html#a1ef2e0a39b0ed448dd072072ac76c68e">More...</a><br /></td></tr>
<tr class="separator:a1ef2e0a39b0ed448dd072072ac76c68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1a94d4d5cc33f606dc0309a1d0b8db"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aea1a94d4d5cc33f606dc0309a1d0b8db">createEmptyTensorToAllocTensorPass</a> ()</td></tr>
<tr class="memdesc:aea1a94d4d5cc33f606dc0309a1d0b8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that rewrites tensor.empty to bufferization.alloc_tensor.  <a href="namespacemlir_1_1bufferization.html#aea1a94d4d5cc33f606dc0309a1d0b8db">More...</a><br /></td></tr>
<tr class="separator:aea1a94d4d5cc33f606dc0309a1d0b8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae342871cac8184abb98eb585dc44bf7e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ae342871cac8184abb98eb585dc44bf7e">dropEquivalentBufferResults</a> (ModuleOp module)</td></tr>
<tr class="memdesc:ae342871cac8184abb98eb585dc44bf7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop all memref function results that are equivalent to a function argument.  <a href="namespacemlir_1_1bufferization.html#ae342871cac8184abb98eb585dc44bf7e">More...</a><br /></td></tr>
<tr class="separator:ae342871cac8184abb98eb585dc44bf7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851c8abcfd5da0332cb96347484e750e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a851c8abcfd5da0332cb96347484e750e">createFinalizingBufferizePass</a> ()</td></tr>
<tr class="memdesc:a851c8abcfd5da0332cb96347484e750e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that finalizes a partial bufferization by removing remaining bufferization.to_tensor and bufferization.to_memref operations.  <a href="namespacemlir_1_1bufferization.html#a851c8abcfd5da0332cb96347484e750e">More...</a><br /></td></tr>
<tr class="separator:a851c8abcfd5da0332cb96347484e750e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a438c09e875e0ca7b69ac35bd415812"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a8a438c09e875e0ca7b69ac35bd415812">createOneShotBufferizePass</a> ()</td></tr>
<tr class="memdesc:a8a438c09e875e0ca7b69ac35bd415812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that bufferizes all ops that implement BufferizableOpInterface with One-Shot Bufferize.  <a href="namespacemlir_1_1bufferization.html#a8a438c09e875e0ca7b69ac35bd415812">More...</a><br /></td></tr>
<tr class="separator:a8a438c09e875e0ca7b69ac35bd415812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6db8eb7bfe512d8fdd2a3bcc14767b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a0e6db8eb7bfe512d8fdd2a3bcc14767b">createOneShotBufferizePass</a> (const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a0e6db8eb7bfe512d8fdd2a3bcc14767b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that bufferizes all ops that implement BufferizableOpInterface with One-Shot Bufferize and the specified bufferization options.  <a href="namespacemlir_1_1bufferization.html#a0e6db8eb7bfe512d8fdd2a3bcc14767b">More...</a><br /></td></tr>
<tr class="separator:a0e6db8eb7bfe512d8fdd2a3bcc14767b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd135f127fc250fb96fd3817f98ab9d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aadd135f127fc250fb96fd3817f98ab9d">createPromoteBuffersToStackPass</a> (unsigned maxAllocSizeInBytes=1024, unsigned maxRankOfAllocatedMemRef=1)</td></tr>
<tr class="memdesc:aadd135f127fc250fb96fd3817f98ab9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that promotes heap-based allocations to stack-based ones.  <a href="namespacemlir_1_1bufferization.html#aadd135f127fc250fb96fd3817f98ab9d">More...</a><br /></td></tr>
<tr class="separator:aadd135f127fc250fb96fd3817f98ab9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a9fdbeb428d3911ee0fbfbc3854283"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a62a9fdbeb428d3911ee0fbfbc3854283">createPromoteBuffersToStackPass</a> (std::function&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; isSmallAlloc)</td></tr>
<tr class="memdesc:a62a9fdbeb428d3911ee0fbfbc3854283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that promotes heap-based allocations to stack-based ones.  <a href="namespacemlir_1_1bufferization.html#a62a9fdbeb428d3911ee0fbfbc3854283">More...</a><br /></td></tr>
<tr class="separator:a62a9fdbeb428d3911ee0fbfbc3854283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d40b6466dba71592273b41aa9abd340"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a9d40b6466dba71592273b41aa9abd340">createEmptyTensorEliminationPass</a> ()</td></tr>
<tr class="memdesc:a9d40b6466dba71592273b41aa9abd340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that tries to eliminate tensor.empty ops that are anchored on insert_slice ops.  <a href="namespacemlir_1_1bufferization.html#a9d40b6466dba71592273b41aa9abd340">More...</a><br /></td></tr>
<tr class="separator:a9d40b6466dba71592273b41aa9abd340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d65c46b9c79a6965bea2b62ef26a649"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a7d65c46b9c79a6965bea2b62ef26a649">eliminateEmptyTensors</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a7d65c46b9c79a6965bea2b62ef26a649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to eliminate "tensor.empty" ops inside <code>op</code>.  <a href="namespacemlir_1_1bufferization.html#a7d65c46b9c79a6965bea2b62ef26a649">More...</a><br /></td></tr>
<tr class="separator:a7d65c46b9c79a6965bea2b62ef26a649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87e9eee7d425c90207d7205106a0ea7"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ae87e9eee7d425c90207d7205106a0ea7">eliminateEmptyTensors</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;state)</td></tr>
<tr class="memdesc:ae87e9eee7d425c90207d7205106a0ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to eliminate "tensor.empty" ops inside <code>op</code>.  <a href="namespacemlir_1_1bufferization.html#ae87e9eee7d425c90207d7205106a0ea7">More...</a><br /></td></tr>
<tr class="separator:ae87e9eee7d425c90207d7205106a0ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6660fcb71a7865869c899d7bd3577e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a2e6660fcb71a7865869c899d7bd3577e">hoistBuffersFromLoops</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a2e6660fcb71a7865869c899d7bd3577e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Within the given operation, hoist buffers from loops where possible.  <a href="namespacemlir_1_1bufferization.html#a2e6660fcb71a7865869c899d7bd3577e">More...</a><br /></td></tr>
<tr class="separator:a2e6660fcb71a7865869c899d7bd3577e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da8751907537f3ff866a413457155a3"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a6da8751907537f3ff866a413457155a3">insertTensorCopies</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *statistics=nullptr)</td></tr>
<tr class="memdesc:a6da8751907537f3ff866a413457155a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve RaW and other conflicts by inserting bufferization.alloc_tensor ops.  <a href="namespacemlir_1_1bufferization.html#a6da8751907537f3ff866a413457155a3">More...</a><br /></td></tr>
<tr class="separator:a6da8751907537f3ff866a413457155a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa163b2955215e8f16e7105f5caa3cb27"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aa163b2955215e8f16e7105f5caa3cb27">insertTensorCopies</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">AnalysisState</a> &amp;state)</td></tr>
<tr class="memdesc:aa163b2955215e8f16e7105f5caa3cb27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve RaW and other conflicts by inserting bufferization.alloc_tensor ops.  <a href="namespacemlir_1_1bufferization.html#aa163b2955215e8f16e7105f5caa3cb27">More...</a><br /></td></tr>
<tr class="separator:aa163b2955215e8f16e7105f5caa3cb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41285ff4926c59c44f84d013df399b83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a41285ff4926c59c44f84d013df399b83">populateEmptyTensorToAllocTensorPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a41285ff4926c59c44f84d013df399b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns to lower tensor.empty ops to bufferization.alloc_tensor ops.  <a href="namespacemlir_1_1bufferization.html#a41285ff4926c59c44f84d013df399b83">More...</a><br /></td></tr>
<tr class="separator:a41285ff4926c59c44f84d013df399b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a976af01e3a00f974529232f7e611233c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976af01e3a00f974529232f7e611233c">&#9670;&nbsp;</a></span>AliasingOpOperandList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1bufferization.html#a976af01e3a00f974529232f7e611233c">mlir::bufferization::AliasingOpOperandList</a> = typedef <a class="el" href="classmlir_1_1bufferization_1_1AliasList.html">AliasList</a>&lt;<a class="el" href="structmlir_1_1bufferization_1_1AliasingOpOperand.html">AliasingOpOperand</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of possible aliasing OpOperands. </p>
<p>This list models the runtime aliasing relationship for a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8h_source.html#l00094">94</a> of file <a class="el" href="BufferizableOpInterface_8h_source.html">BufferizableOpInterface.h</a>.</p>

</div>
</div>
<a id="a3d4492dc8080792451e4432c4b014544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4492dc8080792451e4432c4b014544">&#9670;&nbsp;</a></span>AliasingValueList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1bufferization.html#a3d4492dc8080792451e4432c4b014544">mlir::bufferization::AliasingValueList</a> = typedef <a class="el" href="classmlir_1_1bufferization_1_1AliasList.html">AliasList</a>&lt;<a class="el" href="structmlir_1_1bufferization_1_1AliasingValue.html">AliasingValue</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of possible aliasing Values. </p>
<p>This list models the runtime aliasing relationship for an <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a>. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8h_source.html#l00098">98</a> of file <a class="el" href="BufferizableOpInterface_8h_source.html">BufferizableOpInterface.h</a>.</p>

</div>
</div>
<a id="a76fe5cbf8af77269764f32ac8bf566ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fe5cbf8af77269764f32ac8bf566ea">&#9670;&nbsp;</a></span>DeallocHelperMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1bufferization.html#a76fe5cbf8af77269764f32ac8bf566ea">mlir::bufferization::DeallocHelperMap</a> = typedef <a class="el" href="classllvm_1_1DenseMap.html">llvm::DenseMap</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, func::FuncOp&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps from symbol table to its corresponding dealloc helper function. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Bufferization_2Transforms_2Passes_8h_source.html#l00022">22</a> of file <a class="el" href="Dialect_2Bufferization_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a3f8ce1066619c9152afa16b4ec7286dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8ce1066619c9152afa16b4ec7286dc">&#9670;&nbsp;</a></span>RegisterDependenciesFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1bufferization.html#a3f8ce1066619c9152afa16b4ec7286dc">mlir::bufferization::RegisterDependenciesFn</a> = typedef std::function&lt;void(<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BufferViewFlowOpInterface_8h_source.html#l00020">20</a> of file <a class="el" href="BufferViewFlowOpInterface_8h_source.html">BufferViewFlowOpInterface.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="afbf6d54f9e3c10b9003b66b6224b28bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf6d54f9e3c10b9003b66b6224b28bf">&#9670;&nbsp;</a></span>BufferRelation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bf">mlir::bufferization::BufferRelation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies a fine-grain relationship between buffers to enable more analysis. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afbf6d54f9e3c10b9003b66b6224b28bfa88183b946cc5f0e8c96b2e66e1c74a7e"></a>Unknown&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afbf6d54f9e3c10b9003b66b6224b28bfaafd102579f64c98e96d92a7424130605"></a>Equivalent&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8h_source.html#l00034">34</a> of file <a class="el" href="BufferizableOpInterface_8h_source.html">BufferizableOpInterface.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aab5f2c6412ef78600accb933077b59ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5f2c6412ef78600accb933077b59ec">&#9670;&nbsp;</a></span>allocateTensorForShapedValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::bufferization::allocateTensorForShapedValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>shapedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an AllocTensorOp for the given shaped value (memref or tensor). </p>
<p>Create an AllocTensorOp for the given shaped value.</p>
<p>If <code>copy</code> is set, the shaped value is copied. Otherwise, a tensor with undefined contents is allocated. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00147">147</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00071">copy()</a>, <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00268">mlir::Operation::emitError()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00664">getBufferType()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00138">getOwnerOfValue()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00402">mlir::Operation::getResult()</a>, <a class="el" href="Value_8h_source.html#l00129">mlir::Value::getType()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00133">populateDynamicDimSizes()</a>, and <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00026">mlir::reifyResultShapes()</a>.</p>

</div>
</div>
<a id="a79a75fc3cff64d1470cbf4a50eb0261e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a75fc3cff64d1470cbf4a50eb0261e">&#9670;&nbsp;</a></span>analyzeModuleOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::analyzeModuleOp </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>moduleOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze <code>moduleOp</code> and its nested ops. </p>
<p>Bufferization decisions are stored in <code>state</code>. </p>

<p class="definition">Definition at line <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00374">374</a> of file <a class="el" href="OneShotModuleBufferize_8cpp_source.html">OneShotModuleBufferize.cpp</a>.</p>

</div>
</div>
<a id="a1ec3ce210ab7a2c1c1e82a266bfb9e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec3ce210ab7a2c1c1e82a266bfb9e3f">&#9670;&nbsp;</a></span>analyzeOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::analyzeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze <code>op</code> and its nested ops. </p>
<p>Bufferization decisions are stored in <code>state</code>. </p>

<p class="definition">Definition at line <a class="el" href="OneShotAnalysis_8cpp_source.html#l01339">1339</a> of file <a class="el" href="OneShotAnalysis_8cpp_source.html">OneShotAnalysis.cpp</a>.</p>

</div>
</div>
<a id="a884913e487f39ecc7e0f69694afa9065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884913e487f39ecc7e0f69694afa9065">&#9670;&nbsp;</a></span>bufferizeBlockSignature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::bufferizeBlockSignature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bufferize the signature of <code>block</code> and its callers (i.e., ops that have the given block as a successor). </p>
<p>All block argument types are changed to memref types. All corresponding operands of all callers are wrapped in bufferization.to_memref ops. All uses of bufferized tensor block arguments are wrapped in bufferization.to_tensor ops.</p>
<p>It is expected that all callers implement the <code>BranchOpInterface</code>. Otherwise, this function will fail. The <code>BranchOpInterface</code> is used to query the range of operands that are forwarded to this block.</p>
<p>It is expected that the parent op of this block implements the <code>BufferizableOpInterface</code>. The buffer types of tensor block arguments are computed with <code>BufferizableOpIntercace::getBufferType</code>. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00537">537</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="Block_8h_source.html#l00085">mlir::Block::getArguments()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00664">getBufferType()</a>, <a class="el" href="Block_8cpp_source.html#l00030">mlir::Block::getParentOp()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="Builders_8h_source.html#l00439">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="afb127f406f6c5e58ffe5ee4939037891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb127f406f6c5e58ffe5ee4939037891">&#9670;&nbsp;</a></span>bufferizeModuleOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::bufferizeModuleOp </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>moduleOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>. </p>
<p>Note: This function does not run One-Shot Analysis. No buffer copies are inserted except two cases:</p><ul>
<li><code>options.copyBeforeWrite</code> is set, in which case buffers are copied before every write.</li>
<li><code>options.copyBeforeWrite</code> is not set and <code>options.noAnalysisFuncFilter</code> is not empty. The FuncOps it contains were not analyzed. Buffer copies will be inserted only to these FuncOps. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00425">425</a> of file <a class="el" href="OneShotModuleBufferize_8cpp_source.html">OneShotModuleBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00419">bufferizeOp()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00377">mlir::bufferization::BufferizationOptions::copyBeforeWrite</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00352">foldMemRefCasts()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00292">getFuncOpsOrderedByCalls()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a6b6386e784e181c430f97843ea979015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6386e784e181c430f97843ea979015">&#9670;&nbsp;</a></span>bufferizeOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::bufferizeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>. </p>
<p>Note: This function does not resolve read-after-write conflicts. Use this function only if it is guaranteed that the input IR can bufferize without additional buffer copies or set "options.copyBeforeWrite = true". The general bufferization entry point is <code>runOneShotBufferize</code>. </p>
<p>Check the result of bufferization. Return an error if an op was not bufferized, unless partial bufferization is allowed.</p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00419">419</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00425">bufferizeModuleOp()</a>.</p>

</div>
</div>
<a id="af49b581e6a12f245db92fa4da2d8fd9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af49b581e6a12f245db92fa4da2d8fd9f">&#9670;&nbsp;</a></span>buildBufferDeallocationPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::buildBufferDeallocationPipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferDeallocationPipelineOptions.html">BufferDeallocationPipelineOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the buffer deallocation pipeline to the <code><a class="el" href="classmlir_1_1OpPassManager.html" title="This class represents a pass manager that runs passes on either a specific operation type,...">OpPassManager</a></code>. </p>
<p>This is the standard pipeline for deallocating the MemRefs introduced by the One-Shot bufferization pass. </p>

<p class="definition">Definition at line <a class="el" href="BufferizationPipelines_8cpp_source.html#l00021">21</a> of file <a class="el" href="BufferizationPipelines_8cpp_source.html">BufferizationPipelines.cpp</a>.</p>

<p class="reference">References <a class="el" href="Pass_2Pass_8cpp_source.html#l00363">mlir::OpPassManager::addPass()</a>, <a class="el" href="BufferDeallocationSimplification_8cpp_source.html#l00482">createBufferDeallocationSimplificationPass()</a>, <a class="el" href="Canonicalizer_8cpp_source.html#l00074">mlir::createCanonicalizerPass()</a>, <a class="el" href="CSE_8cpp_source.html#l00416">mlir::createCSEPass()</a>, <a class="el" href="ExpandRealloc_8cpp_source.html#l00173">mlir::memref::createExpandReallocPass()</a>, <a class="el" href="LowerDeallocations_8cpp_source.html#l00550">createLowerDeallocationsPass()</a>, <a class="el" href="OwnershipBasedBufferDeallocation_8cpp_source.html#l01069">createOwnershipBasedBufferDeallocationPass()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizationPipelines_8cpp_source.html#l00037">registerBufferizationPipelines()</a>.</p>

</div>
</div>
<a id="addca2ef035b8c6b2f60fac72c2b9f7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addca2ef035b8c6b2f60fac72c2b9f7e7">&#9670;&nbsp;</a></span>buildDeallocationLibraryFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">func::FuncOp mlir::bufferization::buildDeallocationLibraryFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SymbolTable.html">SymbolTable</a> &amp;&#160;</td>
          <td class="paramname"><em>symbolTable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the library function needed for the fully generic <code>bufferization.dealloc</code> lowering implemented in the LowerDeallocations pass. </p>
<p>The function can then be called at bufferization dealloc sites to determine aliasing and ownership.</p>
<p>The generated function takes two memrefs of indices and three memrefs of booleans as arguments:</p><ul>
<li>The first argument A should contain the result of the extract_aligned_pointer_as_index operation applied to the memrefs to be deallocated</li>
<li>The second argument B should contain the result of the extract_aligned_pointer_as_index operation applied to the memrefs to be retained</li>
<li>The third argument C should contain the conditions as passed directly to the deallocation operation.</li>
<li>The fourth argument D is used to pass results to the caller. Those represent the condition under which the memref at the corresponding position in A should be deallocated.</li>
<li>The fifth argument E is used to pass results to the caller. It provides the ownership value corresponding the the memref at the same position in B</li>
</ul>
<p>This helper function is supposed to be called once for each <code>bufferization.dealloc</code> operation to determine the deallocation need and new ownership indicator for the retained values, but does not perform the deallocation itself.</p>
<p>Generated code: </p><div class="fragment"><div class="line">func.func @dealloc_helper(</div>
<div class="line">    %dyn_dealloc_base_pointer_list: memref&lt;?xindex&gt;,</div>
<div class="line">    %dyn_retain_base_pointer_list: memref&lt;?xindex&gt;,</div>
<div class="line">    %dyn_cond_list: memref&lt;?xi1&gt;,</div>
<div class="line">    %dyn_dealloc_cond_out: memref&lt;?xi1&gt;,</div>
<div class="line">    %dyn_ownership_out: memref&lt;?xi1&gt;) {</div>
<div class="line">  %c0 = arith.constant 0 : index</div>
<div class="line">  %c1 = arith.constant 1 : index</div>
<div class="line">  %<span class="keyword">true</span> = arith.constant <span class="keyword">true</span></div>
<div class="line">  %<span class="keyword">false</span> = arith.constant <span class="keyword">false</span></div>
<div class="line">  %num_dealloc_memrefs = memref.dim %dyn_dealloc_base_pointer_list, %c0</div>
<div class="line">  %num_retain_memrefs = memref.dim %dyn_retain_base_pointer_list, %c0</div>
<div class="line">  <span class="comment">// Zero initialize result buffer.</span></div>
<div class="line">  scf.for %i = %c0 to %num_retain_memrefs step %c1 {</div>
<div class="line">    memref.store %<span class="keyword">false</span>, %dyn_ownership_out[%i] : memref&lt;?xi1&gt;</div>
<div class="line">  }</div>
<div class="line">  scf.for %i = %c0 to %num_dealloc_memrefs step %c1 {</div>
<div class="line">    %dealloc_bp = memref.load %dyn_dealloc_base_pointer_list[%i]</div>
<div class="line">    %cond = memref.load %dyn_cond_list[%i]</div>
<div class="line">    <span class="comment">// Check for aliasing with retained memrefs.</span></div>
<div class="line">    %does_not_alias_retained = scf.for %<a class="code" href="unionj.html">j</a> = %c0 to %num_retain_memrefs</div>
<div class="line">        step %c1 iter_args(%does_not_alias_aggregated = %<span class="keyword">true</span>) -&gt; (i1) {</div>
<div class="line">      %retain_bp = memref.load %dyn_retain_base_pointer_list[%<a class="code" href="unionj.html">j</a>]</div>
<div class="line">      %does_alias = arith.cmpi <a class="code" href="namespacemlir_1_1intrange.html#a781c30a009f6baedd903c15496b9ac31adf22f17124884fc51f1ac69d610096ac">eq</a>, %retain_bp, %dealloc_bp : index</div>
<div class="line">      scf.if %does_alias {</div>
<div class="line">        %curr_ownership = memref.load %dyn_ownership_out[%<a class="code" href="unionj.html">j</a>]</div>
<div class="line">        %updated_ownership = arith.ori %curr_ownership, %cond : i1</div>
<div class="line">        memref.store %updated_ownership, %dyn_ownership_out[%<a class="code" href="unionj.html">j</a>]</div>
<div class="line">      }</div>
<div class="line">      %does_not_alias = arith.cmpi <a class="code" href="namespacemlir_1_1intrange.html#a781c30a009f6baedd903c15496b9ac31ad4f917633649a3c47c7ab917fa990146">ne</a>, %retain_bp, %dealloc_bp : index</div>
<div class="line">      %updated_aggregate = arith.andi %does_not_alias_aggregated,</div>
<div class="line">                                      %does_not_alias : i1</div>
<div class="line">      scf.yield %updated_aggregate : i1</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Check for aliasing with dealloc memrefs in the list before the</span></div>
<div class="line">    <span class="comment">// current one, i.e.,</span></div>
<div class="line">    <span class="comment">// `fix i, forall j &lt; i: check_aliasing(%dyn_dealloc_base_pointer[j],</span></div>
<div class="line">    <span class="comment">// %dyn_dealloc_base_pointer[i])`</span></div>
<div class="line">    %does_not_alias_any = scf.for %<a class="code" href="unionj.html">j</a> = %c0 to %i step %c1</div>
<div class="line">       iter_args(%does_not_alias_agg = %does_not_alias_retained) -&gt; (i1) {</div>
<div class="line">      %prev_dealloc_bp = memref.load %dyn_dealloc_base_pointer_list[%<a class="code" href="unionj.html">j</a>]</div>
<div class="line">      %does_not_alias = arith.cmpi <a class="code" href="namespacemlir_1_1intrange.html#a781c30a009f6baedd903c15496b9ac31ad4f917633649a3c47c7ab917fa990146">ne</a>, %prev_dealloc_bp, %dealloc_bp</div>
<div class="line">      %updated_alias_agg = arith.andi %does_not_alias_agg, %does_not_alias</div>
<div class="line">      scf.yield %updated_alias_agg : i1</div>
<div class="line">    }</div>
<div class="line">    %dealloc_cond = arith.andi %does_not_alias_any, %cond : i1</div>
<div class="line">    memref.store %dealloc_cond, %dyn_dealloc_cond_out[%i] : memref&lt;?xi1&gt;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespacemlir_1_1intrange_html_a781c30a009f6baedd903c15496b9ac31ad4f917633649a3c47c7ab917fa990146"><div class="ttname"><a href="namespacemlir_1_1intrange.html#a781c30a009f6baedd903c15496b9ac31ad4f917633649a3c47c7ab917fa990146">mlir::intrange::CmpPredicate::ne</a></div><div class="ttdeci">@ ne</div></div>
<div class="ttc" id="anamespacemlir_1_1intrange_html_a781c30a009f6baedd903c15496b9ac31adf22f17124884fc51f1ac69d610096ac"><div class="ttname"><a href="namespacemlir_1_1intrange.html#a781c30a009f6baedd903c15496b9ac31adf22f17124884fc51f1ac69d610096ac">mlir::intrange::CmpPredicate::eq</a></div><div class="ttdeci">@ eq</div></div>
<div class="ttc" id="aunionj_html"><div class="ttname"><a href="unionj.html">j</a></div><div class="ttdoc">Eliminates variable at the specified position using Fourier-Motzkin variable elimination.</div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="LowerDeallocations_8cpp_source.html#l00427">427</a> of file <a class="el" href="LowerDeallocations_8cpp_source.html">LowerDeallocations.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00387">mlir::OpBuilder::clearInsertionPoint()</a>, <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00140">mlir::Builder::getBoolAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00120">mlir::Builder::getFunctionType()</a>, <a class="el" href="Builders_8cpp_source.html#l00097">mlir::Builder::getI1Type()</a>, <a class="el" href="Builders_8cpp_source.html#l00148">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00095">mlir::Builder::getIndexType()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00171">mlir::SymbolTable::insert()</a>, <a class="el" href="classmlir_1_1SymbolTable.html#a4f1a6f39b93a08abe4e80a5c15fe32b8a47f9082fc380ca62d531096aa1d110f1">mlir::SymbolTable::Private</a>, and <a class="el" href="Builders_8h_source.html#l00439">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="a15d27e15fb5438e5f331ac1da1bf424c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d27e15fb5438e5f331ac1da1bf424c">&#9670;&nbsp;</a></span>castOrReallocMemRefValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::bufferization::castOrReallocMemRefValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to cast the given ranked MemRef-typed value to the given ranked MemRef type. </p>
<p>Insert a reallocation + copy if it cannot be statically guaranteed that a direct cast would be valid.</p>
<p>E.g., when casting from a ranked MemRef type with dynamic layout to a ranked MemRef type with static layout, it is not statically known whether the cast will succeed or not. Such <code>memref.cast</code> ops may fail at runtime. This function never generates such casts and conservatively inserts a copy.</p>
<p>This function returns <code>failure()</code> in case of unsupported casts. E.g., casts with differing element types or memory spaces. </p>

<p class="definition">Definition at line <a class="el" href="BufferizationOps_8cpp_source.html#l00026">26</a> of file <a class="el" href="BufferizationOps_8cpp_source.html">BufferizationOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00071">copy()</a>, <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="Value_8cpp_source.html#l00026">mlir::Value::getLoc()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00823">mlir::getStridesAndOffset()</a>, <a class="el" href="Value_8h_source.html#l00129">mlir::Value::getType()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00053">mlir::bufferization::BufferizeTypeConverter::BufferizeTypeConverter()</a>, and <a class="el" href="BufferizationOps_8cpp_source.html#l00088">foldToMemrefToTensorPair()</a>.</p>

</div>
</div>
<a id="adbadbbffeae2eddfac65c53b2f1cadba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbadbbffeae2eddfac65c53b2f1cadba">&#9670;&nbsp;</a></span>createBufferDeallocationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferDeallocationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the BufferDeallocation pass to free all allocated buffers. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocation_8cpp_source.html#l00691">691</a> of file <a class="el" href="BufferDeallocation_8cpp_source.html">BufferDeallocation.cpp</a>.</p>

</div>
</div>
<a id="a92ddd371af2e033662320031b07f2297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ddd371af2e033662320031b07f2297">&#9670;&nbsp;</a></span>createBufferDeallocationSimplificationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferDeallocationSimplificationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that optimizes <code>bufferization.dealloc</code> operations. </p>
<p>For example, it reduces the number of alias checks needed at runtime using static alias analysis. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocationSimplification_8cpp_source.html#l00482">482</a> of file <a class="el" href="BufferDeallocationSimplification_8cpp_source.html">BufferDeallocationSimplification.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizationPipelines_8cpp_source.html#l00021">buildBufferDeallocationPipeline()</a>.</p>

</div>
</div>
<a id="a4b99b019001e22f13cbb9adaf483febe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b99b019001e22f13cbb9adaf483febe">&#9670;&nbsp;</a></span>createBufferHoistingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferHoistingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that moves allocations upwards to reduce the number of required copies that are inserted during the BufferDeallocation pass. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00482">482</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="a94f24bfd4dabfbaa35cb099c0cc78480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f24bfd4dabfbaa35cb099c0cc78480">&#9670;&nbsp;</a></span>createBufferLoopHoistingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferLoopHoistingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that moves allocations upwards out of loops. </p>
<p>This avoids reallocations inside of loops. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00486">486</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="a701713c12ed3b4d825153984b184cc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701713c12ed3b4d825153984b184cc07">&#9670;&nbsp;</a></span>createBufferResultsToOutParamsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferResultsToOutParamsPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferResultsToOutParamsOpts.html">BufferResultsToOutParamsOpts</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that converts memref function results to out-params. </p>

<p class="definition">Definition at line <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00257">257</a> of file <a class="el" href="BufferResultsToOutParams_8cpp_source.html">BufferResultsToOutParams.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a1ef2e0a39b0ed448dd072072ac76c68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef2e0a39b0ed448dd072072ac76c68e">&#9670;&nbsp;</a></span>createDropEquivalentBufferResultsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createDropEquivalentBufferResultsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that drops memref function results that are equivalent to a function argument. </p>

<p class="definition">Definition at line <a class="el" href="DropEquivalentBufferResults_8cpp_source.html#l00162">162</a> of file <a class="el" href="DropEquivalentBufferResults_8cpp_source.html">DropEquivalentBufferResults.cpp</a>.</p>

</div>
</div>
<a id="a9d40b6466dba71592273b41aa9abd340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d40b6466dba71592273b41aa9abd340">&#9670;&nbsp;</a></span>createEmptyTensorEliminationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createEmptyTensorEliminationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that tries to eliminate tensor.empty ops that are anchored on insert_slice ops. </p>

<p class="definition">Definition at line <a class="el" href="EmptyTensorElimination_8cpp_source.html#l00216">216</a> of file <a class="el" href="EmptyTensorElimination_8cpp_source.html">EmptyTensorElimination.cpp</a>.</p>

</div>
</div>
<a id="aea1a94d4d5cc33f606dc0309a1d0b8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1a94d4d5cc33f606dc0309a1d0b8db">&#9670;&nbsp;</a></span>createEmptyTensorToAllocTensorPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createEmptyTensorToAllocTensorPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that rewrites tensor.empty to bufferization.alloc_tensor. </p>

<p class="definition">Definition at line <a class="el" href="EmptyTensorToAllocTensor_8cpp_source.html#l00068">68</a> of file <a class="el" href="EmptyTensorToAllocTensor_8cpp_source.html">EmptyTensorToAllocTensor.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a851c8abcfd5da0332cb96347484e750e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851c8abcfd5da0332cb96347484e750e">&#9670;&nbsp;</a></span>createFinalizingBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::bufferization::createFinalizingBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that finalizes a partial bufferization by removing remaining bufferization.to_tensor and bufferization.to_memref operations. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00334">334</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00032">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="a81d5be30e19cfc77aacf19b47819a52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d5be30e19cfc77aacf19b47819a52f">&#9670;&nbsp;</a></span>createLowerDeallocationsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createLowerDeallocationsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the LowerDeallocations pass to lower <code>bufferization.dealloc</code> operations to the <code>memref</code> dialect. </p>

<p class="definition">Definition at line <a class="el" href="LowerDeallocations_8cpp_source.html#l00550">550</a> of file <a class="el" href="LowerDeallocations_8cpp_source.html">LowerDeallocations.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizationPipelines_8cpp_source.html#l00021">buildBufferDeallocationPipeline()</a>.</p>

</div>
</div>
<a id="a8a438c09e875e0ca7b69ac35bd415812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a438c09e875e0ca7b69ac35bd415812">&#9670;&nbsp;</a></span>createOneShotBufferizePass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createOneShotBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that bufferizes all ops that implement BufferizableOpInterface with One-Shot Bufferize. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00324">324</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

</div>
</div>
<a id="a0e6db8eb7bfe512d8fdd2a3bcc14767b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6db8eb7bfe512d8fdd2a3bcc14767b">&#9670;&nbsp;</a></span>createOneShotBufferizePass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createOneShotBufferizePass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that bufferizes all ops that implement BufferizableOpInterface with One-Shot Bufferize and the specified bufferization options. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00328">328</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="abb5478bc4aaa2dfcc1ca2e783dc6ba24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5478bc4aaa2dfcc1ca2e783dc6ba24">&#9670;&nbsp;</a></span>createOptimizeAllocationLivenessPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createOptimizeAllocationLivenessPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that finds all temporary allocations and attempts to move the deallocation after the last user/dependency of the allocation, thereby optimizing allocation liveness. </p>

<p class="definition">Definition at line <a class="el" href="OptimizeAllocationLiveness_8cpp_source.html#l00159">159</a> of file <a class="el" href="OptimizeAllocationLiveness_8cpp_source.html">OptimizeAllocationLiveness.cpp</a>.</p>

</div>
</div>
<a id="a31e57bdde231ec28efdc147d445958ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e57bdde231ec28efdc147d445958ac">&#9670;&nbsp;</a></span>createOwnershipBasedBufferDeallocationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createOwnershipBasedBufferDeallocationPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1DeallocationOptions.html">DeallocationOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1bufferization_1_1DeallocationOptions.html">DeallocationOptions</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the OwnershipBasedBufferDeallocation pass to free all allocated buffers. </p>

<p class="definition">Definition at line <a class="el" href="OwnershipBasedBufferDeallocation_8cpp_source.html#l01069">1069</a> of file <a class="el" href="OwnershipBasedBufferDeallocation_8cpp_source.html">OwnershipBasedBufferDeallocation.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizationPipelines_8cpp_source.html#l00021">buildBufferDeallocationPipeline()</a>.</p>

</div>
</div>
<a id="a62a9fdbeb428d3911ee0fbfbc3854283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a9fdbeb428d3911ee0fbfbc3854283">&#9670;&nbsp;</a></span>createPromoteBuffersToStackPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createPromoteBuffersToStackPass </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;&#160;</td>
          <td class="paramname"><em>isSmallAlloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that promotes heap-based allocations to stack-based ones. </p>
<p>Only buffers smaller with <code>isSmallAlloc(alloc) == true</code> are promoted. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00496">496</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="aadd135f127fc250fb96fd3817f98ab9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd135f127fc250fb96fd3817f98ab9d">&#9670;&nbsp;</a></span>createPromoteBuffersToStackPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createPromoteBuffersToStackPass </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxAllocSizeInBytes</em> = <code>1024</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxRankOfAllocatedMemRef</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that promotes heap-based allocations to stack-based ones. </p>
<p>Only buffers smaller than the provided size are promoted. Dynamic shaped buffers are promoted up to the given rank. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00490">490</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="a8e9fe9c9234e2d22a86553a393f074d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9fe9c9234e2d22a86553a393f074d8">&#9670;&nbsp;</a></span>deallocateBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::deallocateBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run buffer deallocation. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocation_8cpp_source.html#l00651">651</a> of file <a class="el" href="BufferDeallocation_8cpp_source.html">BufferDeallocation.cpp</a>.</p>

</div>
</div>
<a id="aaec5dfe0550744dc49e38d66283e30e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec5dfe0550744dc49e38d66283e30e3">&#9670;&nbsp;</a></span>deallocateBuffersOwnershipBased()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::deallocateBuffersOwnershipBased </td>
          <td>(</td>
          <td class="paramtype">FunctionOpInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1DeallocationOptions.html">DeallocationOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the ownership-based buffer deallocation. </p>

<p class="definition">Definition at line <a class="el" href="OwnershipBasedBufferDeallocation_8cpp_source.html#l01055">1055</a> of file <a class="el" href="OwnershipBasedBufferDeallocation_8cpp_source.html">OwnershipBasedBufferDeallocation.cpp</a>.</p>

</div>
</div>
<a id="ae342871cac8184abb98eb585dc44bf7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae342871cac8184abb98eb585dc44bf7e">&#9670;&nbsp;</a></span>dropEquivalentBufferResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::dropEquivalentBufferResults </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop all memref function results that are equivalent to a function argument. </p>

<p class="definition">Definition at line <a class="el" href="DropEquivalentBufferResults_8cpp_source.html#l00071">71</a> of file <a class="el" href="DropEquivalentBufferResults_8cpp_source.html">DropEquivalentBufferResults.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="DropEquivalentBufferResults_8cpp_source.html#l00048">getAssumedUniqueReturnOp()</a>, <a class="el" href="DropEquivalentBufferResults_8cpp_source.html#l00061">getCalledFunction()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00129">mlir::Value::getType()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00133">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="Builders_8h_source.html#l00406">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="a7d65c46b9c79a6965bea2b62ef26a649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d65c46b9c79a6965bea2b62ef26a649">&#9670;&nbsp;</a></span>eliminateEmptyTensors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::eliminateEmptyTensors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to eliminate "tensor.empty" ops inside <code>op</code>. </p>
<p>This transformation looks for subset ops that insert a tensor that originates from a "tensor.empty" (as per the reverse use-def chain). Such "tensor.empty" ops are replaced with the destination subset.</p>
<p>E.g.: %0 = tensor.empty() : tensor&lt;10xf32&gt; %1 = linalg.fill ... outs(%0 : tensor&lt;10xf32&gt;) %2 = tensor.insert_slice %0 into t ...</p>
<p>In the above example, the subset op is "tensor.insert_slice". When tracing back the reverse use-def chain of a the source, we end up at a "tensor.empty" op. </p>

<p class="definition">Definition at line <a class="el" href="EmptyTensorElimination_8cpp_source.html#l00188">188</a> of file <a class="el" href="EmptyTensorElimination_8cpp_source.html">EmptyTensorElimination.cpp</a>.</p>

</div>
</div>
<a id="ae87e9eee7d425c90207d7205106a0ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87e9eee7d425c90207d7205106a0ea7">&#9670;&nbsp;</a></span>eliminateEmptyTensors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::eliminateEmptyTensors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to eliminate "tensor.empty" ops inside <code>op</code>. </p>
<p>This function overload accepts an existing <code><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html" title="State for analysis-enabled bufferization.">OneShotAnalysisState</a></code>, which contains in-place bufferization decisions. This overload is useful if an existing analysis should be reused for empty tensor elimination. </p>

<p class="definition">Definition at line <a class="el" href="EmptyTensorElimination_8cpp_source.html#l00103">103</a> of file <a class="el" href="EmptyTensorElimination_8cpp_source.html">EmptyTensorElimination.cpp</a>.</p>

</div>
</div>
<a id="a8139947c1966e87061f1e4e5c184c404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8139947c1966e87061f1e4e5c184c404">&#9670;&nbsp;</a></span>findCommonDominator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DominatorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Block.html">Block</a>* mlir::bufferization::findCommonDominator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1BufferViewFlowAnalysis.html#a1602ce2a7a7c54bea6b736faa4cfcd29">BufferViewFlowAnalysis::ValueSetT</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DominatorT &amp;&#160;</td>
          <td class="paramname"><em>doms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a common dominator for the given value while taking the positions of the values in the value set into account. </p>
<p>It supports dominator and post-dominator analyses via template arguments. If no common dominator can be found, this function will return "nullptr". </p>

<p class="definition">Definition at line <a class="el" href="BufferUtils_8h_source.html#l00081">81</a> of file <a class="el" href="BufferUtils_8h_source.html">BufferUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00048">mlir::Value::getParentBlock()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00869">mlir::Operation::getUsers()</a>.</p>

</div>
</div>
<a id="a93c44c6ca8b0e1f2a2b2a21dad9bc4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c44c6ca8b0e1f2a2b2a21dad9bc4ff">&#9670;&nbsp;</a></span>foldToMemrefToTensorPair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::foldToMemrefToTensorPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ToMemrefOp&#160;</td>
          <td class="paramname"><em>toMemref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to fold to_memref(to_tensor(x)). </p>
<p>If x's type and the result type of the to_memref op are different, a memref.cast is needed. </p>

<p class="definition">Definition at line <a class="el" href="BufferizationOps_8cpp_source.html#l00088">88</a> of file <a class="el" href="BufferizationOps_8cpp_source.html">BufferizationOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferizationOps_8cpp_source.html#l00026">castOrReallocMemRefValue()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00133">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00536">mlir::RewriterBase::replaceOpWithNewOp()</a>.</p>

</div>
</div>
<a id="abf241364e9dfd1def82141c75035f4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf241364e9dfd1def82141c75035f4b0">&#9670;&nbsp;</a></span>getBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::bufferization::getBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup the buffer for the given value. </p>
<p>If the value was not bufferized yet, wrap it in a ToMemrefOp. Otherwise, it is the result of a ToTensorOp, from which the memref operand is returned. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00639">639</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00630">ensureToMemrefOpIsValid()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00664">getBufferType()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8cpp_source.html#l00026">mlir::Value::getLoc()</a>, <a class="el" href="Value_8h_source.html#l00129">mlir::Value::getType()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00381">setInsertionPointAfter()</a>.</p>

</div>
</div>
<a id="aadc2d902756788c32c33244776d141c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc2d902756788c32c33244776d141c7">&#9670;&nbsp;</a></span>getBufferType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> &gt; mlir::bufferization::getBufferType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization without bufferizing any IR. </p>
<p>Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization.</p>
<p>Note: It should be sufficient to call <code><a class="el" href="namespacemlir_1_1bufferization.html#abf241364e9dfd1def82141c75035f4b0" title="Lookup the buffer for the given value.">getBuffer()</a>-&gt;<a class="el" href="namespacemlir.html#a348ed9fcbefe1f5094cc571c346c7080" title="Returns the int type of the integer in ofr.">getType()</a></code> in most cases. However, when a buffer type should be predicted without modifying any IR, this function can be used.</p>
<p>This function is a wrapper around BufferizableOpInterface::getBufferType. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00664">664</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00147">allocateTensorForShapedValue()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00537">bufferizeBlockSignature()</a>, and <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00639">getBuffer()</a>.</p>

</div>
</div>
<a id="a452bfb024f3ea3eed5dbdf9eb9a990f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452bfb024f3ea3eed5dbdf9eb9a990f5">&#9670;&nbsp;</a></span>getBufferType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> &gt; mlir::bufferization::getBufferType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>invocationStack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization without bufferizing any IR. </p>
<p>Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization.</p>
<p>This function (and not the other overload without <code>invocationStack</code>) can be used from <code>getBufferType</code> implementations of the <code>BufferizableOpInterface</code>.</p>
<p>Note: It should be sufficient to call <code><a class="el" href="namespacemlir_1_1bufferization.html#abf241364e9dfd1def82141c75035f4b0" title="Lookup the buffer for the given value.">getBuffer()</a>-&gt;<a class="el" href="namespacemlir.html#a348ed9fcbefe1f5094cc571c346c7080" title="Returns the int type of the integer in ofr.">getType()</a></code> in most cases. However, when a buffer type should be predicted without modifying any IR, this function can be used.</p>
<p>This function is a wrapper around <code>BufferizableOpInterface::getBufferType</code>. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00671">671</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00129">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="ac429167681d191256dad3476d862bda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac429167681d191256dad3476d862bda2">&#9670;&nbsp;</a></span>getGlobalFor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; memref::GlobalOp &gt; mlir::bufferization::getGlobalFor </td>
          <td>(</td>
          <td class="paramtype">arith::ConstantOp&#160;</td>
          <td class="paramname"><em>constantOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BufferUtils_8cpp_source.html#l00104">104</a> of file <a class="el" href="BufferUtils_8cpp_source.html">BufferUtils.cpp</a>.</p>

</div>
</div>
<a id="a660fa21f93f165f53aa703efc73fa210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660fa21f93f165f53aa703efc73fa210">&#9670;&nbsp;</a></span>getMemRefType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> mlir::bufferization::getMemRefType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefLayoutAttrInterface&#160;</td>
          <td class="paramname"><em>layout</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a MemRefType to which the type of the given value can be bufferized. </p>
<p>If possible, op bufferization implementations should not use this function and instead infer precise memref types for tensor results by themselves.</p>
<p>Unless a layout map was specified, <code>options.unknownTypeConverterFn</code> determines what kind of layout map will be used. For best composability (without copies), the fully dynamic layout map is used by default.</p>
<p>Note: Canonicalization patterns could clean up layout maps and infer more precise layout maps after bufferization. However, many possible canonicalizations are currently not implemented. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00764">764</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="Value_8h_source.html#l00129">mlir::Value::getType()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00917">mlir::bufferization::detail::defaultGetBufferType()</a>.</p>

</div>
</div>
<a id="af4daaf086abd1c64e90dc9529f76e1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4daaf086abd1c64e90dc9529f76e1d4">&#9670;&nbsp;</a></span>getMemRefTypeWithFullyDynamicLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> mlir::bufferization::getMemRefTypeWithFullyDynamicLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TensorType.html">TensorType</a>&#160;</td>
          <td class="paramname"><em>tensorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a MemRef type with fully dynamic layout. </p>
<p>If the given tensor type is unranked, return an unranked MemRef type. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00790">790</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00035">mlir::Type::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00058">createMemcpy()</a>, <a class="el" href="LoopEmitter_8cpp_source.html#l00231">mlir::sparse_tensor::LoopEmitter::initializeLoopEmit()</a>, and <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00362">mlir::bufferization::BufferizationOptions::setFunctionBoundaryTypeConversion()</a>.</p>

</div>
</div>
<a id="a05d01c9f4f43c19b51520658e24853d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d01c9f4f43c19b51520658e24853d6">&#9670;&nbsp;</a></span>getMemRefTypeWithStaticIdentityLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> mlir::bufferization::getMemRefTypeWithStaticIdentityLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TensorType.html">TensorType</a>&#160;</td>
          <td class="paramname"><em>tensorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a MemRef type with a static identity layout (i.e., no layout map). </p>
<p>If the given tensor type is unranked, return an unranked MemRef type. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00814">814</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00216">mlir::getBufferizationOptionsForSparsification()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00623">getPartialBufferizationOptions()</a>, and <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00362">mlir::bufferization::BufferizationOptions::setFunctionBoundaryTypeConversion()</a>.</p>

</div>
</div>
<a id="a8ab812aaab64b7b9fb0416797db2e146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab812aaab64b7b9fb0416797db2e146">&#9670;&nbsp;</a></span>getNextEnclosingRepetitiveRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Region.html">Region</a> * mlir::bufferization::getNextEnclosingRepetitiveRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assuming that the given region is repetitive, find the next enclosing repetitive region. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00113">113</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8cpp_source.html#l00045">mlir::Region::getParentRegion()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00046">isRepetitiveRegion()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a25ed0ccb4e307d98675ecab129feddf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ed0ccb4e307d98675ecab129feddf5">&#9670;&nbsp;</a></span>getOwnerOfValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * mlir::bufferization::getOwnerOfValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the owner of the given value. </p>
<p>In case of a <a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a> that is the owner of the block. In case of an <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> that is the defining op. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00138">138</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00147">allocateTensorForShapedValue()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00358">mlir::bufferization::BufferizationOptions::dynCastBufferizableOp()</a>, and <a class="el" href="OneShotAnalysis_8cpp_source.html#l00226">mlir::bufferization::OneShotAnalysisState::isWritable()</a>.</p>

</div>
</div>
<a id="a7a8aa5c17d21cdf7873eed41fc2c9b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8aa5c17d21cdf7873eed41fc2c9b24">&#9670;&nbsp;</a></span>getParallelRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Region.html">Region</a> * mlir::bufferization::getParallelRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>region</code> is a parallel region, return <code>region</code>. </p>
<p>Otherwise, find the first enclosing parallel region of <code>region</code>. If there is no such region, return "nullptr".</p>
<p>Note: Whether a region is parallel or sequential is queried from the <code>BufferizableOpInterface</code>. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00123">123</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00200">mlir::Region::getParentOp()</a>, <a class="el" href="IR_2Region_8cpp_source.html#l00045">mlir::Region::getParentRegion()</a>, <a class="el" href="IR_2Region_8cpp_source.html#l00062">mlir::Region::getRegionNumber()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00046">isRepetitiveRegion()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="ac36c97b27b691ad7fcee01d70ca143a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36c97b27b691ad7fcee01d70ca143a9">&#9670;&nbsp;</a></span>getPartialBufferizationOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> mlir::bufferization::getPartialBufferizationOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code><a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html" title="Options for BufferizableOpInterface-based bufferization.">BufferizationOptions</a></code> such that the <code>bufferizeOp</code> behaves like the old (deprecated) partial, dialect conversion-based bufferization passes. </p>
<p>A copy will be inserted before every buffer write. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00623">623</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00814">getMemRefTypeWithStaticIdentityLayout()</a>, <a class="el" href="Value_8h_source.html#l00129">mlir::Value::getType()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="afba911c4f4c1cf1ef5cc1eed1f5cebdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba911c4f4c1cf1ef5cc1eed1f5cebdc">&#9670;&nbsp;</a></span>hasTensorSemantics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::bufferization::hasTensorSemantics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return "true" if the given op has tensor semantics and should be bufferized. </p>
<p>If the op is bufferizable, the BufferizableOpInterface is queried. Otherwise, an op has tensor semantics if it has tensor operands, tensor op results and/or tensor block arguments. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00694">694</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorUtils_8cpp_source.html#l00308">mlir::vector::getMixedSizesXfer()</a>, <a class="el" href="TransposeMatmul_8cpp_source.html#l00081">mlir::linalg::transposeBatchMatmul()</a>, and <a class="el" href="TransposeMatmul_8cpp_source.html#l00031">mlir::linalg::transposeMatmul()</a>.</p>

</div>
</div>
<a id="a2e6660fcb71a7865869c899d7bd3577e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6660fcb71a7865869c899d7bd3577e">&#9670;&nbsp;</a></span>hoistBuffersFromLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::hoistBuffersFromLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Within the given operation, hoist buffers from loops where possible. </p>
<p>See "BufferLoopHoistingPass" for more information. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00477">477</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="aa163b2955215e8f16e7105f5caa3cb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa163b2955215e8f16e7105f5caa3cb27">&#9670;&nbsp;</a></span>insertTensorCopies() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::insertTensorCopies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">AnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve RaW and other conflicts by inserting bufferization.alloc_tensor ops. </p>
<p>After applying this transform, the IR can be bufferized without inserting additional buffer allocations. </p>

<p class="definition">Definition at line <a class="el" href="TensorCopyInsertion_8cpp_source.html#l00051">51</a> of file <a class="el" href="TensorCopyInsertion_8cpp_source.html">TensorCopyInsertion.cpp</a>.</p>

</div>
</div>
<a id="a6da8751907537f3ff866a413457155a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da8751907537f3ff866a413457155a3">&#9670;&nbsp;</a></span>insertTensorCopies() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::insertTensorCopies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve RaW and other conflicts by inserting bufferization.alloc_tensor ops. </p>
<p>After applying this transform, the IR can be bufferized without inserting additional buffer allocations. </p>

<p class="definition">Definition at line <a class="el" href="TensorCopyInsertion_8cpp_source.html#l00029">29</a> of file <a class="el" href="TensorCopyInsertion_8cpp_source.html">TensorCopyInsertion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00478">runOneShotModuleBufferize()</a>, and <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="aa27faa0cefe57ae46dfee1e25392c0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27faa0cefe57ae46dfee1e25392c0d4">&#9670;&nbsp;</a></span>populateBufferizationDeallocLoweringPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::populateBufferizationDeallocLoweringPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1bufferization.html#a76fe5cbf8af77269764f32ac8bf566ea">DeallocHelperMap</a> &amp;&#160;</td>
          <td class="paramname"><em>deallocHelperFuncMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the conversion pattern of the <code>bufferization.dealloc</code> operation to the given pattern set for use in other transformation passes. </p>

<p class="definition">Definition at line <a class="el" href="LowerDeallocations_8cpp_source.html#l00543">543</a> of file <a class="el" href="LowerDeallocations_8cpp_source.html">LowerDeallocations.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a6223871e93de2dbc611e8e54c5e4fb3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6223871e93de2dbc611e8e54c5e4fb3b">&#9670;&nbsp;</a></span>populateBufferizeMaterializationLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::populateBufferizeMaterializationLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks ops used by bufferization for type conversion materializations as "legal" in the given <a class="el" href="classmlir_1_1ConversionTarget.html" title="This class describes a specific conversion target.">ConversionTarget</a>. </p>
<p>This function should be called by all bufferization passes using <a class="el" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html" title="A helper type converter class that automatically populates the relevant materializations and type con...">BufferizeTypeConverter</a> so that materializations work properly. One exception is bufferization passes doing "full" conversions, where it can be desirable for even the materializations to remain illegal so that they are eliminated, such as via the patterns in populateEliminateBufferizeMaterializationsPatterns. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00095">95</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00829">mlir::ConversionTarget::addLegalOp()</a>.</p>

</div>
</div>
<a id="a046f6b3f96cd60275f3bf03f0b17cdae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046f6b3f96cd60275f3bf03f0b17cdae">&#9670;&nbsp;</a></span>populateDeallocOpCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::populateDeallocOpCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the canonicalization patterns for bufferization.dealloc to the given pattern set to make them available to other passes (such as BufferDeallocationSimplification). </p>

<p class="definition">Definition at line <a class="el" href="BufferizationOps_8cpp_source.html#l01175">1175</a> of file <a class="el" href="BufferizationOps_8cpp_source.html">BufferizationOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="af7726e480700dfb860214b275d6a396d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7726e480700dfb860214b275d6a396d">&#9670;&nbsp;</a></span>populateDynamicDimSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::populateDynamicDimSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>shapedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dynamicDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate <code>dynamicDims</code> with tensor::DimOp / memref::DimOp results for all dynamic dimensions of the given shaped value. </p>

<p class="definition">Definition at line <a class="el" href="BufferizationOps_8cpp_source.html#l00133">133</a> of file <a class="el" href="BufferizationOps_8cpp_source.html">BufferizationOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, and <a class="el" href="Value_8h_source.html#l00129">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00147">allocateTensorForShapedValue()</a>.</p>

</div>
</div>
<a id="aea9dc13b8abd5c6ceca11cdf88ef32ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9dc13b8abd5c6ceca11cdf88ef32ff">&#9670;&nbsp;</a></span>populateEliminateBufferizeMaterializationsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::populateEliminateBufferizeMaterializationsPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns to eliminate bufferize materializations. </p>
<p>In particular, these are the tensor_load/buffer_cast ops. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00132">132</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a41285ff4926c59c44f84d013df399b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41285ff4926c59c44f84d013df399b83">&#9670;&nbsp;</a></span>populateEmptyTensorToAllocTensorPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::populateEmptyTensorToAllocTensorPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns to lower tensor.empty ops to bufferization.alloc_tensor ops. </p>

<p class="definition">Definition at line <a class="el" href="EmptyTensorToAllocTensor_8cpp_source.html#l00054">54</a> of file <a class="el" href="EmptyTensorToAllocTensor_8cpp_source.html">EmptyTensorToAllocTensor.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00931">mlir::RewritePatternSet::insert()</a>.</p>

</div>
</div>
<a id="a67a977a84049ece28cbc92bf2c1337f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a977a84049ece28cbc92bf2c1337f7">&#9670;&nbsp;</a></span>promoteBufferResultsToOutParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::promoteBufferResultsToOutParams </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferResultsToOutParamsOpts.html">BufferResultsToOutParamsOpts</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace buffers that are returned from a function with an out parameter. </p>
<p>Also update all call sites. </p>

<p class="definition">Definition at line <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00204">204</a> of file <a class="el" href="BufferResultsToOutParams_8cpp_source.html">BufferResultsToOutParams.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00143">updateCalls()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00051">updateFuncOp()</a>, and <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00108">updateReturnOps()</a>.</p>

</div>
</div>
<a id="a65df8ad92a46defb2d80d780f26bc12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65df8ad92a46defb2d80d780f26bc12e">&#9670;&nbsp;</a></span>registerBufferizationPipelines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::registerBufferizationPipelines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers all pipelines for the <code>bufferization</code> dialect. </p>
<p>Currently, this includes only the "buffer-deallocation-pipeline". </p>

<p class="definition">Definition at line <a class="el" href="BufferizationPipelines_8cpp_source.html#l00037">37</a> of file <a class="el" href="BufferizationPipelines_8cpp_source.html">BufferizationPipelines.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferizationPipelines_8cpp_source.html#l00021">buildBufferDeallocationPipeline()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllPasses_8h_source.html#l00062">mlir::registerAllPasses()</a>.</p>

</div>
</div>
<a id="a2b2d5a6d2e5ab89ec76a879d71e32a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2d5a6d2e5ab89ec76a879d71e32a36">&#9670;&nbsp;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BufferizationTransformOps_8cpp_source.html#l00175">175</a> of file <a class="el" href="BufferizationTransformOps_8cpp_source.html">BufferizationTransformOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00217">mlir::DialectRegistry::addExtensions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllExtensions_8h_source.html#l00058">mlir::registerAllExtensions()</a>.</p>

</div>
</div>
<a id="ac2cfedafe4d56324592c31cbe6c7ddb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2cfedafe4d56324592c31cbe6c7ddb1">&#9670;&nbsp;</a></span>removeBufferizationAttributesInModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::removeBufferizationAttributesInModule </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>moduleOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove bufferization attributes on every FuncOp arguments in the ModuleOp. </p>

<p class="definition">Definition at line <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00417">417</a> of file <a class="el" href="OneShotModuleBufferize_8cpp_source.html">OneShotModuleBufferize.cpp</a>.</p>

</div>
</div>
<a id="a05561ae5b9cceea1c45832340484ad6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05561ae5b9cceea1c45832340484ad6b">&#9670;&nbsp;</a></span>replaceOpWithBufferizedValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::replaceOpWithBufferizedValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace an op with replacement values. </p>
<p>The op is deleted. Tensor OpResults must be replaced with memref values. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00700">700</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

</div>
</div>
<a id="a91366abfb8d491ea5701260487518959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91366abfb8d491ea5701260487518959">&#9670;&nbsp;</a></span>replaceOpWithNewBufferizedOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpTy mlir::bufferization::replaceOpWithNewBufferizedOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace an op with a new op. </p>
<p>The new op must have the same number of results as the replaced op. The new op may not return any tensor values. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8h_source.html#l00632">632</a> of file <a class="el" href="BufferizableOpInterface_8h_source.html">BufferizableOpInterface.h</a>.</p>

</div>
</div>
<a id="a02260c2ee96b5ef6845cf31eefabb24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02260c2ee96b5ef6845cf31eefabb24b">&#9670;&nbsp;</a></span>runOneShotBufferize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::runOneShotBufferize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run One-Shot Bufferize on the given op: Analysis + Bufferization. </p>

<p class="definition">Definition at line <a class="el" href="OneShotAnalysis_8cpp_source.html#l01381">1381</a> of file <a class="el" href="OneShotAnalysis_8cpp_source.html">OneShotAnalysis.cpp</a>.</p>

</div>
</div>
<a id="a3b77f5324f17a99ff8b568521bfaeadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b77f5324f17a99ff8b568521bfaeadd">&#9670;&nbsp;</a></span>runOneShotModuleBufferize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::runOneShotModuleBufferize </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>moduleOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">bufferization::OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run One-Shot Module Bufferization on the given module. </p>
<p>Performs a simple function call analysis to determine which function arguments are inplaceable. Then analyzes and bufferizes FuncOps one-by-one with One-Shot Bufferize. </p>

<p class="definition">Definition at line <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00478">478</a> of file <a class="el" href="OneShotModuleBufferize_8cpp_source.html">OneShotModuleBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="TensorCopyInsertion_8cpp_source.html#l00029">insertTensorCopies()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 7 2024 08:32:19 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
