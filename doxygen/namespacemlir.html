<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">20.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mlir Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Include the generated interface declarations.  
<a href="namespacemlir.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1acc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1acc.html">acc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1affine"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html">affine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1amdgpu"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1amdgpu.html">amdgpu</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1arith"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1arith.html">arith</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1arm__neon"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1arm__neon.html">arm_neon</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1arm__sme"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1arm__sme.html">arm_sme</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1arm__sve"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1arm__sve.html">arm_sve</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1async"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1async.html">async</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1AttributeTrait"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1AttributeTrait.html">AttributeTrait</a></td></tr>
<tr class="memdesc:namespacemlir_1_1AttributeTrait"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait is used to determine if an attribute is a dynamic attribute or not; it should only be implemented by dynamic attributes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1bufferization"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html">bufferization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1builtin"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1builtin.html">builtin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1builtin__dialect__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1builtin__dialect__detail.html">builtin_dialect_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1bytecode"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bytecode.html">bytecode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1call__interface__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1call__interface__impl.html">call_interface_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1cf"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1cf.html">cf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1dataflow"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1dataflow.html">dataflow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespacemlir_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1AttrTypeReplacer.html" title="This is an attribute/type replacer that is naively cached.">AttrTypeReplacer</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1dialect__extension__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1dialect__extension__detail.html">dialect_extension_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1dlti"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1dlti.html">dlti</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1emitc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1emitc.html">emitc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1func"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1func.html">func</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1function__interface__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1function__interface__impl.html">function_interface_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1gpu"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1gpu.html">gpu</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html">impl</a></td></tr>
<tr class="memdesc:namespacemlir_1_1impl"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> collections provide a dictionary-like interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1index"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1index.html">index</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1intrange"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1intrange.html">intrange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1irdl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1irdl.html">irdl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1khr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1khr.html">khr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1linalg"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html">linalg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1LLVM"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1lsp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1lsp.html">lsp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1matchers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1matchers.html">matchers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1math"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1math.html">math</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1MemoryEffects"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1MemoryEffects.html">MemoryEffects</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1memref"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html">memref</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1mesh"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1mesh.html">mesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1ml__program"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1ml__program.html">ml_program</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1nvgpu"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1nvgpu.html">nvgpu</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1NVVM"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1omp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1omp.html">omp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1op__definition__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html">op_definition_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1OpTrait"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait.html">OpTrait</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1pdl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1pdl.html">pdl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1pdl__to__pdl__interp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1pdl__to__pdl__interp.html">pdl_to_pdl_interp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1pdll"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1pdll.html">pdll</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1polynomial"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1polynomial.html">polynomial</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1presburger"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1presburger.html">presburger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1python"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1python.html">python</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1quant"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1quant.html">quant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1query"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1query.html">query</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1ROCDL"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1runtime"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1runtime.html">runtime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1scf"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html">scf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1shape"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1shape.html">shape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1SideEffects"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1SideEffects.html">SideEffects</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1sparse__tensor"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html">sparse_tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1Speculation"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1Speculation.html">Speculation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1spirv"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html">spirv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1tblgen"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tblgen.html">tblgen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1tensor"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html">tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1tosa"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tosa.html">tosa</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1tracing"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tracing.html">tracing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1transform"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform.html">transform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1TypeTrait"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1TypeTrait.html">TypeTrait</a></td></tr>
<tr class="memdesc:namespacemlir_1_1TypeTrait"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait is used to determine if a type is a dynamic type or not; it should only be implemented by dynamic types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1ub"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1ub.html">ub</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1utils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1utils.html">utils</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1vector"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html">vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1x86vector"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1x86vector.html">x86vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1xegpu"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html">xegpu</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LocalAliasAnalysis.html">LocalAliasAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a local form of alias analysis that tries to identify the underlying values addressed by each value and performs a few basic checks to see if they alias.  <a href="classmlir_1_1LocalAliasAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AliasResult.html">AliasResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible results of an alias query.  <a href="classmlir_1_1AliasResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ModRefResult.html">ModRefResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible results of whether a memory access modifies or references a memory location.  <a href="classmlir_1_1ModRefResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AliasAnalysis.html">AliasAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the main alias analysis interface in MLIR.  <a href="classmlir_1_1AliasAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CallGraphNode.html">CallGraphNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single callable in the callgraph.  <a href="classmlir_1_1CallGraphNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CallGraph.html">CallGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CFGLoop.html">CFGLoop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a single loop formed by blocks.  <a href="classmlir_1_1CFGLoop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CFGLoopInfo.html">CFGLoopInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> LoopInfo instantiation for MLIR that provides access to CFG loops found in the dominator tree.  <a href="classmlir_1_1CFGLoopInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ProgramPoint.html">ProgramPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program point represents a specific location in the execution of a program.  <a href="structmlir_1_1ProgramPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1GenericLatticeAnchor.html">GenericLatticeAnchor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for generic lattice anchor.  <a href="classmlir_1_1GenericLatticeAnchor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1GenericLatticeAnchorBase.html">GenericLatticeAnchorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for generic lattice anchor based on a concrete lattice anchor type and a content key.  <a href="classmlir_1_1GenericLatticeAnchorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1LatticeAnchor.html">LatticeAnchor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fundamental IR components are supported as first-class lattice anchor.  <a href="structmlir_1_1LatticeAnchor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataFlowConfig.html">DataFlowConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration class for data flow solver and child analyses.  <a href="classmlir_1_1DataFlowConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataFlowSolver.html">DataFlowSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The general data-flow analysis solver.  <a href="classmlir_1_1DataFlowSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AnalysisState.html">AnalysisState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for generic analysis states.  <a href="classmlir_1_1AnalysisState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataFlowAnalysis.html">DataFlowAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all data-flow analyses.  <a href="classmlir_1_1DataFlowAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores data layout objects for each operation that specifies the data layout above and below the given operation.  <a href="classmlir_1_1DataLayoutAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1FlatLinearConstraints.html" title="FlatLinearConstraints is an extension of IntegerPolyhedron.">FlatLinearConstraints</a> is an extension of IntegerPolyhedron.  <a href="classmlir_1_1FlatLinearConstraints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatLinearValueConstraints.html">FlatLinearValueConstraints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1FlatLinearValueConstraints.html" title="FlatLinearValueConstraints represents an extension of FlatLinearConstraints where each non-local vari...">FlatLinearValueConstraints</a> represents an extension of <a class="el" href="classmlir_1_1FlatLinearConstraints.html" title="FlatLinearConstraints is an extension of IntegerPolyhedron.">FlatLinearConstraints</a> where each non-local variable can have an SSA <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> attached to it.  <a href="classmlir_1_1FlatLinearValueConstraints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Liveness.html">Liveness</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an analysis for computing liveness information from a given top-level operation.  <a href="classmlir_1_1Liveness.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LivenessBlockInfo.html">LivenessBlockInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents liveness information on block level.  <a href="classmlir_1_1LivenessBlockInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SliceOptions.html">SliceOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1BackwardSliceOptions.html">BackwardSliceOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1WalkContinuation.html">WalkContinuation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to signal how to proceed with the walk of the backward slice:  <a href="classmlir_1_1WalkContinuation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SymbolTableAnalysis.html">SymbolTableAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple analysis that contains a symbol table collection and, for simplicity, a reference to the top-level symbol table.  <a href="classmlir_1_1SymbolTableAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParserState.html">AsmParserState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents state from a parsed MLIR textual format string.  <a href="classmlir_1_1AsmParserState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParserCodeCompleteContext.html">AsmParserCodeCompleteContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstract interface into the parser for hooking in code completion events.  <a href="classmlir_1_1AsmParserCodeCompleteContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PyShapedType.html">PyShapedType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shaped <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> Interface - ShapedType.  <a href="classmlir_1_1PyShapedType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectVersion.html">DialectVersion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to represent the version of a dialect, for the purpose of polymorphic destruction.  <a href="classmlir_1_1DialectVersion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectBytecodeReader.html">DialectBytecodeReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines a virtual interface for reading a bytecode stream, providing hooks into the bytecode reader.  <a href="classmlir_1_1DialectBytecodeReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectBytecodeWriter.html">DialectBytecodeWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines a virtual interface for writing to a bytecode stream, providing hooks into the bytecode writer.  <a href="classmlir_1_1DialectBytecodeWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BytecodeDialectInterface.html">BytecodeDialectInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BytecodeReader.html">BytecodeReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1BytecodeReader.html" title="The BytecodeReader allows to load MLIR bytecode files, while keeping the state explicitly available i...">BytecodeReader</a> allows to load MLIR bytecode files, while keeping the state explicitly available in order to support lazy loading.  <a href="classmlir_1_1BytecodeReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttrTypeBytecodeReader.html">AttrTypeBytecodeReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to interact with the attributes and types parser when parsing MLIR bytecode.  <a href="classmlir_1_1AttrTypeBytecodeReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BytecodeReaderConfig.html">BytecodeReaderConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class containing bytecode-specific configurations of the <code><a class="el" href="classmlir_1_1ParserConfig.html" title="This class represents a configuration for the MLIR assembly parser.">ParserConfig</a></code>.  <a href="classmlir_1_1BytecodeReaderConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttrTypeBytecodeWriter.html">AttrTypeBytecodeWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to interact with the attributes and types printer when emitting MLIR bytecode.  <a href="classmlir_1_1AttrTypeBytecodeWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BytecodeWriterConfig.html">BytecodeWriterConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains the configuration used for the bytecode writer.  <a href="classmlir_1_1BytecodeWriterConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> to transform an operation of a specific type.  <a href="classmlir_1_1OperationPass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ComplexStructBuilder.html">ComplexStructBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ControlFlowToSCFTransformation.html">ControlFlowToSCFTransformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <code><a class="el" href="classmlir_1_1CFGToSCFInterface.html" title="Interface that should be implemented by any caller of transformCFGToSCF.">CFGToSCFInterface</a></code> used to lift Control Flow <a class="el" href="classmlir_1_1Dialect.html" title="Dialects are groups of MLIR operations, types and attributes, as well as behavior associated with the...">Dialect</a> operations to SCF <a class="el" href="classmlir_1_1Dialect.html" title="Dialects are groups of MLIR operations, types and attributes, as well as behavior associated with the...">Dialect</a> operations.  <a href="classmlir_1_1ControlFlowToSCFTransformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConvertToLLVMPatternInterface.html">ConvertToLLVMPatternInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for dialect interfaces providing translation to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR.  <a href="classmlir_1_1ConvertToLLVMPatternInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FunctionCallBuilder.html">FunctionCallBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class that automatically populates legalization information for different <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> ops.  <a href="classmlir_1_1LLVMConversionTarget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to control the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> lowering.  <a href="classmlir_1_1LowerToLLVMOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MemRefDescriptor.html">MemRefDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to produce <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect operations extracting or inserting elements of a MemRef descriptor.  <a href="classmlir_1_1MemRefDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MemRefDescriptorView.html">MemRefDescriptorView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class allowing the user to access a range of Values that correspond to an unpacked memref descriptor using named accessors.  <a href="classmlir_1_1MemRefDescriptorView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1UnrankedMemRefDescriptor.html">UnrankedMemRefDescriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConvertToLLVMPattern.html">ConvertToLLVMPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for operation conversions targeting the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect.  <a href="classmlir_1_1ConvertToLLVMPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConvertOpToLLVMPattern.html">ConvertOpToLLVMPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for operation conversions targeting the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect that match exactly one source operation.  <a href="classmlir_1_1ConvertOpToLLVMPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OneToOneConvertToLLVMPattern.html">OneToOneConvertToLLVMPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic implementation of one-to-one conversion from "SourceOp" to "TargetOp" where the latter belongs to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect or an equivalent.  <a href="classmlir_1_1OneToOneConvertToLLVMPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StructBuilder.html">StructBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to produce <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect operations extracting or inserting values to a struct.  <a href="classmlir_1_1StructBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion from types to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect.  <a href="classmlir_1_1LLVMTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttrConvertPassThrough.html">AttrConvertPassThrough</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1VectorConvertToLLVMPattern.html">VectorConvertToLLVMPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic lowering implementation to rewrite Ops with just one result to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> <a class="el" href="classmlir_1_1Dialect.html" title="Dialects are groups of MLIR operations, types and attributes, as well as behavior associated with the...">Dialect</a>.  <a href="classmlir_1_1VectorConvertToLLVMPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AllocationOpLLVMLowering.html">AllocationOpLLVMLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowering for memory allocation ops.  <a href="structmlir_1_1AllocationOpLLVMLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AllocLikeOpLLVMLowering.html">AllocLikeOpLLVMLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowering for AllocOp and AllocaOp.  <a href="structmlir_1_1AllocLikeOpLLVMLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> to transform an operation that implements the given interface.  <a href="classmlir_1_1InterfacePass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ScfToSPIRVContext.html">ScfToSPIRVContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SPIRVToLLVMConversion.html">SPIRVToLLVMConversion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">When lowering an N-d vector transfer op to an (N-1)-d vector transfer op, a temporary buffer is created through which individual (N-1)-d vector are staged.  <a href="structmlir_1_1VectorTransferToSCFOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ArithBuilder.html">ArithBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct to build simple arithmetic quantities with minimal type inference support.  <a href="structmlir_1_1ArithBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BufferViewFlowAnalysis.html">BufferViewFlowAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A straight-forward alias analysis which ensures that all dependencies of all values will be determined.  <a href="classmlir_1_1BufferViewFlowAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BufferOriginAnalysis.html">BufferOriginAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An is-same-buffer analysis that checks if two SSA values belong to the same buffer allocation or not.  <a href="classmlir_1_1BufferOriginAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1HasDefaultDLTIDataLayout.html">HasDefaultDLTIDataLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to be used by operations willing to use the implementation of the data layout interfaces provided by the Target dialect.  <a href="classmlir_1_1HasDefaultDLTIDataLayout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueDecomposer.html">ValueDecomposer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a hook that expands one <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> into multiple <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>'s, with a TypeConverter-inspired callback registration mechanism.  <a href="classmlir_1_1ValueDecomposer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MathPolynomialApproximationOptions.html">MathPolynomialApproximationOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for the Sparsification pass.  <a href="structmlir_1_1SparsificationOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SparseIterationTypeConverter.html">SparseIterationTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> converter for iter_space and iterator.  <a href="structmlir_1_1SparseIterationTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SparseTensorTypeToPtrConverter.html">SparseTensorTypeToPtrConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse tensor type converter into an opaque pointer.  <a href="classmlir_1_1SparseTensorTypeToPtrConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SparseTensorTypeToBufferConverter.html">SparseTensorTypeToBufferConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse tensor type converter into an actual buffer.  <a href="classmlir_1_1SparseTensorTypeToBufferConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageSpecifierToLLVMTypeConverter.html">StorageSpecifierToLLVMTypeConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SPIRVConversionOptions.html">SPIRVConversionOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> conversion from builtin types to SPIR-V types for shader interface.  <a href="classmlir_1_1SPIRVTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SPIRVConversionTarget.html">SPIRVConversionTarget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1VulkanLayoutUtils.html">VulkanLayoutUtils</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">According to the Vulkan spec "15.6.4. Offset and Stride Assignment": "There are different alignment requirements depending on the specific resources and on the features enabled on the device.  <a href="classmlir_1_1VulkanLayoutUtils.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class acts as an owning reference to an op, and will automatically destroy the held op on destruction if the held op is valid.  <a href="classmlir_1_1OwningOpRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of a transform IR operation application.  <a href="classmlir_1_1DiagnosedSilenceableFailure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DiagnosedDefiniteFailure.html">DiagnosedDefiniteFailure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compatibility class connecting <code><a class="el" href="classmlir_1_1InFlightDiagnostic.html" title="This class represents a diagnostic that is inflight and set to be reported.">InFlightDiagnostic</a></code> to <code><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html" title="The result of a transform IR operation application.">DiagnosedSilenceableFailure</a></code> while providing an interface similar to the former.  <a href="classmlir_1_1DiagnosedDefiniteFailure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RaggedArray.html">RaggedArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D array where each row may have different length.  <a href="classmlir_1_1RaggedArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StaticTileOffsetRange.html">StaticTileOffsetRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range-style iterator that allows for iterating over the offsets of all potential tiles of size <code>tileShape</code> within the larger shape <code>shape</code>, using an ordering specified by <code>loopOrder</code>.  <a href="classmlir_1_1StaticTileOffsetRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ComposeReassociativeReshapeOps.html">ComposeReassociativeReshapeOps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to collapse producer/consumer reshape ops that are both collapsing dimensions or are both expanding dimensions.  <a href="structmlir_1_1ComposeReassociativeReshapeOps.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ComposeCollapseOfExpandOp.html">ComposeCollapseOfExpandOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to compose <code>collapse_shape(expand_shape(src, reassociation_1), reassociation_2)</code>.  <a href="structmlir_1_1ComposeCollapseOfExpandOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ComposeExpandOfCollapseOp.html">ComposeExpandOfCollapseOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1Range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a range (offset, size, and stride) where each element of the triple may be dynamic or static.  <a href="structmlir_1_1Range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SaturatedInteger.html">SaturatedInteger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Idiomatic saturated operations on values like offsets, sizes, and strides.  <a href="structmlir_1_1SaturatedInteger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StructuredGenerator.html">StructuredGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper <a class="el" href="classmlir_1_1StructuredGenerator.html" title="Helper StructuredGenerator class to manipulate and rewrite ops with StructuredOpInterface.">StructuredGenerator</a> class to manipulate and rewrite ops with <code>StructuredOpInterface</code>.  <a href="classmlir_1_1StructuredGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SimpleObjectCache.html">SimpleObjectCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple object cache following Lang's LLJITWithObjectCache example.  <a href="classmlir_1_1SimpleObjectCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ExecutionEngineOptions.html">ExecutionEngineOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ExecutionEngine.html">ExecutionEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">JIT-backed execution engine for MLIR.  <a href="classmlir_1_1ExecutionEngine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1JitRunnerOptions.html">JitRunnerOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">JitRunner command line options used by <a class="el" href="structmlir_1_1JitRunnerConfig.html" title="Configuration to override functionality of the JitRunner.">JitRunnerConfig</a> methods.  <a href="structmlir_1_1JitRunnerOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1JitRunnerConfig.html">JitRunnerConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration to override functionality of the JitRunner.  <a href="structmlir_1_1JitRunnerConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OwningMemRef.html">OwningMemRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owning MemRef type that abstracts over the runtime type for ranked strided memref.  <a href="classmlir_1_1OwningMemRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1CallInterfaceCallable.html">CallInterfaceCallable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callable is either a symbol, or an SSA value, that is referenced by a call-like operation.  <a href="structmlir_1_1CallInterfaceCallable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SuccessorOperands.html">SuccessorOperands</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class models how operands are forwarded to block arguments in control flow.  <a href="classmlir_1_1SuccessorOperands.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RegionSuccessor.html">RegionSuccessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a successor of a region.  <a href="classmlir_1_1RegionSuccessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RegionBranchPoint.html">RegionBranchPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a point being branched from in the methods of the <code>RegionBranchOpInterface</code>.  <a href="classmlir_1_1RegionBranchPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1InvocationBounds.html">InvocationBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents upper and lower bounds on the number of times a region of a <code>RegionBranchOpInterface</code> can be invoked.  <a href="classmlir_1_1InvocationBounds.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataLayoutDialectInterface.html">DataLayoutDialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface to be implemented by dialects that can have identifiers in the data layout specification entries.  <a href="classmlir_1_1DataLayoutDialectInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main mechanism for performing data layout queries.  <a href="classmlir_1_1DataLayout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectFoldInterface.html">DialectFoldInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a fold interface to allow for dialects to control specific aspects of the folding behavior for operations they define.  <a href="classmlir_1_1DialectFoldInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConstantIntRanges.html">ConstantIntRanges</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of arbitrary-precision integers representing bounds on a given integer value.  <a href="classmlir_1_1ConstantIntRanges.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerValueRange.html">IntegerValueRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This lattice value represents the integer range of an SSA value.  <a href="classmlir_1_1IntegerValueRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ShapeAdaptor.html">ShapeAdaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor class to abstract the differences between whether value is from a ShapedType or <a class="el" href="classmlir_1_1ShapedTypeComponents.html" title="ShapedTypeComponents that represents the components of a ShapedType.">ShapedTypeComponents</a> or DenseIntElementsAttribute.  <a href="classmlir_1_1ShapeAdaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ShapedTypeComponents.html">ShapedTypeComponents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1ShapedTypeComponents.html" title="ShapedTypeComponents that represents the components of a ShapedType.">ShapedTypeComponents</a> that represents the components of a ShapedType.  <a href="classmlir_1_1ShapedTypeComponents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueShapeRange.html">ValueShapeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1Range.html" title="Represents a range (offset, size, and stride) where each element of the triple may be dynamic or stat...">Range</a> of values and shapes (corresponding effectively to Shapes dialect's ValueShape type concept).  <a href="classmlir_1_1ValueShapeRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1JamBlockGatherer.html">JamBlockGatherer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemorySlot.html">MemorySlot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a slot in memory.  <a href="structmlir_1_1MemorySlot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1DestructurableMemorySlot.html">DestructurableMemorySlot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory slot attached with information about its destructuring procedure.  <a href="structmlir_1_1DestructurableMemorySlot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TilingResult.html">TilingResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for result values of tiling.  <a href="structmlir_1_1TilingResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MergeResult.html">MergeResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for the result of merge operation of tiling.  <a href="structmlir_1_1MergeResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1HyperrectangularSlice.html">HyperrectangularSlice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hyperrectangular slice, represented as a list of offsets, sizes and strides.  <a href="classmlir_1_1HyperrectangularSlice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html">ValueBoundsConstraintSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to be used with <code>ValueBoundsOpInterface</code>.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpWithOffsetSizesAndStridesConstantArgumentFolder.html">OpWithOffsetSizesAndStridesConstantArgumentFolder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to rewrite dynamic offsets/sizes/strides of view/slice-like ops as constant arguments.  <a href="classmlir_1_1OpWithOffsetSizesAndStridesConstantArgumentFolder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for affine expression.  <a href="classmlir_1_1AffineExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineBinaryOpExpr.html">AffineBinaryOpExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Affine binary operation expression.  <a href="classmlir_1_1AffineBinaryOpExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDimExpr.html">AffineDimExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimensional identifier appearing in an affine expression.  <a href="classmlir_1_1AffineDimExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineSymbolExpr.html">AffineSymbolExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A symbolic identifier appearing in an affine expression.  <a href="classmlir_1_1AffineSymbolExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineConstantExpr.html">AffineConstantExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer constant appearing in affine expression.  <a href="classmlir_1_1AffineConstantExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineExprVisitorBase.html">AffineExprVisitorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> visitors/walkers.  <a href="classmlir_1_1AffineExprVisitorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineExprVisitor.html">AffineExprVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">See documentation for <a class="el" href="classmlir_1_1AffineExprVisitorBase.html" title="Base class for AffineExpr visitors/walkers.">AffineExprVisitorBase</a>.  <a href="classmlir_1_1AffineExprVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineExprVisitor_3_01SubClass_00_01LogicalResult_01_4.html">AffineExprVisitor&lt; SubClass, LogicalResult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SimpleAffineExprFlattener.html">SimpleAffineExprFlattener</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-dimensional affine map Affine map's are immutable like <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a>'s, and they are uniqued.  <a href="classmlir_1_1AffineMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MutableAffineMap.html">MutableAffineMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable affine map. Its affine expressions are however unique.  <a href="structmlir_1_1MutableAffineMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmResourceBlob.html">AsmResourceBlob</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following classes enable support for parsing and printing resources within MLIR assembly formats.  <a href="classmlir_1_1AsmResourceBlob.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1HeapAsmResourceBlob.html">HeapAsmResourceBlob</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a simple utility wrapper for creating heap allocated AsmResourceBlobs.  <a href="classmlir_1_1HeapAsmResourceBlob.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1UnmanagedAsmResourceBlob.html">UnmanagedAsmResourceBlob</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a simple utility wrapper for creating "unmanaged" AsmResourceBlobs.  <a href="classmlir_1_1UnmanagedAsmResourceBlob.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmResourceBuilder.html">AsmResourceBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to build resource entries for use by the printer.  <a href="classmlir_1_1AsmResourceBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParsedResourceEntry.html">AsmParsedResourceEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single parsed resource entry.  <a href="classmlir_1_1AsmParsedResourceEntry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmResourceParser.html">AsmResourceParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an instance of a resource parser.  <a href="classmlir_1_1AsmResourceParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmResourcePrinter.html">AsmResourcePrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an instance of a resource printer.  <a href="classmlir_1_1AsmResourcePrinter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FallbackAsmResourceMap.html">FallbackAsmResourceMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fallback map containing external resources not explicitly handled by another parser/printer.  <a href="classmlir_1_1FallbackAsmResourceMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a configuration for the MLIR assembly parser.  <a href="classmlir_1_1ParserConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmState.html">AsmState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides management for the lifetime of the state used when printing the IR.  <a href="classmlir_1_1AsmState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes are known-constant values of operations.  <a href="classmlir_1_1Attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1NamedAttribute.html" title="NamedAttribute represents a combination of a name and an Attribute value.">NamedAttribute</a> represents a combination of a name and an <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> value.  <a href="classmlir_1_1NamedAttribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler_3_01NamedAttribute_01_4.html">AttrTypeSubElementHandler&lt; NamedAttribute &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow walking and replacing the subelements of a <a class="el" href="classmlir_1_1NamedAttribute.html" title="NamedAttribute represents a combination of a name and an Attribute value.">NamedAttribute</a>.  <a href="structmlir_1_1AttrTypeSubElementHandler_3_01NamedAttribute_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttributeInterface.html">AttributeInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base of an attribute interface.  <a href="classmlir_1_1AttributeInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AbstractAttribute.html">AbstractAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the static information common to all instances of a registered <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>.  <a href="classmlir_1_1AbstractAttribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttributeStorage.html">AttributeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base storage class appearing in an attribute.  <a href="classmlir_1_1AttributeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttrTypeWalker.html">AttrTypeWalker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1AttrTypeWalker.html" title="AttrTypeWalker.">AttrTypeWalker</a>.  <a href="classmlir_1_1AttrTypeWalker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttrTypeReplacer.html">AttrTypeReplacer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an attribute/type replacer that is naively cached.  <a href="classmlir_1_1AttrTypeReplacer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CyclicAttrTypeReplacer.html">CyclicAttrTypeReplacer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an attribute/type replacer that supports custom handling of cycles in the replacer logic.  <a href="classmlir_1_1CyclicAttrTypeReplacer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttrTypeImmediateSubElementWalker.html">AttrTypeImmediateSubElementWalker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler.html" title="This class provides support for interacting with the SubElementInterfaces for different types of para...">AttrTypeSubElementHandler</a>.  <a href="classmlir_1_1AttrTypeImmediateSubElementWalker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttrTypeSubElementReplacements.html">AttrTypeSubElementReplacements</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used by <a class="el" href="structmlir_1_1AttrTypeSubElementHandler.html" title="This class provides support for interacting with the SubElementInterfaces for different types of para...">AttrTypeSubElementHandler</a> instances to process sub element replacements.  <a href="classmlir_1_1AttrTypeSubElementReplacements.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler.html">AttrTypeSubElementHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides support for interacting with the SubElementInterfaces for different types of parameters.  <a href="structmlir_1_1AttrTypeSubElementHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_ca2937af926ee576a78a661a53d1729d.html">AttrTypeSubElementHandler&lt; T, std::enable_if_t&lt; std::is_base_of_v&lt; Attribute, T &gt;||std::is_base_of_v&lt; Type, T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for derived Attributes and Types.  <a href="structmlir_1_1AttrTypeSubElementHandler_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_ca2937af926ee576a78a661a53d1729d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler_3_01ArrayRef_3_01T_01_4_00_01std_1_1enable__if__t_3_01ha2f4efb8dddd480d9444418f314b80830.html">AttrTypeSubElementHandler&lt; ArrayRef&lt; T &gt;, std::enable_if_t&lt; has_sub_attr_or_type_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for derived ArrayRef.  <a href="structmlir_1_1AttrTypeSubElementHandler_3_01ArrayRef_3_01T_01_4_00_01std_1_1enable__if__t_3_01ha2f4efb8dddd480d9444418f314b80830.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_00_01std_1_1enable__i69d64aa7e3ec1bb340acfeb6d320e346.html">AttrTypeSubElementHandler&lt; std::tuple&lt; Ts... &gt;, std::enable_if_t&lt; has_sub_attr_or_type_v&lt; Ts... &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for Tuple.  <a href="structmlir_1_1AttrTypeSubElementHandler_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_00_01std_1_1enable__i69d64aa7e3ec1bb340acfeb6d320e346.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements iteration on the types of a given range of values.  <a href="classmlir_1_1ValueTypeRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Block.html">Block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a></code> represents an ordered list of <code><a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a></code>s.  <a href="classmlir_1_1Block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BlockOperand.html">BlockOperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A block operand represents an operand that holds a reference to a <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a>, e.g.  <a href="classmlir_1_1BlockOperand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PredecessorIterator.html">PredecessorIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement a predecessor iterator for blocks.  <a href="classmlir_1_1PredecessorIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SuccessorRange.html">SuccessorRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the successor iterators for <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a>.  <a href="classmlir_1_1SuccessorRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BlockRange.html">BlockRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction over the different types of ranges over Blocks.  <a href="classmlir_1_1BlockRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html">Builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a general helper class for creating context-global objects like types, attributes, and affine expressions.  <a href="classmlir_1_1Builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class helps build Operations.  <a href="classmlir_1_1OpBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1DialectResourceBlobHandle.html">DialectResourceBlobHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines a dialect specific handle to a resource blob.  <a href="structmlir_1_1DialectResourceBlobHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a dense vector or tensor object.  <a href="classmlir_1_1DenseElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SplatElementsAttr.html">SplatElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a splat vector or tensor constant, meaning all of the elements have the same value.  <a href="classmlir_1_1SplatElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BoolAttr.html">BoolAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special case of IntegerAttr to represent boolean integers, i.e., signless i1 integers.  <a href="classmlir_1_1BoolAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatSymbolRefAttr.html">FlatSymbolRefAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A symbol reference with a reference path containing a single element.  <a href="classmlir_1_1FlatSymbolRefAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseFPElementsAttr.html">DenseFPElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a dense float vector or tensor object.  <a href="classmlir_1_1DenseFPElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a dense integer vector or tensor object.  <a href="classmlir_1_1DenseIntElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DistinctAttr.html">DistinctAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that associates a referenced attribute with a unique identifier.  <a href="classmlir_1_1DistinctAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueSemantics.html">ValueSemantics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> trait indicating that the type has value semantics.  <a href="classmlir_1_1ValueSemantics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FloatType.html">FloatType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TensorType.html">TensorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor types represent multi-dimensional arrays, and have two variants: RankedTensorType and UnrankedTensorType.  <a href="classmlir_1_1TensorType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a shared interface for ranked and unranked memref types.  <a href="classmlir_1_1BaseMemRefType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DiagnosticArgument.html">DiagnosticArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant type that holds a single argument for a diagnostic.  <a href="classmlir_1_1DiagnosticArgument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the information necessary to report a diagnostic to the <a class="el" href="classmlir_1_1DiagnosticEngine.html" title="This class is the main interface for diagnostics.">DiagnosticEngine</a>.  <a href="classmlir_1_1Diagnostic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a diagnostic that is inflight and set to be reported.  <a href="classmlir_1_1InFlightDiagnostic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DiagnosticEngine.html">DiagnosticEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the main interface for diagnostics.  <a href="classmlir_1_1DiagnosticEngine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ScopedDiagnosticHandler.html">ScopedDiagnosticHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This diagnostic handler is a simple RAII class that registers and erases a diagnostic handler on a given context.  <a href="classmlir_1_1ScopedDiagnosticHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SourceMgrDiagnosticHandler.html">SourceMgrDiagnosticHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a utility diagnostic handler for use with llvm::SourceMgr.  <a href="classmlir_1_1SourceMgrDiagnosticHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SourceMgrDiagnosticVerifierHandler.html">SourceMgrDiagnosticVerifierHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a utility diagnostic handler for use with llvm::SourceMgr that verifies that emitted diagnostics match 'expected-*' lines on the corresponding line of the source file.  <a href="classmlir_1_1SourceMgrDiagnosticVerifierHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ParallelDiagnosticHandler.html">ParallelDiagnosticHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a utility diagnostic handler for use when multi-threading some part of the compiler where diagnostics may be emitted.  <a href="classmlir_1_1ParallelDiagnosticHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Dialect.html">Dialect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dialects are groups of MLIR operations, types and attributes, as well as behavior associated with the entire group.  <a href="classmlir_1_1Dialect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a pure-virtual base class that exposes the asmprinter hooks necessary to implement a custom printAttribute/printType() method on a dialect.  <a href="classmlir_1_1DialectAsmPrinter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectAsmParser.html">DialectAsmParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1DialectAsmParser.html" title="The DialectAsmParser has methods for interacting with the asm parser when parsing attributes and type...">DialectAsmParser</a> has methods for interacting with the asm parser when parsing attributes and types.  <a href="classmlir_1_1DialectAsmParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser.html">FieldParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a template class that can be specialized by users to dispatch to parsers.  <a href="structmlir_1_1FieldParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01AttributeT_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_3_01Afbf44e752e28f353857b0de6053d0e60.html">FieldParser&lt; AttributeT, std::enable_if_t&lt; std::is_base_of&lt; Attribute, AttributeT &gt;::value, AttributeT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an attribute.  <a href="structmlir_1_1FieldParser_3_01AttributeT_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_3_01Afbf44e752e28f353857b0de6053d0e60.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01TypeT_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_3_01Type_0346a91898fcc3a5091d4a6bb97af4903.html">FieldParser&lt; TypeT, std::enable_if_t&lt; std::is_base_of&lt; Type, TypeT &gt;::value, TypeT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an attribute.  <a href="structmlir_1_1FieldParser_3_01TypeT_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_3_01Type_0346a91898fcc3a5091d4a6bb97af4903.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01IntT_00_01std_1_1enable__if__t_3_01std_1_1is__integral_3_01IntT_01_4_1_1value_00_01IntT_01_4_01_4.html">FieldParser&lt; IntT, std::enable_if_t&lt; std::is_integral&lt; IntT &gt;::value, IntT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse any integer.  <a href="structmlir_1_1FieldParser_3_01IntT_00_01std_1_1enable__if__t_3_01std_1_1is__integral_3_01IntT_01_4_1_1value_00_01IntT_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01std_1_1string_01_4.html">FieldParser&lt; std::string &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a string.  <a href="structmlir_1_1FieldParser_3_01std_1_1string_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01std_1_1optional_3_01AttributeT_01_4_00_01std_1_1enable__if__t_3_01a9544224247644e900417ec0332b0042.html">FieldParser&lt; std::optional&lt; AttributeT &gt;, std::enable_if_t&lt; std::is_base_of&lt; Attribute, AttributeT &gt;::value, std::optional&lt; AttributeT &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an Optional attribute.  <a href="structmlir_1_1FieldParser_3_01std_1_1optional_3_01AttributeT_01_4_00_01std_1_1enable__if__t_3_01a9544224247644e900417ec0332b0042.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01std_1_1optional_3_01IntT_01_4_00_01std_1_1enable__if__t_3_01std_1_6359b16273171b8ce58b2c2f1b4d06a0.html">FieldParser&lt; std::optional&lt; IntT &gt;, std::enable_if_t&lt; std::is_integral&lt; IntT &gt;::value, std::optional&lt; IntT &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an Optional integer.  <a href="structmlir_1_1FieldParser_3_01std_1_1optional_3_01IntT_01_4_00_01std_1_1enable__if__t_3_01std_1_6359b16273171b8ce58b2c2f1b4d06a0.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01ContainerT_00_01std_1_1enable__if__t_3_01llvm_1_1is__detected_3_0112cbbc78ed0c7bbf669a3991e3076f4f.html">FieldParser&lt; ContainerT, std::enable_if_t&lt; llvm::is_detected&lt; detail::has_push_back_t, ContainerT &gt;::value, ContainerT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse any container that supports back insertion as a list.  <a href="structmlir_1_1FieldParser_3_01ContainerT_00_01std_1_1enable__if__t_3_01llvm_1_1is__detected_3_0112cbbc78ed0c7bbf669a3991e3076f4f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01AffineMap_01_4.html">FieldParser&lt; AffineMap &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an affine map.  <a href="structmlir_1_1FieldParser_3_01AffineMap_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectInterface.html">DialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an interface overridden for a single dialect.  <a href="classmlir_1_1DialectInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectInterfaceCollection.html">DialectInterfaceCollection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of dialect interfaces within a context, for a given concrete interface type.  <a href="classmlir_1_1DialectInterfaceCollection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectExtensionBase.html">DialectExtensionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an opaque dialect extension.  <a href="classmlir_1_1DialectExtensionBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectExtension.html">DialectExtension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a dialect extension anchored on the given set of dialects.  <a href="classmlir_1_1DialectExtension.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1DialectRegistry.html" title="The DialectRegistry maps a dialect namespace to a constructor for the matching dialect.">DialectRegistry</a> maps a dialect namespace to a constructor for the matching dialect.  <a href="classmlir_1_1DialectRegistry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectResourceBlobManager.html">DialectResourceBlobManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines a manager for dialect resource blobs.  <a href="classmlir_1_1DialectResourceBlobManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ResourceBlobManagerDialectInterface.html">ResourceBlobManagerDialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a dialect interface that provides common functionality for interacting with a resource blob manager.  <a href="classmlir_1_1ResourceBlobManagerDialectInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ResourceBlobManagerDialectInterfaceBase.html">ResourceBlobManagerDialectInterfaceBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a base class for dialects implementing the resource blob interface.  <a href="classmlir_1_1ResourceBlobManagerDialectInterfaceBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for computing basic dominance information.  <a href="classmlir_1_1DominanceInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PostDominanceInfo.html">PostDominanceInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for computing basic postdominance information.  <a href="classmlir_1_1PostDominanceInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicAttrDefinition.html">DynamicAttrDefinition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a dynamic attribute.  <a href="classmlir_1_1DynamicAttrDefinition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicAttr.html">DynamicAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic attribute instance.  <a href="classmlir_1_1DynamicAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicTypeDefinition.html">DynamicTypeDefinition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a dynamic type.  <a href="classmlir_1_1DynamicTypeDefinition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicType.html">DynamicType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic type instance.  <a href="classmlir_1_1DynamicType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicOpDefinition.html">DynamicOpDefinition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a dynamic op.  <a href="classmlir_1_1DynamicOpDefinition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ExtensibleDialect.html">ExtensibleDialect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dialect that can be extended with new operations/types/attributes at runtime.  <a href="classmlir_1_1ExtensibleDialect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicDialect.html">DynamicDialect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dialect that can be defined at runtime.  <a href="classmlir_1_1DynamicDialect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html" title="ImplicitLocOpBuilder maintains a &#39;current location&#39;, allowing use of the create&lt;&gt; method without spec...">ImplicitLocOpBuilder</a> maintains a 'current location', allowing use of the create&lt;&gt; method without specifying the location.  <a href="classmlir_1_1ImplicitLocOpBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer set representing a conjunction of one or more affine equalities and inequalities.  <a href="classmlir_1_1IntegerSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a utility class for mapping one set of IR entities to another.  <a href="classmlir_1_1IRMapping.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ReverseIterator.html">ReverseIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This iterator enumerates elements in "reverse" order.  <a href="structmlir_1_1ReverseIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ForwardDominanceIterator.html">ForwardDominanceIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This iterator enumerates elements according to their dominance relationship.  <a href="structmlir_1_1ForwardDominanceIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ReverseDominanceIterator.html">ReverseDominanceIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This iterator enumerates elements according to their reverse dominance relationship.  <a href="structmlir_1_1ReverseDominanceIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> objects represent source locations information in MLIR.  <a href="classmlir_1_1LocationAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Location.html">Location</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around a <a class="el" href="classmlir_1_1LocationAttr.html" title="Location objects represent source locations information in MLIR.">LocationAttr</a>.  <a href="classmlir_1_1Location.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FusedLocWith.html">FusedLocWith</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a fused location whose metadata is known to be an instance of the given type.  <a href="classmlir_1_1FusedLocWith.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler_3_01Location_01_4.html">AttrTypeSubElementHandler&lt; Location &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable locations to be introspected as sub-elements.  <a href="structmlir_1_1AttrTypeSubElementHandler_3_01Location_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> is the top-level object for a collection of MLIR operations.  <a href="classmlir_1_1MLIRContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements <code>Optional</code> functionality for ParseResult.  <a href="classmlir_1_1OptionalParseResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1EmptyProperties.html">EmptyProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used by default as a "marker" when no "Properties" are set on an <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>.  <a href="structmlir_1_1EmptyProperties.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PropertiesSelector.html">PropertiesSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits to detect whether an <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> defined a <code>Properties</code> type, otherwise it'll default to <code><a class="el" href="structmlir_1_1EmptyProperties.html" title="Structure used by default as a &quot;marker&quot; when no &quot;Properties&quot; are set on an Operation.">EmptyProperties</a></code>.  <a href="structmlir_1_1PropertiesSelector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PropertiesSelector_3_01Op_00_01std_1_1void__t_3_01typename_01Op_1_1Properties_01_4_01_4.html">PropertiesSelector&lt; Op, std::void_t&lt; typename Op::Properties &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html">OpState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the concrete base class that holds the operation pointer and has non-generic methods that only depend on State (to avoid having them instantiated on template types that don't affect them.  <a href="classmlir_1_1OpState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single result from folding an operation.  <a href="classmlir_1_1OpFoldResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html">Op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides public APIs that all operations should have.  <a href="classmlir_1_1Op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpInterface.html">OpInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base of an operation interface.  <a href="classmlir_1_1OpInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Operation.html">Operation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> is the basic unit of execution within MLIR.  <a href="classmlir_1_1Operation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpaqueProperties.html">OpaqueProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple wrapper around a void* in order to express generically how to pass in op properties through APIs.  <a href="classmlir_1_1OpaqueProperties.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RegisteredOperationName.html">RegisteredOperationName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a "type erased" representation of a registered operation.  <a href="classmlir_1_1RegisteredOperationName.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1NamedAttrList.html" title="NamedAttrList is array of NamedAttributes that tracks whether it is sorted and does some basic work t...">NamedAttrList</a> is array of NamedAttributes that tracks whether it is sorted and does some basic work to remain sorted.  <a href="classmlir_1_1NamedAttrList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents an operation in an abstracted form, suitable for use with the builder APIs.  <a href="structmlir_1_1OperationState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of flags used to control the behavior of the various IR print methods (e.g.  <a href="classmlir_1_1OpPrintingFlags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OperationEquivalence.html">OperationEquivalence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides utilities for computing if two operations are equivalent.  <a href="structmlir_1_1OperationEquivalence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationFingerPrint.html">OperationFingerPrint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique fingerprint for a specific operation, and all of it's internal operations (if <code>includeNested</code> is set).  <a href="classmlir_1_1OperationFingerPrint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmDialectResourceHandle.html">AsmDialectResourceHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an opaque handle to a dialect resource entry.  <a href="classmlir_1_1AsmDialectResourceHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmDialectResourceHandleBase.html">AsmDialectResourceHandleBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a CRTP base class for dialect resource handles.  <a href="classmlir_1_1AsmDialectResourceHandleBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base class exposes generic asm printer hooks, usable across the various derived printers.  <a href="classmlir_1_1AsmPrinter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a pure-virtual base class that exposes the asmprinter hooks necessary to implement a custom <a class="el" href="SPIRVAttributes_8cpp.html#ab9c11536098442a052918c34cb6e4864">print()</a> method.  <a href="classmlir_1_1OpAsmPrinter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html">AsmParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base class exposes generic asm parser hooks, usable across the various derived parsers.  <a href="classmlir_1_1AsmParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1OpAsmParser.html" title="The OpAsmParser has methods for interacting with the asm parser: parsing things from it,...">OpAsmParser</a> has methods for interacting with the asm parser: parsing things from it, emitting errors etc.  <a href="classmlir_1_1OpAsmParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmDialectInterface.html">OpAsmDialectInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the benefit of a pattern match in a unitless scheme that ranges from 0 (very little benefit) to 65K.  <a href="classmlir_1_1PatternBenefit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Pattern.html">Pattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the data related to a pattern, but does not contain any methods or logic for the actual matching.  <a href="classmlir_1_1Pattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewritePattern.html">RewritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements.">RewritePattern</a> is the common base class for all DAG to DAG replacements.  <a href="classmlir_1_1RewritePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpRewritePattern.html">OpRewritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1OpRewritePattern.html" title="OpRewritePattern is a wrapper around RewritePattern that allows for matching and rewriting against an...">OpRewritePattern</a> is a wrapper around <a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements.">RewritePattern</a> that allows for matching and rewriting against an instance of a derived operation class as opposed to a raw <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>.  <a href="structmlir_1_1OpRewritePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpInterfaceRewritePattern.html">OpInterfaceRewritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1OpInterfaceRewritePattern.html" title="OpInterfaceRewritePattern is a wrapper around RewritePattern that allows for matching and rewriting a...">OpInterfaceRewritePattern</a> is a wrapper around <a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements.">RewritePattern</a> that allows for matching and rewriting against an instance of an operation interface instead of a raw <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>.  <a href="structmlir_1_1OpInterfaceRewritePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTraitRewritePattern.html">OpTraitRewritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1OpTraitRewritePattern.html" title="OpTraitRewritePattern is a wrapper around RewritePattern that allows for matching and rewriting again...">OpTraitRewritePattern</a> is a wrapper around <a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements.">RewritePattern</a> that allows for matching and rewriting against instances of an operation that possess a given trait.  <a href="classmlir_1_1OpTraitRewritePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class coordinates the application of a rewrite on a set of IR, providing a way for clients to track mutations and create new operations.  <a href="classmlir_1_1RewriterBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IRRewriter.html">IRRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class coordinates rewriting a piece of IR outside of a pattern rewrite, providing a way to keep track of the mutations made to the IR.  <a href="classmlir_1_1IRRewriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special type of <code><a class="el" href="classmlir_1_1RewriterBase.html" title="This class coordinates the application of a rewrite on a set of IR, providing a way for clients to tr...">RewriterBase</a></code> that coordinates the application of a rewrite pattern on the current IR being matched, providing a way to keep track of any mutations made.  <a href="classmlir_1_1PatternRewriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Region.html">Region</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains a list of basic blocks and a link to the parent operation it is attached to.  <a href="classmlir_1_1Region.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction over the different types of ranges over Regions.  <a href="classmlir_1_1RegionRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SymbolTable.html">SymbolTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows for representing and managing the symbol table used by operations with the '<a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a>' trait.  <a href="classmlir_1_1SymbolTable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a collection of <code><a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a></code>s.  <a href="classmlir_1_1SymbolTableCollection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LockedSymbolTableCollection.html">LockedSymbolTableCollection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a lock-based shared wrapper around a symbol table collection that allows shared access to the collection of symbol tables.  <a href="classmlir_1_1LockedSymbolTableCollection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SymbolUserMap.html">SymbolUserMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a map of symbols to users, and provides efficient implementations of symbol queries related to users; such as collecting the users of a symbol, replacing all uses, etc.  <a href="classmlir_1_1SymbolUserMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction over the various different ranges of value types.  <a href="classmlir_1_1TypeRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeRangeRange.html">TypeRangeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction for a range of <a class="el" href="classmlir_1_1TypeRange.html" title="This class provides an abstraction over the various different ranges of value types.">TypeRange</a>.  <a href="classmlir_1_1TypeRangeRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueTypeIterator.html">ValueTypeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements iteration on the types of a given range of values.  <a href="classmlir_1_1ValueTypeIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler_3_01TypeRange_01_4.html">AttrTypeSubElementHandler&lt; TypeRange &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable <a class="el" href="classmlir_1_1TypeRange.html" title="This class provides an abstraction over the various different ranges of value types.">TypeRange</a> to be introspected for sub-elements.  <a href="structmlir_1_1AttrTypeSubElementHandler_3_01TypeRange_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html">Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instances of the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> class are uniqued, have an immutable identifier and an optional mutable component.  <a href="classmlir_1_1Type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeInterface.html">TypeInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base of a type interface.  <a href="classmlir_1_1TypeInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AbstractType.html">AbstractType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the static information common to all instances of a registered <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a>.  <a href="classmlir_1_1AbstractType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base storage class appearing in a <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a>.  <a href="classmlir_1_1TypeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperandElementTypeIterator.html">OperandElementTypeIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ResultElementTypeIterator.html">ResultElementTypeIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IRUnit.html">IRUnit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1IRUnit.html" title="IRUnit is a union of the different types of IR objects that consistute the IR structure (other than T...">IRUnit</a> is a union of the different types of IR objects that consistute the IR structure (other than <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> and <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>), that is <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>, <a class="el" href="classmlir_1_1Region.html" title="This class contains a list of basic blocks and a link to the parent operation it is attached to.">Region</a>, and <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a>.  <a href="classmlir_1_1IRUnit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueUseIterator.html">ValueUseIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator class that allows for iterating over the uses of an IR operand type.  <a href="classmlir_1_1ValueUseIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueUserIterator.html">ValueUserIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over the users of an IRObject.  <a href="classmlir_1_1ValueUserIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IROperand.html">IROperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to a value, suitable for use as an operand of an operation.  <a href="classmlir_1_1IROperand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IRObjectWithUseList.html">IRObjectWithUseList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single IR object that contains a use list.  <a href="classmlir_1_1IRObjectWithUseList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Value.html">Value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an instance of an SSA value in the MLIR system, representing a computable value that has a type and a set of users.  <a href="classmlir_1_1Value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an operand of an operation.  <a href="classmlir_1_1OpOperand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an argument of a <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a>.  <a href="classmlir_1_1BlockArgument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a value defined by a result of an operation.  <a href="classmlir_1_1OpResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the operand iterators for the <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> class.  <a href="classmlir_1_1OperandRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperandRangeRange.html">OperandRangeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a contiguous range of operand ranges, e.g.  <a href="classmlir_1_1OperandRangeRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MutableOperandRange.html">MutableOperandRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a mutable adaptor for a range of operands.  <a href="classmlir_1_1MutableOperandRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MutableOperandRangeRange.html">MutableOperandRangeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a contiguous range of mutable operand ranges, e.g.  <a href="classmlir_1_1MutableOperandRangeRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ResultRange.html">ResultRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the result iterators for the <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> class.  <a href="classmlir_1_1ResultRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction over the different types of ranges over Values.  <a href="classmlir_1_1ValueRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility result that is used to signal how to proceed with an ongoing walk:  <a href="classmlir_1_1WalkResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ForwardIterator.html">ForwardIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This iterator enumerates the elements in "forward" order.  <a href="structmlir_1_1ForwardIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1WalkStage.html">WalkStage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to encode the current walk stage for "generic" walkers.  <a href="classmlir_1_1WalkStage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AnalysisManager.html">AnalysisManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an analysis manager for a particular operation instance.  <a href="classmlir_1_1AnalysisManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ModuleAnalysisManager.html">ModuleAnalysisManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An analysis manager class specifically for the top-level operation.  <a href="classmlir_1_1ModuleAnalysisManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Pass.html">Pass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base pass class.  <a href="classmlir_1_1Pass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationPass_3_01void_01_4.html">OperationPass&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> to transform an operation.  <a href="classmlir_1_1OperationPass_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassWrapper.html">PassWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a CRTP wrapper around a base pass class to define several necessary utility methods.  <a href="classmlir_1_1PassWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassExecutionAction.html">PassExecutionAction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class encapsulates the "action" of executing a single pass.  <a href="classmlir_1_1PassExecutionAction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassInstrumentation.html">PassInstrumentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1PassInstrumentation.html" title="PassInstrumentation provides several entry points into the pass manager infrastructure.">PassInstrumentation</a> provides several entry points into the pass manager infrastructure.  <a href="classmlir_1_1PassInstrumentation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassInstrumentor.html">PassInstrumentor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class holds a collection of <a class="el" href="classmlir_1_1PassInstrumentation.html" title="PassInstrumentation provides several entry points into the pass manager infrastructure.">PassInstrumentation</a> objects, and invokes their respective call backs.  <a href="classmlir_1_1PassInstrumentor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a pass manager that runs passes on either a specific operation type, or any isolated operation.  <a href="classmlir_1_1OpPassManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ReproducerStream.html">ReproducerStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streams on which to output crash reproducer.  <a href="structmlir_1_1ReproducerStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassManager.html">PassManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main pass manager and pipeline builder.  <a href="classmlir_1_1PassManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassPipelineOptions.html">PassPipelineOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclasses of <a class="el" href="classmlir_1_1PassPipelineOptions.html" title="Subclasses of PassPipelineOptions provide a set of options that can be used to initialize a pass pipe...">PassPipelineOptions</a> provide a set of options that can be used to initialize a pass pipeline.  <a href="classmlir_1_1PassPipelineOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1EmptyPipelineOptions.html">EmptyPipelineOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default empty option struct to be used for passes that do not need to take any options.  <a href="structmlir_1_1EmptyPipelineOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassRegistryEntry.html">PassRegistryEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to group information about a passes and pass pipelines (argument to invoke via mlir-opt, description, pass pipeline builder).  <a href="classmlir_1_1PassRegistryEntry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassPipelineInfo.html">PassPipelineInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to represent the information of a registered pass pipeline.  <a href="classmlir_1_1PassPipelineInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassInfo.html">PassInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to represent the information for a derived pass class.  <a href="classmlir_1_1PassInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassRegistration.html">PassRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1PassRegistration.html" title="PassRegistration provides a global initializer that registers a Pass allocation routine for a concret...">PassRegistration</a> provides a global initializer that registers a <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> allocation routine for a concrete pass instance.  <a href="structmlir_1_1PassRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassPipelineRegistration.html">PassPipelineRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> provides a global initializer that registers a <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> pipeline builder routine.  <a href="structmlir_1_1PassPipelineRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassPipelineRegistration_3_01EmptyPipelineOptions_01_4.html">PassPipelineRegistration&lt; EmptyPipelineOptions &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience specialization of <a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> for EmptyPassOptions that does not pass an empty options struct to the pass builder function.  <a href="structmlir_1_1PassPipelineRegistration_3_01EmptyPipelineOptions_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassPipelineCLParser.html">PassPipelineCLParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a command-line parser for MLIR passes.  <a href="classmlir_1_1PassPipelineCLParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassNameCLParser.html">PassNameCLParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a command-line parser specifically for MLIR pass names.  <a href="classmlir_1_1PassNameCLParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassReproducerOptions.html">PassReproducerOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ReductionNode.html">ReductionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReductionTreePass will build a reduction tree during module reduction and the <a class="el" href="classmlir_1_1ReductionNode.html" title="ReductionTreePass will build a reduction tree during module reduction and the ReductionNode represent...">ReductionNode</a> represents the vertex of the tree.  <a href="classmlir_1_1ReductionNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectReductionPatternInterface.html">DialectReductionPatternInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to report the reduction patterns for a <a class="el" href="classmlir_1_1Dialect.html" title="Dialects are groups of MLIR operations, types and attributes, as well as behavior associated with the...">Dialect</a>.  <a href="classmlir_1_1DialectReductionPatternInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Tester.html">Tester</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to keep track of the testing environment of the tool.  <a href="classmlir_1_1Tester.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a frozen set of patterns that can be processed by a pattern applicator.  <a href="classmlir_1_1FrozenRewritePatternSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ApplyPatternAction.html">ApplyPatternAction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of Action that is dispatched when a pattern is applied.  <a href="classmlir_1_1ApplyPatternAction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PatternApplicator.html">PatternApplicator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class manages the application of a group of rewrite patterns, with a user-provided cost model.  <a href="classmlir_1_1PatternApplicator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CopyOnWriteArrayRef.html">CopyOnWriteArrayRef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CyclicReplacerCache.html">CyclicReplacerCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cache for replacer-like functions that map values between two domains.  <a href="classmlir_1_1CyclicReplacerCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CachedCyclicReplacer.html">CachedCyclicReplacer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for cases where the input/output types of the replacer function is identical to the types stored in the cache.  <a href="classmlir_1_1CachedCyclicReplacer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1raw__indented__ostream.html">raw_indented_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">raw_ostream subclass that simplifies indention a sequence of code.  <a href="classmlir_1_1raw__indented__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html">StorageUniquer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to get or create instances of "storage classes".  <a href="classmlir_1_1StorageUniquer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ThreadLocalCache.html">ThreadLocalCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides support for defining a thread local object with non static storage duration.  <a href="classmlir_1_1ThreadLocalCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TimingIdentifier.html">TimingIdentifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represesents a uniqued string owned by a <code><a class="el" href="classmlir_1_1TimingManager.html" title="This class represents facilities to measure execution time.">TimingManager</a></code>.  <a href="classmlir_1_1TimingIdentifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TimingManager.html">TimingManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents facilities to measure execution time.  <a href="classmlir_1_1TimingManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle for a timer in a <code><a class="el" href="classmlir_1_1TimingManager.html" title="This class represents facilities to measure execution time.">TimingManager</a></code>.  <a href="classmlir_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TimingScope.html">TimingScope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An RAII-style wrapper around a timer that ensures the timer is properly started and stopped.  <a href="classmlir_1_1TimingScope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TimeRecord.html">TimeRecord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple record class to record timing information.  <a href="structmlir_1_1TimeRecord.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OutputStrategy.html">OutputStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facilities for printing timing reports to various output formats.  <a href="classmlir_1_1OutputStrategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DefaultTimingManager.html">DefaultTimingManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facilities for time measurement and report printing to an output stream.  <a href="classmlir_1_1DefaultTimingManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an efficient unique identifier for a specific C++ type.  <a href="classmlir_1_1TypeID.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeIDAllocator.html">TypeIDAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a way to define new TypeIDs at runtime.  <a href="classmlir_1_1TypeIDAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SelfOwningTypeID.html">SelfOwningTypeID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a> for each instance of this class by using a pointer to the instance.  <a href="classmlir_1_1SelfOwningTypeID.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1GenInfo.html">GenInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to group information about a generator (argument to invoke via mlir-tblgen, description, and generator function).  <a href="classmlir_1_1GenInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GenRegistration.html">GenRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1GenRegistration.html" title="GenRegistration provides a global initializer that registers a generator function.">GenRegistration</a> provides a global initializer that registers a generator function.  <a href="structmlir_1_1GenRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GenNameParser.html">GenNameParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds command line option for each registered generator.  <a href="structmlir_1_1GenNameParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMImportDialectInterface.html">LLVMImportDialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for dialect interfaces used to import <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR.  <a href="classmlir_1_1LLVMImportDialectInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMImportInterface.html">LLVMImportInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface collection for the import of <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR that dispatches to a concrete dialect interface implementation.  <a href="classmlir_1_1LLVMImportInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTranslationDialectInterface.html">LLVMTranslationDialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for dialect interfaces providing translation to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR.  <a href="classmlir_1_1LLVMTranslationDialectInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTranslationInterface.html">LLVMTranslationInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface collection for translation to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR, dispatches to a concrete interface implementation based on the dialect to which the given op belongs.  <a href="classmlir_1_1LLVMTranslationInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MlirOptMainConfig.html">MlirOptMainConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration options for the mlir-opt tool.  <a href="classmlir_1_1MlirOptMainConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Translation.html">Translation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the components necessary for performing a translation.  <a href="classmlir_1_1Translation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslateToMLIRRegistration.html">TranslateToMLIRRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Translate[ToMLIR|FromMLIR]Registration as an initializer that registers a function and associates it with name.  <a href="structmlir_1_1TranslateToMLIRRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslateFromMLIRRegistration.html">TranslateFromMLIRRegistration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslateRegistration.html">TranslateRegistration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslationParser.html">TranslationParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A command line parser for translation functions.  <a href="structmlir_1_1TranslationParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1DialectPluginLibraryInfo.html">DialectPluginLibraryInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the plugin required to load its dialects &amp; passes.  <a href="structmlir_1_1DialectPluginLibraryInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectPlugin.html">DialectPlugin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A loaded dialect plugin.  <a href="classmlir_1_1DialectPlugin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassPluginLibraryInfo.html">PassPluginLibraryInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the plugin required to load its passes.  <a href="structmlir_1_1PassPluginLibraryInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassPlugin.html">PassPlugin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A loaded pass plugin.  <a href="classmlir_1_1PassPlugin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CFGToSCFInterface.html">CFGToSCFInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface that should be implemented by any caller of <code>transformCFGToSCF</code>.  <a href="classmlir_1_1CFGToSCFInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> conversion class.  <a href="classmlir_1_1TypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConversionPattern.html">ConversionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for the conversion patterns.  <a href="classmlir_1_1ConversionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpConversionPattern.html">OpConversionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1OpConversionPattern.html" title="OpConversionPattern is a wrapper around ConversionPattern that allows for matching and rewriting agai...">OpConversionPattern</a> is a wrapper around <a class="el" href="classmlir_1_1ConversionPattern.html" title="Base class for the conversion patterns.">ConversionPattern</a> that allows for matching and rewriting against an instance of a derived operation class as opposed to a raw <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>.  <a href="classmlir_1_1OpConversionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpInterfaceConversionPattern.html">OpInterfaceConversionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1OpInterfaceConversionPattern.html" title="OpInterfaceConversionPattern is a wrapper around ConversionPattern that allows for matching and rewri...">OpInterfaceConversionPattern</a> is a wrapper around <a class="el" href="classmlir_1_1ConversionPattern.html" title="Base class for the conversion patterns.">ConversionPattern</a> that allows for matching and rewriting against an instance of an <a class="el" href="classmlir_1_1OpInterface.html" title="This class represents the base of an operation interface.">OpInterface</a> class as opposed to a raw <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>.  <a href="classmlir_1_1OpInterfaceConversionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTraitConversionPattern.html">OpTraitConversionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1OpTraitConversionPattern.html" title="OpTraitConversionPattern is a wrapper around ConversionPattern that allows for matching and rewriting...">OpTraitConversionPattern</a> is a wrapper around <a class="el" href="classmlir_1_1ConversionPattern.html" title="Base class for the conversion patterns.">ConversionPattern</a> that allows for matching and rewriting against instances of an operation that possess a given trait.  <a href="classmlir_1_1OpTraitConversionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConversionPatternRewriter.html">ConversionPatternRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a pattern rewriter for use with ConversionPatterns.  <a href="classmlir_1_1ConversionPatternRewriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class describes a specific conversion target.  <a href="classmlir_1_1ConversionTarget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PDLConversionConfig.html">PDLConversionConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A PDL configuration that is used to supported dialect conversion functionality.  <a href="classmlir_1_1PDLConversionConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Dialect.html" title="Dialects are groups of MLIR operations, types and attributes, as well as behavior associated with the...">Dialect</a> conversion configuration.  <a href="structmlir_1_1ConversionConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1EndomorphismSimplification.html">EndomorphismSimplification</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationFolder.html">OperationFolder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class for folding operations, and unifying duplicated constants generated along the way.  <a href="classmlir_1_1OperationFolder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows control over how the GreedyPatternRewriteDriver works.  <a href="classmlir_1_1GreedyRewriteConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1HomomorphismSimplification.html">HomomorphismSimplification</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1InlinerConfig.html">InlinerConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Inliner.html">Inliner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implementation of the inliner that operates bottom up over the Strongly Connected Components(SCCs) of the <a class="el" href="classmlir_1_1CallGraph.html">CallGraph</a>.  <a href="classmlir_1_1Inliner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectInlinerInterface.html">DialectInlinerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the interface that must be implemented by the dialects of operations to be inlined.  <a href="classmlir_1_1DialectInlinerInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface provides the hooks into the inlining interface.  <a href="classmlir_1_1InlinerInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1Mem2RegStatistics.html">Mem2RegStatistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics collected while applying mem2reg.  <a href="structmlir_1_1Mem2RegStatistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OneToNTypeConverter.html">OneToNTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends <code><a class="el" href="classmlir_1_1TypeConverter.html" title="Type conversion class.">TypeConverter</a></code> with 1:N target materializations.  <a href="classmlir_1_1OneToNTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OneToNTypeMapping.html">OneToNTypeMapping</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a 1:N mapping of types and provides several useful accessors.  <a href="classmlir_1_1OneToNTypeMapping.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewritePatternWithConverter.html">RewritePatternWithConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the basic <code><a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements.">RewritePattern</a></code> class with a type converter member and some accessors to it.  <a href="classmlir_1_1RewritePatternWithConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OneToNPatternRewriter.html">OneToNPatternRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code><a class="el" href="classmlir_1_1PatternRewriter.html" title="A special type of RewriterBase that coordinates the application of a rewrite pattern on the current I...">PatternRewriter</a></code> that <code><a class="el" href="classmlir_1_1OneToNConversionPattern.html" title="Base class for patterns with 1:N type conversions.">OneToNConversionPattern</a></code>s use.  <a href="classmlir_1_1OneToNPatternRewriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OneToNConversionPattern.html">OneToNConversionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for patterns with 1:N type conversions.  <a href="classmlir_1_1OneToNConversionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OneToNOpConversionPattern.html">OneToNOpConversionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a wrapper around <code><a class="el" href="classmlir_1_1OneToNConversionPattern.html" title="Base class for patterns with 1:N type conversions.">OneToNConversionPattern</a></code> for matching against instances of a particular op class.  <a href="classmlir_1_1OneToNOpConversionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SROAStatistics.html">SROAStatistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics collected while applying SROA.  <a href="structmlir_1_1SROAStatistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Lexer.html">Lexer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class breaks up the current file into a token stream.  <a href="classmlir_1_1Lexer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Token.html">Token</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents a token in the MLIR syntax.  <a href="classmlir_1_1Token.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PyPrintAccumulator.html">PyPrintAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulates into a python string from a method that accepts an MlirStringCallback.  <a href="structmlir_1_1PyPrintAccumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PyFileAccumulator.html">PyFileAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulates int a python file-like object, either writing text (default) or binary.  <a href="classmlir_1_1PyFileAccumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PySinglePartStringAccumulator.html">PySinglePartStringAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulates into a python string from a method that is expected to make one (no more, no less) call to the callback (asserts internally on violation).  <a href="structmlir_1_1PySinglePartStringAccumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Sliceable.html">Sliceable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CRTP base class for pseudo-containers willing to support Python-type slicing access on top of indexed access.  <a href="classmlir_1_1Sliceable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ExternalPass.html">ExternalPass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pass class wraps external passes defined in other languages using the MLIR C-interface.  <a href="classmlir_1_1ExternalPass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUDynamicSharedMemoryOpLowering.html">GPUDynamicSharedMemoryOpLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowering for gpu.dynamic.shared.memory to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <a href="structmlir_1_1GPUDynamicSharedMemoryOpLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUFuncOpLoweringOptions.html">GPUFuncOpLoweringOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUFuncOpLowering.html">GPUFuncOpLowering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUPrintfOpToHIPLowering.html">GPUPrintfOpToHIPLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lowering of gpu.printf to a call to HIP hostcalls.  <a href="structmlir_1_1GPUPrintfOpToHIPLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUPrintfOpToLLVMCallLowering.html">GPUPrintfOpToLLVMCallLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lowering of gpu.printf to a call to an external printf() function.  <a href="structmlir_1_1GPUPrintfOpToLLVMCallLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUPrintfOpToVPrintfLowering.html">GPUPrintfOpToVPrintfLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowering of gpu.printf to a vprintf standard library.  <a href="structmlir_1_1GPUPrintfOpToVPrintfLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUReturnOpLowering.html">GPUReturnOpLowering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ScalarizeVectorOpLowering.html">ScalarizeVectorOpLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewriting that unrolls SourceOp to scalars if it's operating on vectors.  <a href="structmlir_1_1ScalarizeVectorOpLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpToFuncCallLowering.html">OpToFuncCallLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewriting that replace SourceOp with a CallOp to <code>f32Func</code> or <code>f64Func</code> or <code>f32ApproxFunc</code> or <code>f16Func</code> depending on the element type and the fastMathFlag of that <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a>.  <a href="structmlir_1_1OpToFuncCallLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ScfToSPIRVContextImpl.html">ScfToSPIRVContextImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01DeviceIDTargetDeviceSpecPair_01_4.html">FieldParser&lt; DeviceIDTargetDeviceSpecPair &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structmlir_1_1FieldParser.html" title="Provide a template class that can be specialized by users to dispatch to parsers.">FieldParser</a> for key-value pairs of DeviceID-target device spec pairs that make up a target system spec.  <a href="structmlir_1_1FieldParser_3_01DeviceIDTargetDeviceSpecPair_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AttrTypeSubElementHandler_3_01LLVM_1_1detail_1_1LLVMStructTypeStorage_1_1Key_01_4.html">AttrTypeSubElementHandler&lt; LLVM::detail::LLVMStructTypeStorage::Key &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow walking and replacing the subelements of a LLVMStructTypeStorage key.  <a href="structmlir_1_1AttrTypeSubElementHandler_3_01LLVM_1_1detail_1_1LLVMStructTypeStorage_1_1Key_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MLIRContextImpl.html">MLIRContextImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the implementation of the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> class, using the pImpl idiom.  <a href="classmlir_1_1MLIRContextImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OperationConverter.html">OperationConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2b41c5a75264460202bc6e5da0518c15"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2b41c5a75264460202bc6e5da0518c15">TransitiveFilter</a> = <a class="el" href="structmlir_1_1SliceOptions.html#a667b0cbe189fd8ce9af2f0475a14b602">SliceOptions::TransitiveFilter</a></td></tr>
<tr class="separator:a2b41c5a75264460202bc6e5da0518c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbb33912ce41da593598188d8bcc13a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5bbb33912ce41da593598188d8bcc13a">ForwardSliceOptions</a> = <a class="el" href="structmlir_1_1SliceOptions.html">SliceOptions</a></td></tr>
<tr class="separator:a5bbb33912ce41da593598188d8bcc13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb40c25041db8d506e4b23fb8c86d5c6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afb40c25041db8d506e4b23fb8c86d5c6">WalkCallback</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">mlir::function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkContinuation.html">WalkContinuation</a>(<a class="el" href="classmlir_1_1Value.html">mlir::Value</a>)&gt;</td></tr>
<tr class="memdesc:afb40c25041db8d506e4b23fb8c86d5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback that is invoked for each value encountered during the walk of the slice.  <a href="namespacemlir.html#afb40c25041db8d506e4b23fb8c86d5c6">More...</a><br /></td></tr>
<tr class="separator:afb40c25041db8d506e4b23fb8c86d5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594a45ae9aa1ccffd960f369da94d156"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a594a45ae9aa1ccffd960f369da94d156">LoweringCallback</a> = std::function&lt; std::unique_ptr&lt; llvm::Module &gt;(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, llvm::LLVMContext &amp;, StringRef)&gt;</td></tr>
<tr class="separator:a594a45ae9aa1ccffd960f369da94d156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc8d74e74ce84649cf5ee6135cd09a4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2cc8d74e74ce84649cf5ee6135cd09a4">MemorySpaceMapping</a> = std::function&lt; unsigned(gpu::AddressSpace)&gt;</td></tr>
<tr class="memdesc:a2cc8d74e74ce84649cf5ee6135cd09a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that maps a MemorySpace enum to a target-specific integer value.  <a href="namespacemlir.html#a2cc8d74e74ce84649cf5ee6135cd09a4">More...</a><br /></td></tr>
<tr class="separator:a2cc8d74e74ce84649cf5ee6135cd09a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66e7b63d5fa8a2a0339c23648a51fbe"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 2 &gt;</td></tr>
<tr class="separator:af66e7b63d5fa8a2a0339c23648a51fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8ab57590177d757d89848504dd7c5f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7f8ab57590177d757d89848504dd7c5f">MemrefValue</a> = <a class="el" href="namespacemlir.html#a39768b5816332d4970911da09de5cec4">TypedValue</a>&lt; <a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> &gt;</td></tr>
<tr class="memdesc:a7f8ab57590177d757d89848504dd7c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A value with a memref type.  <a href="namespacemlir.html#a7f8ab57590177d757d89848504dd7c5f">More...</a><br /></td></tr>
<tr class="separator:a7f8ab57590177d757d89848504dd7c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c8735b67af7a64e4deff16477a06eb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; scf::ForOp, 8 &gt;</td></tr>
<tr class="memdesc:ad5c8735b67af7a64e4deff16477a06eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile a nest of standard for loops rooted at <code>rootForOp</code> by finding such parametric tile sizes that the outer loops have a fixed number of iterations as defined in <code>sizes</code>.  <a href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">More...</a><br /></td></tr>
<tr class="separator:ad5c8735b67af7a64e4deff16477a06eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0d45d0562d47acc2c42934ccbfea19"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3f0d45d0562d47acc2c42934ccbfea19">TileLoops</a> = std::pair&lt; <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>, <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a> &gt;</td></tr>
<tr class="separator:a3f0d45d0562d47acc2c42934ccbfea19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed845b40509fa999492a04654211321"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7ed845b40509fa999492a04654211321">ReassociationIndicesRef</a> = <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;</td></tr>
<tr class="separator:a7ed845b40509fa999492a04654211321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cf0e24a954fa30fb469105d4ca5dd8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae5cf0e24a954fa30fb469105d4ca5dd8">ReassociationExprs</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2 &gt;</td></tr>
<tr class="separator:ae5cf0e24a954fa30fb469105d4ca5dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9afb3b6f82b256aea9f20e913e8afd5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac9afb3b6f82b256aea9f20e913e8afd5">AllocFunType</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; void *(size_t)&gt;</td></tr>
<tr class="separator:ac9afb3b6f82b256aea9f20e913e8afd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae076c6e0e79ca32d89266007db06f358"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae076c6e0e79ca32d89266007db06f358"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae076c6e0e79ca32d89266007db06f358">ElementWiseVisitor</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; void(T &amp;ptr, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;)&gt;</td></tr>
<tr class="memdesc:ae076c6e0e79ca32d89266007db06f358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient callback to "visit" a memref element by element.  <a href="namespacemlir.html#ae076c6e0e79ca32d89266007db06f358">More...</a><br /></td></tr>
<tr class="separator:ae076c6e0e79ca32d89266007db06f358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33732a3813b186ef51131421fac26f4a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a33732a3813b186ef51131421fac26f4a">DataLayoutEntryKey</a> = <a class="el" href="classllvm_1_1PointerUnion.html">llvm::PointerUnion</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, StringAttr &gt;</td></tr>
<tr class="separator:a33732a3813b186ef51131421fac26f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a4f77607d05cf551b24ceb9362c034"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a72a4f77607d05cf551b24ceb9362c034">DataLayoutEntryList</a> = <a class="el" href="classllvm_1_1SmallVector.html">llvm::SmallVector</a>&lt; DataLayoutEntryInterface, 4 &gt;</td></tr>
<tr class="separator:a72a4f77607d05cf551b24ceb9362c034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577834e9b93afb653df29d66a6975ecf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a> = <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; DataLayoutEntryInterface &gt;</td></tr>
<tr class="separator:a577834e9b93afb653df29d66a6975ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90f8dcaf13650935b7e9a32ccf0c055"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa90f8dcaf13650935b7e9a32ccf0c055">TargetDeviceSpecListRef</a> = <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; TargetDeviceSpecInterface &gt;</td></tr>
<tr class="separator:aa90f8dcaf13650935b7e9a32ccf0c055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefb76d43733fcaa50b62e0962d9c463"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acefb76d43733fcaa50b62e0962d9c463">DeviceIDTargetDeviceSpecPair</a> = std::pair&lt; StringAttr, TargetDeviceSpecInterface &gt;</td></tr>
<tr class="separator:acefb76d43733fcaa50b62e0962d9c463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52075acbb1e5eb0da479dc2b7d864a4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac52075acbb1e5eb0da479dc2b7d864a4">DeviceIDTargetDeviceSpecPairListRef</a> = <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#acefb76d43733fcaa50b62e0962d9c463">DeviceIDTargetDeviceSpecPair</a> &gt;</td></tr>
<tr class="separator:ac52075acbb1e5eb0da479dc2b7d864a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5c1ae42afa0427a3f833888eef1a97"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abf5c1ae42afa0427a3f833888eef1a97">SetIntRangeFn</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Value.html">Value</a>, const <a class="el" href="classmlir_1_1ConstantIntRanges.html">ConstantIntRanges</a> &amp;)&gt;</td></tr>
<tr class="memdesc:abf5c1ae42afa0427a3f833888eef1a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the <code>setResultRanges</code> callback provided to ops implementing InferIntRangeInterface.  <a href="namespacemlir.html#abf5c1ae42afa0427a3f833888eef1a97">More...</a><br /></td></tr>
<tr class="separator:abf5c1ae42afa0427a3f833888eef1a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426e7736067d3718883782ec71f12d49"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a426e7736067d3718883782ec71f12d49">SetIntLatticeFn</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Value.html">Value</a>, const <a class="el" href="classmlir_1_1IntegerValueRange.html">IntegerValueRange</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a426e7736067d3718883782ec71f12d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to SetIntRangeFn, but operating on <a class="el" href="classmlir_1_1IntegerValueRange.html" title="This lattice value represents the integer range of an SSA value.">IntegerValueRange</a> lattice values.  <a href="namespacemlir.html#a426e7736067d3718883782ec71f12d49">More...</a><br /></td></tr>
<tr class="separator:a426e7736067d3718883782ec71f12d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5ee68dc80640e6ac9c4a6011d18bc1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0a5ee68dc80640e6ac9c4a6011d18bc1">ReifiedRankedShapedTypeDims</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;</td></tr>
<tr class="separator:a0a5ee68dc80640e6ac9c4a6011d18bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a2f522a6f1ebf6ac3b3ba85a12b9e4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a70a2f522a6f1ebf6ac3b3ba85a12b9e4">NewYieldValuesFn</a> = std::function&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt; newBbArgs)&gt;</td></tr>
<tr class="memdesc:a70a2f522a6f1ebf6ac3b3ba85a12b9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that returns the additional yielded values during <code>replaceWithAdditionalYields</code>.  <a href="namespacemlir.html#a70a2f522a6f1ebf6ac3b3ba85a12b9e4">More...</a><br /></td></tr>
<tr class="separator:a70a2f522a6f1ebf6ac3b3ba85a12b9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c852d22f676b319b260b86ad21499ac"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9c852d22f676b319b260b86ad21499ac">ValueDimList</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; std::pair&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, std::optional&lt; int64_t &gt; &gt;&gt;</td></tr>
<tr class="separator:a9c852d22f676b319b260b86ad21499ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759bdae349015b16ce375bdd46c1e16c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a759bdae349015b16ce375bdd46c1e16c">DefaultAttributeStorage</a> = <a class="el" href="classmlir_1_1AttributeStorage.html">AttributeStorage</a></td></tr>
<tr class="memdesc:a759bdae349015b16ce375bdd46c1e16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default storage type for attributes that require no additional initialization or storage.  <a href="namespacemlir.html#a759bdae349015b16ce375bdd46c1e16c">More...</a><br /></td></tr>
<tr class="separator:a759bdae349015b16ce375bdd46c1e16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8f5011648c4f698028afb8a96b31ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aad8f5011648c4f698028afb8a96b31ce">AttributeStorageAllocator</a> = <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td></tr>
<tr class="separator:aad8f5011648c4f698028afb8a96b31ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ea1893e6ad27965d15e12d6f545008"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a16ea1893e6ad27965d15e12d6f545008">AttrSubElementReplacements</a> = <a class="el" href="classmlir_1_1AttrTypeSubElementReplacements.html">AttrTypeSubElementReplacements</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td></tr>
<tr class="separator:a16ea1893e6ad27965d15e12d6f545008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdd84a4516a711493014c535e027b86"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9cdd84a4516a711493014c535e027b86">TypeSubElementReplacements</a> = <a class="el" href="classmlir_1_1AttrTypeSubElementReplacements.html">AttrTypeSubElementReplacements</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;</td></tr>
<tr class="separator:a9cdd84a4516a711493014c535e027b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6841368c88bd98143c5b7fc3174fc663"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6841368c88bd98143c5b7fc3174fc663">DenseResourceElementsHandle</a> = <a class="el" href="structmlir_1_1DialectResourceBlobHandle.html">DialectResourceBlobHandle</a>&lt; BuiltinDialect &gt;</td></tr>
<tr class="separator:a6841368c88bd98143c5b7fc3174fc663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dffb2feeebaff96012a0f11534ecb42"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7dffb2feeebaff96012a0f11534ecb42">DenseBoolArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt; bool &gt;</td></tr>
<tr class="separator:a7dffb2feeebaff96012a0f11534ecb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90796fd9f1813081632c1402c9ab0f5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab90796fd9f1813081632c1402c9ab0f5">DenseI8ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt; int8_t &gt;</td></tr>
<tr class="separator:ab90796fd9f1813081632c1402c9ab0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684fa3991fcdc7c970ec8a74aa461a77"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a684fa3991fcdc7c970ec8a74aa461a77">DenseI16ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt; int16_t &gt;</td></tr>
<tr class="separator:a684fa3991fcdc7c970ec8a74aa461a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9107ae5cb34fa1aa00e0fd1377ad89"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ace9107ae5cb34fa1aa00e0fd1377ad89">DenseI32ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt; int32_t &gt;</td></tr>
<tr class="separator:ace9107ae5cb34fa1aa00e0fd1377ad89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50858f49b4d3e313809688de651162e3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt; int64_t &gt;</td></tr>
<tr class="separator:a50858f49b4d3e313809688de651162e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057c3db4d18f7bc0ebd0e5943ab4f6f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a057c3db4d18f7bc0ebd0e5943ab4f6f8">DenseF32ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt; float &gt;</td></tr>
<tr class="separator:a057c3db4d18f7bc0ebd0e5943ab4f6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd8e5d82c207ff36cbbf5abad9ca288"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#accd8e5d82c207ff36cbbf5abad9ca288">DenseF64ArrayAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt; double &gt;</td></tr>
<tr class="separator:accd8e5d82c207ff36cbbf5abad9ca288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1691413cd0a4f426cddf9c9ec13c0523"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1691413cd0a4f426cddf9c9ec13c0523">DenseBoolResourceElementsAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt; bool &gt;</td></tr>
<tr class="separator:a1691413cd0a4f426cddf9c9ec13c0523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c8652ae83dca72bfa8476f790a779e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a80c8652ae83dca72bfa8476f790a779e">DenseI8ResourceElementsAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt; int8_t &gt;</td></tr>
<tr class="separator:a80c8652ae83dca72bfa8476f790a779e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313e0d370789a4ea8efc263c0212e445"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a313e0d370789a4ea8efc263c0212e445">DenseI16ResourceElementsAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt; int16_t &gt;</td></tr>
<tr class="separator:a313e0d370789a4ea8efc263c0212e445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82486c15d0b4b7a7c6aeaf299655cae4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a82486c15d0b4b7a7c6aeaf299655cae4">DenseI32ResourceElementsAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt; int32_t &gt;</td></tr>
<tr class="separator:a82486c15d0b4b7a7c6aeaf299655cae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702b9fea87b463a5d46d215e2a41b434"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a702b9fea87b463a5d46d215e2a41b434">DenseI64ResourceElementsAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt; int64_t &gt;</td></tr>
<tr class="separator:a702b9fea87b463a5d46d215e2a41b434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be9cf4f237c5eb1d4ae5ceedca018e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0be9cf4f237c5eb1d4ae5ceedca018e8">DenseUI8ResourceElementsAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt; uint8_t &gt;</td></tr>
<tr class="separator:a0be9cf4f237c5eb1d4ae5ceedca018e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d38dcceb11bdea46ed3a87eae2c0e4e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9d38dcceb11bdea46ed3a87eae2c0e4e">DenseUI16ResourceElementsAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt; uint16_t &gt;</td></tr>
<tr class="separator:a9d38dcceb11bdea46ed3a87eae2c0e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62ce2fff3156992f2755bc853f1f85f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad62ce2fff3156992f2755bc853f1f85f">DenseUI32ResourceElementsAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt; uint32_t &gt;</td></tr>
<tr class="separator:ad62ce2fff3156992f2755bc853f1f85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2b788b2acc9e11d299d1bdfc6ab941"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aac2b788b2acc9e11d299d1bdfc6ab941">DenseUI64ResourceElementsAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt; uint64_t &gt;</td></tr>
<tr class="separator:aac2b788b2acc9e11d299d1bdfc6ab941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af658dc01559125b6634401cc7a8128d1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af658dc01559125b6634401cc7a8128d1">DenseF32ResourceElementsAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt; float &gt;</td></tr>
<tr class="separator:af658dc01559125b6634401cc7a8128d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af761c00f33889d6ec2a2247517748327"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af761c00f33889d6ec2a2247517748327">DenseF64ResourceElementsAttr</a> = <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt; double &gt;</td></tr>
<tr class="separator:af761c00f33889d6ec2a2247517748327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e943fa4f63d44d69d846e504c16d5f6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2e943fa4f63d44d69d846e504c16d5f6">DialectAllocatorFunction</a> = std::function&lt; <a class="el" href="classmlir_1_1Dialect.html">Dialect</a> *(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="separator:a2e943fa4f63d44d69d846e504c16d5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffd752ab3a9dd88587958c328e34e70"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6ffd752ab3a9dd88587958c328e34e70">DialectAllocatorFunctionRef</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1Dialect.html">Dialect</a> *(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="separator:a6ffd752ab3a9dd88587958c328e34e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226a6f936696eac398cee8be0368046b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a226a6f936696eac398cee8be0368046b">DynamicDialectPopulationFunction</a> = std::function&lt; void(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *, <a class="el" href="classmlir_1_1DynamicDialect.html">DynamicDialect</a> *)&gt;</td></tr>
<tr class="separator:a226a6f936696eac398cee8be0368046b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbc3d0362a57c5175f05dd95fb59641"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aedbc3d0362a57c5175f05dd95fb59641">DominanceInfoNode</a> = llvm::DomTreeNodeBase&lt; <a class="el" href="classmlir_1_1Block.html">Block</a> &gt;</td></tr>
<tr class="separator:aedbc3d0362a57c5175f05dd95fb59641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0887111bf825d1f766ef9e0911394d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab0887111bf825d1f766ef9e0911394d5">OpAsmSetValueNameFn</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Value.html">Value</a>, StringRef)&gt;</td></tr>
<tr class="memdesc:ab0887111bf825d1f766ef9e0911394d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor used to set the name of the start of a result group of an operation.  <a href="namespacemlir.html#ab0887111bf825d1f766ef9e0911394d5">More...</a><br /></td></tr>
<tr class="separator:ab0887111bf825d1f766ef9e0911394d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d45da2e2b2d5f705d618b778e36d52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af2d45da2e2b2d5f705d618b778e36d52">OpAsmSetBlockNameFn</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Block.html">Block</a> *, StringRef)&gt;</td></tr>
<tr class="memdesc:af2d45da2e2b2d5f705d618b778e36d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor used to set the name of blocks in regions directly nested under an operation.  <a href="namespacemlir.html#af2d45da2e2b2d5f705d618b778e36d52">More...</a><br /></td></tr>
<tr class="separator:af2d45da2e2b2d5f705d618b778e36d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bff85dd5cf397b62e521086d55e2d37"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3bff85dd5cf397b62e521086d55e2d37">TypeRangeRangeIterator</a> = llvm::mapped_iterator&lt; llvm::iota_range&lt; unsigned &gt;::iterator, std::function&lt; <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>(unsigned)&gt; &gt;</td></tr>
<tr class="separator:a3bff85dd5cf397b62e521086d55e2d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b36f0e85767ed4e793d86f40bd8fe55"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8b36f0e85767ed4e793d86f40bd8fe55">DefaultTypeStorage</a> = <a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td></tr>
<tr class="memdesc:a8b36f0e85767ed4e793d86f40bd8fe55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default storage type for types that require no additional initialization or storage.  <a href="namespacemlir.html#a8b36f0e85767ed4e793d86f40bd8fe55">More...</a><br /></td></tr>
<tr class="separator:a8b36f0e85767ed4e793d86f40bd8fe55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e9069ef9040ccc727d541c02d49ecd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a01e9069ef9040ccc727d541c02d49ecd">TypeStorageAllocator</a> = <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td></tr>
<tr class="memdesc:a01e9069ef9040ccc727d541c02d49ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a utility allocator used to allocate memory for instances of derived Types.  <a href="namespacemlir.html#a01e9069ef9040ccc727d541c02d49ecd">More...</a><br /></td></tr>
<tr class="separator:a01e9069ef9040ccc727d541c02d49ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3789e28c54bcaf5d2c3baf5f99eb615f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3789e28c54bcaf5d2c3baf5f99eb615f">OperandElementTypeRange</a> = <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1OperandElementTypeIterator.html">OperandElementTypeIterator</a> &gt;</td></tr>
<tr class="separator:a3789e28c54bcaf5d2c3baf5f99eb615f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253b95ef2aaf79bdc612ae40fddc0732"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a253b95ef2aaf79bdc612ae40fddc0732">ResultElementTypeRange</a> = <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1ResultElementTypeIterator.html">ResultElementTypeIterator</a> &gt;</td></tr>
<tr class="separator:a253b95ef2aaf79bdc612ae40fddc0732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39768b5816332d4970911da09de5cec4"><td class="memTemplParams" colspan="2">template&lt;typename Ty , typename Value  = mlir::Value&gt; </td></tr>
<tr class="memitem:a39768b5816332d4970911da09de5cec4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a39768b5816332d4970911da09de5cec4">TypedValue</a> = std::conditional_t&lt; std::is_same_v&lt; Ty, <a class="el" href="classmlir_1_1Type.html">mlir::Type</a> &gt;, <a class="el" href="classmlir_1_1Value.html">mlir::Value</a>, <a class="el" href="structmlir_1_1detail_1_1TypedValue.html">detail::TypedValue</a>&lt; Ty &gt; &gt;</td></tr>
<tr class="memdesc:a39768b5816332d4970911da09de5cec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Ty is <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">mlir::Type</a> this will select <code><a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a></code> instead of having a wrapper around it.  <a href="namespacemlir.html#a39768b5816332d4970911da09de5cec4">More...</a><br /></td></tr>
<tr class="separator:a39768b5816332d4970911da09de5cec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52947e76a1893a1429c9219d1c96fd20"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a52947e76a1893a1429c9219d1c96fd20">ReproducerStreamFactory</a> = std::function&lt; std::unique_ptr&lt; <a class="el" href="structmlir_1_1ReproducerStream.html">ReproducerStream</a> &gt;(std::string &amp;error)&gt;</td></tr>
<tr class="memdesc:a52947e76a1893a1429c9219d1c96fd20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method type for constructing <a class="el" href="structmlir_1_1ReproducerStream.html" title="Streams on which to output crash reproducer.">ReproducerStream</a>.  <a href="namespacemlir.html#a52947e76a1893a1429c9219d1c96fd20">More...</a><br /></td></tr>
<tr class="separator:a52947e76a1893a1429c9219d1c96fd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ccb1e7accf2ec0c57b1aea967ccd02"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af4ccb1e7accf2ec0c57b1aea967ccd02">PassRegistryFunction</a> = std::function&lt; LogicalResult(<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;, StringRef <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; LogicalResult(const Twine &amp;)&gt; errorHandler)&gt;</td></tr>
<tr class="memdesc:af4ccb1e7accf2ec0c57b1aea967ccd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">A registry function that adds passes to the given pass manager.  <a href="namespacemlir.html#af4ccb1e7accf2ec0c57b1aea967ccd02">More...</a><br /></td></tr>
<tr class="separator:af4ccb1e7accf2ec0c57b1aea967ccd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48db7fd5d49bfa7ca8c81e5a6a058683"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a48db7fd5d49bfa7ca8c81e5a6a058683">PassAllocatorFunction</a> = std::function&lt; std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;()&gt;</td></tr>
<tr class="separator:a48db7fd5d49bfa7ca8c81e5a6a058683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087da824f0d25f4e19913ab4f2688c7b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Enable  = void&gt; </td></tr>
<tr class="memitem:a087da824f0d25f4e19913ab4f2688c7b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a087da824f0d25f4e19913ab4f2688c7b">DenseMapInfo</a> = <a class="el" href="structllvm_1_1DenseMapInfo.html">llvm::DenseMapInfo</a>&lt; T, Enable &gt;</td></tr>
<tr class="separator:a087da824f0d25f4e19913ab4f2688c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f731697783a754f6f0e3821d1264b2"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename KeyInfoT  = DenseMapInfo&lt;KeyT&gt;, typename BucketT  = llvm::detail::DenseMapPair&lt;KeyT, ValueT&gt;&gt; </td></tr>
<tr class="memitem:ad7f731697783a754f6f0e3821d1264b2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a> = <a class="el" href="classllvm_1_1DenseMap.html">llvm::DenseMap</a>&lt; KeyT, ValueT, KeyInfoT, BucketT &gt;</td></tr>
<tr class="separator:ad7f731697783a754f6f0e3821d1264b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d6aae8a616cd9d13c8b1edb1095948"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueInfoT  = DenseMapInfo&lt;ValueT&gt;&gt; </td></tr>
<tr class="memitem:a59d6aae8a616cd9d13c8b1edb1095948"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a> = <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt; ValueT, ValueInfoT &gt;</td></tr>
<tr class="separator:a59d6aae8a616cd9d13c8b1edb1095948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee6ce60684197b50504a1df1f9214f2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Vector  = llvm::SmallVector&lt;T, 0&gt;, typename Set  = DenseSet&lt;T&gt;, unsigned N = 0&gt; </td></tr>
<tr class="memitem:a1ee6ce60684197b50504a1df1f9214f2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a> = <a class="el" href="classllvm_1_1SetVector.html">llvm::SetVector</a>&lt; T, <a class="el" href="structVector.html">Vector</a>, Set, N &gt;</td></tr>
<tr class="separator:a1ee6ce60684197b50504a1df1f9214f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b3592ab67f8512cb18e62375d7ff4b"><td class="memTemplParams" colspan="2">template&lt;typename AllocatorTy  = llvm::MallocAllocator&gt; </td></tr>
<tr class="memitem:ac2b3592ab67f8512cb18e62375d7ff4b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac2b3592ab67f8512cb18e62375d7ff4b">StringSet</a> = <a class="el" href="classllvm_1_1StringSet.html">llvm::StringSet</a>&lt; AllocatorTy &gt;</td></tr>
<tr class="separator:ac2b3592ab67f8512cb18e62375d7ff4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac474b9f30a56412e090d9919e4dd8b34"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = T&gt; </td></tr>
<tr class="memitem:ac474b9f30a56412e090d9919e4dd8b34"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac474b9f30a56412e090d9919e4dd8b34">StringSwitch</a> = <a class="el" href="classllvm_1_1StringSwitch.html">llvm::StringSwitch</a>&lt; T, R &gt;</td></tr>
<tr class="separator:ac474b9f30a56412e090d9919e4dd8b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf44d03780c99376ac0c1dd1caed0f4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ResultT  = void&gt; </td></tr>
<tr class="memitem:abcf44d03780c99376ac0c1dd1caed0f4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abcf44d03780c99376ac0c1dd1caed0f4">TypeSwitch</a> = <a class="el" href="classllvm_1_1TypeSwitch.html">llvm::TypeSwitch</a>&lt; T, ResultT &gt;</td></tr>
<tr class="separator:abcf44d03780c99376ac0c1dd1caed0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bff6226b7c81b6134b8c1130403a172"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a0bff6226b7c81b6134b8c1130403a172"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; Fn &gt;</td></tr>
<tr class="separator:a0bff6226b7c81b6134b8c1130403a172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb0c2458571cd80ebb876d979e24346"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aafb0c2458571cd80ebb876d979e24346">ChunkBufferHandler</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; LogicalResult(std::unique_ptr&lt; llvm::MemoryBuffer &gt; chunkBuffer, raw_ostream &amp;os)&gt;</td></tr>
<tr class="separator:aafb0c2458571cd80ebb876d979e24346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff1d39837ac221ad45acd865c73c83e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3ff1d39837ac221ad45acd865c73c83e">GenFunction</a> = std::function&lt; bool(const llvm::RecordKeeper &amp;records, raw_ostream &amp;os)&gt;</td></tr>
<tr class="memdesc:a3ff1d39837ac221ad45acd865c73c83e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generator function to invoke.  <a href="namespacemlir.html#a3ff1d39837ac221ad45acd865c73c83e">More...</a><br /></td></tr>
<tr class="separator:a3ff1d39837ac221ad45acd865c73c83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22124ccf5219095aee552486366ccc0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa22124ccf5219095aee552486366ccc0">PassPipelineFn</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; LogicalResult(<a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;pm)&gt;</td></tr>
<tr class="memdesc:aa22124ccf5219095aee552486366ccc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This defines the function type used to setup the pass manager.  <a href="namespacemlir.html#aa22124ccf5219095aee552486366ccc0">More...</a><br /></td></tr>
<tr class="separator:aa22124ccf5219095aee552486366ccc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2fc3e0eaaa708d4f579d33d914aafb4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab2fc3e0eaaa708d4f579d33d914aafb4">TranslateSourceMgrToMLIRFunction</a> = std::function&lt; <a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;(const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;sourceMgr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="memdesc:ab2fc3e0eaaa708d4f579d33d914aafb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that translates the sources managed by <code>sourceMgr</code> to MLIR.  <a href="namespacemlir.html#ab2fc3e0eaaa708d4f579d33d914aafb4">More...</a><br /></td></tr>
<tr class="separator:ab2fc3e0eaaa708d4f579d33d914aafb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e66fd933b3c9e825ff92ccea2450120"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2e66fd933b3c9e825ff92ccea2450120">TranslateRawSourceMgrToMLIRFunction</a> = std::function&lt; <a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;(llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="separator:a2e66fd933b3c9e825ff92ccea2450120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7afe9f2206cbd31d4c274a8a496fcc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9e7afe9f2206cbd31d4c274a8a496fcc">TranslateStringRefToMLIRFunction</a> = std::function&lt; <a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;(llvm::StringRef, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="memdesc:a9e7afe9f2206cbd31d4c274a8a496fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that translates the given string to MLIR.  <a href="namespacemlir.html#a9e7afe9f2206cbd31d4c274a8a496fcc">More...</a><br /></td></tr>
<tr class="separator:a9e7afe9f2206cbd31d4c274a8a496fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f6096a57734eed0290d2ab34ad5e79"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a86f6096a57734eed0290d2ab34ad5e79">TranslateFromMLIRFunction</a> = std::function&lt; LogicalResult(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, llvm::raw_ostream &amp;output)&gt;</td></tr>
<tr class="memdesc:a86f6096a57734eed0290d2ab34ad5e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that translates MLIR to a different format and outputs the result to a stream.  <a href="namespacemlir.html#a86f6096a57734eed0290d2ab34ad5e79">More...</a><br /></td></tr>
<tr class="separator:a86f6096a57734eed0290d2ab34ad5e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a36971a2ce3497d801451c71cabd7f0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0a36971a2ce3497d801451c71cabd7f0">TranslateFunction</a> = std::function&lt; LogicalResult(const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;sourceMgr, llvm::raw_ostream &amp;output, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="memdesc:a0a36971a2ce3497d801451c71cabd7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that performs file-to-file translation involving MLIR.  <a href="namespacemlir.html#a0a36971a2ce3497d801451c71cabd7f0">More...</a><br /></td></tr>
<tr class="separator:a0a36971a2ce3497d801451c71cabd7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4308db4537fab4bd6031bf3ba2206525"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4308db4537fab4bd6031bf3ba2206525">DialectRegistrationFunction</a> = std::function&lt; void(<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a4308db4537fab4bd6031bf3ba2206525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that adds all dialects and dialect extensions used for the translation to the given <a class="el" href="classmlir_1_1DialectRegistry.html" title="The DialectRegistry maps a dialect namespace to a constructor for the matching dialect.">DialectRegistry</a>.  <a href="namespacemlir.html#a4308db4537fab4bd6031bf3ba2206525">More...</a><br /></td></tr>
<tr class="separator:a4308db4537fab4bd6031bf3ba2206525"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2c02a386e5ba59c4c88f83ac471f999d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> { <a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999da4bac8cdf0a968472b519b3b295d0d48b">NoChange</a>
, <a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999daf4ec5f57bd4d31b803312d873be40da9">Change</a>
 }</td></tr>
<tr class="memdesc:a2c02a386e5ba59c4c88f83ac471f999d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A result type used to indicate if a change happened.  <a href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">More...</a><br /></td></tr>
<tr class="separator:a2c02a386e5ba59c4c88f83ac471f999d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e07796c43d9bdf22c519ff44150daaf"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6e07796c43d9bdf22c519ff44150daaf">HoistingKind</a> : uint8_t { <a class="el" href="namespacemlir.html#a6e07796c43d9bdf22c519ff44150daafa6adf97f83acf6453d4a6a4b1070f3754">None</a> = 0
, <a class="el" href="namespacemlir.html#a6e07796c43d9bdf22c519ff44150daafa89d7b10cb4238977d2b523dfd9ea7745">Loop</a> = 1 &lt;&lt; 0
, <a class="el" href="namespacemlir.html#a6e07796c43d9bdf22c519ff44150daafae1e4c8c9ccd9fc39c391da4bcd093fb2">Block</a> = 1 &lt;&lt; 1
 }</td></tr>
<tr class="separator:a6e07796c43d9bdf22c519ff44150daaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781474aef998ccce168b69ae973cd832"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832">SparseParallelizationStrategy</a> { <br />
&#160;&#160;<a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832a35c3ace1970663a16e5c65baa5941b13">kNone</a>
, <a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832a09e4a3d1c3e70c9426528f102480e6e7">kDenseOuterLoop</a>
, <a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832afe3590ad05890d8754eef93504f9b7af">kAnyStorageOuterLoop</a>
, <a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832a0d7778373362fd80feddcb9b38a354b8">kDenseAnyLoop</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832a3b1257bf6747bc07f90c215e9aafd4a7">kAnyStorageAnyLoop</a>
<br />
 }</td></tr>
<tr class="memdesc:a781474aef998ccce168b69ae973cd832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a parallelization strategy.  <a href="namespacemlir.html#a781474aef998ccce168b69ae973cd832">More...</a><br /></td></tr>
<tr class="separator:a781474aef998ccce168b69ae973cd832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855a7d93430958efaaf3a6f69e3dac1c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a855a7d93430958efaaf3a6f69e3dac1c">ReinterpretMapScope</a> { <a class="el" href="namespacemlir.html#a855a7d93430958efaaf3a6f69e3dac1ca34bdbffdb1c0e1b603f58fc0d49548b6">kAll</a>
, <a class="el" href="namespacemlir.html#a855a7d93430958efaaf3a6f69e3dac1cafb396f5b35d10c817b375435e3432d4b">kGenericOnly</a>
, <a class="el" href="namespacemlir.html#a855a7d93430958efaaf3a6f69e3dac1ca301ae8b60ff2983a1038cc11eb53089b">kExceptGeneric</a>
 }</td></tr>
<tr class="memdesc:a855a7d93430958efaaf3a6f69e3dac1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a scope for reinterpret map pass.  <a href="namespacemlir.html#a855a7d93430958efaaf3a6f69e3dac1c">More...</a><br /></td></tr>
<tr class="separator:a855a7d93430958efaaf3a6f69e3dac1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f3feaa61d2ade78f26489cc92061c9"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a90f3feaa61d2ade78f26489cc92061c9">SparseEmitStrategy</a> { <a class="el" href="namespacemlir.html#a90f3feaa61d2ade78f26489cc92061c9a2396498c3d09ffee6d390b4dc4939025">kFunctional</a>
, <a class="el" href="namespacemlir.html#a90f3feaa61d2ade78f26489cc92061c9a6a8bfeffa090dea6b9365e13b07de8f5">kSparseIterator</a>
, <a class="el" href="namespacemlir.html#a90f3feaa61d2ade78f26489cc92061c9a1f8ee8266ac6831bf04f91a30d755554">kDebugInterface</a>
 }</td></tr>
<tr class="memdesc:a90f3feaa61d2ade78f26489cc92061c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a scope for reinterpret map pass.  <a href="namespacemlir.html#a90f3feaa61d2ade78f26489cc92061c9">More...</a><br /></td></tr>
<tr class="separator:a90f3feaa61d2ade78f26489cc92061c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399e164b35d18e1a77053d39719844de"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a399e164b35d18e1a77053d39719844de">SPIRVSubByteTypeStorage</a> { <a class="el" href="namespacemlir.html#a399e164b35d18e1a77053d39719844deaa1977c3f68d4d3bbfe14d0e51a575482">Packed</a>
 }</td></tr>
<tr class="memdesc:a399e164b35d18e1a77053d39719844de"><td class="mdescLeft">&#160;</td><td class="mdescRight">How sub-byte values are storaged in memory.  <a href="namespacemlir.html#a399e164b35d18e1a77053d39719844de">More...</a><br /></td></tr>
<tr class="separator:a399e164b35d18e1a77053d39719844de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade54ec9589eb0733abcaed08e634be01"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ade54ec9589eb0733abcaed08e634be01">ReshapeOpKind</a> { <a class="el" href="namespacemlir.html#ade54ec9589eb0733abcaed08e634be01a95e20eb827cd738ef3a2b9551135da09">kExpand</a>
, <a class="el" href="namespacemlir.html#ade54ec9589eb0733abcaed08e634be01a76fd6a1e50a2e2a0b5579d446b01a5da">kCollapse</a>
 }</td></tr>
<tr class="separator:ade54ec9589eb0733abcaed08e634be01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b49fcd2b613b6c30ffc13f35b8675c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a98b49fcd2b613b6c30ffc13f35b8675c">DeletionKind</a> { <a class="el" href="namespacemlir.html#a98b49fcd2b613b6c30ffc13f35b8675ca02bce93bff905887ad2233110bf9c49e">Keep</a>
, <a class="el" href="namespacemlir.html#a98b49fcd2b613b6c30ffc13f35b8675caf2a6c498fb90ee345d997f888fce3b18">Delete</a>
 }</td></tr>
<tr class="memdesc:a98b49fcd2b613b6c30ffc13f35b8675c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returned by operation promotion logic requesting the deletion of an operation.  <a href="namespacemlir.html#a98b49fcd2b613b6c30ffc13f35b8675c">More...</a><br /></td></tr>
<tr class="separator:a98b49fcd2b613b6c30ffc13f35b8675c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3b7fd763c24274db6c115579084133"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">AffineExprKind</a> { <br />
&#160;&#160;<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133aec211f7c20af43e742bf2570c3cb84f9">Add</a>
, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a62b6d55816cf737bfc6f42e60df1a3f2">Mul</a>
, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a7aeb0277500c86e4aa6bd23f9a737942">Mod</a>
, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133abaa422535e7ce48b442cc07089e64e7a">FloorDiv</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a30c212eb3184a5ed41f01a25c8124e8a">CeilDiv</a>
, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a4be6ccd8c4af006587a76a5fd3e7dc24">LAST_AFFINE_BINARY_OP</a> = CeilDiv
, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">Constant</a>
, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133ab49b848e4bb608f4d5650e4b2817c641">DimId</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133aea00d3c6059a4ff11d351696747fc7ff">SymbolId</a>
<br />
 }</td></tr>
<tr class="separator:a6d3b7fd763c24274db6c115579084133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84871bcca0aaa0176d43dbdbffe9a6c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac84871bcca0aaa0176d43dbdbffe9a6c">AsmResourceEntryKind</a> { <a class="el" href="namespacemlir.html#ac84871bcca0aaa0176d43dbdbffe9a6cae8016c85ada38bdc5fac616ec1318047">Blob</a>
, <a class="el" href="namespacemlir.html#ac84871bcca0aaa0176d43dbdbffe9a6cac26f15e86e3de4c398a8273272aba034">Bool</a>
, <a class="el" href="namespacemlir.html#ac84871bcca0aaa0176d43dbdbffe9a6ca27118326006d3829667a400ad23d5d98">String</a>
 }</td></tr>
<tr class="memdesc:ac84871bcca0aaa0176d43dbdbffe9a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enum represents the different kinds of resource values.  <a href="namespacemlir.html#ac84871bcca0aaa0176d43dbdbffe9a6c">More...</a><br /></td></tr>
<tr class="separator:ac84871bcca0aaa0176d43dbdbffe9a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11353e6611651b85531ad95629c57d75"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">SliceVerificationResult</a> { <br />
&#160;&#160;<a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a505a83f220c02df2f85c3810cd9ceb38">Success</a>
, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a780dd32ee9af184442cea3f2a2a75271">RankTooLarge</a>
, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a87c69361ccd090c9c844e19d08432a26">SizeMismatch</a>
, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a6341e1bfc09d56fa49bb1b9400459d8e">ElemTypeMismatch</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a36a2220daadd84aaba239b031cf4cd23">MemSpaceMismatch</a>
, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a36297823a9892f9936fba1805a1c52ca">LayoutMismatch</a>
<br />
 }</td></tr>
<tr class="memdesc:a11353e6611651b85531ad95629c57d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum that captures information related to verifier error conditions on slice insert/extract type of ops.  <a href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">More...</a><br /></td></tr>
<tr class="separator:a11353e6611651b85531ad95629c57d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247bc9a6d1f1577f2d876cb55e2ea752"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752">DiagnosticSeverity</a> { <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a3b0649c72650c313a357338dcdfb64ec">Note</a>
, <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a0eaadb4fcb48a0a0ed7bc9868be9fbaa">Warning</a>
, <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd">Error</a>
, <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a91921ada405fd6ba65dff028df047cb6">Remark</a>
 }</td></tr>
<tr class="memdesc:a247bc9a6d1f1577f2d876cb55e2ea752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the different supported severity of a diagnostic.  <a href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752">More...</a><br /></td></tr>
<tr class="separator:a247bc9a6d1f1577f2d876cb55e2ea752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb30aa1b062bf437bf3ea2b843a2ae1"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abeb30aa1b062bf437bf3ea2b843a2ae1">RegionKind</a> { <a class="el" href="namespacemlir.html#abeb30aa1b062bf437bf3ea2b843a2ae1abfd486e5c2cad6a0ba13ec4e1951815b">SSACFG</a>
, <a class="el" href="namespacemlir.html#abeb30aa1b062bf437bf3ea2b843a2ae1a4cdbd2bafa8193091ba09509cedf94fd">Graph</a>
 }</td></tr>
<tr class="memdesc:abeb30aa1b062bf437bf3ea2b843a2ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kinds of regions contained in an operation.  <a href="namespacemlir.html#abeb30aa1b062bf437bf3ea2b843a2ae1">More...</a><br /></td></tr>
<tr class="separator:abeb30aa1b062bf437bf3ea2b843a2ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fa9dd53c74f1ca73aa7ef263c94adc"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> { <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc">PreOrder</a>
, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163">PostOrder</a>
 }</td></tr>
<tr class="memdesc:a59fa9dd53c74f1ca73aa7ef263c94adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traversal order for region, block and operation walk utilities.  <a href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">More...</a><br /></td></tr>
<tr class="separator:a59fa9dd53c74f1ca73aa7ef263c94adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64460ede39d8480e398fd2e6810d95b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95b">PassDisplayMode</a> { <a class="el" href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95ba4ee29ca12c7d126654bd0e5275de6135">List</a>
, <a class="el" href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95baaeaeaec51b4e6b88122f10ad96a8de72">Pipeline</a>
 }</td></tr>
<tr class="memdesc:ab64460ede39d8480e398fd2e6810d95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum describing the different display modes for the information within the pass manager.  <a href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95b">More...</a><br /></td></tr>
<tr class="separator:ab64460ede39d8480e398fd2e6810d95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4d5a3d224089fd8a2ebc3e933d08b5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5">TraversalMode</a> { <a class="el" href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5ab8166871d66f03feaa6948b3f5727c96">SinglePath</a>
, <a class="el" href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5ad4f6ed581fb2f9d06c062711e30c13e1">Backtrack</a>
, <a class="el" href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5a9addc7d66f740728689b7f9abde66593">MultiPath</a>
 }</td></tr>
<tr class="memdesc:a9e4d5a3d224089fd8a2ebc3e933d08b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the traversal method options to be used in the reduction tree traversal.  <a href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5">More...</a><br /></td></tr>
<tr class="separator:a9e4d5a3d224089fd8a2ebc3e933d08b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb0dcd5ae75936e3c6f177223c9d5eb"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acbb0dcd5ae75936e3c6f177223c9d5eb">GreedyRewriteStrictness</a> { <a class="el" href="namespacemlir.html#acbb0dcd5ae75936e3c6f177223c9d5eba97d3def284d4e3d3bef99205c339fceb">AnyOp</a>
, <a class="el" href="namespacemlir.html#acbb0dcd5ae75936e3c6f177223c9d5eba8fc95fc7cfbd316cce7d887ab38f6120">ExistingAndNewOps</a>
, <a class="el" href="namespacemlir.html#acbb0dcd5ae75936e3c6f177223c9d5eba475f4ba4004dc37c3764009114b6e69b">ExistingOps</a>
 }</td></tr>
<tr class="memdesc:acbb0dcd5ae75936e3c6f177223c9d5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enum controls which ops are put on the worklist during a greedy pattern rewrite.  <a href="namespacemlir.html#acbb0dcd5ae75936e3c6f177223c9d5eb">More...</a><br /></td></tr>
<tr class="separator:acbb0dcd5ae75936e3c6f177223c9d5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aef2e1e7dac5cf18273429ca58e3f4f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2aef2e1e7dac5cf18273429ca58e3f4f">GreedySimplifyRegionLevel</a> { <a class="el" href="namespacemlir.html#a2aef2e1e7dac5cf18273429ca58e3f4fab9f5c797ebbf55adccdd8539a65a0241">Disabled</a>
, <a class="el" href="namespacemlir.html#a2aef2e1e7dac5cf18273429ca58e3f4fa960b44c579bc2f6818d2daaf9e4c16f0">Normal</a>
, <a class="el" href="namespacemlir.html#a2aef2e1e7dac5cf18273429ca58e3f4fa389a96d0d9b3feb46b8c9d941566a4ae">Aggressive</a>
 }</td></tr>
<tr class="separator:a2aef2e1e7dac5cf18273429ca58e3f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af8130946445de43cbbe975607457e51c"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af8130946445de43cbbe975607457e51c">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1AliasResult.html">AliasResult</a> &amp;result)</td></tr>
<tr class="separator:af8130946445de43cbbe975607457e51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8ea3e011d372d1f5b3bc1fb34e1286"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0e8ea3e011d372d1f5b3bc1fb34e1286">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1ModRefResult.html">ModRefResult</a> &amp;result)</td></tr>
<tr class="separator:a0e8ea3e011d372d1f5b3bc1fb34e1286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609ab9ceb7a2ad554864c86fc7ece4fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a609ab9ceb7a2ad554864c86fc7ece4fd">operator|</a> (<a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> lhs, <a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> rhs)</td></tr>
<tr class="separator:a609ab9ceb7a2ad554864c86fc7ece4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001ec055bf293748f02c00aff842dc38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a001ec055bf293748f02c00aff842dc38">operator|=</a> (<a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> &amp;lhs, <a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> rhs)</td></tr>
<tr class="separator:a001ec055bf293748f02c00aff842dc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5d450d84010aaf140c9cccddf00804"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4f5d450d84010aaf140c9cccddf00804">operator&amp;</a> (<a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> lhs, <a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> rhs)</td></tr>
<tr class="separator:a4f5d450d84010aaf140c9cccddf00804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90cebc5db982e1f7b1147c8c6595595"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa90cebc5db982e1f7b1147c8c6595595">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1AnalysisState.html">AnalysisState</a> &amp;state)</td></tr>
<tr class="separator:aa90cebc5db982e1f7b1147c8c6595595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b04ef5fe364cd0e2f086eb998894ca"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa0b04ef5fe364cd0e2f086eb998894ca">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="structmlir_1_1LatticeAnchor.html">LatticeAnchor</a> anchor)</td></tr>
<tr class="separator:aa0b04ef5fe364cd0e2f086eb998894ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e1219853f339da1b9caa57a9503c5c"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac0e1219853f339da1b9caa57a9503c5c">getFlattenedAffineExpr</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, unsigned numDims, unsigned numSymbols, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *flattenedExpr, <a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a> *cst=nullptr, bool addConservativeSemiAffineBounds=false)</td></tr>
<tr class="memdesc:ac0e1219853f339da1b9caa57a9503c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens 'expr' into 'flattenedExpr', which contains the coefficients of the dimensions, symbols, and additional variables that represent floor divisions of dimensions, symbols, and in turn other floor divisions.  <a href="namespacemlir.html#ac0e1219853f339da1b9caa57a9503c5c">More...</a><br /></td></tr>
<tr class="separator:ac0e1219853f339da1b9caa57a9503c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9cccd81f500fe900e2a7d3e68c7c84f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac9cccd81f500fe900e2a7d3e68c7c84f">getFlattenedAffineExprs</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *flattenedExprs, <a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a> *cst=nullptr, bool addConservativeSemiAffineBounds=false)</td></tr>
<tr class="memdesc:ac9cccd81f500fe900e2a7d3e68c7c84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens the result expressions of the map to their corresponding flattened forms and set in 'flattenedExprs'.  <a href="namespacemlir.html#ac9cccd81f500fe900e2a7d3e68c7c84f">More...</a><br /></td></tr>
<tr class="separator:ac9cccd81f500fe900e2a7d3e68c7c84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d3ec2b375b73649766ce133c49aa1e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a99d3ec2b375b73649766ce133c49aa1e">getFlattenedAffineExprs</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *flattenedExprs, <a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a> *cst=nullptr)</td></tr>
<tr class="separator:a99d3ec2b375b73649766ce133c49aa1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb248e9fd529c9528e4e235a52941e67"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeb248e9fd529c9528e4e235a52941e67">getMultiAffineFunctionFromMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1presburger_1_1MultiAffineFunction.html">presburger::MultiAffineFunction</a> &amp;multiAff)</td></tr>
<tr class="separator:aeb248e9fd529c9528e4e235a52941e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcc9dc786aa8f64a60f1d51cdad3361"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5bcc9dc786aa8f64a60f1d51cdad3361">alignAffineMapWithValues</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> dims, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> syms, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *newSyms=nullptr)</td></tr>
<tr class="memdesc:a5bcc9dc786aa8f64a60f1d51cdad3361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-indexes the dimensions and symbols of an affine map with given <code>operands</code> values to align with <code>dims</code> and <code>syms</code> values.  <a href="namespacemlir.html#a5bcc9dc786aa8f64a60f1d51cdad3361">More...</a><br /></td></tr>
<tr class="separator:a5bcc9dc786aa8f64a60f1d51cdad3361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffe695e75923a7c364bceee778826a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afffe695e75923a7c364bceee778826a9">getForwardSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *forwardSlice, const <a class="el" href="namespacemlir.html#a5bbb33912ce41da593598188d8bcc13a">ForwardSliceOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>={})</td></tr>
<tr class="memdesc:afffe695e75923a7c364bceee778826a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills <code>forwardSlice</code> with the computed forward slice (i.e.  <a href="namespacemlir.html#afffe695e75923a7c364bceee778826a9">More...</a><br /></td></tr>
<tr class="separator:afffe695e75923a7c364bceee778826a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d503b65f87b6cab0452ff97122cbff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a54d503b65f87b6cab0452ff97122cbff">getForwardSlice</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> root, <a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *forwardSlice, const <a class="el" href="namespacemlir.html#a5bbb33912ce41da593598188d8bcc13a">ForwardSliceOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>={})</td></tr>
<tr class="memdesc:a54d503b65f87b6cab0452ff97122cbff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value-rooted version of <code>getForwardSlice</code>.  <a href="namespacemlir.html#a54d503b65f87b6cab0452ff97122cbff">More...</a><br /></td></tr>
<tr class="separator:a54d503b65f87b6cab0452ff97122cbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4984b71591e73aa40a13f020a3547233"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4984b71591e73aa40a13f020a3547233">getBackwardSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *backwardSlice, const <a class="el" href="structmlir_1_1BackwardSliceOptions.html">BackwardSliceOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>={})</td></tr>
<tr class="memdesc:a4984b71591e73aa40a13f020a3547233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills <code>backwardSlice</code> with the computed backward slice (i.e.  <a href="namespacemlir.html#a4984b71591e73aa40a13f020a3547233">More...</a><br /></td></tr>
<tr class="separator:a4984b71591e73aa40a13f020a3547233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7584eb4e9bf1c3d0b146ff37bca2da90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7584eb4e9bf1c3d0b146ff37bca2da90">getBackwardSlice</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> root, <a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *backwardSlice, const <a class="el" href="structmlir_1_1BackwardSliceOptions.html">BackwardSliceOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>={})</td></tr>
<tr class="memdesc:a7584eb4e9bf1c3d0b146ff37bca2da90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value-rooted version of <code>getBackwardSlice</code>.  <a href="namespacemlir.html#a7584eb4e9bf1c3d0b146ff37bca2da90">More...</a><br /></td></tr>
<tr class="separator:a7584eb4e9bf1c3d0b146ff37bca2da90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9f91ff576a4cb961289ea2f9e3dd0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acd9f91ff576a4cb961289ea2f9e3dd0f">getSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="structmlir_1_1BackwardSliceOptions.html">BackwardSliceOptions</a> &amp;backwardSliceOptions={}, const <a class="el" href="namespacemlir.html#a5bbb33912ce41da593598188d8bcc13a">ForwardSliceOptions</a> &amp;forwardSliceOptions={})</td></tr>
<tr class="memdesc:acd9f91ff576a4cb961289ea2f9e3dd0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratively computes backward slices and forward slices until a fixed point is reached.  <a href="namespacemlir.html#acd9f91ff576a4cb961289ea2f9e3dd0f">More...</a><br /></td></tr>
<tr class="separator:acd9f91ff576a4cb961289ea2f9e3dd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc751bc8f30d71ad4cb771c0fcc788b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6bc751bc8f30d71ad4cb771c0fcc788b">matchReduction</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt; iterCarriedArgs, unsigned redPos, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;combinerOps)</td></tr>
<tr class="memdesc:a6bc751bc8f30d71ad4cb771c0fcc788b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to match a generic reduction given a list of iteration-carried arguments, <code>iterCarriedArgs</code> and the position of the potential reduction argument within the list, <code>redPos</code>.  <a href="namespacemlir.html#a6bc751bc8f30d71ad4cb771c0fcc788b">More...</a><br /></td></tr>
<tr class="separator:a6bc751bc8f30d71ad4cb771c0fcc788b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bf64684e4364416fb8d648c251d41b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1WalkContinuation.html">WalkContinuation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a95bf64684e4364416fb8d648c251d41b">walkSlice</a> (<a class="el" href="classmlir_1_1ValueRange.html">mlir::ValueRange</a> rootValues, <a class="el" href="namespacemlir.html#afb40c25041db8d506e4b23fb8c86d5c6">WalkCallback</a> walkCallback)</td></tr>
<tr class="memdesc:a95bf64684e4364416fb8d648c251d41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walks the slice starting from the <code>rootValues</code> using a depth-first traversal.  <a href="namespacemlir.html#a95bf64684e4364416fb8d648c251d41b">More...</a><br /></td></tr>
<tr class="separator:a95bf64684e4364416fb8d648c251d41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b466301e036ddc2e72c55838139324"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a20b466301e036ddc2e72c55838139324">getControlFlowPredecessors</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a20b466301e036ddc2e72c55838139324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a vector of all control predecessors of <code>value</code>.  <a href="namespacemlir.html#a20b466301e036ddc2e72c55838139324">More...</a><br /></td></tr>
<tr class="separator:a20b466301e036ddc2e72c55838139324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb95f9dc749d6a604340f83fd16b19f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adb95f9dc749d6a604340f83fd16b19f9">sortTopologically</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> &gt; ops, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; isOperandReady=nullptr)</td></tr>
<tr class="memdesc:adb95f9dc749d6a604340f83fd16b19f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a block, sort a range operations in said block in topological order.  <a href="namespacemlir.html#adb95f9dc749d6a604340f83fd16b19f9">More...</a><br /></td></tr>
<tr class="separator:adb95f9dc749d6a604340f83fd16b19f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35009cf90a73229f64f9090d4e5aa2b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a35009cf90a73229f64f9090d4e5aa2b7">sortTopologically</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; isOperandReady=nullptr)</td></tr>
<tr class="memdesc:a35009cf90a73229f64f9090d4e5aa2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a block, sort its operations in topological order, excluding its terminator if it has one.  <a href="namespacemlir.html#a35009cf90a73229f64f9090d4e5aa2b7">More...</a><br /></td></tr>
<tr class="separator:a35009cf90a73229f64f9090d4e5aa2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28129a93d39ade2d40077f25a09eb389"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a28129a93d39ade2d40077f25a09eb389">computeTopologicalSorting</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; ops, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; isOperandReady=nullptr)</td></tr>
<tr class="memdesc:a28129a93d39ade2d40077f25a09eb389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a topological ordering of the given ops.  <a href="namespacemlir.html#a28129a93d39ade2d40077f25a09eb389">More...</a><br /></td></tr>
<tr class="separator:a28129a93d39ade2d40077f25a09eb389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee8e54b17fecc4eaad55779facd0068"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1ee8e54b17fecc4eaad55779facd0068">getBlocksSortedByDominance</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:a1ee8e54b17fecc4eaad55779facd0068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a list of blocks that is sorted according to dominance.  <a href="namespacemlir.html#a1ee8e54b17fecc4eaad55779facd0068">More...</a><br /></td></tr>
<tr class="separator:a1ee8e54b17fecc4eaad55779facd0068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb30909b4006046e7b4248b8d5a5a26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afbb30909b4006046e7b4248b8d5a5a26">topologicalSort</a> (const <a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;toSort)</td></tr>
<tr class="memdesc:afbb30909b4006046e7b4248b8d5a5a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts all operations in <code>toSort</code> topologically while also considering region semantics.  <a href="namespacemlir.html#afbb30909b4006046e7b4248b8d5a5a26">More...</a><br /></td></tr>
<tr class="separator:afbb30909b4006046e7b4248b8d5a5a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce4d766139754b57d04b314aefacea5"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2ce4d766139754b57d04b314aefacea5">parseAsmSourceFile</a> (const llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config, <a class="el" href="classmlir_1_1AsmParserState.html">AsmParserState</a> *asmState=nullptr, <a class="el" href="classmlir_1_1AsmParserCodeCompleteContext.html">AsmParserCodeCompleteContext</a> *codeCompleteContext=nullptr)</td></tr>
<tr class="memdesc:a2ce4d766139754b57d04b314aefacea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated SourceMgr and appends parsed operations to the given block.  <a href="namespacemlir.html#a2ce4d766139754b57d04b314aefacea5">More...</a><br /></td></tr>
<tr class="separator:a2ce4d766139754b57d04b314aefacea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6658f887276425945e0ebe6fcc194c23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6658f887276425945e0ebe6fcc194c23">parseAttribute</a> (llvm::StringRef attrStr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1Type.html">Type</a> type={}, size_t *numRead=nullptr, bool isKnownNullTerminated=false)</td></tr>
<tr class="memdesc:a6658f887276425945e0ebe6fcc194c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses a single MLIR attribute to an MLIR context if it was valid.  <a href="namespacemlir.html#a6658f887276425945e0ebe6fcc194c23">More...</a><br /></td></tr>
<tr class="separator:a6658f887276425945e0ebe6fcc194c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab8375de28e1d1916659a658e7ad318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abab8375de28e1d1916659a658e7ad318">parseType</a> (llvm::StringRef typeStr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, size_t *numRead=nullptr, bool isKnownNullTerminated=false)</td></tr>
<tr class="memdesc:abab8375de28e1d1916659a658e7ad318"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses a single MLIR type to an MLIR context if it was valid.  <a href="namespacemlir.html#abab8375de28e1d1916659a658e7ad318">More...</a><br /></td></tr>
<tr class="separator:abab8375de28e1d1916659a658e7ad318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351183b9c1036310349dea952c1f2d5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a351183b9c1036310349dea952c1f2d5a">parseAffineMap</a> (llvm::StringRef str, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a351183b9c1036310349dea952c1f2d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses a single IntegerSet/AffineMap to an MLIR context if it was valid.  <a href="namespacemlir.html#a351183b9c1036310349dea952c1f2d5a">More...</a><br /></td></tr>
<tr class="separator:a351183b9c1036310349dea952c1f2d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda383f3d69ddb866ea67abc7ba9e75e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acda383f3d69ddb866ea67abc7ba9e75e">parseIntegerSet</a> (llvm::StringRef str, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="separator:acda383f3d69ddb866ea67abc7ba9e75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef4c7804d8356c0813ce04f87b2b1ff"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a2ef4c7804d8356c0813ce04f87b2b1ff"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2ef4c7804d8356c0813ce04f87b2b1ff">readResourceHandle</a> (<a class="el" href="classmlir_1_1DialectBytecodeReader.html">DialectBytecodeReader</a> &amp;reader, FailureOr&lt; T &gt; &amp;value, Ts &amp;&amp;...params)</td></tr>
<tr class="memdesc:a2ef4c7804d8356c0813ce04f87b2b1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for resource handle reading that returns LogicalResult.  <a href="namespacemlir.html#a2ef4c7804d8356c0813ce04f87b2b1ff">More...</a><br /></td></tr>
<tr class="separator:a2ef4c7804d8356c0813ce04f87b2b1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4871db68c59a176135e0e35a3625e73"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:ab4871db68c59a176135e0e35a3625e73"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab4871db68c59a176135e0e35a3625e73">get</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, Ts &amp;&amp;...params)</td></tr>
<tr class="memdesc:ab4871db68c59a176135e0e35a3625e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method that injects context only if needed, this helps unify some of the attribute construction methods.  <a href="namespacemlir.html#ab4871db68c59a176135e0e35a3625e73">More...</a><br /></td></tr>
<tr class="separator:ab4871db68c59a176135e0e35a3625e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336eaa1f1417cbe1468e56b34ce866a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a336eaa1f1417cbe1468e56b34ce866a1">isBytecode</a> (llvm::MemoryBufferRef buffer)</td></tr>
<tr class="memdesc:a336eaa1f1417cbe1468e56b34ce866a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given buffer starts with the magic bytes that signal MLIR bytecode.  <a href="namespacemlir.html#a336eaa1f1417cbe1468e56b34ce866a1">More...</a><br /></td></tr>
<tr class="separator:a336eaa1f1417cbe1468e56b34ce866a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b71d67f0d7fe035e455a121e826f08"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad3b71d67f0d7fe035e455a121e826f08">readBytecodeFile</a> (llvm::MemoryBufferRef buffer, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config)</td></tr>
<tr class="memdesc:ad3b71d67f0d7fe035e455a121e826f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the operations defined within the given memory buffer, containing MLIR bytecode, into the provided block.  <a href="namespacemlir.html#ad3b71d67f0d7fe035e455a121e826f08">More...</a><br /></td></tr>
<tr class="separator:ad3b71d67f0d7fe035e455a121e826f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98f1102c5f82e37f4e4cf21be1736f8"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af98f1102c5f82e37f4e4cf21be1736f8">readBytecodeFile</a> (const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;sourceMgr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config)</td></tr>
<tr class="memdesc:af98f1102c5f82e37f4e4cf21be1736f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload with a source manager whose main file buffer is used for parsing.  <a href="namespacemlir.html#af98f1102c5f82e37f4e4cf21be1736f8">More...</a><br /></td></tr>
<tr class="separator:af98f1102c5f82e37f4e4cf21be1736f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17b909cf0c32c717226432e6a65f61e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae17b909cf0c32c717226432e6a65f61e">writeBytecodeToFile</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, raw_ostream &amp;os, const <a class="el" href="classmlir_1_1BytecodeWriterConfig.html">BytecodeWriterConfig</a> &amp;config={})</td></tr>
<tr class="memdesc:ae17b909cf0c32c717226432e6a65f61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the bytecode for the given operation to the provided output stream.  <a href="namespacemlir.html#ae17b909cf0c32c717226432e6a65f61e">More...</a><br /></td></tr>
<tr class="separator:ae17b909cf0c32c717226432e6a65f61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7856a3b7ff811204524bbc9959c8c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aee7856a3b7ff811204524bbc9959c8c9">populateAffineToStdConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aee7856a3b7ff811204524bbc9959c8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the Affine dialect to the Standard dialect, in particular convert structured affine control flow into CFG branch-based control flow.  <a href="namespacemlir.html#aee7856a3b7ff811204524bbc9959c8c9">More...</a><br /></td></tr>
<tr class="separator:aee7856a3b7ff811204524bbc9959c8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a984b6da6b0bf690f727bd2e20dd31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad6a984b6da6b0bf690f727bd2e20dd31">populateAffineToVectorConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ad6a984b6da6b0bf690f727bd2e20dd31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert vector-related Affine ops to the <a class="el" href="structVector.html">Vector</a> dialect.  <a href="namespacemlir.html#ad6a984b6da6b0bf690f727bd2e20dd31">More...</a><br /></td></tr>
<tr class="separator:ad6a984b6da6b0bf690f727bd2e20dd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4cd463c8738400fd147e2f040e89948"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af4cd463c8738400fd147e2f040e89948">lowerAffineLowerBound</a> (affine::AffineForOp op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:af4cd463c8738400fd147e2f040e89948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that computes the lower bound of the given affine loop using standard arithmetic operations.  <a href="namespacemlir.html#af4cd463c8738400fd147e2f040e89948">More...</a><br /></td></tr>
<tr class="separator:af4cd463c8738400fd147e2f040e89948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b670d3c5d9075cd52ef9d183168708"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a59b670d3c5d9075cd52ef9d183168708">lowerAffineUpperBound</a> (affine::AffineForOp op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:a59b670d3c5d9075cd52ef9d183168708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that computes the upper bound of the given affine loop using standard arithmetic operations.  <a href="namespacemlir.html#a59b670d3c5d9075cd52ef9d183168708">More...</a><br /></td></tr>
<tr class="separator:a59b670d3c5d9075cd52ef9d183168708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09ce34232ab009ce688d7cdc63695a8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae09ce34232ab009ce688d7cdc63695a8">createLowerAffinePass</a> ()</td></tr>
<tr class="memdesc:ae09ce34232ab009ce688d7cdc63695a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowers affine control flow operations (ForStmt, IfStmt and AffineApplyOp) to equivalent lower-level constructs (flow of basic blocks and arithmetic primitives).  <a href="namespacemlir.html#ae09ce34232ab009ce688d7cdc63695a8">More...</a><br /></td></tr>
<tr class="separator:ae09ce34232ab009ce688d7cdc63695a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a3e582e3af3713bff9b27e6a924cf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a62a3e582e3af3713bff9b27e6a924cf3">populateAMDGPUToROCDLConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="structmlir_1_1amdgpu_1_1Chipset.html">amdgpu::Chipset</a> chipset)</td></tr>
<tr class="memdesc:a62a3e582e3af3713bff9b27e6a924cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note: The <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> target does not support the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> bfloat type at this time and so this function will add conversions to change all <code>bfloat</code> uses to <code>i16</code>.  <a href="namespacemlir.html#a62a3e582e3af3713bff9b27e6a924cf3">More...</a><br /></td></tr>
<tr class="separator:a62a3e582e3af3713bff9b27e6a924cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1b32f0e812af513c57185c972dc0ae"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4e1b32f0e812af513c57185c972dc0ae">createConvertAMDGPUToROCDLPass</a> ()</td></tr>
<tr class="separator:a4e1b32f0e812af513c57185c972dc0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc52e1e0b9c1d604f07abeb1c33cd6eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adc52e1e0b9c1d604f07abeb1c33cd6eb">populateArithToEmitCPatterns</a> (<a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:adc52e1e0b9c1d604f07abeb1c33cd6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f6113274b77800e7c3b22dd83771e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a45f6113274b77800e7c3b22dd83771e0">populateConvertArmNeon2dToIntrPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a45f6113274b77800e7c3b22dd83771e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns for the lowering of Arm NEON 2D ops to intrinsics.  <a href="namespacemlir.html#a45f6113274b77800e7c3b22dd83771e0">More...</a><br /></td></tr>
<tr class="separator:a45f6113274b77800e7c3b22dd83771e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4655b459042808cdaf22b54faf67aaf6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4655b459042808cdaf22b54faf67aaf6">createConvertArmNeon2dToIntrPass</a> ()</td></tr>
<tr class="memdesc:a4655b459042808cdaf22b54faf67aaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to lower Arm NEON 2D ops to intrinsics, i.e.  <a href="namespacemlir.html#a4655b459042808cdaf22b54faf67aaf6">More...</a><br /></td></tr>
<tr class="separator:a4655b459042808cdaf22b54faf67aaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d03e883b6465225cf16db9093a723a4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0d03e883b6465225cf16db9093a723a4">createConvertArmSMEToLLVMPass</a> (bool dumpTileLiveRanges=false)</td></tr>
<tr class="memdesc:a0d03e883b6465225cf16db9093a723a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert from the ArmSME dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <a href="namespacemlir.html#a0d03e883b6465225cf16db9093a723a4">More...</a><br /></td></tr>
<tr class="separator:a0d03e883b6465225cf16db9093a723a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fc9cf7db1e6fcc78850ac4ab89742c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac5fc9cf7db1e6fcc78850ac4ab89742c">configureArmSMEToLLVMConversionLegality</a> (<a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:ac5fc9cf7db1e6fcc78850ac4ab89742c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure target to convert from the ArmSME dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <a href="namespacemlir.html#ac5fc9cf7db1e6fcc78850ac4ab89742c">More...</a><br /></td></tr>
<tr class="separator:ac5fc9cf7db1e6fcc78850ac4ab89742c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2a83e0a6a467d1838b6dd39f65fb6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afe2a83e0a6a467d1838b6dd39f65fb6d">populateArmSMEToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:afe2a83e0a6a467d1838b6dd39f65fb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from the ArmSME dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <a href="namespacemlir.html#afe2a83e0a6a467d1838b6dd39f65fb6d">More...</a><br /></td></tr>
<tr class="separator:afe2a83e0a6a467d1838b6dd39f65fb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726da53640cac549a26c8eb0396fb0e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a726da53640cac549a26c8eb0396fb0e6">populateArmSMEToSCFConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a726da53640cac549a26c8eb0396fb0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the ArmSME dialect to SCF.  <a href="namespacemlir.html#a726da53640cac549a26c8eb0396fb0e6">More...</a><br /></td></tr>
<tr class="separator:a726da53640cac549a26c8eb0396fb0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09aec6549507dfd07b98e4afb14e7c5e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a09aec6549507dfd07b98e4afb14e7c5e">createConvertArmSMEToSCFPass</a> ()</td></tr>
<tr class="memdesc:a09aec6549507dfd07b98e4afb14e7c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert a subset of ArmSME ops to SCF.  <a href="namespacemlir.html#a09aec6549507dfd07b98e4afb14e7c5e">More...</a><br /></td></tr>
<tr class="separator:a09aec6549507dfd07b98e4afb14e7c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9659670212051d0795efd99cf38772ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9659670212051d0795efd99cf38772ed">populateAsyncStructuralTypeConversionsAndLegality</a> (<a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a9659670212051d0795efd99cf38772ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns for async structural type conversions.  <a href="namespacemlir.html#a9659670212051d0795efd99cf38772ed">More...</a><br /></td></tr>
<tr class="separator:a9659670212051d0795efd99cf38772ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01b05ed73bc512e7ae40bc6d37ae1a0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae01b05ed73bc512e7ae40bc6d37ae1a0">createBufferizationToMemRefPass</a> ()</td></tr>
<tr class="separator:ae01b05ed73bc512e7ae40bc6d37ae1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af655a0b587c08462a963b23b6c656ca5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af655a0b587c08462a963b23b6c656ca5">populateComplexToLibmConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit)</td></tr>
<tr class="memdesc:af655a0b587c08462a963b23b6c656ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Complex to Libm calls.  <a href="namespacemlir.html#af655a0b587c08462a963b23b6c656ca5">More...</a><br /></td></tr>
<tr class="separator:af655a0b587c08462a963b23b6c656ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3204f9ba36eb541a03f8bf0ed4a9a7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1c3204f9ba36eb541a03f8bf0ed4a9a7">createConvertComplexToLibmPass</a> ()</td></tr>
<tr class="memdesc:a1c3204f9ba36eb541a03f8bf0ed4a9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Complex operations to libm calls.  <a href="namespacemlir.html#a1c3204f9ba36eb541a03f8bf0ed4a9a7">More...</a><br /></td></tr>
<tr class="separator:a1c3204f9ba36eb541a03f8bf0ed4a9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48ef5a36418902001d584219b110c25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab48ef5a36418902001d584219b110c25">populateComplexToLLVMConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ab48ef5a36418902001d584219b110c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Complex to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="namespacemlir.html#ab48ef5a36418902001d584219b110c25">More...</a><br /></td></tr>
<tr class="separator:ab48ef5a36418902001d584219b110c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e3131ae05feac332799cb2de81be2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a92e3131ae05feac332799cb2de81be2f">registerConvertComplexToLLVMInterface</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a92e3131ae05feac332799cb2de81be2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59f15aca5e1be49c639ee5b12e611f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac59f15aca5e1be49c639ee5b12e611f2">populateComplexToSPIRVPatterns</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ac59f15aca5e1be49c639ee5b12e611f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating Complex ops to SPIR-V ops.  <a href="namespacemlir.html#ac59f15aca5e1be49c639ee5b12e611f2">More...</a><br /></td></tr>
<tr class="separator:ac59f15aca5e1be49c639ee5b12e611f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09be0ab6e12c19fefea09a6cb423c54d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a09be0ab6e12c19fefea09a6cb423c54d">populateComplexToStandardConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a09be0ab6e12c19fefea09a6cb423c54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Complex to Standard.  <a href="namespacemlir.html#a09be0ab6e12c19fefea09a6cb423c54d">More...</a><br /></td></tr>
<tr class="separator:a09be0ab6e12c19fefea09a6cb423c54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad891730d98fe42a400b188049ff923f2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad891730d98fe42a400b188049ff923f2">createConvertComplexToStandardPass</a> ()</td></tr>
<tr class="memdesc:ad891730d98fe42a400b188049ff923f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Complex operations to the Standard dialect.  <a href="namespacemlir.html#ad891730d98fe42a400b188049ff923f2">More...</a><br /></td></tr>
<tr class="separator:ad891730d98fe42a400b188049ff923f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0b6795b3be074dc19b6445f2cc687a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3d0b6795b3be074dc19b6445f2cc687a">createConvertControlFlowToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a3d0b6795b3be074dc19b6445f2cc687a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert ControlFlow ops to SPIR-V ops.  <a href="namespacemlir.html#a3d0b6795b3be074dc19b6445f2cc687a">More...</a><br /></td></tr>
<tr class="separator:a3d0b6795b3be074dc19b6445f2cc687a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd3c63a12bd65ca2208a6353dbc9186"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1bd3c63a12bd65ca2208a6353dbc9186">populateConversionTargetFromOperation</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a1bd3c63a12bd65ca2208a6353dbc9186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively walk the IR and collect all dialects implementing the interface, and populate the conversion patterns.  <a href="namespacemlir.html#a1bd3c63a12bd65ca2208a6353dbc9186">More...</a><br /></td></tr>
<tr class="separator:a1bd3c63a12bd65ca2208a6353dbc9186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586ff454b60cac278bed38d19b5cbdb2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a586ff454b60cac278bed38d19b5cbdb2">createConvertToLLVMPass</a> ()</td></tr>
<tr class="memdesc:a586ff454b60cac278bed38d19b5cbdb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that performs dialect conversion to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> for all dialects implementing <code><a class="el" href="classmlir_1_1ConvertToLLVMPatternInterface.html" title="Base class for dialect interfaces providing translation to LLVM IR.">ConvertToLLVMPatternInterface</a></code>.  <a href="namespacemlir.html#a586ff454b60cac278bed38d19b5cbdb2">More...</a><br /></td></tr>
<tr class="separator:a586ff454b60cac278bed38d19b5cbdb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1cfd257150164208f96531454b4d59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8a1cfd257150164208f96531454b4d59">registerConvertToLLVMDependentDialectLoading</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a8a1cfd257150164208f96531454b4d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the extension that will load dependent dialects for <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> conversion.  <a href="namespacemlir.html#a8a1cfd257150164208f96531454b4d59">More...</a><br /></td></tr>
<tr class="separator:a8a1cfd257150164208f96531454b4d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51559adfe7e07f3de36209e85d8d035d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a51559adfe7e07f3de36209e85d8d035d">populateFuncToEmitCPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a51559adfe7e07f3de36209e85d8d035d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab178e3da97c296703d0ae8f56436f802"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; LLVM::LLVMFuncOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab178e3da97c296703d0ae8f56436f802">convertFuncOpToLLVMFuncOp</a> (FunctionOpInterface funcOp, <a class="el" href="classmlir_1_1ConversionPatternRewriter.html">ConversionPatternRewriter</a> &amp;rewriter, const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter)</td></tr>
<tr class="memdesc:ab178e3da97c296703d0ae8f56436f802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert input FunctionOpInterface operation to LLVMFuncOp by using the provided <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a>.  <a href="namespacemlir.html#ab178e3da97c296703d0ae8f56436f802">More...</a><br /></td></tr>
<tr class="separator:ab178e3da97c296703d0ae8f56436f802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbd8e05d2cb08371e1749e025f1eb8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2fbd8e05d2cb08371e1749e025f1eb8a">populateFuncToLLVMFuncOpConversionPattern</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a2fbd8e05d2cb08371e1749e025f1eb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the default pattern to convert a FuncOp to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <a href="namespacemlir.html#a2fbd8e05d2cb08371e1749e025f1eb8a">More...</a><br /></td></tr>
<tr class="separator:a2fbd8e05d2cb08371e1749e025f1eb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28dd26d18b33cefbf959b5e703a5a7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad28dd26d18b33cefbf959b5e703a5a7e">populateFuncToLLVMConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="classmlir_1_1SymbolTable.html">SymbolTable</a> *symbolTable=nullptr)</td></tr>
<tr class="memdesc:ad28dd26d18b33cefbf959b5e703a5a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the patterns to convert from the Func dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="namespacemlir.html#ad28dd26d18b33cefbf959b5e703a5a7e">More...</a><br /></td></tr>
<tr class="separator:ad28dd26d18b33cefbf959b5e703a5a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd7b1431f65dc7d952407a7e062e63f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4cd7b1431f65dc7d952407a7e062e63f">registerConvertFuncToLLVMInterface</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a4cd7b1431f65dc7d952407a7e062e63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bf9368c68fc8006128f4ff2f1c5001"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a62bf9368c68fc8006128f4ff2f1c5001">populateFuncToSPIRVPatterns</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a62bf9368c68fc8006128f4ff2f1c5001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating Func ops to SPIR-V ops.  <a href="namespacemlir.html#a62bf9368c68fc8006128f4ff2f1c5001">More...</a><br /></td></tr>
<tr class="separator:a62bf9368c68fc8006128f4ff2f1c5001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1face754eadd25641ccf594efd52ba7b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1face754eadd25641ccf594efd52ba7b">createConvertFuncToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a1face754eadd25641ccf594efd52ba7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert Func ops to SPIR-V ops.  <a href="namespacemlir.html#a1face754eadd25641ccf594efd52ba7b">More...</a><br /></td></tr>
<tr class="separator:a1face754eadd25641ccf594efd52ba7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a6eaafe741bc1b5aaef4e3e188e868"><td class="memItemLeft" align="right" valign="top">spirv::StorageClass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a51a6eaafe741bc1b5aaef4e3e188e868">addressSpaceToStorageClass</a> (gpu::AddressSpace addressSpace)</td></tr>
<tr class="separator:a51a6eaafe741bc1b5aaef4e3e188e868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64e765657131fd8d2a82f34f3ffcda7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae64e765657131fd8d2a82f34f3ffcda7">populateGpuToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool kernelBarePtrCallConv=false)</td></tr>
<tr class="memdesc:ae64e765657131fd8d2a82f34f3ffcda7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> and populate converter for gpu types.  <a href="namespacemlir.html#ae64e765657131fd8d2a82f34f3ffcda7">More...</a><br /></td></tr>
<tr class="separator:ae64e765657131fd8d2a82f34f3ffcda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a64af4be39c0a24e5cf7dd18d7f619f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9a64af4be39c0a24e5cf7dd18d7f619f">populateGpuMemorySpaceAttributeConversions</a> (<a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, const <a class="el" href="namespacemlir.html#a2cc8d74e74ce84649cf5ee6135cd09a4">MemorySpaceMapping</a> &amp;mapping)</td></tr>
<tr class="memdesc:a9a64af4be39c0a24e5cf7dd18d7f619f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates memory space attribute conversion rules for lowering gpu.address_space to integer values.  <a href="namespacemlir.html#a9a64af4be39c0a24e5cf7dd18d7f619f">More...</a><br /></td></tr>
<tr class="separator:a9a64af4be39c0a24e5cf7dd18d7f619f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d3286013eff75a1bf8168b7f569308"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a15d3286013eff75a1bf8168b7f569308">populateGpuToLLVMSPVConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a15d3286013eff75a1bf8168b7f569308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07982150babf881946ef966e4d7842e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a07982150babf881946ef966e4d7842e0">populateGpuMemorySpaceAttributeConversions</a> (<a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter)</td></tr>
<tr class="memdesc:a07982150babf881946ef966e4d7842e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates memory space attribute conversion rules for lowering gpu.address_space to integer values.  <a href="namespacemlir.html#a07982150babf881946ef966e4d7842e0">More...</a><br /></td></tr>
<tr class="separator:a07982150babf881946ef966e4d7842e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23560b6de94f046854c32398b275f8b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVM::LLVMStructType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a23560b6de94f046854c32398b275f8b6">convertMMAToLLVMType</a> (<a class="el" href="classmlir_1_1gpu_1_1MMAMatrixType.html">gpu::MMAMatrixType</a> type)</td></tr>
<tr class="memdesc:a23560b6de94f046854c32398b275f8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the LLVMStructureType corresponding to the MMAMatrixType <code>type</code>.  <a href="namespacemlir.html#a23560b6de94f046854c32398b275f8b6">More...</a><br /></td></tr>
<tr class="separator:a23560b6de94f046854c32398b275f8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa896c9229c786edc4a7970b960b208"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7fa896c9229c786edc4a7970b960b208">configureGpuToNVVMConversionLegality</a> (<a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a7fa896c9229c786edc4a7970b960b208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure target to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>.  <a href="namespacemlir.html#a7fa896c9229c786edc4a7970b960b208">More...</a><br /></td></tr>
<tr class="separator:a7fa896c9229c786edc4a7970b960b208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1473896b49605a762f57d5c23466bca5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1473896b49605a762f57d5c23466bca5">populateGpuToNVVMConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a1473896b49605a762f57d5c23466bca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>.  <a href="namespacemlir.html#a1473896b49605a762f57d5c23466bca5">More...</a><br /></td></tr>
<tr class="separator:a1473896b49605a762f57d5c23466bca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff29070c95cb99fb8e350aa50259d4ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aff29070c95cb99fb8e350aa50259d4ff">populateGpuSubgroupReduceOpLoweringPattern</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aff29070c95cb99fb8e350aa50259d4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate GpuSubgroupReduce pattern to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>.  <a href="namespacemlir.html#aff29070c95cb99fb8e350aa50259d4ff">More...</a><br /></td></tr>
<tr class="separator:aff29070c95cb99fb8e350aa50259d4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d1cd185a90ffc654522763de411592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af9d1cd185a90ffc654522763de411592">populateGpuWMMAToNVVMConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:af9d1cd185a90ffc654522763de411592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert WMMA ops from GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>.  <a href="namespacemlir.html#af9d1cd185a90ffc654522763de411592">More...</a><br /></td></tr>
<tr class="separator:af9d1cd185a90ffc654522763de411592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49059e037af730c35fa299678d4fceab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a49059e037af730c35fa299678d4fceab">populateGpuToROCDLConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="namespacemlir_1_1gpu_1_1amd.html#a8637afbd01b984be30dbd1cdb78ae45f">gpu::amd::Runtime</a> runtime)</td></tr>
<tr class="memdesc:a49059e037af730c35fa299678d4fceab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a>.  <a href="namespacemlir.html#a49059e037af730c35fa299678d4fceab">More...</a><br /></td></tr>
<tr class="separator:a49059e037af730c35fa299678d4fceab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c490624b02da7c5cb78aa071e0aa2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a65c490624b02da7c5cb78aa071e0aa2a">configureGpuToROCDLConversionLegality</a> (<a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a65c490624b02da7c5cb78aa071e0aa2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure target to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a>.  <a href="namespacemlir.html#a65c490624b02da7c5cb78aa071e0aa2a">More...</a><br /></td></tr>
<tr class="separator:a65c490624b02da7c5cb78aa071e0aa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb6ab100d4d15861d7ed00e702ff0ed"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; gpu::GPUModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6cb6ab100d4d15861d7ed00e702ff0ed">createLowerGpuOpsToROCDLOpsPass</a> (const std::string &amp;chipset=&quot;gfx900&quot;, unsigned indexBitwidth=<a class="el" href="namespacemlir.html#a2887883f00b094c5ca61c631d7b093a0">kDeriveIndexBitwidthFromDataLayout</a>, bool useBarePtrCallConv=false, <a class="el" href="namespacemlir_1_1gpu_1_1amd.html#a8637afbd01b984be30dbd1cdb78ae45f">gpu::amd::Runtime</a> runtime=gpu::amd::Runtime::Unknown)</td></tr>
<tr class="memdesc:a6cb6ab100d4d15861d7ed00e702ff0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that lowers GPU dialect operations to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> counterparts.  <a href="namespacemlir.html#a6cb6ab100d4d15861d7ed00e702ff0ed">More...</a><br /></td></tr>
<tr class="separator:a6cb6ab100d4d15861d7ed00e702ff0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38792a214e31cdbf60cb4b3f859767d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa38792a214e31cdbf60cb4b3f859767d">populateGPUToSPIRVPatterns</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aa38792a214e31cdbf60cb4b3f859767d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating GPU Ops to SPIR-V ops.  <a href="namespacemlir.html#aa38792a214e31cdbf60cb4b3f859767d">More...</a><br /></td></tr>
<tr class="separator:aa38792a214e31cdbf60cb4b3f859767d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875bfbc01fd879b9697d28ef7856b4f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a875bfbc01fd879b9697d28ef7856b4f7">populateGpuWMMAToSPIRVCoopMatrixKHRConversionPatterns</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a875bfbc01fd879b9697d28ef7856b4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert WMMA ops from GPU dialect to SPIRV, using the KHR Cooperative Matrix extension.  <a href="namespacemlir.html#a875bfbc01fd879b9697d28ef7856b4f7">More...</a><br /></td></tr>
<tr class="separator:a875bfbc01fd879b9697d28ef7856b4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ca5cbf58aa081676683b5b8111cc50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab2ca5cbf58aa081676683b5b8111cc50">populateMMAToSPIRVCoopMatrixTypeConversion</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter)</td></tr>
<tr class="memdesc:ab2ca5cbf58aa081676683b5b8111cc50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <code>MMAMatrixType</code> conversions to SPIR-V cooperative matrix KHR type conversion to the type converter.  <a href="namespacemlir.html#ab2ca5cbf58aa081676683b5b8111cc50">More...</a><br /></td></tr>
<tr class="separator:ab2ca5cbf58aa081676683b5b8111cc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112698688acfebc3284b59e6ffa4d155"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a112698688acfebc3284b59e6ffa4d155">createConvertGPUToSPIRVPass</a> (bool mapMemorySpace=true)</td></tr>
<tr class="memdesc:a112698688acfebc3284b59e6ffa4d155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert GPU kernel ops to corresponding SPIR-V ops.  <a href="namespacemlir.html#a112698688acfebc3284b59e6ffa4d155">More...</a><br /></td></tr>
<tr class="separator:a112698688acfebc3284b59e6ffa4d155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39c9d3321b2f5f4aee088b02b535f9b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; mlir::ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad39c9d3321b2f5f4aee088b02b535f9b">createConvertGpuLaunchFuncToVulkanLaunchFuncPass</a> ()</td></tr>
<tr class="separator:ad39c9d3321b2f5f4aee088b02b535f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb33f39a4ad0d4d52396f132bee84cf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aefb33f39a4ad0d4d52396f132bee84cf">createConvertLinalgToStandardPass</a> ()</td></tr>
<tr class="memdesc:aefb33f39a4ad0d4d52396f132bee84cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations to the Standard dialect.  <a href="namespacemlir.html#aefb33f39a4ad0d4d52396f132bee84cf">More...</a><br /></td></tr>
<tr class="separator:aefb33f39a4ad0d4d52396f132bee84cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528c0559f393f6206d80cdb29394fa1c"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a528c0559f393f6206d80cdb29394fa1c">structFuncArgTypeConverter</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:a528c0559f393f6206d80cdb29394fa1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to convert function argument types.  <a href="namespacemlir.html#a528c0559f393f6206d80cdb29394fa1c">More...</a><br /></td></tr>
<tr class="separator:a528c0559f393f6206d80cdb29394fa1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b57be921931a80cdd8e7b0f96fc6e9f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0b57be921931a80cdd8e7b0f96fc6e9f">barePtrFuncArgTypeConverter</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:a0b57be921931a80cdd8e7b0f96fc6e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to convert function argument types.  <a href="namespacemlir.html#a0b57be921931a80cdd8e7b0f96fc6e9f">More...</a><br /></td></tr>
<tr class="separator:a0b57be921931a80cdd8e7b0f96fc6e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d02c131fc732f88a4f4bbd96470b159"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7d02c131fc732f88a4f4bbd96470b159">populateMathToLibmConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a7d02c131fc732f88a4f4bbd96470b159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Math to Libm calls.  <a href="namespacemlir.html#a7d02c131fc732f88a4f4bbd96470b159">More...</a><br /></td></tr>
<tr class="separator:a7d02c131fc732f88a4f4bbd96470b159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0be8ab8e597910498a4a64215faa2fb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa0be8ab8e597910498a4a64215faa2fb">createConvertMathToLibmPass</a> ()</td></tr>
<tr class="memdesc:aa0be8ab8e597910498a4a64215faa2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Math operations to libm calls.  <a href="namespacemlir.html#aa0be8ab8e597910498a4a64215faa2fb">More...</a><br /></td></tr>
<tr class="separator:aa0be8ab8e597910498a4a64215faa2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2210541bcd8d4217fe2fc09cf044495c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2210541bcd8d4217fe2fc09cf044495c">populateMathToLLVMConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool approximateLog1p=true)</td></tr>
<tr class="separator:a2210541bcd8d4217fe2fc09cf044495c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af524bd5bb2e7831529a737536dee9e63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af524bd5bb2e7831529a737536dee9e63">registerConvertMathToLLVMInterface</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:af524bd5bb2e7831529a737536dee9e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb1e6c26cd3f8d24c93a96dfd84ee6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afcb1e6c26cd3f8d24c93a96dfd84ee6d">populateMathToROCDLConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:afcb1e6c26cd3f8d24c93a96dfd84ee6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Math to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> calls.  <a href="namespacemlir.html#afcb1e6c26cd3f8d24c93a96dfd84ee6d">More...</a><br /></td></tr>
<tr class="separator:afcb1e6c26cd3f8d24c93a96dfd84ee6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5cdff8faeb322f48015571f5f4aae2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6c5cdff8faeb322f48015571f5f4aae2">populateMathToSPIRVPatterns</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a6c5cdff8faeb322f48015571f5f4aae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating Math ops to SPIR-V ops.  <a href="namespacemlir.html#a6c5cdff8faeb322f48015571f5f4aae2">More...</a><br /></td></tr>
<tr class="separator:a6c5cdff8faeb322f48015571f5f4aae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c8995bd3756d7b1e15813d96b2b2ad"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a10c8995bd3756d7b1e15813d96b2b2ad">createConvertMathToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a10c8995bd3756d7b1e15813d96b2b2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert Math ops to SPIR-V ops.  <a href="namespacemlir.html#a10c8995bd3756d7b1e15813d96b2b2ad">More...</a><br /></td></tr>
<tr class="separator:a10c8995bd3756d7b1e15813d96b2b2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58637750147b089cca80eec8603b220f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a58637750147b089cca80eec8603b220f">populateMemRefToEmitCTypeConversion</a> (<a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter)</td></tr>
<tr class="separator:a58637750147b089cca80eec8603b220f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99266ebe2b3be9d39e425ef361013656"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a99266ebe2b3be9d39e425ef361013656">populateMemRefToEmitCConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="separator:a99266ebe2b3be9d39e425ef361013656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600f4579b547917666e45a3c6b25f068"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a600f4579b547917666e45a3c6b25f068">populateFinalizeMemRefToLLVMConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a600f4579b547917666e45a3c6b25f068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert memory-related operations from the MemRef dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <a href="namespacemlir.html#a600f4579b547917666e45a3c6b25f068">More...</a><br /></td></tr>
<tr class="separator:a600f4579b547917666e45a3c6b25f068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064361570e348faf435496fbf4d5db7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a064361570e348faf435496fbf4d5db7d">registerConvertMemRefToLLVMInterface</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a064361570e348faf435496fbf4d5db7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19383f60ade82f3ca68e0cabda60d42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad19383f60ade82f3ca68e0cabda60d42">populateMemRefToSPIRVPatterns</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ad19383f60ade82f3ca68e0cabda60d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating MemRef ops to SPIR-V ops.  <a href="namespacemlir.html#ad19383f60ade82f3ca68e0cabda60d42">More...</a><br /></td></tr>
<tr class="separator:ad19383f60ade82f3ca68e0cabda60d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5b68602e237b1c1c3209ae71184cd2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0c5b68602e237b1c1c3209ae71184cd2">createMapMemRefStorageClassPass</a> ()</td></tr>
<tr class="memdesc:a0c5b68602e237b1c1c3209ae71184cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to map numeric MemRef memory spaces to symbolic SPIR-V storage classes.  <a href="namespacemlir.html#a0c5b68602e237b1c1c3209ae71184cd2">More...</a><br /></td></tr>
<tr class="separator:a0c5b68602e237b1c1c3209ae71184cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bec430062ec4285c83eccbab6ebbe29"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3bec430062ec4285c83eccbab6ebbe29">createConvertMemRefToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a3bec430062ec4285c83eccbab6ebbe29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert MemRef ops to SPIR-V ops.  <a href="namespacemlir.html#a3bec430062ec4285c83eccbab6ebbe29">More...</a><br /></td></tr>
<tr class="separator:a3bec430062ec4285c83eccbab6ebbe29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bc264eaa4a13001177aa530bcd2313"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a77bc264eaa4a13001177aa530bcd2313">populateNVGPUToNVVMConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a77bc264eaa4a13001177aa530bcd2313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35eb3329af0ae57e8a63db9abeaf88e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a35eb3329af0ae57e8a63db9abeaf88e5">populateNVVMToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a35eb3329af0ae57e8a63db9abeaf88e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ef9c68e63c5458b7258ecb9b48b8bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af5ef9c68e63c5458b7258ecb9b48b8bf">registerConvertNVVMToLLVMInterface</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:af5ef9c68e63c5458b7258ecb9b48b8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725b3caed685f9615fba2027124f359f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a725b3caed685f9615fba2027124f359f">populateOpenACCToSCFConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a725b3caed685f9615fba2027124f359f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the patterns to convert from the OpenACC dialect to OpenACC with SCF dialect.  <a href="namespacemlir.html#a725b3caed685f9615fba2027124f359f">More...</a><br /></td></tr>
<tr class="separator:a725b3caed685f9615fba2027124f359f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1dc4bc47a3830e063b709a36e0ab91"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3c1dc4bc47a3830e063b709a36e0ab91">createConvertOpenACCToSCFPass</a> ()</td></tr>
<tr class="memdesc:a3c1dc4bc47a3830e063b709a36e0ab91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert the OpenACC dialect into the LLVMIR dialect.  <a href="namespacemlir.html#a3c1dc4bc47a3830e063b709a36e0ab91">More...</a><br /></td></tr>
<tr class="separator:a3c1dc4bc47a3830e063b709a36e0ab91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3aae89781697b10e37f29e112251443"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab3aae89781697b10e37f29e112251443">configureOpenMPToLLVMConversionLegality</a> (<a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter)</td></tr>
<tr class="memdesc:ab3aae89781697b10e37f29e112251443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure dynamic conversion legality of regionless operations from OpenMP to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="namespacemlir.html#ab3aae89781697b10e37f29e112251443">More...</a><br /></td></tr>
<tr class="separator:ab3aae89781697b10e37f29e112251443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1111bfc29c10d7cd2ebba33996e38509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1111bfc29c10d7cd2ebba33996e38509">populateOpenMPToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a1111bfc29c10d7cd2ebba33996e38509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from OpenMP to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="namespacemlir.html#a1111bfc29c10d7cd2ebba33996e38509">More...</a><br /></td></tr>
<tr class="separator:a1111bfc29c10d7cd2ebba33996e38509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af882e712b4e426905d73c1c74bd0f353"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af882e712b4e426905d73c1c74bd0f353">createPDLToPDLInterpPass</a> ()</td></tr>
<tr class="memdesc:af882e712b4e426905d73c1c74bd0f353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a pass to convert PDL ops to PDL interpreter ops.  <a href="namespacemlir.html#af882e712b4e426905d73c1c74bd0f353">More...</a><br /></td></tr>
<tr class="separator:af882e712b4e426905d73c1c74bd0f353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b51cc369e6be47cad63fe35c030ca3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae7b51cc369e6be47cad63fe35c030ca3">createPDLToPDLInterpPass</a> (<a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, PDLPatternConfigSet * &gt; &amp;configMap)</td></tr>
<tr class="memdesc:ae7b51cc369e6be47cad63fe35c030ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a pass to convert PDL ops to PDL interpreter ops.  <a href="namespacemlir.html#ae7b51cc369e6be47cad63fe35c030ca3">More...</a><br /></td></tr>
<tr class="separator:ae7b51cc369e6be47cad63fe35c030ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab06609d5a7ea6d475070dcc8d271725"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aab06609d5a7ea6d475070dcc8d271725">createReconcileUnrealizedCastsPass</a> ()</td></tr>
<tr class="memdesc:aab06609d5a7ea6d475070dcc8d271725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that eliminates noop <code>unrealized_conversion_cast</code> operation sequences.  <a href="namespacemlir.html#aab06609d5a7ea6d475070dcc8d271725">More...</a><br /></td></tr>
<tr class="separator:aab06609d5a7ea6d475070dcc8d271725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc663ae01ea2b6384c3f6ce299be3b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9fc663ae01ea2b6384c3f6ce299be3b0">populateSCFToControlFlowConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a9fc663ae01ea2b6384c3f6ce299be3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert SCF operations to CFG branch-based operations within the ControlFlow dialect.  <a href="namespacemlir.html#a9fc663ae01ea2b6384c3f6ce299be3b0">More...</a><br /></td></tr>
<tr class="separator:a9fc663ae01ea2b6384c3f6ce299be3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877c34cdb063f52ff5ea4efd82807621"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a877c34cdb063f52ff5ea4efd82807621">createConvertSCFToCFPass</a> ()</td></tr>
<tr class="memdesc:a877c34cdb063f52ff5ea4efd82807621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert SCF operations to CFG branch-based operation in the ControlFlow dialect.  <a href="namespacemlir.html#a877c34cdb063f52ff5ea4efd82807621">More...</a><br /></td></tr>
<tr class="separator:a877c34cdb063f52ff5ea4efd82807621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558ec60b7aaa291cc8bc55442f4e18c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a558ec60b7aaa291cc8bc55442f4e18c6">populateSCFToEmitCConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a558ec60b7aaa291cc8bc55442f4e18c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert SCF operations to the EmitC dialect.  <a href="namespacemlir.html#a558ec60b7aaa291cc8bc55442f4e18c6">More...</a><br /></td></tr>
<tr class="separator:a558ec60b7aaa291cc8bc55442f4e18c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e36f1b7aaec9319e5ba11077079aa4e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4e36f1b7aaec9319e5ba11077079aa4e">convertAffineLoopNestToGPULaunch</a> (affine::AffineForOp forOp, unsigned numBlockDims, unsigned numThreadDims)</td></tr>
<tr class="memdesc:a4e36f1b7aaec9319e5ba11077079aa4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a perfect affine loop nest with the outermost loop identified by <code>forOp</code> into a gpu::Launch operation.  <a href="namespacemlir.html#a4e36f1b7aaec9319e5ba11077079aa4e">More...</a><br /></td></tr>
<tr class="separator:a4e36f1b7aaec9319e5ba11077079aa4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1727b1783cbf671c6ee60cc2a5c2f132"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1727b1783cbf671c6ee60cc2a5c2f132">populateParallelLoopToGPUPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a1727b1783cbf671c6ee60cc2a5c2f132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the conversion pattern from <code>scf.parallel</code> to <code>gpu.launch</code> to the provided pattern list.  <a href="namespacemlir.html#a1727b1783cbf671c6ee60cc2a5c2f132">More...</a><br /></td></tr>
<tr class="separator:a1727b1783cbf671c6ee60cc2a5c2f132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01d59b73ef695a82338e96055101c16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af01d59b73ef695a82338e96055101c16">configureParallelLoopToGPULegality</a> (<a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:af01d59b73ef695a82338e96055101c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the rewrite target such that only <code>scf.parallel</code> operations that are not rewritten by the provided patterns are legal.  <a href="namespacemlir.html#af01d59b73ef695a82338e96055101c16">More...</a><br /></td></tr>
<tr class="separator:af01d59b73ef695a82338e96055101c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b8cb2bfcf870fb9909b4805c0aad13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a04b8cb2bfcf870fb9909b4805c0aad13">finalizeParallelLoopToGPUConversion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a04b8cb2bfcf870fb9909b4805c0aad13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after applyPartialConversion/applyFullConversion call.  <a href="namespacemlir.html#a04b8cb2bfcf870fb9909b4805c0aad13">More...</a><br /></td></tr>
<tr class="separator:a04b8cb2bfcf870fb9909b4805c0aad13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec40c7aecb333928b9b4e9e409f0670"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a>&lt; FunctionOpInterface &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0ec40c7aecb333928b9b4e9e409f0670">createAffineForToGPUPass</a> (unsigned numBlockDims, unsigned numThreadDims)</td></tr>
<tr class="memdesc:a0ec40c7aecb333928b9b4e9e409f0670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that converts loop nests into GPU kernels.  <a href="namespacemlir.html#a0ec40c7aecb333928b9b4e9e409f0670">More...</a><br /></td></tr>
<tr class="separator:a0ec40c7aecb333928b9b4e9e409f0670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec305cc3472323a62580de136ce81cc3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a>&lt; FunctionOpInterface &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aec305cc3472323a62580de136ce81cc3">createAffineForToGPUPass</a> ()</td></tr>
<tr class="separator:aec305cc3472323a62580de136ce81cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f36107d7ffc6c1f873c746385d9de0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa2f36107d7ffc6c1f873c746385d9de0">createParallelLoopToGpuPass</a> ()</td></tr>
<tr class="memdesc:aa2f36107d7ffc6c1f873c746385d9de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that converts scf.parallel operations into a gpu.launch operation.  <a href="namespacemlir.html#aa2f36107d7ffc6c1f873c746385d9de0">More...</a><br /></td></tr>
<tr class="separator:aa2f36107d7ffc6c1f873c746385d9de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca1349510877edff1b6a3fe7249226c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8ca1349510877edff1b6a3fe7249226c">populateSCFToSPIRVPatterns</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="structmlir_1_1ScfToSPIRVContext.html">ScfToSPIRVContext</a> &amp;scfToSPIRVContext, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a8ca1349510877edff1b6a3fe7249226c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects a set of patterns to lower from scf.for, scf.if, and loop.terminator to CFG operations within the SPIR-V dialect.  <a href="namespacemlir.html#a8ca1349510877edff1b6a3fe7249226c">More...</a><br /></td></tr>
<tr class="separator:a8ca1349510877edff1b6a3fe7249226c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c87a4d7e914dda62d03a97cf7e8963"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a74c87a4d7e914dda62d03a97cf7e8963">createConvertSCFToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a74c87a4d7e914dda62d03a97cf7e8963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert SCF ops into SPIR-V ops.  <a href="namespacemlir.html#a74c87a4d7e914dda62d03a97cf7e8963">More...</a><br /></td></tr>
<tr class="separator:a74c87a4d7e914dda62d03a97cf7e8963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d32c331310df6a35924ac128fa789f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9d32c331310df6a35924ac128fa789f3">populateShapeToStandardConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a9d32c331310df6a35924ac128fa789f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9ecc9afba558cb026032d0453a7c95"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abc9ecc9afba558cb026032d0453a7c95">createConvertShapeToStandardPass</a> ()</td></tr>
<tr class="separator:abc9ecc9afba558cb026032d0453a7c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e66615eb7e50976ed8c89b2bb05adc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae6e66615eb7e50976ed8c89b2bb05adc">populateConvertShapeConstraintsConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:ae6e66615eb7e50976ed8c89b2bb05adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85b8b89468b7fc2b347d361b512e8d3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac85b8b89468b7fc2b347d361b512e8d3">createConvertShapeConstraintsPass</a> ()</td></tr>
<tr class="separator:ac85b8b89468b7fc2b347d361b512e8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1053fc52d14c30b033f053dd93383659"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1053fc52d14c30b033f053dd93383659">storageClassToAddressSpace</a> (spirv::ClientAPI clientAPI, spirv::StorageClass storageClass)</td></tr>
<tr class="separator:a1053fc52d14c30b033f053dd93383659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8075944125730fed529e3b93dcfed5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab8075944125730fed529e3b93dcfed5b">encodeBindAttribute</a> (ModuleOp module)</td></tr>
<tr class="memdesc:ab8075944125730fed529e3b93dcfed5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes global variable's descriptor set and binding into its name if they both exist.  <a href="namespacemlir.html#ab8075944125730fed529e3b93dcfed5b">More...</a><br /></td></tr>
<tr class="separator:ab8075944125730fed529e3b93dcfed5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35333950f5d30c0990ebca7da9dd882c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a35333950f5d30c0990ebca7da9dd882c">populateSPIRVToLLVMTypeConversion</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter, spirv::ClientAPI clientAPIForAddressSpaceMapping=spirv::ClientAPI::Unknown)</td></tr>
<tr class="memdesc:a35333950f5d30c0990ebca7da9dd882c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates type conversions with additional SPIR-V types.  <a href="namespacemlir.html#a35333950f5d30c0990ebca7da9dd882c">More...</a><br /></td></tr>
<tr class="separator:a35333950f5d30c0990ebca7da9dd882c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47a30210dfc5deae1daa2e2c8840d8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa47a30210dfc5deae1daa2e2c8840d8f">populateSPIRVToLLVMConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, spirv::ClientAPI clientAPIForAddressSpaceMapping=spirv::ClientAPI::Unknown)</td></tr>
<tr class="memdesc:aa47a30210dfc5deae1daa2e2c8840d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the given list with patterns that convert from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="namespacemlir.html#aa47a30210dfc5deae1daa2e2c8840d8f">More...</a><br /></td></tr>
<tr class="separator:aa47a30210dfc5deae1daa2e2c8840d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee4e0b9121971b2ca8fcc16640d457f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6ee4e0b9121971b2ca8fcc16640d457f">populateSPIRVToLLVMFunctionConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a6ee4e0b9121971b2ca8fcc16640d457f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the given list with patterns for function conversion from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="namespacemlir.html#a6ee4e0b9121971b2ca8fcc16640d457f">More...</a><br /></td></tr>
<tr class="separator:a6ee4e0b9121971b2ca8fcc16640d457f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe47840c56acca273d219c5fc82b179d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abe47840c56acca273d219c5fc82b179d">populateSPIRVToLLVMModuleConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:abe47840c56acca273d219c5fc82b179d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the given patterns for module conversion from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="namespacemlir.html#abe47840c56acca273d219c5fc82b179d">More...</a><br /></td></tr>
<tr class="separator:abe47840c56acca273d219c5fc82b179d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8ecf548ab4c5b21eddf5ee62e618e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5b8ecf548ab4c5b21eddf5ee62e618e8">populateTensorToLinalgPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a5b8ecf548ab4c5b21eddf5ee62e618e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating tensor ops to Linalg ops.  <a href="namespacemlir.html#a5b8ecf548ab4c5b21eddf5ee62e618e8">More...</a><br /></td></tr>
<tr class="separator:a5b8ecf548ab4c5b21eddf5ee62e618e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff30b5a742e19dd8d8fea41d953fbe4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2ff30b5a742e19dd8d8fea41d953fbe4">createConvertTensorToLinalgPass</a> ()</td></tr>
<tr class="memdesc:a2ff30b5a742e19dd8d8fea41d953fbe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert Tensor ops to Linalg ops.  <a href="namespacemlir.html#a2ff30b5a742e19dd8d8fea41d953fbe4">More...</a><br /></td></tr>
<tr class="separator:a2ff30b5a742e19dd8d8fea41d953fbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba8a125094bd28e1f1db4858eb5ff52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0ba8a125094bd28e1f1db4858eb5ff52">populateTensorToSPIRVPatterns</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, int64_t byteCountThreshold, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a0ba8a125094bd28e1f1db4858eb5ff52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating tensor ops to SPIR-V ops.  <a href="namespacemlir.html#a0ba8a125094bd28e1f1db4858eb5ff52">More...</a><br /></td></tr>
<tr class="separator:a0ba8a125094bd28e1f1db4858eb5ff52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d3655f76a6db563fa528a741573691"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a81d3655f76a6db563fa528a741573691">createConvertTensorToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a81d3655f76a6db563fa528a741573691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert Tensor ops to SPIR-V ops.  <a href="namespacemlir.html#a81d3655f76a6db563fa528a741573691">More...</a><br /></td></tr>
<tr class="separator:a81d3655f76a6db563fa528a741573691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae512bcd2d0e2cc4f8ddb82e2922ccc8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae512bcd2d0e2cc4f8ddb82e2922ccc8b">populateVectorToArmSMEPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;ctx)</td></tr>
<tr class="memdesc:ae512bcd2d0e2cc4f8ddb82e2922ccc8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to lower <a class="el" href="structVector.html">Vector</a> ops to ArmSME ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <a href="namespacemlir.html#ae512bcd2d0e2cc4f8ddb82e2922ccc8b">More...</a><br /></td></tr>
<tr class="separator:ae512bcd2d0e2cc4f8ddb82e2922ccc8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6248f4bc8957bd0e7339b5de636be1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1e6248f4bc8957bd0e7339b5de636be1">createConvertVectorToArmSMEPass</a> ()</td></tr>
<tr class="memdesc:a1e6248f4bc8957bd0e7339b5de636be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to lower operations from the vector dialect to Arm SME.  <a href="namespacemlir.html#a1e6248f4bc8957bd0e7339b5de636be1">More...</a><br /></td></tr>
<tr class="separator:a1e6248f4bc8957bd0e7339b5de636be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10daa5ecf515d29ea9079368f9b9b08d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a10daa5ecf515d29ea9079368f9b9b08d">populatePrepareVectorToMMAPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool useNvGpu=false)</td></tr>
<tr class="memdesc:a10daa5ecf515d29ea9079368f9b9b08d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to transform vector ops into a canonical form to convert to MMA matrix operations.  <a href="namespacemlir.html#a10daa5ecf515d29ea9079368f9b9b08d">More...</a><br /></td></tr>
<tr class="separator:a10daa5ecf515d29ea9079368f9b9b08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d71d5f26ac7f264365e6fb7a6aadff"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af7d71d5f26ac7f264365e6fb7a6aadff">convertVectorToMMAOps</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *rootOp)</td></tr>
<tr class="memdesc:af7d71d5f26ac7f264365e6fb7a6aadff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert vector ops to MMA matrix operations nested under <code>rootOp</code>.  <a href="namespacemlir.html#af7d71d5f26ac7f264365e6fb7a6aadff">More...</a><br /></td></tr>
<tr class="separator:af7d71d5f26ac7f264365e6fb7a6aadff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d66f364335bd7ca0a98bb53f82f0a77"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8d66f364335bd7ca0a98bb53f82f0a77">convertVectorToNVVMCompatibleMMASync</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *rootOp)</td></tr>
<tr class="memdesc:a8d66f364335bd7ca0a98bb53f82f0a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert vector ops ops nested under <code>rootOp</code> to vector and GPU operaitons compatible with the <code>nvvm.mma.sync</code> lowering path.  <a href="namespacemlir.html#a8d66f364335bd7ca0a98bb53f82f0a77">More...</a><br /></td></tr>
<tr class="separator:a8d66f364335bd7ca0a98bb53f82f0a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e64d4460362ea3cdb2edc8b746396c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad3e64d4460362ea3cdb2edc8b746396c">createConvertVectorToGPUPass</a> (bool useNvGpu=false)</td></tr>
<tr class="memdesc:ad3e64d4460362ea3cdb2edc8b746396c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from vector to GPU ops.  <a href="namespacemlir.html#ad3e64d4460362ea3cdb2edc8b746396c">More...</a><br /></td></tr>
<tr class="separator:ad3e64d4460362ea3cdb2edc8b746396c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb11dbe1feb192f2f3de9500e820c7a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeb11dbe1feb192f2f3de9500e820c7a8">populateVectorToLLVMMatrixConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aeb11dbe1feb192f2f3de9500e820c7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from <a class="el" href="structVector.html">Vector</a> contractions to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> Matrix Intrinsics.  <a href="namespacemlir.html#aeb11dbe1feb192f2f3de9500e820c7a8">More...</a><br /></td></tr>
<tr class="separator:aeb11dbe1feb192f2f3de9500e820c7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e959362ad476f9889cf483664e0789"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac0e959362ad476f9889cf483664e0789">populateVectorToLLVMConversionPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool reassociateFPReductions=false, bool force32BitVectorIndices=false)</td></tr>
<tr class="memdesc:ac0e959362ad476f9889cf483664e0789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the <a class="el" href="structVector.html">Vector</a> dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="namespacemlir.html#ac0e959362ad476f9889cf483664e0789">More...</a><br /></td></tr>
<tr class="separator:ac0e959362ad476f9889cf483664e0789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c6c9c53e199da9b2def6f5e62eec02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a96c6c9c53e199da9b2def6f5e62eec02">populateVectorToSCFConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>=<a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a>())</td></tr>
<tr class="memdesc:a96c6c9c53e199da9b2def6f5e62eec02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the <a class="el" href="structVector.html">Vector</a> dialect to SCF + func.  <a href="namespacemlir.html#a96c6c9c53e199da9b2def6f5e62eec02">More...</a><br /></td></tr>
<tr class="separator:a96c6c9c53e199da9b2def6f5e62eec02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c71e471d7d8cdda288a27d1ae75642"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac5c71e471d7d8cdda288a27d1ae75642">createConvertVectorToSCFPass</a> (const <a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>=<a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a>())</td></tr>
<tr class="memdesc:ac5c71e471d7d8cdda288a27d1ae75642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert a subset of vector ops to SCF.  <a href="namespacemlir.html#ac5c71e471d7d8cdda288a27d1ae75642">More...</a><br /></td></tr>
<tr class="separator:ac5c71e471d7d8cdda288a27d1ae75642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2bafba6c8ae1b85a1abadc386f22a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aff2bafba6c8ae1b85a1abadc386f22a3">populateVectorToSPIRVPatterns</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aff2bafba6c8ae1b85a1abadc386f22a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating <a class="el" href="structVector.html">Vector</a> Ops to SPIR-V ops.  <a href="namespacemlir.html#aff2bafba6c8ae1b85a1abadc386f22a3">More...</a><br /></td></tr>
<tr class="separator:aff2bafba6c8ae1b85a1abadc386f22a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdbf57d9d955aea59286a07c5c3c03a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7fdbf57d9d955aea59286a07c5c3c03a">populateVectorReductionToSPIRVDotProductPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a7fdbf57d9d955aea59286a07c5c3c03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns to convert vector reduction of the form:  <a href="namespacemlir.html#a7fdbf57d9d955aea59286a07c5c3c03a">More...</a><br /></td></tr>
<tr class="separator:a7fdbf57d9d955aea59286a07c5c3c03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8113c1109f8cc9f8d47492fce5d7723f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8113c1109f8cc9f8d47492fce5d7723f">createConvertVectorToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a8113c1109f8cc9f8d47492fce5d7723f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert <a class="el" href="structVector.html">Vector</a> Ops to SPIR-V ops.  <a href="namespacemlir.html#a8113c1109f8cc9f8d47492fce5d7723f">More...</a><br /></td></tr>
<tr class="separator:a8113c1109f8cc9f8d47492fce5d7723f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a6fd23ac57182bebb5185f7013e2fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a94a6fd23ac57182bebb5185f7013e2fa">populateVectorToXeGPUConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a94a6fd23ac57182bebb5185f7013e2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the vector to XeGPU ops.  <a href="namespacemlir.html#a94a6fd23ac57182bebb5185f7013e2fa">More...</a><br /></td></tr>
<tr class="separator:a94a6fd23ac57182bebb5185f7013e2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd10dfc8f20e1f212be133738228aaf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acbd10dfc8f20e1f212be133738228aaf">createConvertVectorToXeGPUPass</a> ()</td></tr>
<tr class="memdesc:acbd10dfc8f20e1f212be133738228aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert ops from vector to XeGPU.  <a href="namespacemlir.html#acbd10dfc8f20e1f212be133738228aaf">More...</a><br /></td></tr>
<tr class="separator:acbd10dfc8f20e1f212be133738228aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37afe16f80bc8bacb6914dd6f0b869c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a37afe16f80bc8bacb6914dd6f0b869c0">setupDebuggerExecutionContextHook</a> (<a class="el" href="classmlir_1_1tracing_1_1ExecutionContext.html">tracing::ExecutionContext</a> &amp;executionContext)</td></tr>
<tr class="separator:a37afe16f80bc8bacb6914dd6f0b869c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2932952899b602b89ed345a2fcaa317"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae2932952899b602b89ed345a2fcaa317">populateAMXLegalizeForLLVMExportPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ae2932952899b602b89ed345a2fcaa317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to lower AMX ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <a href="namespacemlir.html#ae2932952899b602b89ed345a2fcaa317">More...</a><br /></td></tr>
<tr class="separator:ae2932952899b602b89ed345a2fcaa317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3c1de7f45b21ef1f9deddb22b03655"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acc3c1de7f45b21ef1f9deddb22b03655">configureAMXLegalizeForExportTarget</a> (<a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:acc3c1de7f45b21ef1f9deddb22b03655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the target to support lowering AMX ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <a href="namespacemlir.html#acc3c1de7f45b21ef1f9deddb22b03655">More...</a><br /></td></tr>
<tr class="separator:acc3c1de7f45b21ef1f9deddb22b03655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23862ef78a8ff63b4f6a3c344448e16"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa23862ef78a8ff63b4f6a3c344448e16">inferExpandShapeOutputShape</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, ShapedType expandedType, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; reassociation, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; inputShape)</td></tr>
<tr class="memdesc:aa23862ef78a8ff63b4f6a3c344448e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the output shape for a {memref|tensor}.expand_shape when it is possible to do so.  <a href="namespacemlir.html#aa23862ef78a8ff63b4f6a3c344448e16">More...</a><br /></td></tr>
<tr class="separator:aa23862ef78a8ff63b4f6a3c344448e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7736bcb70dbd9f242cd5182dd443031"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">detail::op_matcher</a>&lt; <a class="el" href="classmlir_1_1arith_1_1ConstantIndexOp.html">arith::ConstantIndexOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac7736bcb70dbd9f242cd5182dd443031">matchConstantIndex</a> ()</td></tr>
<tr class="memdesc:ac7736bcb70dbd9f242cd5182dd443031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a ConstantIndexOp.  <a href="namespacemlir.html#ac7736bcb70dbd9f242cd5182dd443031">More...</a><br /></td></tr>
<tr class="separator:ac7736bcb70dbd9f242cd5182dd443031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bdf7e87740dbe0f603efdbc83c0a68"><td class="memItemLeft" align="right" valign="top">llvm::SmallBitVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac1bdf7e87740dbe0f603efdbc83c0a68">getPositionsOfShapeOne</a> (unsigned rank, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape)</td></tr>
<tr class="separator:ac1bdf7e87740dbe0f603efdbc83c0a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4654f8a83dcd16f99ce83a6a991fa348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4654f8a83dcd16f99ce83a6a991fa348">getValueOrCreateConstantIntOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr)</td></tr>
<tr class="memdesc:a4654f8a83dcd16f99ce83a6a991fa348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="namespacemlir.html#a4654f8a83dcd16f99ce83a6a991fa348">More...</a><br /></td></tr>
<tr class="separator:a4654f8a83dcd16f99ce83a6a991fa348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa058eb9c12d3b97deb073543c1372195"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa058eb9c12d3b97deb073543c1372195">getValueOrCreateConstantIndexOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr)</td></tr>
<tr class="memdesc:aa058eb9c12d3b97deb073543c1372195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="namespacemlir.html#aa058eb9c12d3b97deb073543c1372195">More...</a><br /></td></tr>
<tr class="separator:aa058eb9c12d3b97deb073543c1372195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09c62516a7b31fc96892014feeae832"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab09c62516a7b31fc96892014feeae832">getValueOrCreateConstantIndexOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; valueOrAttrVec)</td></tr>
<tr class="memdesc:ab09c62516a7b31fc96892014feeae832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the other overload, but converts multiple OpFoldResults into Values.  <a href="namespacemlir.html#ab09c62516a7b31fc96892014feeae832">More...</a><br /></td></tr>
<tr class="separator:ab09c62516a7b31fc96892014feeae832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8bbfc3d0c15e92f5cba28e5ef447b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7d8bbfc3d0c15e92f5cba28e5ef447b5">getValueOrCreateCastToIndexLike</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> targetType, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a7d8bbfc3d0c15e92f5cba28e5ef447b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a cast from an index-like value (index or integer) to another index-like value.  <a href="namespacemlir.html#a7d8bbfc3d0c15e92f5cba28e5ef447b5">More...</a><br /></td></tr>
<tr class="separator:a7d8bbfc3d0c15e92f5cba28e5ef447b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d383da63b1370b9cf5c13c252b391d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a10d383da63b1370b9cf5c13c252b391d">convertScalarToDtype</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> operand, <a class="el" href="classmlir_1_1Type.html">Type</a> toType, bool isUnsignedCast)</td></tr>
<tr class="memdesc:a10d383da63b1370b9cf5c13c252b391d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a scalar value <code>operand</code> to type <code>toType</code>.  <a href="namespacemlir.html#a10d383da63b1370b9cf5c13c252b391d">More...</a><br /></td></tr>
<tr class="separator:a10d383da63b1370b9cf5c13c252b391d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147eacb98e107c587492012f9981cd62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a147eacb98e107c587492012f9981cd62">createScalarOrSplatConstant</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> type, const APInt &amp;value)</td></tr>
<tr class="memdesc:a147eacb98e107c587492012f9981cd62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a constant of type <code>type</code> at location <code>loc</code> whose value is <code>value</code> (an APInt or APFloat whose type must match the element type of <code>type</code>).  <a href="namespacemlir.html#a147eacb98e107c587492012f9981cd62">More...</a><br /></td></tr>
<tr class="separator:a147eacb98e107c587492012f9981cd62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083c2c253d760b0fb021e6ce396105ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a083c2c253d760b0fb021e6ce396105ed">createScalarOrSplatConstant</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> type, int64_t value)</td></tr>
<tr class="separator:a083c2c253d760b0fb021e6ce396105ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7b8f0656a50e3147f888f41325b8bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acd7b8f0656a50e3147f888f41325b8bb">createScalarOrSplatConstant</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> type, const APFloat &amp;value)</td></tr>
<tr class="separator:acd7b8f0656a50e3147f888f41325b8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348ed9fcbefe1f5094cc571c346c7080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a348ed9fcbefe1f5094cc571c346c7080">getType</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr)</td></tr>
<tr class="memdesc:a348ed9fcbefe1f5094cc571c346c7080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the int type of the integer in ofr.  <a href="namespacemlir.html#a348ed9fcbefe1f5094cc571c346c7080">More...</a><br /></td></tr>
<tr class="separator:a348ed9fcbefe1f5094cc571c346c7080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e0bc56426ca98e9bddc31e4ec82d35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab4e0bc56426ca98e9bddc31e4ec82d35">populateArmSVELegalizeForLLVMExportPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ab4e0bc56426ca98e9bddc31e4ec82d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to lower ArmSVE ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <a href="namespacemlir.html#ab4e0bc56426ca98e9bddc31e4ec82d35">More...</a><br /></td></tr>
<tr class="separator:ab4e0bc56426ca98e9bddc31e4ec82d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026c18765c0bc2d44d9ab120174d36ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a026c18765c0bc2d44d9ab120174d36ae">configureArmSVELegalizeForExportTarget</a> (<a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a026c18765c0bc2d44d9ab120174d36ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the target to support lowering ArmSVE ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <a href="namespacemlir.html#a026c18765c0bc2d44d9ab120174d36ae">More...</a><br /></td></tr>
<tr class="separator:a026c18765c0bc2d44d9ab120174d36ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4239fe8f68fb32a8788127f7a6850950"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4239fe8f68fb32a8788127f7a6850950">createAsyncParallelForPass</a> ()</td></tr>
<tr class="separator:a4239fe8f68fb32a8788127f7a6850950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755ae56707350858331f8a2d72036f86"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a755ae56707350858331f8a2d72036f86">createAsyncParallelForPass</a> (bool asyncDispatch, int32_t numWorkerThreads, int32_t minTaskSize)</td></tr>
<tr class="separator:a755ae56707350858331f8a2d72036f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ea90e10c603e639fe6b6cbc9f24265"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa9ea90e10c603e639fe6b6cbc9f24265">populateAsyncFuncToAsyncRuntimeConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="separator:aa9ea90e10c603e639fe6b6cbc9f24265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef286aa7b84037b9a4b9b638c57d20c1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aef286aa7b84037b9a4b9b638c57d20c1">createAsyncFuncToAsyncRuntimePass</a> ()</td></tr>
<tr class="separator:aef286aa7b84037b9a4b9b638c57d20c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda37b3719dc71d8caddd1d39ca215db"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acda37b3719dc71d8caddd1d39ca215db">createAsyncToAsyncRuntimePass</a> ()</td></tr>
<tr class="separator:acda37b3719dc71d8caddd1d39ca215db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74b480a928c4e1972270a410dd3e214"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac74b480a928c4e1972270a410dd3e214">createAsyncRuntimeRefCountingPass</a> ()</td></tr>
<tr class="separator:ac74b480a928c4e1972270a410dd3e214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29ec7fe477dccf07bddf61bec9c3ac7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac29ec7fe477dccf07bddf61bec9c3ac7">createAsyncRuntimeRefCountingOptPass</a> ()</td></tr>
<tr class="separator:ac29ec7fe477dccf07bddf61bec9c3ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c5cda96fda85b96d4c5786f58680bd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a89c5cda96fda85b96d4c5786f58680bd">createAsyncRuntimePolicyBasedRefCountingPass</a> ()</td></tr>
<tr class="separator:a89c5cda96fda85b96d4c5786f58680bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790a3bb4de1793749c35325783ab5107"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class PoisonAttr  = ub::PoisonAttr, class CalculationT  = function_ref&lt;              std::optional&lt;ElementValueT&gt;(ElementValueT, ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:a790a3bb4de1793749c35325783ab5107"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a790a3bb4de1793749c35325783ab5107">constFoldBinaryOpConditional</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, CalculationT &amp;&amp;calculate)</td></tr>
<tr class="memdesc:a790a3bb4de1793749c35325783ab5107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs constant folding <code>calculate</code> with element-wise behavior on the two attributes in <code>operands</code> and returns the result if possible.  <a href="namespacemlir.html#a790a3bb4de1793749c35325783ab5107">More...</a><br /></td></tr>
<tr class="separator:a790a3bb4de1793749c35325783ab5107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1febec8a9cbec424911c290ed1b574"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class PoisonAttr  = ub::PoisonAttr, class CalculationT  = function_ref&lt;              std::optional&lt;ElementValueT&gt;(ElementValueT, ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:a9e1febec8a9cbec424911c290ed1b574"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9e1febec8a9cbec424911c290ed1b574">constFoldBinaryOpConditional</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, CalculationT &amp;&amp;calculate)</td></tr>
<tr class="memdesc:a9e1febec8a9cbec424911c290ed1b574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs constant folding <code>calculate</code> with element-wise behavior on the two attributes in <code>operands</code> and returns the result if possible.  <a href="namespacemlir.html#a9e1febec8a9cbec424911c290ed1b574">More...</a><br /></td></tr>
<tr class="separator:a9e1febec8a9cbec424911c290ed1b574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fdc959472e22be684140b76ece47d5"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class PoisonAttr  = void, class CalculationT  = function_ref&lt;ElementValueT(ElementValueT, ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:ad3fdc959472e22be684140b76ece47d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad3fdc959472e22be684140b76ece47d5">constFoldBinaryOp</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, CalculationT &amp;&amp;calculate)</td></tr>
<tr class="separator:ad3fdc959472e22be684140b76ece47d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b6240841ff6c3a830c2e638547d1c2"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class PoisonAttr  = ub::PoisonAttr, class CalculationT  = function_ref&lt;ElementValueT(ElementValueT, ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:ae0b6240841ff6c3a830c2e638547d1c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae0b6240841ff6c3a830c2e638547d1c2">constFoldBinaryOp</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, CalculationT &amp;&amp;calculate)</td></tr>
<tr class="separator:ae0b6240841ff6c3a830c2e638547d1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a44de2c24a2631be3084ffc5fd95431"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class PoisonAttr  = ub::PoisonAttr, class CalculationT  = function_ref&lt;std::optional&lt;ElementValueT&gt;(ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:a5a44de2c24a2631be3084ffc5fd95431"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5a44de2c24a2631be3084ffc5fd95431">constFoldUnaryOpConditional</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, CalculationT &amp;&amp;calculate)</td></tr>
<tr class="memdesc:a5a44de2c24a2631be3084ffc5fd95431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs constant folding <code>calculate</code> with element-wise behavior on the one attributes in <code>operands</code> and returns the result if possible.  <a href="namespacemlir.html#a5a44de2c24a2631be3084ffc5fd95431">More...</a><br /></td></tr>
<tr class="separator:a5a44de2c24a2631be3084ffc5fd95431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321429a6eb4c4480414e9a365d11caf6"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class PoisonAttr  = ub::PoisonAttr, class CalculationT  = function_ref&lt;ElementValueT(ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:a321429a6eb4c4480414e9a365d11caf6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a321429a6eb4c4480414e9a365d11caf6">constFoldUnaryOp</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, CalculationT &amp;&amp;calculate)</td></tr>
<tr class="separator:a321429a6eb4c4480414e9a365d11caf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2927f15718a47f9dfaa0090c2235e954"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT , class TargetAttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class TargetElementValueT  = typename TargetAttrElementT::ValueType, class PoisonAttr  = ub::PoisonAttr, class CalculationT  = function_ref&lt;TargetElementValueT(ElementValueT, bool)&gt;&gt; </td></tr>
<tr class="memitem:a2927f15718a47f9dfaa0090c2235e954"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2927f15718a47f9dfaa0090c2235e954">constFoldCastOp</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, <a class="el" href="classmlir_1_1Type.html">Type</a> resType, CalculationT &amp;&amp;calculate)</td></tr>
<tr class="separator:a2927f15718a47f9dfaa0090c2235e954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f173d8afb5bfa9aca23651433c1c3a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5f173d8afb5bfa9aca23651433c1c3a1">populateEmitCSizeTTypeConversions</a> (<a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="separator:a5f173d8afb5bfa9aca23651433c1c3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6c390c632d0dfd004c2b3459720f45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3f6c390c632d0dfd004c2b3459720f45">populateDecomposeCallGraphTypesPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1ValueDecomposer.html">ValueDecomposer</a> &amp;decomposer, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a3f6c390c632d0dfd004c2b3459720f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the patterns needed to drive the conversion process for decomposing call graph types with the given <code><a class="el" href="classmlir_1_1ValueDecomposer.html" title="This class provides a hook that expands one Value into multiple Value&#39;s, with a TypeConverter-inspire...">ValueDecomposer</a></code>.  <a href="namespacemlir.html#a3f6c390c632d0dfd004c2b3459720f45">More...</a><br /></td></tr>
<tr class="separator:a3f6c390c632d0dfd004c2b3459720f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2564dc4e65f0be3ee7ceb257b620e80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab2564dc4e65f0be3ee7ceb257b620e80">populateCallOpTypeConversionPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="memdesc:ab2564dc4e65f0be3ee7ceb257b620e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pattern to the given pattern list to convert the operand and result types of a CallOp with the given type converter.  <a href="namespacemlir.html#ab2564dc4e65f0be3ee7ceb257b620e80">More...</a><br /></td></tr>
<tr class="separator:ab2564dc4e65f0be3ee7ceb257b620e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf0dbbf2d29448b8f9d7783f060d2aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aacf0dbbf2d29448b8f9d7783f060d2aa">populateBranchOpInterfaceTypeConversionPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(BranchOpInterface branchOp, int idx)&gt; shouldConvertBranchOperand=nullptr)</td></tr>
<tr class="memdesc:aacf0dbbf2d29448b8f9d7783f060d2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pattern to the given pattern list to rewrite branch operations to use operands that have been legalized by the conversion framework.  <a href="namespacemlir.html#aacf0dbbf2d29448b8f9d7783f060d2aa">More...</a><br /></td></tr>
<tr class="separator:aacf0dbbf2d29448b8f9d7783f060d2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57575f33d64fcef5f5027164a59d87d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af57575f33d64fcef5f5027164a59d87d">isLegalForBranchOpInterfaceTypeConversionPattern</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="memdesc:af57575f33d64fcef5f5027164a59d87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if op is a BranchOpInterface op whose operands are all legal according to converter.  <a href="namespacemlir.html#af57575f33d64fcef5f5027164a59d87d">More...</a><br /></td></tr>
<tr class="separator:af57575f33d64fcef5f5027164a59d87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb212d1d50001fc703faf9a1575ccd2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adb212d1d50001fc703faf9a1575ccd2a">populateReturnOpTypeConversionPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="memdesc:adb212d1d50001fc703faf9a1575ccd2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pattern to the given pattern list to rewrite <code>return</code> ops to use operands that have been legalized by the conversion framework.  <a href="namespacemlir.html#adb212d1d50001fc703faf9a1575ccd2a">More...</a><br /></td></tr>
<tr class="separator:adb212d1d50001fc703faf9a1575ccd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4d325aad6186114a919156b25b29bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0a4d325aad6186114a919156b25b29bc">isLegalForReturnOpTypeConversionPattern</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter, bool returnOpAlwaysLegal=false)</td></tr>
<tr class="memdesc:a0a4d325aad6186114a919156b25b29bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">For ReturnLike ops (except <code>return</code>), return True.  <a href="namespacemlir.html#a0a4d325aad6186114a919156b25b29bc">More...</a><br /></td></tr>
<tr class="separator:a0a4d325aad6186114a919156b25b29bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625259a35e521a9f6d7b7fe115423e87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a625259a35e521a9f6d7b7fe115423e87">isNotBranchOpInterfaceOrReturnLikeOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a625259a35e521a9f6d7b7fe115423e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if op is neither BranchOpInterface nor ReturnLike.  <a href="namespacemlir.html#a625259a35e521a9f6d7b7fe115423e87">More...</a><br /></td></tr>
<tr class="separator:a625259a35e521a9f6d7b7fe115423e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da469115de233ce1c98f2ff68cd67be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1da469115de233ce1c98f2ff68cd67be">populateFuncTypeConversionPatterns</a> (const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a1da469115de233ce1c98f2ff68cd67be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7173c36d6b113dcdb0599eb672526b43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7173c36d6b113dcdb0599eb672526b43">promoteToWorkgroupMemory</a> (gpu::GPUFuncOp op, unsigned arg)</td></tr>
<tr class="memdesc:a7173c36d6b113dcdb0599eb672526b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes a function argument to workgroup memory in the given function.  <a href="namespacemlir.html#a7173c36d6b113dcdb0599eb672526b43">More...</a><br /></td></tr>
<tr class="separator:a7173c36d6b113dcdb0599eb672526b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66200178a198c2f8aae15e94882f0788"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a66200178a198c2f8aae15e94882f0788">createGpuLauchSinkIndexComputationsPass</a> ()</td></tr>
<tr class="memdesc:a66200178a198c2f8aae15e94882f0788"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> that moves ops which are likely an index computation into gpu.launch body.  <a href="namespacemlir.html#a66200178a198c2f8aae15e94882f0788">More...</a><br /></td></tr>
<tr class="separator:a66200178a198c2f8aae15e94882f0788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae628f55b8a69b490ef848ceb63d234b9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae628f55b8a69b490ef848ceb63d234b9">createGpuKernelOutliningPass</a> (StringRef dataLayoutStr=StringRef())</td></tr>
<tr class="memdesc:ae628f55b8a69b490ef848ceb63d234b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces <code>gpu.launch</code> with <code>gpu.launch_func</code> by moving the region into a separate kernel function.  <a href="namespacemlir.html#ae628f55b8a69b490ef848ceb63d234b9">More...</a><br /></td></tr>
<tr class="separator:ae628f55b8a69b490ef848ceb63d234b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd2637570ab4c74519de8ed73747b5f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8bd2637570ab4c74519de8ed73747b5f">createGpuAsyncRegionPass</a> ()</td></tr>
<tr class="memdesc:a8bd2637570ab4c74519de8ed73747b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites a function region so that GPU ops execute asynchronously.  <a href="namespacemlir.html#a8bd2637570ab4c74519de8ed73747b5f">More...</a><br /></td></tr>
<tr class="separator:a8bd2637570ab4c74519de8ed73747b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc65540e2fcc88965c99cf18236192b4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acc65540e2fcc88965c99cf18236192b4">createGpuMapParallelLoopsPass</a> ()</td></tr>
<tr class="memdesc:acc65540e2fcc88965c99cf18236192b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the parallel loops found in the given function to workgroups.  <a href="namespacemlir.html#acc65540e2fcc88965c99cf18236192b4">More...</a><br /></td></tr>
<tr class="separator:acc65540e2fcc88965c99cf18236192b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352a5fec8fc09705220c6ed268d15709"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a352a5fec8fc09705220c6ed268d15709">populateGpuGlobalIdPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a352a5fec8fc09705220c6ed268d15709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to rewrite GlobalIdOp op within the GPU dialect.  <a href="namespacemlir.html#a352a5fec8fc09705220c6ed268d15709">More...</a><br /></td></tr>
<tr class="separator:a352a5fec8fc09705220c6ed268d15709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cdef2da7628821e92464510d6556332"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1cdef2da7628821e92464510d6556332">populateGpuShufflePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a1cdef2da7628821e92464510d6556332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to rewrite shuffle ops within the GPU dialect.  <a href="namespacemlir.html#a1cdef2da7628821e92464510d6556332">More...</a><br /></td></tr>
<tr class="separator:a1cdef2da7628821e92464510d6556332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9701a7692a76e65edd69bd6f22156776"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9701a7692a76e65edd69bd6f22156776">populateGpuAllReducePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a9701a7692a76e65edd69bd6f22156776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to rewrite all-reduce ops within the GPU dialect.  <a href="namespacemlir.html#a9701a7692a76e65edd69bd6f22156776">More...</a><br /></td></tr>
<tr class="separator:a9701a7692a76e65edd69bd6f22156776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57dcf9ca48416677b4f10118916da61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab57dcf9ca48416677b4f10118916da61">populateGpuBreakDownSubgroupReducePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, unsigned maxShuffleBitwidth=32, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:ab57dcf9ca48416677b4f10118916da61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to break down subgroup_reduce ops into smaller ones supported by the target of <code>size &lt;= maxShuffleBitwidth</code>, where <code>size</code> is the subgroup_reduce value bitwidth.  <a href="namespacemlir.html#ab57dcf9ca48416677b4f10118916da61">More...</a><br /></td></tr>
<tr class="separator:ab57dcf9ca48416677b4f10118916da61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c34168191ab5b4336dd5a832eab08e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6c34168191ab5b4336dd5a832eab08e0">populateGpuLowerSubgroupReduceToShufflePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, unsigned subgroupSize, unsigned shuffleBitwidth=32, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a6c34168191ab5b4336dd5a832eab08e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to lower <code>gpu.subgroup_reduce</code> into <code>gpu.shuffle</code> ops over <code>shuffleBitwidth</code> scalar types.  <a href="namespacemlir.html#a6c34168191ab5b4336dd5a832eab08e0">More...</a><br /></td></tr>
<tr class="separator:a6c34168191ab5b4336dd5a832eab08e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7feacef2681f1cb159920f8a6ed188ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7feacef2681f1cb159920f8a6ed188ad">populateGpuLowerClusteredSubgroupReduceToShufflePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, unsigned subgroupSize, unsigned shuffleBitwidth=32, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a7feacef2681f1cb159920f8a6ed188ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjoint counterpart of <code>populateGpuLowerSubgroupReduceToShufflePatterns</code> that only matches <code>gpu.subgroup_reduce</code> ops with a <code>cluster_size</code>.  <a href="namespacemlir.html#a7feacef2681f1cb159920f8a6ed188ad">More...</a><br /></td></tr>
<tr class="separator:a7feacef2681f1cb159920f8a6ed188ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae1d309360c9e54edaa39ddb48d3ea1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4ae1d309360c9e54edaa39ddb48d3ea1">populateGpuRewritePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a4ae1d309360c9e54edaa39ddb48d3ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect all patterns to rewrite ops within the GPU dialect.  <a href="namespacemlir.html#a4ae1d309360c9e54edaa39ddb48d3ea1">More...</a><br /></td></tr>
<tr class="separator:a4ae1d309360c9e54edaa39ddb48d3ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ea23f9a62b16d2214c2e70f282c5c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac0ea23f9a62b16d2214c2e70f282c5c1">populateGpuDecomposeMemrefsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ac0ea23f9a62b16d2214c2e70f282c5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to decompose memrefs ops.  <a href="namespacemlir.html#ac0ea23f9a62b16d2214c2e70f282c5c1">More...</a><br /></td></tr>
<tr class="separator:ac0ea23f9a62b16d2214c2e70f282c5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f5fa04ae55102b2acaeb79274545da"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a94f5fa04ae55102b2acaeb79274545da">createGpuDecomposeMemrefsPass</a> ()</td></tr>
<tr class="memdesc:a94f5fa04ae55102b2acaeb79274545da"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> decomposes memref ops inside <code>gpu.launch</code> body.  <a href="namespacemlir.html#a94f5fa04ae55102b2acaeb79274545da">More...</a><br /></td></tr>
<tr class="separator:a94f5fa04ae55102b2acaeb79274545da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5eff4e5da432d2edf4f655585785460"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af5eff4e5da432d2edf4f655585785460">populateGpuEliminateBarriersPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:af5eff4e5da432d2edf4f655585785460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase barriers that do not enforce conflicting memory side effects.  <a href="namespacemlir.html#af5eff4e5da432d2edf4f655585785460">More...</a><br /></td></tr>
<tr class="separator:af5eff4e5da432d2edf4f655585785460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9152a09d079148a1a2f40d4946f7c17"><td class="memItemLeft" align="right" valign="top">gpu::GPUFuncOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae9152a09d079148a1a2f40d4946f7c17">outlineKernelFunc</a> (gpu::LaunchOp launchOp, StringRef kernelFnName, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;operands)</td></tr>
<tr class="memdesc:ae9152a09d079148a1a2f40d4946f7c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a gpu.func created from outlining the region of a gpu.launch op with the given <code>kernelFnName</code>.  <a href="namespacemlir.html#ae9152a09d079148a1a2f40d4946f7c17">More...</a><br /></td></tr>
<tr class="separator:ae9152a09d079148a1a2f40d4946f7c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e007ae66428f560626d4ba3c58dfe2"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa6e007ae66428f560626d4ba3c58dfe2">sinkOperationsIntoLaunchOp</a> (gpu::LaunchOp launchOp, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; isSinkingBeneficiary)</td></tr>
<tr class="memdesc:aa6e007ae66428f560626d4ba3c58dfe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink operations into the <code>launchOp</code> to reduce the number of values that are used within the region of the operation, but defined outside of the region.  <a href="namespacemlir.html#aa6e007ae66428f560626d4ba3c58dfe2">More...</a><br /></td></tr>
<tr class="separator:aa6e007ae66428f560626d4ba3c58dfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095b024ace01a15b05be2f298195850e"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a095b024ace01a15b05be2f298195850e">parseSemiFunctionType</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;argumentType, <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;resultType)</td></tr>
<tr class="memdesc:a095b024ace01a15b05be2f298195850e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a single non-function type or a function type with at least one argument.  <a href="namespacemlir.html#a095b024ace01a15b05be2f298195850e">More...</a><br /></td></tr>
<tr class="separator:a095b024ace01a15b05be2f298195850e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee9c22e4e76e3de2f4c6da9783145a4"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3ee9c22e4e76e3de2f4c6da9783145a4">parseSemiFunctionType</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;argumentType, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;resultTypes)</td></tr>
<tr class="separator:a3ee9c22e4e76e3de2f4c6da9783145a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979423818fdead0e008345256a1e2d10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a979423818fdead0e008345256a1e2d10">printSemiFunctionType</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Type.html">Type</a> argumentType, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> resultType)</td></tr>
<tr class="memdesc:a979423818fdead0e008345256a1e2d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints argument and result types in a syntax similar to that of FunctionType but allowing and requiring one to omit the parens around the argument type in absence of result types, and without the trailing <code>-&gt; ()</code>.  <a href="namespacemlir.html#a979423818fdead0e008345256a1e2d10">More...</a><br /></td></tr>
<tr class="separator:a979423818fdead0e008345256a1e2d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5759ad12a88abff67b9657ca557bbcf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5759ad12a88abff67b9657ca557bbcf3">printSemiFunctionType</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Type.html">Type</a> argumentType, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType)</td></tr>
<tr class="separator:a5759ad12a88abff67b9657ca557bbcf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad882bbe96acab6803e205bac71f694fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad882bbe96acab6803e205bac71f694fe">populateExpandCtlzPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:ad882bbe96acab6803e205bac71f694fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e85fbc0b8884dd2405be7b78b0c8e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a84e85fbc0b8884dd2405be7b78b0c8e7">populateExpandTanPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a84e85fbc0b8884dd2405be7b78b0c8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06045eacdfd93245579eba16924771b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a06045eacdfd93245579eba16924771b5">populateExpandSinhPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a06045eacdfd93245579eba16924771b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4e84ddbc3228f4fc5592ef3892171b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9d4e84ddbc3228f4fc5592ef3892171b">populateExpandCoshPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a9d4e84ddbc3228f4fc5592ef3892171b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbc60c17752a76af9b0f28ffa36d4f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2fbc60c17752a76af9b0f28ffa36d4f9">populateExpandTanhPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a2fbc60c17752a76af9b0f28ffa36d4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90a77b67aaeebb4186d1c5906618ac4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad90a77b67aaeebb4186d1c5906618ac4">populateExpandAsinhPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:ad90a77b67aaeebb4186d1c5906618ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6bf3e42ad0de0e8b55002b0ec60756"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4b6bf3e42ad0de0e8b55002b0ec60756">populateExpandAcoshPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a4b6bf3e42ad0de0e8b55002b0ec60756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae611d296fc5c823d51a12603ec8f5145"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae611d296fc5c823d51a12603ec8f5145">populateExpandAtanhPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:ae611d296fc5c823d51a12603ec8f5145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377a5d6d036008ba5e6416dc651dba6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a377a5d6d036008ba5e6416dc651dba6e">populateExpandFmaFPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a377a5d6d036008ba5e6416dc651dba6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d52687fa07fb3c88f0d4f19471094a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af4d52687fa07fb3c88f0d4f19471094a">populateExpandFloorFPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:af4d52687fa07fb3c88f0d4f19471094a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d2110655a5086ecee6eac3405c8e25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac9d2110655a5086ecee6eac3405c8e25">populateExpandCeilFPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:ac9d2110655a5086ecee6eac3405c8e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d2ac5ca6fe4c18adb5d7c32da4d914"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab7d2ac5ca6fe4c18adb5d7c32da4d914">populateExpandExp2FPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:ab7d2ac5ca6fe4c18adb5d7c32da4d914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760b455909b9e4e765071fa20fbd6aef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a760b455909b9e4e765071fa20fbd6aef">populateExpandPowFPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a760b455909b9e4e765071fa20fbd6aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53afead42f935771f9b0216159302004"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a53afead42f935771f9b0216159302004">populateExpandFPowIPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a53afead42f935771f9b0216159302004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7559586e5b98d3d19dd9b234ee93b39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa7559586e5b98d3d19dd9b234ee93b39">populateExpandRoundFPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:aa7559586e5b98d3d19dd9b234ee93b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53fc446b430869ef74c6382f675b1ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae53fc446b430869ef74c6382f675b1ba">populateExpandRoundEvenPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:ae53fc446b430869ef74c6382f675b1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2721b4426839ca6cc30843669e9bea6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2721b4426839ca6cc30843669e9bea6e">populateExpandRsqrtPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a2721b4426839ca6cc30843669e9bea6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747b91bacc09bde115c3e891deb5ebe5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a747b91bacc09bde115c3e891deb5ebe5">populateMathAlgebraicSimplificationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a747b91bacc09bde115c3e891deb5ebe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350315b238bcca2eb1b91364e55deaf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a350315b238bcca2eb1b91364e55deaf4">populatePolynomialApproximateTanhPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a350315b238bcca2eb1b91364e55deaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3114521ec355e66601d128ab0cb9426f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3114521ec355e66601d128ab0cb9426f">populatePolynomialApproximateErfPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a3114521ec355e66601d128ab0cb9426f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada84ecb306c38b4e2a547962acc98dfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ada84ecb306c38b4e2a547962acc98dfd">populateMathPolynomialApproximationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="structmlir_1_1MathPolynomialApproximationOptions.html">MathPolynomialApproximationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>={})</td></tr>
<tr class="separator:ada84ecb306c38b4e2a547962acc98dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54519be832df231094e4e22a067bde19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a54519be832df231094e4e22a067bde19">populateUpliftToFMAPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a54519be832df231094e4e22a067bde19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e879c874e4fdc6aaf9d4742abdb876"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac7e879c874e4fdc6aaf9d4742abdb876">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="structmlir_1_1Range.html">Range</a> &amp;range)</td></tr>
<tr class="separator:ac7e879c874e4fdc6aaf9d4742abdb876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e134959101de052e7dbfd12610b5d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a>, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a45e134959101de052e7dbfd12610b5d6">getOrCreateRanges</a> (OffsetSizeAndStrideOpInterface op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a45e134959101de052e7dbfd12610b5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of <a class="el" href="structmlir_1_1Range.html" title="Represents a range (offset, size, and stride) where each element of the triple may be dynamic or stat...">Range</a> (i.e.  <a href="namespacemlir.html#a45e134959101de052e7dbfd12610b5d6">More...</a><br /></td></tr>
<tr class="separator:a45e134959101de052e7dbfd12610b5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2a7464fefab1d85cec445e487f0d0c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8c2a7464fefab1d85cec445e487f0d0c">createSCFBufferizePass</a> ()</td></tr>
<tr class="memdesc:a8c2a7464fefab1d85cec445e487f0d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that bufferizes the SCF dialect.  <a href="namespacemlir.html#a8c2a7464fefab1d85cec445e487f0d0c">More...</a><br /></td></tr>
<tr class="separator:a8c2a7464fefab1d85cec445e487f0d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d49e4ae28aeaaa552466850cc5e04ec"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1d49e4ae28aeaaa552466850cc5e04ec">createForLoopSpecializationPass</a> ()</td></tr>
<tr class="memdesc:a1d49e4ae28aeaaa552466850cc5e04ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that specializes for loop for unrolling and vectorization.  <a href="namespacemlir.html#a1d49e4ae28aeaaa552466850cc5e04ec">More...</a><br /></td></tr>
<tr class="separator:a1d49e4ae28aeaaa552466850cc5e04ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acfeadb8fff74a53be77ccf540be99b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7acfeadb8fff74a53be77ccf540be99b">createForLoopPeelingPass</a> ()</td></tr>
<tr class="memdesc:a7acfeadb8fff74a53be77ccf540be99b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that peels for loops at their upper bounds for better vectorization.  <a href="namespacemlir.html#a7acfeadb8fff74a53be77ccf540be99b">More...</a><br /></td></tr>
<tr class="separator:a7acfeadb8fff74a53be77ccf540be99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f8ebf7a2133d1c68cea6e20fba0ea8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac7f8ebf7a2133d1c68cea6e20fba0ea8">createSCFForLoopCanonicalizationPass</a> ()</td></tr>
<tr class="memdesc:ac7f8ebf7a2133d1c68cea6e20fba0ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that canonicalizes affine.min and affine.max operations inside of scf.for loops with known lower and upper bounds.  <a href="namespacemlir.html#ac7f8ebf7a2133d1c68cea6e20fba0ea8">More...</a><br /></td></tr>
<tr class="separator:ac7f8ebf7a2133d1c68cea6e20fba0ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03de4687b73fcc63bfde7e0dda6b741"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab03de4687b73fcc63bfde7e0dda6b741">createTestSCFParallelLoopCollapsingPass</a> ()</td></tr>
<tr class="memdesc:ab03de4687b73fcc63bfde7e0dda6b741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that transforms a single ParallelLoop over N induction variables into another ParallelLoop over less than N induction variables.  <a href="namespacemlir.html#ab03de4687b73fcc63bfde7e0dda6b741">More...</a><br /></td></tr>
<tr class="separator:ab03de4687b73fcc63bfde7e0dda6b741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00701d01638289dd08ec9e255076f50"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad00701d01638289dd08ec9e255076f50">createParallelLoopFusionPass</a> ()</td></tr>
<tr class="memdesc:ad00701d01638289dd08ec9e255076f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop fusion pass which fuses parallel loops.  <a href="namespacemlir.html#ad00701d01638289dd08ec9e255076f50">More...</a><br /></td></tr>
<tr class="separator:ad00701d01638289dd08ec9e255076f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b9f8678ec66eed9c66536834540184"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a16b9f8678ec66eed9c66536834540184">createParallelLoopSpecializationPass</a> ()</td></tr>
<tr class="memdesc:a16b9f8678ec66eed9c66536834540184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that specializes parallel loop for unrolling and vectorization.  <a href="namespacemlir.html#a16b9f8678ec66eed9c66536834540184">More...</a><br /></td></tr>
<tr class="separator:a16b9f8678ec66eed9c66536834540184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e453b62efd8209d12c5c0f43c409952"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1e453b62efd8209d12c5c0f43c409952">createParallelLoopTilingPass</a> (<a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; int64_t &gt; tileSize={}, bool noMinMaxBounds=false)</td></tr>
<tr class="memdesc:a1e453b62efd8209d12c5c0f43c409952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which tiles innermost parallel loops.  <a href="namespacemlir.html#a1e453b62efd8209d12c5c0f43c409952">More...</a><br /></td></tr>
<tr class="separator:a1e453b62efd8209d12c5c0f43c409952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6597022fdb6de5a99b895b2bfc9e0a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2a6597022fdb6de5a99b895b2bfc9e0a">createForLoopRangeFoldingPass</a> ()</td></tr>
<tr class="memdesc:a2a6597022fdb6de5a99b895b2bfc9e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which folds arith ops on induction variable into loop range.  <a href="namespacemlir.html#a2a6597022fdb6de5a99b895b2bfc9e0a">More...</a><br /></td></tr>
<tr class="separator:a2a6597022fdb6de5a99b895b2bfc9e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e00e282baf336b34a2bb6252d163b3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a20e00e282baf336b34a2bb6252d163b3">createForallToForLoopPass</a> ()</td></tr>
<tr class="memdesc:a20e00e282baf336b34a2bb6252d163b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that converts SCF forall loops to SCF for loops.  <a href="namespacemlir.html#a20e00e282baf336b34a2bb6252d163b3">More...</a><br /></td></tr>
<tr class="separator:a20e00e282baf336b34a2bb6252d163b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe217f8821de800b3899f931875c1c4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0fe217f8821de800b3899f931875c1c4">createForallToParallelLoopPass</a> ()</td></tr>
<tr class="memdesc:a0fe217f8821de800b3899f931875c1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that converts SCF forall loops to SCF parallel loops.  <a href="namespacemlir.html#a0fe217f8821de800b3899f931875c1c4">More...</a><br /></td></tr>
<tr class="separator:a0fe217f8821de800b3899f931875c1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76018eef454fd668d103ea3cc6afc52a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a76018eef454fd668d103ea3cc6afc52a">createForToWhileLoopPass</a> ()</td></tr>
<tr class="separator:a76018eef454fd668d103ea3cc6afc52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210a664ca21b677121c83e0589945a86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; scf::ForOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a210a664ca21b677121c83e0589945a86">replaceLoopNestWithNewYields</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; scf::ForOp &gt; loopNest, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newIterOperands, const <a class="el" href="namespacemlir.html#a70a2f522a6f1ebf6ac3b3ba85a12b9e4">NewYieldValuesFn</a> &amp;newYieldValuesFn, bool replaceIterOperandsUsesInLoop=true)</td></tr>
<tr class="memdesc:a210a664ca21b677121c83e0589945a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a perfectly nested loop nest to yield new values from the innermost loop and propagating it up through the loop nest.  <a href="namespacemlir.html#a210a664ca21b677121c83e0589945a86">More...</a><br /></td></tr>
<tr class="separator:a210a664ca21b677121c83e0589945a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdec8fa23b93085ee2e142defd7c5599"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; func::FuncOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abdec8fa23b93085ee2e142defd7c5599">outlineSingleBlockRegion</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, StringRef funcName, func::CallOp *callOp=nullptr)</td></tr>
<tr class="memdesc:abdec8fa23b93085ee2e142defd7c5599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outline a region with a single block into a new FuncOp.  <a href="namespacemlir.html#abdec8fa23b93085ee2e142defd7c5599">More...</a><br /></td></tr>
<tr class="separator:abdec8fa23b93085ee2e142defd7c5599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10aad3624e000c0585087c96357ea857"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a10aad3624e000c0585087c96357ea857">outlineIfOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, scf::IfOp ifOp, func::FuncOp *thenFn, StringRef thenFnName, func::FuncOp *elseFn, StringRef elseFnName)</td></tr>
<tr class="memdesc:a10aad3624e000c0585087c96357ea857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outline the then and/or else regions of <code>ifOp</code> as follows:  <a href="namespacemlir.html#a10aad3624e000c0585087c96357ea857">More...</a><br /></td></tr>
<tr class="separator:a10aad3624e000c0585087c96357ea857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820f3296c3cd59eaed418f42f874a217"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a820f3296c3cd59eaed418f42f874a217">getInnermostParallelLoops</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *rootOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; scf::ParallelOp &gt; &amp;result)</td></tr>
<tr class="memdesc:a820f3296c3cd59eaed418f42f874a217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of innermost parallel loops contained in <code>rootOp</code>.  <a href="namespacemlir.html#a820f3296c3cd59eaed418f42f874a217">More...</a><br /></td></tr>
<tr class="separator:a820f3296c3cd59eaed418f42f874a217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22ed238130b85dadcd9f75892b540b1"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::pair&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab22ed238130b85dadcd9f75892b540b1">getSCFMinMaxExpr</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dims, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;symbols, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; loopFilter=nullptr)</td></tr>
<tr class="memdesc:ab22ed238130b85dadcd9f75892b540b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the min/max expressions for <code>value</code> if it is an induction variable from scf.for or scf.parallel loop.  <a href="namespacemlir.html#ab22ed238130b85dadcd9f75892b540b1">More...</a><br /></td></tr>
<tr class="separator:ab22ed238130b85dadcd9f75892b540b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d3795f1b83fc9e56398102edb81bd4"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad6d3795f1b83fc9e56398102edb81bd4">coalesceLoops</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; scf::ForOp &gt; loops)</td></tr>
<tr class="memdesc:ad6d3795f1b83fc9e56398102edb81bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a perfect nest of "for" loops with a single linearized loop.  <a href="namespacemlir.html#ad6d3795f1b83fc9e56398102edb81bd4">More...</a><br /></td></tr>
<tr class="separator:ad6d3795f1b83fc9e56398102edb81bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbbec94f6bbf0a536fa87c73dd4c61b"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abfbbec94f6bbf0a536fa87c73dd4c61b">coalesceLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; scf::ForOp &gt;)</td></tr>
<tr class="separator:abfbbec94f6bbf0a536fa87c73dd4c61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a046fcc3a4da7eb0d54f9f6a65c3c5"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a39a046fcc3a4da7eb0d54f9f6a65c3c5">coalescePerfectlyNestedSCFForLoops</a> (scf::ForOp op)</td></tr>
<tr class="memdesc:a39a046fcc3a4da7eb0d54f9f6a65c3c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk an affine.for to find a band to coalesce.  <a href="namespacemlir.html#a39a046fcc3a4da7eb0d54f9f6a65c3c5">More...</a><br /></td></tr>
<tr class="separator:a39a046fcc3a4da7eb0d54f9f6a65c3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56042c88e158beeafccbff36bdc1cb42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a56042c88e158beeafccbff36bdc1cb42">collapseParallelLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, scf::ParallelOp loops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::vector&lt; unsigned &gt;&gt; combinedDimensions)</td></tr>
<tr class="memdesc:a56042c88e158beeafccbff36bdc1cb42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the ParallelLoop and for each set of dimension indices, combine them into a single dimension.  <a href="namespacemlir.html#a56042c88e158beeafccbff36bdc1cb42">More...</a><br /></td></tr>
<tr class="separator:a56042c88e158beeafccbff36bdc1cb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040c47f3f5d15eecb05a18c6343df489"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a040c47f3f5d15eecb05a18c6343df489">loopUnrollByFactor</a> (scf::ForOp forOp, uint64_t unrollFactor, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(unsigned, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt; annotateFn=nullptr)</td></tr>
<tr class="memdesc:a040c47f3f5d15eecb05a18c6343df489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls this for operation by the specified unroll factor.  <a href="namespacemlir.html#a040c47f3f5d15eecb05a18c6343df489">More...</a><br /></td></tr>
<tr class="separator:a040c47f3f5d15eecb05a18c6343df489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0b0e4e1d0aa48d157009f2f9530492"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7f0b0e4e1d0aa48d157009f2f9530492">loopUnrollJamByFactor</a> (scf::ForOp forOp, uint64_t unrollFactor)</td></tr>
<tr class="memdesc:a7f0b0e4e1d0aa48d157009f2f9530492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls and jams this <code>scf.for</code> operation by the specified unroll factor.  <a href="namespacemlir.html#a7f0b0e4e1d0aa48d157009f2f9530492">More...</a><br /></td></tr>
<tr class="separator:a7f0b0e4e1d0aa48d157009f2f9530492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf5a29768872240e0bbd49d969f084b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1Range.html">Range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aecf5a29768872240e0bbd49d969f084b">emitNormalizedLoopBounds</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> lb, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ub, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> step)</td></tr>
<tr class="memdesc:aecf5a29768872240e0bbd49d969f084b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize bounds and step of a zero-based and unit-step loop derived by normalizing the specified bounds and step.  <a href="namespacemlir.html#aecf5a29768872240e0bbd49d969f084b">More...</a><br /></td></tr>
<tr class="separator:aecf5a29768872240e0bbd49d969f084b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad9612c1d4f11375369c3d1b2029b5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acad9612c1d4f11375369c3d1b2029b5c">denormalizeInductionVariable</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> normalizedIv, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> origLb, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> origStep)</td></tr>
<tr class="memdesc:acad9612c1d4f11375369c3d1b2029b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get back the original induction variable values after loop normalization.  <a href="namespacemlir.html#acad9612c1d4f11375369c3d1b2029b5c">More...</a><br /></td></tr>
<tr class="separator:acad9612c1d4f11375369c3d1b2029b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdaa20d0acb7aec0f05cb700b1e09df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a3f0d45d0562d47acc2c42934ccbfea19">TileLoops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aecdaa20d0acb7aec0f05cb700b1e09df">extractFixedOuterLoops</a> (scf::ForOp rootFOrOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizes)</td></tr>
<tr class="separator:aecdaa20d0acb7aec0f05cb700b1e09df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15bd4c107bb9ea52b7fcc11c283c129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab15bd4c107bb9ea52b7fcc11c283c129">tile</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt; forOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt; targets)</td></tr>
<tr class="memdesc:ab15bd4c107bb9ea52b7fcc11c283c129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tiling fo imperfectly nested loops (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under each of the <code>targets</code>.  <a href="namespacemlir.html#ab15bd4c107bb9ea52b7fcc11c283c129">More...</a><br /></td></tr>
<tr class="separator:ab15bd4c107bb9ea52b7fcc11c283c129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3ac25a4d763e0e5234f6b347c7f17a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adb3ac25a4d763e0e5234f6b347c7f17a">tile</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt; forOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizes, scf::ForOp target)</td></tr>
<tr class="memdesc:adb3ac25a4d763e0e5234f6b347c7f17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tiling (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under <code>target</code>.  <a href="namespacemlir.html#adb3ac25a4d763e0e5234f6b347c7f17a">More...</a><br /></td></tr>
<tr class="separator:adb3ac25a4d763e0e5234f6b347c7f17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76588ffa46e04caaa584360fa5cdde4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a76588ffa46e04caaa584360fa5cdde4c">tilePerfectlyNested</a> (scf::ForOp rootForOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizes)</td></tr>
<tr class="memdesc:a76588ffa46e04caaa584360fa5cdde4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile a nest of scf::ForOp loops rooted at <code>rootForOp</code> with the given (parametric) sizes.  <a href="namespacemlir.html#a76588ffa46e04caaa584360fa5cdde4c">More...</a><br /></td></tr>
<tr class="separator:a76588ffa46e04caaa584360fa5cdde4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002c6258ba17b3a08e25cde241861c3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a002c6258ba17b3a08e25cde241861c3f">getPerfectlyNestedLoops</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; scf::ForOp &gt; &amp;nestedLoops, scf::ForOp root)</td></tr>
<tr class="memdesc:a002c6258ba17b3a08e25cde241861c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get perfectly nested sequence of loops starting at root of loop nest (the first op being another AffineFor, and the second op - a terminator).  <a href="namespacemlir.html#a002c6258ba17b3a08e25cde241861c3f">More...</a><br /></td></tr>
<tr class="separator:a002c6258ba17b3a08e25cde241861c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfbb5ad3709577536fd8002ed734921"><td class="memItemLeft" align="right" valign="top">scf::ForallOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acdfbb5ad3709577536fd8002ed734921">fuseIndependentSiblingForallLoops</a> (scf::ForallOp target, scf::ForallOp source, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter)</td></tr>
<tr class="memdesc:acdfbb5ad3709577536fd8002ed734921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two scf.forall loops, <code>target</code> and <code>source</code>, fuses <code>target</code> into <code>source</code>.  <a href="namespacemlir.html#acdfbb5ad3709577536fd8002ed734921">More...</a><br /></td></tr>
<tr class="separator:acdfbb5ad3709577536fd8002ed734921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7634eaf008502f8ebca317ec4a1ad84"><td class="memItemLeft" align="right" valign="top">scf::ForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad7634eaf008502f8ebca317ec4a1ad84">fuseIndependentSiblingForLoops</a> (scf::ForOp target, scf::ForOp source, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter)</td></tr>
<tr class="memdesc:ad7634eaf008502f8ebca317ec4a1ad84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two scf.for loops, <code>target</code> and <code>source</code>, fuses <code>target</code> into <code>source</code>.  <a href="namespacemlir.html#ad7634eaf008502f8ebca317ec4a1ad84">More...</a><br /></td></tr>
<tr class="separator:ad7634eaf008502f8ebca317ec4a1ad84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff65ad1a751cdba6e58ef912d9ebaa8"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; scf::ForallOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afff65ad1a751cdba6e58ef912d9ebaa8">normalizeForallOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, scf::ForallOp forallOp)</td></tr>
<tr class="memdesc:afff65ad1a751cdba6e58ef912d9ebaa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize an <code>scf.forall</code> operation.  <a href="namespacemlir.html#afff65ad1a751cdba6e58ef912d9ebaa8">More...</a><br /></td></tr>
<tr class="separator:afff65ad1a751cdba6e58ef912d9ebaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050e7653e9cef5f155370ca0425994e9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a050e7653e9cef5f155370ca0425994e9">createShapeToShapeLowering</a> ()</td></tr>
<tr class="memdesc:a050e7653e9cef5f155370ca0425994e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the ShapeToShapeLowering pass that legalizes Shape dialect to be convertible to Arith.  <a href="namespacemlir.html#a050e7653e9cef5f155370ca0425994e9">More...</a><br /></td></tr>
<tr class="separator:a050e7653e9cef5f155370ca0425994e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068b739b7424900d4d98c15c81e4609e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a068b739b7424900d4d98c15c81e4609e">populateShapeRewritePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a068b739b7424900d4d98c15c81e4609e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects a set of patterns to rewrite ops within the Shape dialect.  <a href="namespacemlir.html#a068b739b7424900d4d98c15c81e4609e">More...</a><br /></td></tr>
<tr class="separator:a068b739b7424900d4d98c15c81e4609e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac260b877914dd5ce7bf80eb50ff87a4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac260b877914dd5ce7bf80eb50ff87a4b">populateRemoveShapeConstraintsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:ac260b877914dd5ce7bf80eb50ff87a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79c79f5d3c3fd8668be6d76e33bad9a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad79c79f5d3c3fd8668be6d76e33bad9a">createRemoveShapeConstraintsPass</a> ()</td></tr>
<tr class="separator:ad79c79f5d3c3fd8668be6d76e33bad9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb4bec758f757740b983d352319eccb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4bb4bec758f757740b983d352319eccb">createOutlineShapeComputationPass</a> ()</td></tr>
<tr class="memdesc:a4bb4bec758f757740b983d352319eccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outline the shape computation part by adding shape.func and populate conrresponding mapping infomation into ShapeMappingAnalysis.  <a href="namespacemlir.html#a4bb4bec758f757740b983d352319eccb">More...</a><br /></td></tr>
<tr class="separator:a4bb4bec758f757740b983d352319eccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaa4c3b727375b5ba2dc196a70a42bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aacaa4c3b727375b5ba2dc196a70a42bb">populateSparseAssembler</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool directOut)</td></tr>
<tr class="separator:aacaa4c3b727375b5ba2dc196a70a42bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07377f22cc6146bebe3a32a4a13c00bb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a07377f22cc6146bebe3a32a4a13c00bb">createSparseAssembler</a> ()</td></tr>
<tr class="separator:a07377f22cc6146bebe3a32a4a13c00bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48caf279aad98e01f3db2a93a2f51b48"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a48caf279aad98e01f3db2a93a2f51b48">createSparseAssembler</a> (bool directOut)</td></tr>
<tr class="separator:a48caf279aad98e01f3db2a93a2f51b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3deec09ef78fca6282e45bfd4649d7e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3deec09ef78fca6282e45bfd4649d7e7">populateSparseReinterpretMap</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="namespacemlir.html#a855a7d93430958efaaf3a6f69e3dac1c">ReinterpretMapScope</a> scope)</td></tr>
<tr class="separator:a3deec09ef78fca6282e45bfd4649d7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3968e0a16a255017c133162badae2da2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3968e0a16a255017c133162badae2da2">createSparseReinterpretMapPass</a> ()</td></tr>
<tr class="separator:a3968e0a16a255017c133162badae2da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f3748b0d302eac21bac48a9887146b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac6f3748b0d302eac21bac48a9887146b">createSparseReinterpretMapPass</a> (<a class="el" href="namespacemlir.html#a855a7d93430958efaaf3a6f69e3dac1c">ReinterpretMapScope</a> scope)</td></tr>
<tr class="separator:ac6f3748b0d302eac21bac48a9887146b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667f68e2860101c8caec8f46732e316e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a667f68e2860101c8caec8f46732e316e">populatePreSparsificationRewriting</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a667f68e2860101c8caec8f46732e316e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6abc74515648dc477ae4f5af8cbf310"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa6abc74515648dc477ae4f5af8cbf310">createPreSparsificationRewritePass</a> ()</td></tr>
<tr class="separator:aa6abc74515648dc477ae4f5af8cbf310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f7f8933f0baf6ebeddfdc698327c31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a86f7f8933f0baf6ebeddfdc698327c31">populateSparsificationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>=<a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a>())</td></tr>
<tr class="memdesc:a86f7f8933f0baf6ebeddfdc698327c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up sparsification rewriting rules with the given options.  <a href="namespacemlir.html#a86f7f8933f0baf6ebeddfdc698327c31">More...</a><br /></td></tr>
<tr class="separator:a86f7f8933f0baf6ebeddfdc698327c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0be4f778219bfb3917a2c7d3e7e1bd0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae0be4f778219bfb3917a2c7d3e7e1bd0">createSparsificationPass</a> ()</td></tr>
<tr class="separator:ae0be4f778219bfb3917a2c7d3e7e1bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b0dcc4a707e4e560a7a2f69a95a7c9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a11b0dcc4a707e4e560a7a2f69a95a7c9">createSparsificationPass</a> (const <a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="separator:a11b0dcc4a707e4e560a7a2f69a95a7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05749dd321afd1862ad40e29349e733"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab05749dd321afd1862ad40e29349e733">populateStageSparseOperationsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ab05749dd321afd1862ad40e29349e733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up StageSparseOperation rewriting rules.  <a href="namespacemlir.html#ab05749dd321afd1862ad40e29349e733">More...</a><br /></td></tr>
<tr class="separator:ab05749dd321afd1862ad40e29349e733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa7974cf8032ae0d38f7fcc16387d3a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adfa7974cf8032ae0d38f7fcc16387d3a">createStageSparseOperationsPass</a> ()</td></tr>
<tr class="separator:adfa7974cf8032ae0d38f7fcc16387d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9848c16612b09d5d062b7e49564e8659"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9848c16612b09d5d062b7e49564e8659">populateLowerSparseOpsToForeachPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool enableRT, bool enableConvert)</td></tr>
<tr class="separator:a9848c16612b09d5d062b7e49564e8659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c927ead951ebddddb979353f1ddda9e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0c927ead951ebddddb979353f1ddda9e">createLowerSparseOpsToForeachPass</a> ()</td></tr>
<tr class="separator:a0c927ead951ebddddb979353f1ddda9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93efca2366cbf131cf7359f94cc5f2a5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a93efca2366cbf131cf7359f94cc5f2a5">createLowerSparseOpsToForeachPass</a> (bool enableRT, bool enableConvert)</td></tr>
<tr class="separator:a93efca2366cbf131cf7359f94cc5f2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac82ef141dff9c99336d99169954925"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeac82ef141dff9c99336d99169954925">populateLowerForeachToSCFPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:aeac82ef141dff9c99336d99169954925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0dbcff2285d9b5fc43c67189e783d6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aaa0dbcff2285d9b5fc43c67189e783d6">createLowerForeachToSCFPass</a> ()</td></tr>
<tr class="separator:aaa0dbcff2285d9b5fc43c67189e783d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f175c99ce23bb21e02b216876b31171"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8f175c99ce23bb21e02b216876b31171">populateLowerSparseIterationToSCFPatterns</a> (const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a8f175c99ce23bb21e02b216876b31171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab956888e7892e8d37b40f660d2ab3222"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab956888e7892e8d37b40f660d2ab3222">createLowerSparseIterationToSCFPass</a> ()</td></tr>
<tr class="separator:ab956888e7892e8d37b40f660d2ab3222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a109a00c2dac890cb8db767e9a9982d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5a109a00c2dac890cb8db767e9a9982d">populateSparseTensorConversionPatterns</a> (const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a5a109a00c2dac890cb8db767e9a9982d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up sparse tensor conversion rules.  <a href="namespacemlir.html#a5a109a00c2dac890cb8db767e9a9982d">More...</a><br /></td></tr>
<tr class="separator:a5a109a00c2dac890cb8db767e9a9982d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fe6af993ee7df395f88312234f0dc0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a50fe6af993ee7df395f88312234f0dc0">createSparseTensorConversionPass</a> ()</td></tr>
<tr class="separator:a50fe6af993ee7df395f88312234f0dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271ea308903cf0d605df0c3ba5f13b6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a271ea308903cf0d605df0c3ba5f13b6c">populateSparseTensorCodegenPatterns</a> (const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool createSparseDeallocs, bool enableBufferInitialization)</td></tr>
<tr class="memdesc:a271ea308903cf0d605df0c3ba5f13b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up sparse tensor codegen rules.  <a href="namespacemlir.html#a271ea308903cf0d605df0c3ba5f13b6c">More...</a><br /></td></tr>
<tr class="separator:a271ea308903cf0d605df0c3ba5f13b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1444af92cb6556316a97dbd17dc10ea4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1444af92cb6556316a97dbd17dc10ea4">createSparseTensorCodegenPass</a> ()</td></tr>
<tr class="separator:a1444af92cb6556316a97dbd17dc10ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11d8839f833db69a07242adf6894472"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad11d8839f833db69a07242adf6894472">createSparseTensorCodegenPass</a> (bool createSparseDeallocs, bool enableBufferInitialization)</td></tr>
<tr class="separator:ad11d8839f833db69a07242adf6894472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6168f425252f728e066433be9ee022b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6168f425252f728e066433be9ee022b2">populateSparseBufferRewriting</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool enableBufferInitialization)</td></tr>
<tr class="separator:a6168f425252f728e066433be9ee022b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52922b4f9a9b71d07318a65565e1d95d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a52922b4f9a9b71d07318a65565e1d95d">createSparseBufferRewritePass</a> ()</td></tr>
<tr class="separator:a52922b4f9a9b71d07318a65565e1d95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c5d254155d499befa419181f2539ea"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa9c5d254155d499befa419181f2539ea">createSparseBufferRewritePass</a> (bool enableBufferInitialization)</td></tr>
<tr class="separator:aa9c5d254155d499befa419181f2539ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76dc06de29760922469c1e4bd10a62c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a76dc06de29760922469c1e4bd10a62c9">populateSparseVectorizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, unsigned vectorLength, bool enableVLAVectorization, bool enableSIMDIndex32)</td></tr>
<tr class="memdesc:a76dc06de29760922469c1e4bd10a62c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the given patterns list with vectorization rules.  <a href="namespacemlir.html#a76dc06de29760922469c1e4bd10a62c9">More...</a><br /></td></tr>
<tr class="separator:a76dc06de29760922469c1e4bd10a62c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a9ca41ccfad286cda8688e8d66f588"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a06a9ca41ccfad286cda8688e8d66f588">createSparseVectorizationPass</a> ()</td></tr>
<tr class="separator:a06a9ca41ccfad286cda8688e8d66f588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3399bec16625e6af75488bb739d48d4c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3399bec16625e6af75488bb739d48d4c">createSparseVectorizationPass</a> (unsigned vectorLength, bool enableVLAVectorization, bool enableSIMDIndex32)</td></tr>
<tr class="separator:a3399bec16625e6af75488bb739d48d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48873e0e6f944a5579b28be3cc1c944"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad48873e0e6f944a5579b28be3cc1c944">populateSparseGPUCodegenPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, unsigned numThreads)</td></tr>
<tr class="separator:ad48873e0e6f944a5579b28be3cc1c944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ac451ba0b1c3393df013233d3c93c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a41ac451ba0b1c3393df013233d3c93c2">populateSparseGPULibgenPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool enableRT)</td></tr>
<tr class="separator:a41ac451ba0b1c3393df013233d3c93c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa7d8a0754783f37e6e38a77c7e8116"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2fa7d8a0754783f37e6e38a77c7e8116">createSparseGPUCodegenPass</a> ()</td></tr>
<tr class="separator:a2fa7d8a0754783f37e6e38a77c7e8116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19ebeb6aa5cf97ebbb73f3b7cd8c6c1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab19ebeb6aa5cf97ebbb73f3b7cd8c6c1">createSparseGPUCodegenPass</a> (unsigned numThreads, bool enableRT)</td></tr>
<tr class="separator:ab19ebeb6aa5cf97ebbb73f3b7cd8c6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d707e1aa02507e261dec9e171b37d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a07d707e1aa02507e261dec9e171b37d1">populateStorageSpecifierToLLVMPatterns</a> (const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a07d707e1aa02507e261dec9e171b37d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52fe837d33ee51beba517a1d44dbea3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa52fe837d33ee51beba517a1d44dbea3">createStorageSpecifierToLLVMPass</a> ()</td></tr>
<tr class="separator:aa52fe837d33ee51beba517a1d44dbea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3775f03f9a65464fefb370229adcac95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">bufferization::OneShotBufferizationOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3775f03f9a65464fefb370229adcac95">getBufferizationOptionsForSparsification</a> (bool analysisOnly)</td></tr>
<tr class="separator:a3775f03f9a65464fefb370229adcac95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5328b60bddf5d222bef6d92658019b9d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5328b60bddf5d222bef6d92658019b9d">createSparsificationAndBufferizationPass</a> ()</td></tr>
<tr class="separator:a5328b60bddf5d222bef6d92658019b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af312c1b22096f10a3123c5136824b691"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af312c1b22096f10a3123c5136824b691">createSparsificationAndBufferizationPass</a> (const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">bufferization::OneShotBufferizationOptions</a> &amp;bufferizationOptions, const <a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;sparsificationOptions, bool createSparseDeallocs, bool enableRuntimeLibrary, bool enableBufferInitialization, unsigned vectorLength, bool enableVLAVectorization, bool enableSIMDIndex32, bool enableGPULibgen, <a class="el" href="namespacemlir.html#a90f3feaa61d2ade78f26489cc92061c9">SparseEmitStrategy</a> emitStrategy, <a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832">SparseParallelizationStrategy</a> parallelizationStrategy)</td></tr>
<tr class="separator:af312c1b22096f10a3123c5136824b691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3110b4f58e57c2f284923d882d45cff4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3110b4f58e57c2f284923d882d45cff4">createSparseSpaceCollapsePass</a> ()</td></tr>
<tr class="separator:a3110b4f58e57c2f284923d882d45cff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9ab382a920a458ce63cd4534dcb273"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5c9ab382a920a458ce63cd4534dcb273">populateBuiltinFuncToSPIRVPatterns</a> (const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a5c9ab382a920a458ce63cd4534dcb273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating the builtin <code>func</code> op to the SPIR-V dialect.  <a href="namespacemlir.html#a5c9ab382a920a458ce63cd4534dcb273">More...</a><br /></td></tr>
<tr class="separator:a5c9ab382a920a458ce63cd4534dcb273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c79fe894fb6efe41ad37b5219a7b8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a00c79fe894fb6efe41ad37b5219a7b8a">populateFuncOpVectorRewritePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a00c79fe894fb6efe41ad37b5219a7b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2162d2bc9640db32d4ae88c12ef3bd23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2162d2bc9640db32d4ae88c12ef3bd23">populateReturnOpVectorRewritePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a2162d2bc9640db32d4ae88c12ef3bd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7739fe988f31077f0005b73f457eb373"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DiagnosedDefiniteFailure.html">DiagnosedDefiniteFailure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7739fe988f31077f0005b73f457eb373">emitDefiniteFailure</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message)</td></tr>
<tr class="memdesc:a7739fe988f31077f0005b73f457eb373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a definite failure with the given message.  <a href="namespacemlir.html#a7739fe988f31077f0005b73f457eb373">More...</a><br /></td></tr>
<tr class="separator:a7739fe988f31077f0005b73f457eb373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f82005038ea404596c74643db0d564f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DiagnosedDefiniteFailure.html">DiagnosedDefiniteFailure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1f82005038ea404596c74643db0d564f">emitDefiniteFailure</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const Twine &amp;message={})</td></tr>
<tr class="separator:a1f82005038ea404596c74643db0d564f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428b91d18eabd5b259a3ed6e0f27f60c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a428b91d18eabd5b259a3ed6e0f27f60c">emitSilenceableFailure</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message={})</td></tr>
<tr class="memdesc:a428b91d18eabd5b259a3ed6e0f27f60c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a silenceable failure with the given message.  <a href="namespacemlir.html#a428b91d18eabd5b259a3ed6e0f27f60c">More...</a><br /></td></tr>
<tr class="separator:a428b91d18eabd5b259a3ed6e0f27f60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078c07e9f16a6122a56bae420ce94308"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a078c07e9f16a6122a56bae420ce94308">emitSilenceableFailure</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const Twine &amp;message={})</td></tr>
<tr class="separator:a078c07e9f16a6122a56bae420ce94308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93db6f545964ed23f06b57618f09b33a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a93db6f545964ed23f06b57618f09b33a">computeSuffixProduct</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizes)</td></tr>
<tr class="memdesc:a93db6f545964ed23f06b57618f09b33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of sizes, return the suffix product.  <a href="namespacemlir.html#a93db6f545964ed23f06b57618f09b33a">More...</a><br /></td></tr>
<tr class="separator:a93db6f545964ed23f06b57618f09b33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f80386c0deb6ec32cbf4c8f3b929c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a41f80386c0deb6ec32cbf4c8f3b929c3">computeStrides</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizes)</td></tr>
<tr class="separator:a41f80386c0deb6ec32cbf4c8f3b929c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7ccdb269314ad17ee4550b4bcb608a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1c7ccdb269314ad17ee4550b4bcb608a">computeElementwiseMul</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; v1, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; v2)</td></tr>
<tr class="memdesc:a1c7ccdb269314ad17ee4550b4bcb608a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing llvm::zip_equal(v1, v2) multiplied elementwise.  <a href="namespacemlir.html#a1c7ccdb269314ad17ee4550b4bcb608a">More...</a><br /></td></tr>
<tr class="separator:a1c7ccdb269314ad17ee4550b4bcb608a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea26c0821fa35a09260cd1aeb694d0df"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aea26c0821fa35a09260cd1aeb694d0df">computeSum</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; basis)</td></tr>
<tr class="memdesc:aea26c0821fa35a09260cd1aeb694d0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Self-explicit.  <a href="namespacemlir.html#aea26c0821fa35a09260cd1aeb694d0df">More...</a><br /></td></tr>
<tr class="separator:aea26c0821fa35a09260cd1aeb694d0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e66c407bcfb1b4bbba4693496dbdc6"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a68e66c407bcfb1b4bbba4693496dbdc6">computeProduct</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; basis)</td></tr>
<tr class="memdesc:a68e66c407bcfb1b4bbba4693496dbdc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Self-explicit.  <a href="namespacemlir.html#a68e66c407bcfb1b4bbba4693496dbdc6">More...</a><br /></td></tr>
<tr class="separator:a68e66c407bcfb1b4bbba4693496dbdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c157bd2c9cf4949b45235593f6ef994"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9c157bd2c9cf4949b45235593f6ef994">computeMaxLinearIndex</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; basis)</td></tr>
<tr class="memdesc:a9c157bd2c9cf4949b45235593f6ef994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements of basis (i.e.  <a href="namespacemlir.html#a9c157bd2c9cf4949b45235593f6ef994">More...</a><br /></td></tr>
<tr class="separator:a9c157bd2c9cf4949b45235593f6ef994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84b6a6dfd9d9eb78ca02c17cabbebed"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac84b6a6dfd9d9eb78ca02c17cabbebed">linearize</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; offsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; basis)</td></tr>
<tr class="memdesc:ac84b6a6dfd9d9eb78ca02c17cabbebed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the linearized index of 'offsets' w.r.t.  <a href="namespacemlir.html#ac84b6a6dfd9d9eb78ca02c17cabbebed">More...</a><br /></td></tr>
<tr class="separator:ac84b6a6dfd9d9eb78ca02c17cabbebed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448d2cc69bc47c1304f4f1608937c3c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a448d2cc69bc47c1304f4f1608937c3c4">delinearize</a> (int64_t linearIndex, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; strides)</td></tr>
<tr class="memdesc:a448d2cc69bc47c1304f4f1608937c3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the strides together with a linear index in the dimension space, return the vector-space offsets in each dimension for a de-linearized index.  <a href="namespacemlir.html#a448d2cc69bc47c1304f4f1608937c3c4">More...</a><br /></td></tr>
<tr class="separator:a448d2cc69bc47c1304f4f1608937c3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c2ae63c247a9ba4509c8d1181127b0"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad1c2ae63c247a9ba4509c8d1181127b0">computeShapeRatio</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; subShape)</td></tr>
<tr class="memdesc:ad1c2ae63c247a9ba4509c8d1181127b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the multi-dimensional integral ratio of <code>subShape</code> to the trailing dimensions of <code>shape</code>.  <a href="namespacemlir.html#ad1c2ae63c247a9ba4509c8d1181127b0">More...</a><br /></td></tr>
<tr class="separator:ad1c2ae63c247a9ba4509c8d1181127b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530d6a928389d2f4c0234b059442a03a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a530d6a928389d2f4c0234b059442a03a">computeSuffixProduct</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; sizes)</td></tr>
<tr class="memdesc:a530d6a928389d2f4c0234b059442a03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of sizes, return the suffix product.  <a href="namespacemlir.html#a530d6a928389d2f4c0234b059442a03a">More...</a><br /></td></tr>
<tr class="separator:a530d6a928389d2f4c0234b059442a03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b9af9c7621d308e75814d488a9f6d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a53b9af9c7621d308e75814d488a9f6d7">computeStrides</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; sizes)</td></tr>
<tr class="separator:a53b9af9c7621d308e75814d488a9f6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f77472da918076c9d2a222a501823f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad0f77472da918076c9d2a222a501823f">computeElementwiseMul</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; v1, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; v2)</td></tr>
<tr class="memdesc:ad0f77472da918076c9d2a222a501823f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing llvm::zip_equal(v1, v2) multiplied elementwise.  <a href="namespacemlir.html#ad0f77472da918076c9d2a222a501823f">More...</a><br /></td></tr>
<tr class="separator:ad0f77472da918076c9d2a222a501823f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb1a444a06409db3eedd783e7f9ab0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4cb1a444a06409db3eedd783e7f9ab0b">computeSum</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; basis)</td></tr>
<tr class="memdesc:a4cb1a444a06409db3eedd783e7f9ab0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Self-explicit.  <a href="namespacemlir.html#a4cb1a444a06409db3eedd783e7f9ab0b">More...</a><br /></td></tr>
<tr class="separator:a4cb1a444a06409db3eedd783e7f9ab0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8d7a2a03264db5a6ac02a351f1e059"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ada8d7a2a03264db5a6ac02a351f1e059">computeProduct</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; basis)</td></tr>
<tr class="memdesc:ada8d7a2a03264db5a6ac02a351f1e059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Self-explicit.  <a href="namespacemlir.html#ada8d7a2a03264db5a6ac02a351f1e059">More...</a><br /></td></tr>
<tr class="separator:ada8d7a2a03264db5a6ac02a351f1e059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2248838afeb293df08c1731f2d12fc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac2248838afeb293df08c1731f2d12fc2">computeMaxLinearIndex</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; basis)</td></tr>
<tr class="memdesc:ac2248838afeb293df08c1731f2d12fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements of basis (i.e.  <a href="namespacemlir.html#ac2248838afeb293df08c1731f2d12fc2">More...</a><br /></td></tr>
<tr class="separator:ac2248838afeb293df08c1731f2d12fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e83fe20fc8231df5769e1eebe268bdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3e83fe20fc8231df5769e1eebe268bdd">linearize</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; offsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; basis)</td></tr>
<tr class="memdesc:a3e83fe20fc8231df5769e1eebe268bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the linearized index of 'offsets' w.r.t.  <a href="namespacemlir.html#a3e83fe20fc8231df5769e1eebe268bdd">More...</a><br /></td></tr>
<tr class="separator:a3e83fe20fc8231df5769e1eebe268bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0b8417b72fde91ffbc7d792fc97121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1c0b8417b72fde91ffbc7d792fc97121">linearize</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; offsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; basis)</td></tr>
<tr class="separator:a1c0b8417b72fde91ffbc7d792fc97121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1041856e784cdbf7811cd10bc5a5ffd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1041856e784cdbf7811cd10bc5a5ffd6">delinearize</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> linearIndex, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; strides)</td></tr>
<tr class="memdesc:a1041856e784cdbf7811cd10bc5a5ffd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the strides together with a linear index in the dimension space, return the vector-space offsets in each dimension for a de-linearized index.  <a href="namespacemlir.html#a1041856e784cdbf7811cd10bc5a5ffd6">More...</a><br /></td></tr>
<tr class="separator:a1041856e784cdbf7811cd10bc5a5ffd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2830e5f60c269c339ef24c33d8f7fbf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2830e5f60c269c339ef24c33d8f7fbf0">delinearize</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> linearIndex, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; strides)</td></tr>
<tr class="separator:a2830e5f60c269c339ef24c33d8f7fbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44886de1f618c57e6589a875d1407830"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a44886de1f618c57e6589a875d1407830"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a44886de1f618c57e6589a875d1407830">applyPermutation</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; T &gt; input, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; permutation)</td></tr>
<tr class="separator:a44886de1f618c57e6589a875d1407830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920cb0f71558f739ea5605f05354ca01"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a920cb0f71558f739ea5605f05354ca01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a920cb0f71558f739ea5605f05354ca01">applyPermutation</a> (const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; T &gt; &amp;input, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; permutation)</td></tr>
<tr class="separator:a920cb0f71558f739ea5605f05354ca01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcff71555e8c1965e508f324f43a55a"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned N&gt; </td></tr>
<tr class="memitem:adbcff71555e8c1965e508f324f43a55a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adbcff71555e8c1965e508f324f43a55a">applyPermutationToVector</a> (<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T, N &gt; &amp;inVec, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; permutation)</td></tr>
<tr class="memdesc:adbcff71555e8c1965e508f324f43a55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the permutation defined by <code>permutation</code> to <code>inVec</code>.  <a href="namespacemlir.html#adbcff71555e8c1965e508f324f43a55a">More...</a><br /></td></tr>
<tr class="separator:adbcff71555e8c1965e508f324f43a55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc254f56cba37671e1e5b2b933c6a090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afc254f56cba37671e1e5b2b933c6a090">invertPermutationVector</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; permutation)</td></tr>
<tr class="memdesc:afc254f56cba37671e1e5b2b933c6a090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to apply to inverse a permutation.  <a href="namespacemlir.html#afc254f56cba37671e1e5b2b933c6a090">More...</a><br /></td></tr>
<tr class="separator:afc254f56cba37671e1e5b2b933c6a090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf90202d2d87692ea1b8d22068bffa7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6cf90202d2d87692ea1b8d22068bffa7">isIdentityPermutation</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; permutation)</td></tr>
<tr class="memdesc:a6cf90202d2d87692ea1b8d22068bffa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>permutation</code> is an identity permutation.  <a href="namespacemlir.html#a6cf90202d2d87692ea1b8d22068bffa7">More...</a><br /></td></tr>
<tr class="separator:a6cf90202d2d87692ea1b8d22068bffa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb49fb26d8c1e3dc571db7ff9e34cb7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeb49fb26d8c1e3dc571db7ff9e34cb7f">isPermutationVector</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; interchange)</td></tr>
<tr class="memdesc:aeb49fb26d8c1e3dc571db7ff9e34cb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to check if an interchange vector is a permutation.  <a href="namespacemlir.html#aeb49fb26d8c1e3dc571db7ff9e34cb7f">More...</a><br /></td></tr>
<tr class="separator:aeb49fb26d8c1e3dc571db7ff9e34cb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eab61c26bfef3d7aaf3db051d58230b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6eab61c26bfef3d7aaf3db051d58230b">computePermutationVector</a> (int64_t permSize, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; positions, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; desiredPositions)</td></tr>
<tr class="memdesc:a6eab61c26bfef3d7aaf3db051d58230b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a permutation vector of size permSize that would result in moving positions into desiredPositions.  <a href="namespacemlir.html#a6eab61c26bfef3d7aaf3db051d58230b">More...</a><br /></td></tr>
<tr class="separator:a6eab61c26bfef3d7aaf3db051d58230b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf688b845e36e8284034d28fe9899bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeaf688b845e36e8284034d28fe9899bc">dropDims</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inputPerm, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; dropPositions)</td></tr>
<tr class="memdesc:aeaf688b845e36e8284034d28fe9899bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a permutation vector that drop the input dims in dropPositions from inputPerm.  <a href="namespacemlir.html#aeaf688b845e36e8284034d28fe9899bc">More...</a><br /></td></tr>
<tr class="separator:aeaf688b845e36e8284034d28fe9899bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84637d8636fade36ebdd466b38527c23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a84637d8636fade36ebdd466b38527c23">getI64SubArray</a> (ArrayAttr arrayAttr, unsigned <a class="el" href="CRunnerUtils_8h.html#aa3eaa688e40e1afbf39c1a4736aae30b">dropFront</a>=0, unsigned dropBack=0)</td></tr>
<tr class="memdesc:a84637d8636fade36ebdd466b38527c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to return a subset of <code>arrayAttr</code> as a vector of int64_t.  <a href="namespacemlir.html#a84637d8636fade36ebdd466b38527c23">More...</a><br /></td></tr>
<tr class="separator:a84637d8636fade36ebdd466b38527c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eafff30d6e835bda8247cf34463df2c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3eafff30d6e835bda8247cf34463df2c">computeLinearIndex</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> sourceOffset, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; strides, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; indices)</td></tr>
<tr class="memdesc:a3eafff30d6e835bda8247cf34463df2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute linear index from provided strides and indices, assuming strided layout.  <a href="namespacemlir.html#a3eafff30d6e835bda8247cf34463df2c">More...</a><br /></td></tr>
<tr class="separator:a3eafff30d6e835bda8247cf34463df2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e07ab53e78b29f77777f2ade29c9e8"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a19e07ab53e78b29f77777f2ade29c9e8">computeLinearIndex</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> sourceOffset, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; strides, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; indices)</td></tr>
<tr class="separator:a19e07ab53e78b29f77777f2ade29c9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12acf2020ef95ce0a5d7c3f2bbb6af14"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a12acf2020ef95ce0a5d7c3f2bbb6af14">getReassociationAttrName</a> ()</td></tr>
<tr class="memdesc:a12acf2020ef95ce0a5d7c3f2bbb6af14"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> name for the ArrayAttr which encodes reassociation indices.  <a href="namespacemlir.html#a12acf2020ef95ce0a5d7c3f2bbb6af14">More...</a><br /></td></tr>
<tr class="separator:a12acf2020ef95ce0a5d7c3f2bbb6af14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab965622bbf0ccdfcb51384517fd3117"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aab965622bbf0ccdfcb51384517fd3117">composeReassociationIndices</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; producerReassociations, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; consumerReassociations, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:aab965622bbf0ccdfcb51384517fd3117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose reassociation maps that are used in pair of reshape ops where one is a producer and other is the consumer.  <a href="namespacemlir.html#aab965622bbf0ccdfcb51384517fd3117">More...</a><br /></td></tr>
<tr class="separator:aab965622bbf0ccdfcb51384517fd3117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2799e8f52860dadc460b88a8f2df32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2 &gt;, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9b2799e8f52860dadc460b88a8f2df32">convertReassociationIndicesToExprs</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; reassociationIndices)</td></tr>
<tr class="memdesc:a9b2799e8f52860dadc460b88a8f2df32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert reassociation indices to affine expressions.  <a href="namespacemlir.html#a9b2799e8f52860dadc460b88a8f2df32">More...</a><br /></td></tr>
<tr class="separator:a9b2799e8f52860dadc460b88a8f2df32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561d5231fcefc471a4c9069fce2eaf87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a561d5231fcefc471a4c9069fce2eaf87">getSymbolLessAffineMaps</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ae5cf0e24a954fa30fb469105d4ca5dd8">ReassociationExprs</a> &gt; reassociation)</td></tr>
<tr class="memdesc:a561d5231fcefc471a4c9069fce2eaf87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs affine maps out of Array&lt;Array&lt;AffineExpr&gt;&gt;.  <a href="namespacemlir.html#a561d5231fcefc471a4c9069fce2eaf87">More...</a><br /></td></tr>
<tr class="separator:a561d5231fcefc471a4c9069fce2eaf87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecbdeef85cdbc2ce3b49a088fa5946a"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8ecbdeef85cdbc2ce3b49a088fa5946a">getReassociationIndicesAttribute</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; reassociation)</td></tr>
<tr class="memdesc:a8ecbdeef85cdbc2ce3b49a088fa5946a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a list of reassociations in an ArrayAttr.  <a href="namespacemlir.html#a8ecbdeef85cdbc2ce3b49a088fa5946a">More...</a><br /></td></tr>
<tr class="separator:a8ecbdeef85cdbc2ce3b49a088fa5946a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a9251459ba0d0ff0b94d3084e429c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a59a9251459ba0d0ff0b94d3084e429c4">convertReassociationMapsToIndices</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ae5cf0e24a954fa30fb469105d4ca5dd8">ReassociationExprs</a> &gt; reassociationExprs)</td></tr>
<tr class="memdesc:a59a9251459ba0d0ff0b94d3084e429c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Array&lt;Array&lt;AffineExpr&gt;&gt; to Array&lt;Array&lt;int64_t&gt;&gt;.  <a href="namespacemlir.html#a59a9251459ba0d0ff0b94d3084e429c4">More...</a><br /></td></tr>
<tr class="separator:a59a9251459ba0d0ff0b94d3084e429c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6783c78835273b8062a5b5e2a710d863"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6783c78835273b8062a5b5e2a710d863">getReassociationIndicesForReshape</a> (ShapedType sourceType, ShapedType targetType)</td></tr>
<tr class="memdesc:a6783c78835273b8062a5b5e2a710d863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reassociations maps to use to reshape given the source type and the target type when possible.  <a href="namespacemlir.html#a6783c78835273b8062a5b5e2a710d863">More...</a><br /></td></tr>
<tr class="separator:a6783c78835273b8062a5b5e2a710d863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b303e750705222900d23e44f2a22ce"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a76b303e750705222900d23e44f2a22ce">getReassociationIndicesForCollapse</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sourceShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; targetShape)</td></tr>
<tr class="memdesc:a76b303e750705222900d23e44f2a22ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reassociation maps to collapse <code>sourceShape</code> to <code>targetShape</code> if possible.  <a href="namespacemlir.html#a76b303e750705222900d23e44f2a22ce">More...</a><br /></td></tr>
<tr class="separator:a76b303e750705222900d23e44f2a22ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3d6f94b6a941066c3e7e5535817a9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9e3d6f94b6a941066c3e7e5535817a9b">isReassociationValid</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; reassociation, int *invalidIndex=nullptr)</td></tr>
<tr class="memdesc:a9e3d6f94b6a941066c3e7e5535817a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the reassociation specification is valid, false otherwise.  <a href="namespacemlir.html#a9e3d6f94b6a941066c3e7e5535817a9b">More...</a><br /></td></tr>
<tr class="separator:a9e3d6f94b6a941066c3e7e5535817a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0271e4a2b1e694242618a6e91a9c37"><td class="memTemplParams" colspan="2">template&lt;typename ReshapeOpTy , typename InverseReshapeOpTy &gt; </td></tr>
<tr class="memitem:a2b0271e4a2b1e694242618a6e91a9c37"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2b0271e4a2b1e694242618a6e91a9c37">foldReshapeOp</a> (ReshapeOpTy reshapeOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands)</td></tr>
<tr class="separator:a2b0271e4a2b1e694242618a6e91a9c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e37ef38e035b072204c4cc6f2bc6a5"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename T &gt; </td></tr>
<tr class="memitem:a59e37ef38e035b072204c4cc6f2bc6a5"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a59e37ef38e035b072204c4cc6f2bc6a5">verifyReshapeLikeTypes</a> (<a class="el" href="classmlir_1_1Op.html">Op</a> op, T expandedType, T collapsedType, bool isExpansion)</td></tr>
<tr class="memdesc:a59e37ef38e035b072204c4cc6f2bc6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common verifier for reshape-like types.  <a href="namespacemlir.html#a59e37ef38e035b072204c4cc6f2bc6a5">More...</a><br /></td></tr>
<tr class="separator:a59e37ef38e035b072204c4cc6f2bc6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a364dd32a6190474be758d1a6b9d5f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a64a364dd32a6190474be758d1a6b9d5f">reshapeLikeShapesAreCompatible</a> (<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; LogicalResult(const Twine &amp;)&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; collapsedShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; expandedShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; reassociationMaps, bool isExpandingReshape)</td></tr>
<tr class="memdesc:a64a364dd32a6190474be758d1a6b9d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that shapes of the reshaped types using following rule: if a dimension in the collapsed type is static, then the corresponding dimensions in the expanded shape should be a) static b) the product should be same as the collaped shape.  <a href="namespacemlir.html#a64a364dd32a6190474be758d1a6b9d5f">More...</a><br /></td></tr>
<tr class="separator:a64a364dd32a6190474be758d1a6b9d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1858ec5ab152ee2a09d4ceaf95cf2811"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1858ec5ab152ee2a09d4ceaf95cf2811">hasNonIdentityLayout</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memdesc:a1858ec5ab152ee2a09d4ceaf95cf2811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the type is a MemRefType and has a non-identity layout.  <a href="namespacemlir.html#a1858ec5ab152ee2a09d4ceaf95cf2811">More...</a><br /></td></tr>
<tr class="separator:a1858ec5ab152ee2a09d4ceaf95cf2811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10337918edd90e6a270db09d71d66dc5"><td class="memItemLeft" align="right" valign="top">llvm::SmallBitVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a10337918edd90e6a270db09d71d66dc5">getSlicedDimensions</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sliceInputShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; sliceParams)</td></tr>
<tr class="memdesc:a10337918edd90e6a270db09d71d66dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input parameters <code>offsets</code>, <code>sizes</code>, <code>strides</code> specify a rectangular non rank-reducing slice of the collapse_shape output.  <a href="namespacemlir.html#a10337918edd90e6a270db09d71d66dc5">More...</a><br /></td></tr>
<tr class="separator:a10337918edd90e6a270db09d71d66dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace39a548030ae8416f5ae52af1eb24e1"><td class="memItemLeft" align="right" valign="top">llvm::SmallBitVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ace39a548030ae8416f5ae52af1eb24e1">getLinearizedDimensions</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; reassociationIndices)</td></tr>
<tr class="memdesc:ace39a548030ae8416f5ae52af1eb24e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine which dimensions are linearized by a <code>tensor.collapse_shape</code> op by inspecting its reassociation indices.  <a href="namespacemlir.html#ace39a548030ae8416f5ae52af1eb24e1">More...</a><br /></td></tr>
<tr class="separator:ace39a548030ae8416f5ae52af1eb24e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04dd9fbdfc3426b88a910e2e7ded495c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a04dd9fbdfc3426b88a910e2e7ded495c">isZeroIndex</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> v)</td></tr>
<tr class="memdesc:a04dd9fbdfc3426b88a910e2e7ded495c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <code>v</code> is an IntegerAttr with value <code>0</code> of a ConstantIndexOp with attribute with value <code>0</code>.  <a href="namespacemlir.html#a04dd9fbdfc3426b88a910e2e7ded495c">More...</a><br /></td></tr>
<tr class="separator:a04dd9fbdfc3426b88a910e2e7ded495c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d96a98d184d13853b53c410d814775c"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0d96a98d184d13853b53c410d814775c">getOffsetsSizesAndStrides</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; ranges)</td></tr>
<tr class="memdesc:a0d96a98d184d13853b53c410d814775c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an array of <a class="el" href="structmlir_1_1Range.html" title="Represents a range (offset, size, and stride) where each element of the triple may be dynamic or stat...">Range</a> values, return a tuple of (offset vector, sizes vector, and strides vector) formed by separating out the individual elements of each range.  <a href="namespacemlir.html#a0d96a98d184d13853b53c410d814775c">More...</a><br /></td></tr>
<tr class="separator:a0d96a98d184d13853b53c410d814775c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9a8d86f0213b02a553c01aea31e6e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abf9a8d86f0213b02a553c01aea31e6e4">dispatchIndexOpFoldResult</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dynamicVec, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;staticVec)</td></tr>
<tr class="memdesc:abf9a8d86f0213b02a553c01aea31e6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to dispatch an <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> into <code>staticVec</code> if: a) it is an IntegerAttr In other cases, the <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> is dispached to the <code>dynamicVec</code>.  <a href="namespacemlir.html#abf9a8d86f0213b02a553c01aea31e6e4">More...</a><br /></td></tr>
<tr class="separator:abf9a8d86f0213b02a553c01aea31e6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923d05c8f39df57cf19f1ec709bbe5a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a923d05c8f39df57cf19f1ec709bbe5a5">dispatchIndexOpFoldResults</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ofrs, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dynamicVec, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;staticVec)</td></tr>
<tr class="memdesc:a923d05c8f39df57cf19f1ec709bbe5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to dispatch multiple OpFoldResults according to the behavior of <code>dispatchIndexOpFoldResult(<a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> ofr</code> for a single <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>.  <a href="namespacemlir.html#a923d05c8f39df57cf19f1ec709bbe5a5">More...</a><br /></td></tr>
<tr class="separator:a923d05c8f39df57cf19f1ec709bbe5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6511366965a313e6b0eb85c620b941d0"><td class="memTemplParams" colspan="2">template&lt;typename IntTy &gt; </td></tr>
<tr class="memitem:a6511366965a313e6b0eb85c620b941d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; IntTy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6511366965a313e6b0eb85c620b941d0">extractFromIntegerArrayAttr</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:a6511366965a313e6b0eb85c620b941d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract integer values from the assumed ArrayAttr of IntegerAttr.  <a href="namespacemlir.html#a6511366965a313e6b0eb85c620b941d0">More...</a><br /></td></tr>
<tr class="separator:a6511366965a313e6b0eb85c620b941d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19b7af1333485b34ebfe4bf6300c362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac19b7af1333485b34ebfe4bf6300c362">getAsOpFoldResult</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:ac19b7af1333485b34ebfe4bf6300c362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a value, try to extract a constant <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>.  <a href="namespacemlir.html#ac19b7af1333485b34ebfe4bf6300c362">More...</a><br /></td></tr>
<tr class="separator:ac19b7af1333485b34ebfe4bf6300c362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4688956ac5cd539b0b3e134af30248"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0f4688956ac5cd539b0b3e134af30248">getAsOpFoldResult</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values)</td></tr>
<tr class="memdesc:a0f4688956ac5cd539b0b3e134af30248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an array of values, try to extract a constant <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> from each value.  <a href="namespacemlir.html#a0f4688956ac5cd539b0b3e134af30248">More...</a><br /></td></tr>
<tr class="separator:a0f4688956ac5cd539b0b3e134af30248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622f03f8cb8e4cfde7e34c30e9aa02b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a622f03f8cb8e4cfde7e34c30e9aa02b6">getAsOpFoldResult</a> (ArrayAttr arrayAttr)</td></tr>
<tr class="memdesc:a622f03f8cb8e4cfde7e34c30e9aa02b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <code>arrayAttr</code> to a vector of <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>.  <a href="namespacemlir.html#a622f03f8cb8e4cfde7e34c30e9aa02b6">More...</a><br /></td></tr>
<tr class="separator:a622f03f8cb8e4cfde7e34c30e9aa02b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c18958fe34840cfafad41a1226f7a68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0c18958fe34840cfafad41a1226f7a68">getAsIndexOpFoldResult</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, int64_t val)</td></tr>
<tr class="memdesc:a0c18958fe34840cfafad41a1226f7a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert int64_t to integer attributes of index type and return them as <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>.  <a href="namespacemlir.html#a0c18958fe34840cfafad41a1226f7a68">More...</a><br /></td></tr>
<tr class="separator:a0c18958fe34840cfafad41a1226f7a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4f49fb88f428ae223bf75ce8e9f849"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3b4f49fb88f428ae223bf75ce8e9f849">getAsIndexOpFoldResult</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="separator:a3b4f49fb88f428ae223bf75ce8e9f849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bfcc5fa9deffb32e7c39183f732c90"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a22bfcc5fa9deffb32e7c39183f732c90">getConstantIntValue</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr)</td></tr>
<tr class="memdesc:a22bfcc5fa9deffb32e7c39183f732c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">If ofr is a constant integer or an IntegerAttr, return the integer.  <a href="namespacemlir.html#a22bfcc5fa9deffb32e7c39183f732c90">More...</a><br /></td></tr>
<tr class="separator:a22bfcc5fa9deffb32e7c39183f732c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addda9c80b032fe1ec781a4317d45725f"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#addda9c80b032fe1ec781a4317d45725f">getConstantIntValues</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ofrs)</td></tr>
<tr class="memdesc:addda9c80b032fe1ec781a4317d45725f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If all ofrs are constant integers or IntegerAttrs, return the integers.  <a href="namespacemlir.html#addda9c80b032fe1ec781a4317d45725f">More...</a><br /></td></tr>
<tr class="separator:addda9c80b032fe1ec781a4317d45725f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043789541ff1881513700b717bf5491d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a043789541ff1881513700b717bf5491d">isConstantIntValue</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr, int64_t value)</td></tr>
<tr class="memdesc:a043789541ff1881513700b717bf5491d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <code>ofr</code> is constant integer equal to <code>value</code>.  <a href="namespacemlir.html#a043789541ff1881513700b717bf5491d">More...</a><br /></td></tr>
<tr class="separator:a043789541ff1881513700b717bf5491d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee77c6f0feb82212b1b817785f95f48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2ee77c6f0feb82212b1b817785f95f48">isEqualConstantIntOrValue</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr1, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr2)</td></tr>
<tr class="memdesc:a2ee77c6f0feb82212b1b817785f95f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if ofr1 and ofr2 are the same integer constant attribute values or the same SSA value.  <a href="namespacemlir.html#a2ee77c6f0feb82212b1b817785f95f48">More...</a><br /></td></tr>
<tr class="separator:a2ee77c6f0feb82212b1b817785f95f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03d63917414f04e985c804f24086b76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab03d63917414f04e985c804f24086b76">isEqualConstantIntOrValueArray</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ofrs1, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ofrs2)</td></tr>
<tr class="separator:ab03d63917414f04e985c804f24086b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad6a59a2a6b463b300c786547c64563"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abad6a59a2a6b463b300c786547c64563">getMixedValues</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; staticValues, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> dynamicValues, <a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;b)</td></tr>
<tr class="memdesc:abad6a59a2a6b463b300c786547c64563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of OpFoldResults with the same size a staticValues, but all elements for which ShapedType::isDynamic is true, will be replaced by dynamicValues.  <a href="namespacemlir.html#abad6a59a2a6b463b300c786547c64563">More...</a><br /></td></tr>
<tr class="separator:abad6a59a2a6b463b300c786547c64563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4a8218eabc2fa6756612f896572dff"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9c4a8218eabc2fa6756612f896572dff">decomposeMixedValues</a> (const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;mixedValues)</td></tr>
<tr class="memdesc:a9c4a8218eabc2fa6756612f896572dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a vector of mixed static or dynamic values into the corresponding pair of arrays.  <a href="namespacemlir.html#a9c4a8218eabc2fa6756612f896572dff">More...</a><br /></td></tr>
<tr class="separator:a9c4a8218eabc2fa6756612f896572dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b5c05e14ade6108624f49c4c8bf104"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae8b5c05e14ade6108624f49c4c8bf104">getValuesSortedByKey</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; keys, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; values, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt; compare)</td></tr>
<tr class="memdesc:ae8b5c05e14ade6108624f49c4c8bf104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to sort <code>values</code> according to matching <code>keys</code>.  <a href="namespacemlir.html#ae8b5c05e14ade6108624f49c4c8bf104">More...</a><br /></td></tr>
<tr class="separator:ae8b5c05e14ade6108624f49c4c8bf104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ec25d896f63f835649e57fa1156deb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af3ec25d896f63f835649e57fa1156deb">getValuesSortedByKey</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; keys, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; values, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt; compare)</td></tr>
<tr class="separator:af3ec25d896f63f835649e57fa1156deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a106cc8c510602a1ee219489b64c5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac4a106cc8c510602a1ee219489b64c5c">getValuesSortedByKey</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; keys, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt; compare)</td></tr>
<tr class="separator:ac4a106cc8c510602a1ee219489b64c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653bf589569eab36eb696bc4db3371c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a653bf589569eab36eb696bc4db3371c6">hasValidSizesOffsets</a> (<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; sizesOrOffsets)</td></tr>
<tr class="memdesc:a653bf589569eab36eb696bc4db3371c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to check whether the passed in <code>sizes</code> or <code>offsets</code> are valid.  <a href="namespacemlir.html#a653bf589569eab36eb696bc4db3371c6">More...</a><br /></td></tr>
<tr class="separator:a653bf589569eab36eb696bc4db3371c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88795bccdeef2b7388f2bbd6d1c15ae7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a88795bccdeef2b7388f2bbd6d1c15ae7">hasValidStrides</a> (<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; strides)</td></tr>
<tr class="memdesc:a88795bccdeef2b7388f2bbd6d1c15ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to check whether the passed in <code>strides</code> are valid.  <a href="namespacemlir.html#a88795bccdeef2b7388f2bbd6d1c15ae7">More...</a><br /></td></tr>
<tr class="separator:a88795bccdeef2b7388f2bbd6d1c15ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afccef918a87cccab273bba3cb00beed7"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afccef918a87cccab273bba3cb00beed7">foldDynamicIndexList</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;ofrs, bool onlyNonNegative=false, bool onlyNonZero=false)</td></tr>
<tr class="memdesc:afccef918a87cccab273bba3cb00beed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "success" when any of the elements in <code>ofrs</code> is a constant value.  <a href="namespacemlir.html#afccef918a87cccab273bba3cb00beed7">More...</a><br /></td></tr>
<tr class="separator:afccef918a87cccab273bba3cb00beed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04a9037c5785dac1e037c025297c4da"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af04a9037c5785dac1e037c025297c4da">foldDynamicOffsetSizeList</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;offsetsOrSizes)</td></tr>
<tr class="memdesc:af04a9037c5785dac1e037c025297c4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "success" when any of the elements in <code>offsetsOrSizes</code> is a constant value.  <a href="namespacemlir.html#af04a9037c5785dac1e037c025297c4da">More...</a><br /></td></tr>
<tr class="separator:af04a9037c5785dac1e037c025297c4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f1eae6696c52c728b7109da9e8ceb8"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a26f1eae6696c52c728b7109da9e8ceb8">foldDynamicStrideList</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;strides)</td></tr>
<tr class="memdesc:a26f1eae6696c52c728b7109da9e8ceb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "success" when any of the elements in <code>strides</code> is a constant value.  <a href="namespacemlir.html#a26f1eae6696c52c728b7109da9e8ceb8">More...</a><br /></td></tr>
<tr class="separator:a26f1eae6696c52c728b7109da9e8ceb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694b6ad2c919c4bcef792aca11deda42"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a694b6ad2c919c4bcef792aca11deda42">constantTripCount</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> lb, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ub, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> step)</td></tr>
<tr class="memdesc:a694b6ad2c919c4bcef792aca11deda42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of iterations for a loop with a lower bound <code>lb</code>, upper bound <code>ub</code> and step <code>step</code>.  <a href="namespacemlir.html#a694b6ad2c919c4bcef792aca11deda42">More...</a><br /></td></tr>
<tr class="separator:a694b6ad2c919c4bcef792aca11deda42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53f9bcf99efe125a11237ad6b64642c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae53f9bcf99efe125a11237ad6b64642c">isRowMajorMatmul</a> (ArrayAttr indexingMaps)</td></tr>
<tr class="memdesc:ae53f9bcf99efe125a11237ad6b64642c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given maps describe a row major matmul.  <a href="namespacemlir.html#ae53f9bcf99efe125a11237ad6b64642c">More...</a><br /></td></tr>
<tr class="separator:ae53f9bcf99efe125a11237ad6b64642c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfea8ee2dd0eba944b0cd299591ccf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0dfea8ee2dd0eba944b0cd299591ccf9">isColumnMajorMatmul</a> (ArrayAttr indexingMaps)</td></tr>
<tr class="memdesc:a0dfea8ee2dd0eba944b0cd299591ccf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given maps describe a column major matmul.  <a href="namespacemlir.html#a0dfea8ee2dd0eba944b0cd299591ccf9">More...</a><br /></td></tr>
<tr class="separator:a0dfea8ee2dd0eba944b0cd299591ccf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28d7afae3a8e6d54489b5857b938d07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa28d7afae3a8e6d54489b5857b938d07">isRowMajorBatchMatmul</a> (ArrayAttr indexingMaps)</td></tr>
<tr class="memdesc:aa28d7afae3a8e6d54489b5857b938d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given maps describe a row major batch matmul.  <a href="namespacemlir.html#aa28d7afae3a8e6d54489b5857b938d07">More...</a><br /></td></tr>
<tr class="separator:aa28d7afae3a8e6d54489b5857b938d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fb321c11f8758094dbc4ece855d206"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac5fb321c11f8758094dbc4ece855d206">isVecmat</a> (ArrayAttr indexingMaps)</td></tr>
<tr class="memdesc:ac5fb321c11f8758094dbc4ece855d206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given maps describe a vector matrix multiplication.  <a href="namespacemlir.html#ac5fb321c11f8758094dbc4ece855d206">More...</a><br /></td></tr>
<tr class="separator:ac5fb321c11f8758094dbc4ece855d206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3a18535f4146298157c782e5254e94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9c3a18535f4146298157c782e5254e94">isBatchVecmat</a> (ArrayAttr indexingMaps)</td></tr>
<tr class="memdesc:a9c3a18535f4146298157c782e5254e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given maps describe a batch vector matrix multiplication.  <a href="namespacemlir.html#a9c3a18535f4146298157c782e5254e94">More...</a><br /></td></tr>
<tr class="separator:a9c3a18535f4146298157c782e5254e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50aeecdfac818acb74f464b9f19a030e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a50aeecdfac818acb74f464b9f19a030e">isMatvec</a> (ArrayAttr indexingMaps)</td></tr>
<tr class="memdesc:a50aeecdfac818acb74f464b9f19a030e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given maps describe a matrix vector multiplication.  <a href="namespacemlir.html#a50aeecdfac818acb74f464b9f19a030e">More...</a><br /></td></tr>
<tr class="separator:a50aeecdfac818acb74f464b9f19a030e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2823559fb2fadd8959a578eecc499342"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2823559fb2fadd8959a578eecc499342">isBatchMatvec</a> (ArrayAttr indexingMaps)</td></tr>
<tr class="memdesc:a2823559fb2fadd8959a578eecc499342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given maps describe a batch matrix vector multiplication.  <a href="namespacemlir.html#a2823559fb2fadd8959a578eecc499342">More...</a><br /></td></tr>
<tr class="separator:a2823559fb2fadd8959a578eecc499342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb672e2258ecd8657ec36b0fd391208a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adb672e2258ecd8657ec36b0fd391208a">findPositionsOfType</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt; iteratorTypes, utils::IteratorType iteratorTypeName, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; unsigned &gt; &amp;res)</td></tr>
<tr class="memdesc:adb672e2258ecd8657ec36b0fd391208a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return positions in <code>iteratorTypes</code> that match <code>iteratorTypeName</code>.  <a href="namespacemlir.html#adb672e2258ecd8657ec36b0fd391208a">More...</a><br /></td></tr>
<tr class="separator:adb672e2258ecd8657ec36b0fd391208a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07dda6e0df087e91b18fdb2b8bfe5aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab07dda6e0df087e91b18fdb2b8bfe5aa">clone</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> newResultTypes, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newOperands)</td></tr>
<tr class="separator:ab07dda6e0df087e91b18fdb2b8bfe5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75b562b2c25a3d66295d10efde0b996"><td class="memTemplParams" colspan="2">template&lt;typename OpT &gt; </td></tr>
<tr class="memitem:aa75b562b2c25a3d66295d10efde0b996"><td class="memTemplItemLeft" align="right" valign="top">OpT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa75b562b2c25a3d66295d10efde0b996">clone</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, OpT op, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> newResultTypes, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newOperands)</td></tr>
<tr class="separator:aa75b562b2c25a3d66295d10efde0b996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49429f945b2bca0efdd4c315bb68505b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a49429f945b2bca0efdd4c315bb68505b">cloneWithoutRegions</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> newResultTypes, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newOperands)</td></tr>
<tr class="separator:a49429f945b2bca0efdd4c315bb68505b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba376b9b63ed400e64bb041e459a62e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeba376b9b63ed400e64bb041e459a62e">getPrunedAttributeList</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt; elidedAttrs)</td></tr>
<tr class="separator:aeba376b9b63ed400e64bb041e459a62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05930f6194dee5366651710de8da45c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a05930f6194dee5366651710de8da45c9">populateX86VectorLegalizeForLLVMExportPatterns</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a05930f6194dee5366651710de8da45c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to lower X86Vector ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <a href="namespacemlir.html#a05930f6194dee5366651710de8da45c9">More...</a><br /></td></tr>
<tr class="separator:a05930f6194dee5366651710de8da45c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8013cee2241cd53aa923b23e4e3575"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afa8013cee2241cd53aa923b23e4e3575">configureX86VectorLegalizeForExportTarget</a> (<a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:afa8013cee2241cd53aa923b23e4e3575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the target to support lowering X86Vector ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <a href="namespacemlir.html#afa8013cee2241cd53aa923b23e4e3575">More...</a><br /></td></tr>
<tr class="separator:afa8013cee2241cd53aa923b23e4e3575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfe9337070eb0f67cb7a3098ee136ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4bfe9337070eb0f67cb7a3098ee136ee">JitRunnerMain</a> (int argc, char **argv, const <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry, <a class="el" href="structmlir_1_1JitRunnerConfig.html">JitRunnerConfig</a> config={})</td></tr>
<tr class="memdesc:a4bfe9337070eb0f67cb7a3098ee136ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for all CPU runners.  <a href="namespacemlir.html#a4bfe9337070eb0f67cb7a3098ee136ee">More...</a><br /></td></tr>
<tr class="separator:a4bfe9337070eb0f67cb7a3098ee136ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643fb5da616fe37fef528fbcf735b8ec"><td class="memItemLeft" align="right" valign="top">std::function&lt; llvm::Error(llvm::Module *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a643fb5da616fe37fef528fbcf735b8ec">makeOptimizingTransformer</a> (unsigned optLevel, unsigned sizeLevel, llvm::TargetMachine *targetMachine)</td></tr>
<tr class="memdesc:a643fb5da616fe37fef528fbcf735b8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a module transformer function for MLIR <a class="el" href="classmlir_1_1ExecutionEngine.html" title="JIT-backed execution engine for MLIR.">ExecutionEngine</a> that runs <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR passes corresponding to the given speed and size optimization levels (e.g.  <a href="namespacemlir.html#a643fb5da616fe37fef528fbcf735b8ec">More...</a><br /></td></tr>
<tr class="separator:a643fb5da616fe37fef528fbcf735b8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe55df95d48191f0fa2c5ab8f4e81e34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afe55df95d48191f0fa2c5ab8f4e81e34">registerAllDialects</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:afe55df95d48191f0fa2c5ab8f4e81e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all the MLIR dialects to the provided registry.  <a href="namespacemlir.html#afe55df95d48191f0fa2c5ab8f4e81e34">More...</a><br /></td></tr>
<tr class="separator:afe55df95d48191f0fa2c5ab8f4e81e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcd07e2ad26a58627d961ce8e544f1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5fcd07e2ad26a58627d961ce8e544f1b">registerAllDialects</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a5fcd07e2ad26a58627d961ce8e544f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append all the MLIR dialects to the registry contained in the given context.  <a href="namespacemlir.html#a5fcd07e2ad26a58627d961ce8e544f1b">More...</a><br /></td></tr>
<tr class="separator:a5fcd07e2ad26a58627d961ce8e544f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af478d18d439a803300e8e086d32bbb6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af478d18d439a803300e8e086d32bbb6e">registerAllExtensions</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:af478d18d439a803300e8e086d32bbb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function may be called to register all MLIR dialect extensions with the provided registry.  <a href="namespacemlir.html#af478d18d439a803300e8e086d32bbb6e">More...</a><br /></td></tr>
<tr class="separator:af478d18d439a803300e8e086d32bbb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb552a159c6c887b98b3583dfd5cbe5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afb552a159c6c887b98b3583dfd5cbe5d">registerAllPasses</a> ()</td></tr>
<tr class="separator:afb552a159c6c887b98b3583dfd5cbe5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a267e7e7ec38e0a09285a20831414d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7a267e7e7ec38e0a09285a20831414d3">registerFromLLVMIRTranslation</a> ()</td></tr>
<tr class="separator:a7a267e7e7ec38e0a09285a20831414d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ef91a9901d4d87a042990ccb79f2be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a51ef91a9901d4d87a042990ccb79f2be">registerFromSPIRVTranslation</a> ()</td></tr>
<tr class="separator:a51ef91a9901d4d87a042990ccb79f2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520bc0aa5f34c15a39f2202fdf521382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a520bc0aa5f34c15a39f2202fdf521382">registerToCppTranslation</a> ()</td></tr>
<tr class="separator:a520bc0aa5f34c15a39f2202fdf521382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003d72c96a8bffacc207ba165212e2db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a003d72c96a8bffacc207ba165212e2db">registerToLLVMIRTranslation</a> ()</td></tr>
<tr class="separator:a003d72c96a8bffacc207ba165212e2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f5d34c37689ae9b05537a040d9e0a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af7f5d34c37689ae9b05537a040d9e0a0">registerToSPIRVTranslation</a> ()</td></tr>
<tr class="separator:af7f5d34c37689ae9b05537a040d9e0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d16808b31b66905b067720d428adf61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8d16808b31b66905b067720d428adf61">registerAllTranslations</a> ()</td></tr>
<tr class="separator:a8d16808b31b66905b067720d428adf61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62534636110d65226b611986e9a316a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a62534636110d65226b611986e9a316a1">operator!=</a> (<a class="el" href="classmlir_1_1RegionBranchPoint.html">RegionBranchPoint</a> lhs, <a class="el" href="classmlir_1_1RegionBranchPoint.html">RegionBranchPoint</a> rhs)</td></tr>
<tr class="separator:a62534636110d65226b611986e9a316a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426b7e62d7400b01d368a3db835df9d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a426b7e62d7400b01d368a3db835df9d3">insideMutuallyExclusiveRegions</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *a, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *b)</td></tr>
<tr class="memdesc:a426b7e62d7400b01d368a3db835df9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>a</code> and <code>b</code> are in mutually exclusive regions as per RegionBranchOpInterface.  <a href="namespacemlir.html#a426b7e62d7400b01d368a3db835df9d3">More...</a><br /></td></tr>
<tr class="separator:a426b7e62d7400b01d368a3db835df9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59222c6d1f54e57a5f71291f205911da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a59222c6d1f54e57a5f71291f205911da">getEnclosingRepetitiveRegion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a59222c6d1f54e57a5f71291f205911da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first enclosing region of the given op that may be executed repetitively as per RegionBranchOpInterface or <code>nullptr</code> if no such region exists.  <a href="namespacemlir.html#a59222c6d1f54e57a5f71291f205911da">More...</a><br /></td></tr>
<tr class="separator:a59222c6d1f54e57a5f71291f205911da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea4281da1b0006e0c9622cff14858a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abea4281da1b0006e0c9622cff14858a7">getEnclosingRepetitiveRegion</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:abea4281da1b0006e0c9622cff14858a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first enclosing region of the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> that may be executed repetitively as per RegionBranchOpInterface or <code>nullptr</code> if no such region exists.  <a href="namespacemlir.html#abea4281da1b0006e0c9622cff14858a7">More...</a><br /></td></tr>
<tr class="separator:abea4281da1b0006e0c9622cff14858a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbf6a6a0dd14f6d2f1e7d7772006077"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7cbf6a6a0dd14f6d2f1e7d7772006077">operator&lt;&lt;</a> (raw_ostream &amp;, const <a class="el" href="classmlir_1_1ConstantIntRanges.html">ConstantIntRanges</a> &amp;)</td></tr>
<tr class="separator:a7cbf6a6a0dd14f6d2f1e7d7772006077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96f3b26c90ea659c4be029b0e410cd3"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab96f3b26c90ea659c4be029b0e410cd3">operator&lt;&lt;</a> (raw_ostream &amp;, const <a class="el" href="classmlir_1_1IntegerValueRange.html">IntegerValueRange</a> &amp;)</td></tr>
<tr class="separator:ab96f3b26c90ea659c4be029b0e410cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24aeba82a83b5f51bfe338ed5156887a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a24aeba82a83b5f51bfe338ed5156887a">reifyResultShapes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0a5ee68dc80640e6ac9c4a6011d18bc1">ReifiedRankedShapedTypeDims</a> &amp;reifiedReturnShapes)</td></tr>
<tr class="memdesc:a24aeba82a83b5f51bfe338ed5156887a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reify the shape of the result of an operation (typically in terms of the shape of its operands).  <a href="namespacemlir.html#a24aeba82a83b5f51bfe338ed5156887a">More...</a><br /></td></tr>
<tr class="separator:a24aeba82a83b5f51bfe338ed5156887a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bdf3d5eaaef529cc7cf1ea0fa1808b"><td class="memTemplParams" colspan="2">template&lt;typename EffectTy &gt; </td></tr>
<tr class="memitem:a54bdf3d5eaaef529cc7cf1ea0fa1808b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a54bdf3d5eaaef529cc7cf1ea0fa1808b">hasSingleEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a54bdf3d5eaaef529cc7cf1ea0fa1808b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>op</code> has only an effect of type <code>EffectTy</code>.  <a href="namespacemlir.html#a54bdf3d5eaaef529cc7cf1ea0fa1808b">More...</a><br /></td></tr>
<tr class="separator:a54bdf3d5eaaef529cc7cf1ea0fa1808b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5c028078f8fdc86950f374b834cb07"><td class="memTemplParams" colspan="2">template&lt;typename EffectTy &gt; </td></tr>
<tr class="memitem:a4e5c028078f8fdc86950f374b834cb07"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4e5c028078f8fdc86950f374b834cb07">hasSingleEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a4e5c028078f8fdc86950f374b834cb07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>op</code> has only an effect of type <code>EffectTy</code> (and of no other type) on <code>value</code>.  <a href="namespacemlir.html#a4e5c028078f8fdc86950f374b834cb07">More...</a><br /></td></tr>
<tr class="separator:a4e5c028078f8fdc86950f374b834cb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1879b99cadf0d3c0c5de98b33412b650"><td class="memTemplParams" colspan="2">template&lt;typename ValueTy , typename EffectTy &gt; </td></tr>
<tr class="memitem:a1879b99cadf0d3c0c5de98b33412b650"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1879b99cadf0d3c0c5de98b33412b650">hasSingleEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, ValueTy value)</td></tr>
<tr class="memdesc:a1879b99cadf0d3c0c5de98b33412b650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>op</code> has only an effect of type <code>EffectTy</code> (and of no other type) on <code>value</code> of type <code>ValueTy</code>.  <a href="namespacemlir.html#a1879b99cadf0d3c0c5de98b33412b650">More...</a><br /></td></tr>
<tr class="separator:a1879b99cadf0d3c0c5de98b33412b650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac155ca106ea75d1bf8f9b995d7e2d99d"><td class="memTemplParams" colspan="2">template&lt;typename... EffectTys&gt; </td></tr>
<tr class="memitem:ac155ca106ea75d1bf8f9b995d7e2d99d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac155ca106ea75d1bf8f9b995d7e2d99d">hasEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ac155ca106ea75d1bf8f9b995d7e2d99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>op</code> has an effect of type <code>EffectTy</code>.  <a href="namespacemlir.html#ac155ca106ea75d1bf8f9b995d7e2d99d">More...</a><br /></td></tr>
<tr class="separator:ac155ca106ea75d1bf8f9b995d7e2d99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27d7e4ff6226389cfa4a4a5129caea0"><td class="memTemplParams" colspan="2">template&lt;typename... EffectTys&gt; </td></tr>
<tr class="memitem:ae27d7e4ff6226389cfa4a4a5129caea0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae27d7e4ff6226389cfa4a4a5129caea0">hasEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:ae27d7e4ff6226389cfa4a4a5129caea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>op</code> has an effect of type <code>EffectTy</code> on <code>value</code>.  <a href="namespacemlir.html#ae27d7e4ff6226389cfa4a4a5129caea0">More...</a><br /></td></tr>
<tr class="separator:ae27d7e4ff6226389cfa4a4a5129caea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc8a79e07b7e048723a9fbfe9bc914e"><td class="memTemplParams" colspan="2">template&lt;typename ValueTy , typename... EffectTys&gt; </td></tr>
<tr class="memitem:a4bc8a79e07b7e048723a9fbfe9bc914e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4bc8a79e07b7e048723a9fbfe9bc914e">hasEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, ValueTy value)</td></tr>
<tr class="memdesc:a4bc8a79e07b7e048723a9fbfe9bc914e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>op</code> has an effect of type <code>EffectTy</code> on <code>value</code> of type <code>ValueTy</code>.  <a href="namespacemlir.html#a4bc8a79e07b7e048723a9fbfe9bc914e">More...</a><br /></td></tr>
<tr class="separator:a4bc8a79e07b7e048723a9fbfe9bc914e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8583719d6a8f0699c36ac4c4b53057f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8583719d6a8f0699c36ac4c4b53057f2">isOpTriviallyDead</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a8583719d6a8f0699c36ac4c4b53057f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given operation is unused, and has no side effects on memory that prevent erasing.  <a href="namespacemlir.html#a8583719d6a8f0699c36ac4c4b53057f2">More...</a><br /></td></tr>
<tr class="separator:a8583719d6a8f0699c36ac4c4b53057f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655db45ed8c23d04d5ed5ee0abe041ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a655db45ed8c23d04d5ed5ee0abe041ad">wouldOpBeTriviallyDead</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a655db45ed8c23d04d5ed5ee0abe041ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given operation would be dead if unused, and has no side effects on memory that would prevent erasing.  <a href="namespacemlir.html#a655db45ed8c23d04d5ed5ee0abe041ad">More...</a><br /></td></tr>
<tr class="separator:a655db45ed8c23d04d5ed5ee0abe041ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5799849a369b839d27241c96a9572de7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5799849a369b839d27241c96a9572de7">isMemoryEffectFree</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a5799849a369b839d27241c96a9572de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given operation is free of memory effects.  <a href="namespacemlir.html#a5799849a369b839d27241c96a9572de7">More...</a><br /></td></tr>
<tr class="separator:a5799849a369b839d27241c96a9572de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4e8ec066bf4a2025b81d2a8c0c9ebe"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">llvm::SmallVector</a>&lt; <a class="el" href="namespacemlir_1_1MemoryEffects.html#ac845c307c34161d9e9c0c1a0287c9664">MemoryEffects::EffectInstance</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abd4e8ec066bf4a2025b81d2a8c0c9ebe">getEffectsRecursively</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *rootOp)</td></tr>
<tr class="memdesc:abd4e8ec066bf4a2025b81d2a8c0c9ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the side effects of an operation.  <a href="namespacemlir.html#abd4e8ec066bf4a2025b81d2a8c0c9ebe">More...</a><br /></td></tr>
<tr class="separator:abd4e8ec066bf4a2025b81d2a8c0c9ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2c465ce654633415e61167b64b8a91"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7a2c465ce654633415e61167b64b8a91">isSpeculatable</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a7a2c465ce654633415e61167b64b8a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given operation is speculatable, i.e.  <a href="namespacemlir.html#a7a2c465ce654633415e61167b64b8a91">More...</a><br /></td></tr>
<tr class="separator:a7a2c465ce654633415e61167b64b8a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550cdaef652bf5d59dfe33a15dc81af5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a550cdaef652bf5d59dfe33a15dc81af5">isPure</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a550cdaef652bf5d59dfe33a15dc81af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given operation is pure, i.e., is speculatable that does not touch memory.  <a href="namespacemlir.html#a550cdaef652bf5d59dfe33a15dc81af5">More...</a><br /></td></tr>
<tr class="separator:a550cdaef652bf5d59dfe33a15dc81af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568cd5e110b674070bdd28be46158fce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a568cd5e110b674070bdd28be46158fce">printDynamicIndexList</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a> values, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; integers, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt; scalables, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> valueTypes=<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>(), <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a> delimiter=<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a>)</td></tr>
<tr class="memdesc:a568cd5e110b674070bdd28be46158fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Printer hook for custom directive in assemblyFormat.  <a href="namespacemlir.html#a568cd5e110b674070bdd28be46158fce">More...</a><br /></td></tr>
<tr class="separator:a568cd5e110b674070bdd28be46158fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3d9353398664321147f5b579f1d767"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aac3d9353398664321147f5b579f1d767">printDynamicIndexList</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a> values, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; integers, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> valueTypes=<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>(), <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a> delimiter=<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a>)</td></tr>
<tr class="separator:aac3d9353398664321147f5b579f1d767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad736d3dd9c0d332b3dd23d7e6dd14963"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad736d3dd9c0d332b3dd23d7e6dd14963">parseDynamicIndexList</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt; &amp;values, <a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a> &amp;integers, <a class="el" href="namespacemlir.html#a7dffb2feeebaff96012a0f11534ecb42">DenseBoolArrayAttr</a> &amp;scalableVals, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; *valueTypes=nullptr, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a> delimiter=<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a>)</td></tr>
<tr class="memdesc:ad736d3dd9c0d332b3dd23d7e6dd14963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parser hook for custom directive in assemblyFormat.  <a href="namespacemlir.html#ad736d3dd9c0d332b3dd23d7e6dd14963">More...</a><br /></td></tr>
<tr class="separator:ad736d3dd9c0d332b3dd23d7e6dd14963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113026edf72f8e99369fc9128e2e0da2"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a113026edf72f8e99369fc9128e2e0da2">parseDynamicIndexList</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt; &amp;values, <a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a> &amp;integers, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; *valueTypes=nullptr, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a> delimiter=<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a>)</td></tr>
<tr class="separator:a113026edf72f8e99369fc9128e2e0da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8511448207eb11107861cc37482f7c56"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8511448207eb11107861cc37482f7c56">parseDynamicIndexList</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt; &amp;values, <a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a> &amp;integers, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;valueTypes, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a> delimiter=<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a>)</td></tr>
<tr class="separator:a8511448207eb11107861cc37482f7c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a67dbd082125f72a4a5b17e4b659d17"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0a67dbd082125f72a4a5b17e4b659d17">parseDynamicIndexList</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt; &amp;values, <a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a> &amp;integers, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;valueTypes, <a class="el" href="namespacemlir.html#a7dffb2feeebaff96012a0f11534ecb42">DenseBoolArrayAttr</a> &amp;scalableVals, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a> delimiter=<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a>)</td></tr>
<tr class="separator:a0a67dbd082125f72a4a5b17e4b659d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a1c57fc94caa37e2b98499a48eea86"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad1a1c57fc94caa37e2b98499a48eea86">verifyListOfOperandsOrIntegers</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, StringRef name, unsigned expectedNumElements, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; attr, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values)</td></tr>
<tr class="memdesc:ad1a1c57fc94caa37e2b98499a48eea86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that a the <code>values</code> has as many elements as the number of entries in <code>attr</code> for which <code>isDynamic</code> evaluates to true.  <a href="namespacemlir.html#ad1a1c57fc94caa37e2b98499a48eea86">More...</a><br /></td></tr>
<tr class="separator:ad1a1c57fc94caa37e2b98499a48eea86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9141d8b586a68549d2ecaccbce99a69"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad9141d8b586a68549d2ecaccbce99a69">hash_value</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> arg)</td></tr>
<tr class="memdesc:ad9141d8b586a68549d2ecaccbce99a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> hashable.  <a href="namespacemlir.html#ad9141d8b586a68549d2ecaccbce99a69">More...</a><br /></td></tr>
<tr class="separator:ad9141d8b586a68549d2ecaccbce99a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6f52bcd2d859c9d9a6f393ad5481c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8f6f52bcd2d859c9d9a6f393ad5481c1">operator+</a> (int64_t val, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="separator:a8f6f52bcd2d859c9d9a6f393ad5481c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9137193b56dc5134c3092273b13e3f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9137193b56dc5134c3092273b13e3f47">operator*</a> (int64_t val, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="separator:a9137193b56dc5134c3092273b13e3f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72aa3fc8e169b33e5d4a63f593172d4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a72aa3fc8e169b33e5d4a63f593172d4e">operator-</a> (int64_t val, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="separator:a72aa3fc8e169b33e5d4a63f593172d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfd4323ef72147332661606b030d04d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">getAffineDimExpr</a> (unsigned position, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:addfd4323ef72147332661606b030d04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">These free functions allow clients of the API to not use classes in detail.  <a href="namespacemlir.html#addfd4323ef72147332661606b030d04d">More...</a><br /></td></tr>
<tr class="separator:addfd4323ef72147332661606b030d04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb7ba5a55b4f16631528884d3617a47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aefb7ba5a55b4f16631528884d3617a47">getAffineSymbolExpr</a> (unsigned position, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="separator:aefb7ba5a55b4f16631528884d3617a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26cdced424aa629fde4150cc8674d50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab26cdced424aa629fde4150cc8674d50">getAffineConstantExpr</a> (int64_t constant, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="separator:ab26cdced424aa629fde4150cc8674d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace395202c24e4dc75013296cf46ed692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ace395202c24e4dc75013296cf46ed692">getAffineConstantExprs</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; constants, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="separator:ace395202c24e4dc75013296cf46ed692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8a0f44c623301035b6151ca51cca4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6e8a0f44c623301035b6151ca51cca4d">getAffineBinaryOpExpr</a> (<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">AffineExprKind</a> kind, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> lhs, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> rhs)</td></tr>
<tr class="separator:a6e8a0f44c623301035b6151ca51cca4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad71c14bebce843758768ff160e2283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8ad71c14bebce843758768ff160e2283">getAffineExprFromFlatForm</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; flatExprs, unsigned numDims, unsigned numSymbols, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; localExprs, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a8ad71c14bebce843758768ff160e2283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an affine expression from a flat ArrayRef.  <a href="namespacemlir.html#a8ad71c14bebce843758768ff160e2283">More...</a><br /></td></tr>
<tr class="separator:a8ad71c14bebce843758768ff160e2283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69078b1d3f3263a1769df2e0f1730df"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae69078b1d3f3263a1769df2e0f1730df">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="separator:ae69078b1d3f3263a1769df2e0f1730df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf369c69cfb613cd018ef4ce188809c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acbf369c69cfb613cd018ef4ce188809c">simplifyAffineExpr</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, unsigned numDims, unsigned numSymbols)</td></tr>
<tr class="memdesc:acbf369c69cfb613cd018ef4ce188809c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify an affine expression by flattening and some amount of simple analysis.  <a href="namespacemlir.html#acbf369c69cfb613cd018ef4ce188809c">More...</a><br /></td></tr>
<tr class="separator:acbf369c69cfb613cd018ef4ce188809c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d147ba82716614172eb7e9b5209d3eb"><td class="memTemplParams" colspan="2">template&lt;typename... AffineExprTy&gt; </td></tr>
<tr class="memitem:a3d147ba82716614172eb7e9b5209d3eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3d147ba82716614172eb7e9b5209d3eb">bindDims</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, AffineExprTy &amp;...exprs)</td></tr>
<tr class="memdesc:a3d147ba82716614172eb7e9b5209d3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a list of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> references to DimExpr at positions: [0 .  <a href="namespacemlir.html#a3d147ba82716614172eb7e9b5209d3eb">More...</a><br /></td></tr>
<tr class="separator:a3d147ba82716614172eb7e9b5209d3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c870d90073423151a32e2c0f2afa506"><td class="memTemplParams" colspan="2">template&lt;typename AffineExprTy &gt; </td></tr>
<tr class="memitem:a2c870d90073423151a32e2c0f2afa506"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2c870d90073423151a32e2c0f2afa506">bindDimsList</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineExprTy &gt; exprs)</td></tr>
<tr class="separator:a2c870d90073423151a32e2c0f2afa506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df39b3ef750e258dbe3dfe5b251cea5"><td class="memTemplParams" colspan="2">template&lt;typename... AffineExprTy&gt; </td></tr>
<tr class="memitem:a8df39b3ef750e258dbe3dfe5b251cea5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8df39b3ef750e258dbe3dfe5b251cea5">bindSymbols</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, AffineExprTy &amp;...exprs)</td></tr>
<tr class="memdesc:a8df39b3ef750e258dbe3dfe5b251cea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a list of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> references to SymbolExpr at positions: [0 .  <a href="namespacemlir.html#a8df39b3ef750e258dbe3dfe5b251cea5">More...</a><br /></td></tr>
<tr class="separator:a8df39b3ef750e258dbe3dfe5b251cea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af523defc0429b26ab3f85b7023748822"><td class="memTemplParams" colspan="2">template&lt;typename AffineExprTy &gt; </td></tr>
<tr class="memitem:af523defc0429b26ab3f85b7023748822"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af523defc0429b26ab3f85b7023748822">bindSymbolsList</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineExprTy &gt; exprs)</td></tr>
<tr class="separator:af523defc0429b26ab3f85b7023748822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23af303f7dd3f645fbb9d05338774b7c"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a23af303f7dd3f645fbb9d05338774b7c">getBoundForAffineExpr</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, unsigned numDims, unsigned numSymbols, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::optional&lt; int64_t &gt;&gt; constLowerBounds, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::optional&lt; int64_t &gt;&gt; constUpperBounds, bool isUpper)</td></tr>
<tr class="memdesc:a23af303f7dd3f645fbb9d05338774b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a lower or upper (depending on <code>isUpper</code>) bound for <code>expr</code> while using the constant lower and upper bounds for its inputs provided in <code>constLowerBounds</code> and <code>constUpperBounds</code>.  <a href="namespacemlir.html#a23af303f7dd3f645fbb9d05338774b7c">More...</a><br /></td></tr>
<tr class="separator:a23af303f7dd3f645fbb9d05338774b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032c893ca9a2fff3b16e5a7cb6d413cd"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a032c893ca9a2fff3b16e5a7cb6d413cd">hash_value</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> arg)</td></tr>
<tr class="separator:a032c893ca9a2fff3b16e5a7cb6d413cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014d8e82c51794d145267690b2b5bd58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a014d8e82c51794d145267690b2b5bd58">simplifyAffineMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a014d8e82c51794d145267690b2b5bd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies an affine map by simplifying its underlying <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> results.  <a href="namespacemlir.html#a014d8e82c51794d145267690b2b5bd58">More...</a><br /></td></tr>
<tr class="separator:a014d8e82c51794d145267690b2b5bd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05caafff59182b2191e4645cdceb5d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab05caafff59182b2191e4645cdceb5d5">compressDims</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, const llvm::SmallBitVector &amp;unusedDims)</td></tr>
<tr class="memdesc:ab05caafff59182b2191e4645cdceb5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the dims that are listed in <code>unusedDims</code>.  <a href="namespacemlir.html#ab05caafff59182b2191e4645cdceb5d5">More...</a><br /></td></tr>
<tr class="separator:ab05caafff59182b2191e4645cdceb5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f84d2ce14eec6c85a20251582e5cc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a99f84d2ce14eec6c85a20251582e5cc1">compressUnusedDims</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a99f84d2ce14eec6c85a20251582e5cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the dims that are not used.  <a href="namespacemlir.html#a99f84d2ce14eec6c85a20251582e5cc1">More...</a><br /></td></tr>
<tr class="separator:a99f84d2ce14eec6c85a20251582e5cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a3cbce4381f83b710fe6cfc9a867c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae2a3cbce4381f83b710fe6cfc9a867c9">compressUnusedDims</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps)</td></tr>
<tr class="memdesc:ae2a3cbce4381f83b710fe6cfc9a867c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the dims that are not used by any of the individual maps in <code>maps</code>.  <a href="namespacemlir.html#ae2a3cbce4381f83b710fe6cfc9a867c9">More...</a><br /></td></tr>
<tr class="separator:ae2a3cbce4381f83b710fe6cfc9a867c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de5b9ec7c351db7ed870d0df7248342"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6de5b9ec7c351db7ed870d0df7248342">compressSymbols</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, const llvm::SmallBitVector &amp;unusedSymbols)</td></tr>
<tr class="memdesc:a6de5b9ec7c351db7ed870d0df7248342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the symbols that are listed in <code>unusedSymbols</code>.  <a href="namespacemlir.html#a6de5b9ec7c351db7ed870d0df7248342">More...</a><br /></td></tr>
<tr class="separator:a6de5b9ec7c351db7ed870d0df7248342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c401a074fdcc1cb0efb7e5369b2ef3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae4c401a074fdcc1cb0efb7e5369b2ef3">compressUnusedSymbols</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:ae4c401a074fdcc1cb0efb7e5369b2ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the symbols that are not used.  <a href="namespacemlir.html#ae4c401a074fdcc1cb0efb7e5369b2ef3">More...</a><br /></td></tr>
<tr class="separator:ae4c401a074fdcc1cb0efb7e5369b2ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a26d1a643586acb4362f535168be129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4a26d1a643586acb4362f535168be129">compressUnusedSymbols</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps)</td></tr>
<tr class="memdesc:a4a26d1a643586acb4362f535168be129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the symbols that are not used by any of the individual maps in <code>maps</code>.  <a href="namespacemlir.html#a4a26d1a643586acb4362f535168be129">More...</a><br /></td></tr>
<tr class="separator:a4a26d1a643586acb4362f535168be129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92bdb36e3e6eeecc32f23923e58d973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae92bdb36e3e6eeecc32f23923e58d973">foldAttributesIntoMap</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;b, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;remainingValues)</td></tr>
<tr class="memdesc:ae92bdb36e3e6eeecc32f23923e58d973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold all attributes among the given operands into the affine map.  <a href="namespacemlir.html#ae92bdb36e3e6eeecc32f23923e58d973">More...</a><br /></td></tr>
<tr class="separator:ae92bdb36e3e6eeecc32f23923e58d973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa0a7e84eb2af3d70c98d59fc9ccbd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1fa0a7e84eb2af3d70c98d59fc9ccbd3">removeDuplicateExprs</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a1fa0a7e84eb2af3d70c98d59fc9ccbd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map with the same dimension and symbol count as <code>map</code>, but whose results are the unique affine expressions of <code>map</code>.  <a href="namespacemlir.html#a1fa0a7e84eb2af3d70c98d59fc9ccbd3">More...</a><br /></td></tr>
<tr class="separator:a1fa0a7e84eb2af3d70c98d59fc9ccbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b322818d83a2256d4e4391acbf78a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a52b322818d83a2256d4e4391acbf78a2">inversePermutation</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a52b322818d83a2256d4e4391acbf78a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map of codomain to domain dimensions such that the first codomain dimension for a particular domain dimension is selected.  <a href="namespacemlir.html#a52b322818d83a2256d4e4391acbf78a2">More...</a><br /></td></tr>
<tr class="separator:a52b322818d83a2256d4e4391acbf78a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39612be2ef116102866d3bb9c6a8ca88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a39612be2ef116102866d3bb9c6a8ca88">inverseAndBroadcastProjectedPermutation</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a39612be2ef116102866d3bb9c6a8ca88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reverse map of a projected permutation where the projected dimensions are transformed into 0s.  <a href="namespacemlir.html#a39612be2ef116102866d3bb9c6a8ca88">More...</a><br /></td></tr>
<tr class="separator:a39612be2ef116102866d3bb9c6a8ca88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d24d64d6db077b8d5c88316b0d6c717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6d24d64d6db077b8d5c88316b0d6c717">concatAffineMaps</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps)</td></tr>
<tr class="memdesc:a6d24d64d6db077b8d5c88316b0d6c717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates a list of <code>maps</code> into a single <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a>, stepping over potentially empty maps.  <a href="namespacemlir.html#a6d24d64d6db077b8d5c88316b0d6c717">More...</a><br /></td></tr>
<tr class="separator:a6d24d64d6db077b8d5c88316b0d6c717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1261e0343cefe25ab1724c67005b7d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae1261e0343cefe25ab1724c67005b7d2">projectDims</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, const llvm::SmallBitVector &amp;projectedDimensions, bool compressDimsFlag=false)</td></tr>
<tr class="memdesc:ae1261e0343cefe25ab1724c67005b7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map that results from projecting out the dimensions specified in <code>projectedDimensions</code>.  <a href="namespacemlir.html#ae1261e0343cefe25ab1724c67005b7d2">More...</a><br /></td></tr>
<tr class="separator:ae1261e0343cefe25ab1724c67005b7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ec6082bc5758f83f4b0938b00b160d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae5ec6082bc5758f83f4b0938b00b160d">projectSymbols</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, const llvm::SmallBitVector &amp;projectedSymbols, bool compressSymbolsFlag=false)</td></tr>
<tr class="memdesc:ae5ec6082bc5758f83f4b0938b00b160d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol counterpart of <code>projectDims</code>.  <a href="namespacemlir.html#ae5ec6082bc5758f83f4b0938b00b160d">More...</a><br /></td></tr>
<tr class="separator:ae5ec6082bc5758f83f4b0938b00b160d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45e3ce76869b05848f96a5f8b97fc90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab45e3ce76869b05848f96a5f8b97fc90">getProjectedMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, const llvm::SmallBitVector &amp;projectedDimensions, bool compressDimsFlag=true, bool compressSymbolsFlag=true)</td></tr>
<tr class="memdesc:ab45e3ce76869b05848f96a5f8b97fc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code>projectDims(map, projectedDimensions, compressDimsFlag)</code>.  <a href="namespacemlir.html#ab45e3ce76869b05848f96a5f8b97fc90">More...</a><br /></td></tr>
<tr class="separator:ab45e3ce76869b05848f96a5f8b97fc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61c6bb6068af953a0711cf404a99645"><td class="memItemLeft" align="right" valign="top">llvm::SmallBitVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac61c6bb6068af953a0711cf404a99645">getUnusedDimsBitVector</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps)</td></tr>
<tr class="separator:ac61c6bb6068af953a0711cf404a99645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2798707e1d2321021e16802305d3c152"><td class="memItemLeft" align="right" valign="top">llvm::SmallBitVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2798707e1d2321021e16802305d3c152">getUnusedSymbolsBitVector</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps)</td></tr>
<tr class="separator:a2798707e1d2321021e16802305d3c152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbb3252a45b5feab49c0bac2a68779c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0bbb3252a45b5feab49c0bac2a68779c">expandDimsToRank</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, int64_t rank, const llvm::SmallBitVector &amp;projectedDimensions)</td></tr>
<tr class="memdesc:a0bbb3252a45b5feab49c0bac2a68779c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand <code>map</code> to operate on <code>rank</code> dims while projecting out the dims in <code>projectedDimensions</code>.  <a href="namespacemlir.html#a0bbb3252a45b5feab49c0bac2a68779c">More...</a><br /></td></tr>
<tr class="separator:a0bbb3252a45b5feab49c0bac2a68779c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f93a44db5e2d93372201d5a594e51cd"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6f93a44db5e2d93372201d5a594e51cd">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="separator:a6f93a44db5e2d93372201d5a594e51cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b76f177cd65bd4fd394f9dc65d20be2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b76f177cd65bd4fd394f9dc65d20be2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2b76f177cd65bd4fd394f9dc65d20be2">applyPermutationMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; T &gt; source)</td></tr>
<tr class="memdesc:a2b76f177cd65bd4fd394f9dc65d20be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a permutation from <code>map</code> to <code>source</code> and return the result.  <a href="namespacemlir.html#a2b76f177cd65bd4fd394f9dc65d20be2">More...</a><br /></td></tr>
<tr class="separator:a2b76f177cd65bd4fd394f9dc65d20be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74485bec820f2186ce852a09f45ebd47"><td class="memTemplParams" colspan="2">template&lt;typename AffineExprContainer &gt; </td></tr>
<tr class="memitem:a74485bec820f2186ce852a09f45ebd47"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a74485bec820f2186ce852a09f45ebd47">getMaxDimAndSymbol</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineExprContainer &gt; exprsList, int64_t &amp;maxDim, int64_t &amp;maxSym)</td></tr>
<tr class="memdesc:a74485bec820f2186ce852a09f45ebd47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates maximum dimension and symbol positions from the expressions in <code>exprsLists</code> and stores them in <code>maxDim</code> and <code>maxSym</code> respectively.  <a href="namespacemlir.html#a74485bec820f2186ce852a09f45ebd47">More...</a><br /></td></tr>
<tr class="separator:a74485bec820f2186ce852a09f45ebd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e5dd60111e86e0df4b52a7d3befd33"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a23e5dd60111e86e0df4b52a7d3befd33">toString</a> (<a class="el" href="namespacemlir.html#ac84871bcca0aaa0176d43dbdbffe9a6c">AsmResourceEntryKind</a> kind)</td></tr>
<tr class="separator:a23e5dd60111e86e0df4b52a7d3befd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894a08aa6ed051f55e57bc35859a379f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a894a08aa6ed051f55e57bc35859a379f">registerAsmPrinterCLOptions</a> ()</td></tr>
<tr class="memdesc:a894a08aa6ed051f55e57bc35859a379f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a set of useful command-line options that can be used to configure various flags within the <a class="el" href="classmlir_1_1AsmPrinter.html" title="This base class exposes generic asm printer hooks, usable across the various derived printers.">AsmPrinter</a>.  <a href="namespacemlir.html#a894a08aa6ed051f55e57bc35859a379f">More...</a><br /></td></tr>
<tr class="separator:a894a08aa6ed051f55e57bc35859a379f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8f0e932c305de3ac1584560d1b03d0"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5e8f0e932c305de3ac1584560d1b03d0">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="separator:a5e8f0e932c305de3ac1584560d1b03d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bae84b1d7cdba11b048d9af3478a07"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a68bae84b1d7cdba11b048d9af3478a07">hash_value</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> arg)</td></tr>
<tr class="separator:a68bae84b1d7cdba11b048d9af3478a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b795f2f972c070efff53082563f976"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa4b795f2f972c070efff53082563f976">hash_value</a> (const <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &amp;arg)</td></tr>
<tr class="separator:aa4b795f2f972c070efff53082563f976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e488dd4f0933d688cd10581b313afb"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a13e488dd4f0933d688cd10581b313afb">operator&lt;&lt;</a> (raw_ostream &amp;, <a class="el" href="classmlir_1_1Block.html">Block</a> &amp;)</td></tr>
<tr class="separator:a13e488dd4f0933d688cd10581b313afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543c4328a4fa5ed530aa88a9d7d158a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a543c4328a4fa5ed530aa88a9d7d158a9">operator==</a> (StringAttr lhs, std::nullptr_t)</td></tr>
<tr class="memdesc:a543c4328a4fa5ed530aa88a9d7d158a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define comparisons for StringAttr against nullptr and itself to avoid the StringRef overloads from being chosen when not desirable.  <a href="namespacemlir.html#a543c4328a4fa5ed530aa88a9d7d158a9">More...</a><br /></td></tr>
<tr class="separator:a543c4328a4fa5ed530aa88a9d7d158a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db56ba5c170b04848e194937be59a56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8db56ba5c170b04848e194937be59a56">operator!=</a> (StringAttr lhs, std::nullptr_t)</td></tr>
<tr class="separator:a8db56ba5c170b04848e194937be59a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ce38cb70a016263f28574d4982475b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a40ce38cb70a016263f28574d4982475b">operator==</a> (StringAttr lhs, StringAttr rhs)</td></tr>
<tr class="separator:a40ce38cb70a016263f28574d4982475b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb385e3105982b905c5ef4db9f9f21b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6bb385e3105982b905c5ef4db9f9f21b">operator!=</a> (StringAttr lhs, StringAttr rhs)</td></tr>
<tr class="separator:a6bb385e3105982b905c5ef4db9f9f21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075d7bf5dfe5d33c409763bc28330180"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a075d7bf5dfe5d33c409763bc28330180">operator==</a> (StringAttr lhs, StringRef rhs)</td></tr>
<tr class="memdesc:a075d7bf5dfe5d33c409763bc28330180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow direct comparison with StringRef.  <a href="namespacemlir.html#a075d7bf5dfe5d33c409763bc28330180">More...</a><br /></td></tr>
<tr class="separator:a075d7bf5dfe5d33c409763bc28330180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48146d74baebce1c83140c378053f3c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a48146d74baebce1c83140c378053f3c2">operator!=</a> (StringAttr lhs, StringRef rhs)</td></tr>
<tr class="separator:a48146d74baebce1c83140c378053f3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c46bfb0a0fbbe700ef6c07a611dbf8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a50c46bfb0a0fbbe700ef6c07a611dbf8">operator==</a> (StringRef lhs, StringAttr rhs)</td></tr>
<tr class="separator:a50c46bfb0a0fbbe700ef6c07a611dbf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfbb1c5941d2cc005eb3f483e881202"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4bfbb1c5941d2cc005eb3f483e881202">operator!=</a> (StringRef lhs, StringAttr rhs)</td></tr>
<tr class="separator:a4bfbb1c5941d2cc005eb3f483e881202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923fafcbdcfdcb3b735fab2ab293a1ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a923fafcbdcfdcb3b735fab2ab293a1ad">makeStridedLinearLayoutMap</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; strides, int64_t offset, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a923fafcbdcfdcb3b735fab2ab293a1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of strides (in which ShapedType::kDynamic represents a dynamic value), return the single result <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> which represents the linearized strided layout map.  <a href="namespacemlir.html#a923fafcbdcfdcb3b735fab2ab293a1ad">More...</a><br /></td></tr>
<tr class="separator:a923fafcbdcfdcb3b735fab2ab293a1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e47350637dfbf8ad64f9e3bba17bdd"><td class="memItemLeft" align="right" valign="top">std::optional&lt; llvm::SmallDenseSet&lt; unsigned &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac7e47350637dfbf8ad64f9e3bba17bdd">computeRankReductionMask</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; originalShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; reducedShape, bool matchDynamic=false)</td></tr>
<tr class="memdesc:ac7e47350637dfbf8ad64f9e3bba17bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an <code>originalShape</code> and a <code>reducedShape</code> assumed to be a subset of <code>originalShape</code> with some <code>1</code> entries erased, return the set of indices that specifies which of the entries of <code>originalShape</code> are dropped to obtain <code>reducedShape</code>.  <a href="namespacemlir.html#ac7e47350637dfbf8ad64f9e3bba17bdd">More...</a><br /></td></tr>
<tr class="separator:ac7e47350637dfbf8ad64f9e3bba17bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae209f096d9240a818927afbab10f43b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">SliceVerificationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae209f096d9240a818927afbab10f43b8">isRankReducedType</a> (ShapedType originalType, ShapedType candidateReducedType)</td></tr>
<tr class="memdesc:ae209f096d9240a818927afbab10f43b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>originalType</code> can be rank reduced to <code>candidateReducedType</code> type by dropping some dimensions with static size <code>1</code>.  <a href="namespacemlir.html#ae209f096d9240a818927afbab10f43b8">More...</a><br /></td></tr>
<tr class="separator:ae209f096d9240a818927afbab10f43b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506c478f802ab2f874c0b34a18bc091b"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a506c478f802ab2f874c0b34a18bc091b">getStridesAndOffset</a> (MemRefType t, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;strides, int64_t &amp;offset)</td></tr>
<tr class="memdesc:a506c478f802ab2f874c0b34a18bc091b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the strides of the MemRef if the layout map is in strided form.  <a href="namespacemlir.html#a506c478f802ab2f874c0b34a18bc091b">More...</a><br /></td></tr>
<tr class="separator:a506c478f802ab2f874c0b34a18bc091b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91209454b6a2bc993c1d3ebc2ac3aab1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a91209454b6a2bc993c1d3ebc2ac3aab1">getStridesAndOffset</a> (MemRefType t)</td></tr>
<tr class="memdesc:a91209454b6a2bc993c1d3ebc2ac3aab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around getStridesAndOffset(MemRefType, SmallVectorImpl&lt;int64_t&gt;, int64_t) that will assert if the logical result is not succeeded.  <a href="namespacemlir.html#a91209454b6a2bc993c1d3ebc2ac3aab1">More...</a><br /></td></tr>
<tr class="separator:a91209454b6a2bc993c1d3ebc2ac3aab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dcfbd64b4c5038926d874e46edeea2"><td class="memItemLeft" align="right" valign="top">MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a80dcfbd64b4c5038926d874e46edeea2">canonicalizeStridedLayout</a> (MemRefType t)</td></tr>
<tr class="memdesc:a80dcfbd64b4c5038926d874e46edeea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a version of <code>t</code> with identity layout if it can be determined statically that the layout is the canonical contiguous strided layout.  <a href="namespacemlir.html#a80dcfbd64b4c5038926d874e46edeea2">More...</a><br /></td></tr>
<tr class="separator:a80dcfbd64b4c5038926d874e46edeea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac603376cc0dac0b2bd27c2dcde3c2e14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac603376cc0dac0b2bd27c2dcde3c2e14">makeCanonicalStridedLayoutExpr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; exprs, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ac603376cc0dac0b2bd27c2dcde3c2e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given MemRef <code>sizes</code> that are either static or dynamic, returns the canonical "contiguous" strides <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a>.  <a href="namespacemlir.html#ac603376cc0dac0b2bd27c2dcde3c2e14">More...</a><br /></td></tr>
<tr class="separator:ac603376cc0dac0b2bd27c2dcde3c2e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25cd8672ecb721d7a4f0ecd22bac6e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad25cd8672ecb721d7a4f0ecd22bac6e8">makeCanonicalStridedLayoutExpr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizes, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ad25cd8672ecb721d7a4f0ecd22bac6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of makeCanonicalStrudedLayoutExpr for the common case where <code>exprs</code> is {d0, d1, .., d_(sizes.size()-1)}.  <a href="namespacemlir.html#ad25cd8672ecb721d7a4f0ecd22bac6e8">More...</a><br /></td></tr>
<tr class="separator:ad25cd8672ecb721d7a4f0ecd22bac6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c26bcf64137533f38f2cda9abd75af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad0c26bcf64137533f38f2cda9abd75af">isStrided</a> (MemRefType t)</td></tr>
<tr class="memdesc:ad0c26bcf64137533f38f2cda9abd75af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if the layout for <code>t</code> is compatible with strided semantics.  <a href="namespacemlir.html#ad0c26bcf64137533f38f2cda9abd75af">More...</a><br /></td></tr>
<tr class="separator:ad0c26bcf64137533f38f2cda9abd75af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3094da0d25a9eabb0cea9f0b859c0adc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3094da0d25a9eabb0cea9f0b859c0adc">isLastMemrefDimUnitStride</a> (MemRefType type)</td></tr>
<tr class="memdesc:a3094da0d25a9eabb0cea9f0b859c0adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if the last dimension of the given type has a static unit stride.  <a href="namespacemlir.html#a3094da0d25a9eabb0cea9f0b859c0adc">More...</a><br /></td></tr>
<tr class="separator:a3094da0d25a9eabb0cea9f0b859c0adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fbeb913d35e020e382b9f6c82a2fa8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af7fbeb913d35e020e382b9f6c82a2fa8">trailingNDimsContiguous</a> (MemRefType type, int64_t n)</td></tr>
<tr class="memdesc:af7fbeb913d35e020e382b9f6c82a2fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if the last N dimensions of the given type are contiguous.  <a href="namespacemlir.html#af7fbeb913d35e020e382b9f6c82a2fa8">More...</a><br /></td></tr>
<tr class="separator:af7fbeb913d35e020e382b9f6c82a2fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72e36349258a6b2baeae78188a74550"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae72e36349258a6b2baeae78188a74550">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1DiagnosticArgument.html">DiagnosticArgument</a> &amp;arg)</td></tr>
<tr class="separator:ae72e36349258a6b2baeae78188a74550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b9a8e647d5e73b7e107b0669ec9e29"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a85b9a8e647d5e73b7e107b0669ec9e29">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a> &amp;<a class="el" href="ModuleImport_8cpp.html#a0ba25d7b0573f8dd5fd669095441a61e">diag</a>)</td></tr>
<tr class="separator:a85b9a8e647d5e73b7e107b0669ec9e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e96b0c437652eb5a4890734bb6bcee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a4e96b0c437652eb5a4890734bb6bcee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to emit an error message using this location.  <a href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">More...</a><br /></td></tr>
<tr class="separator:a4e96b0c437652eb5a4890734bb6bcee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc4e9418ff63ebea20c7f709ebcb0f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2dc4e9418ff63ebea20c7f709ebcb0f8">emitError</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message)</td></tr>
<tr class="separator:a2dc4e9418ff63ebea20c7f709ebcb0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0768c8a572dc71b0b00d57414b56b60d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0768c8a572dc71b0b00d57414b56b60d">emitWarning</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a0768c8a572dc71b0b00d57414b56b60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to emit a warning message using this location.  <a href="namespacemlir.html#a0768c8a572dc71b0b00d57414b56b60d">More...</a><br /></td></tr>
<tr class="separator:a0768c8a572dc71b0b00d57414b56b60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e96e5ea091fb5bea539cef6ea7c5624"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5e96e5ea091fb5bea539cef6ea7c5624">emitWarning</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message)</td></tr>
<tr class="separator:a5e96e5ea091fb5bea539cef6ea7c5624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9ca6fe9d5aab498bf090db3e878c87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8a9ca6fe9d5aab498bf090db3e878c87">emitRemark</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a8a9ca6fe9d5aab498bf090db3e878c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to emit a remark message using this location.  <a href="namespacemlir.html#a8a9ca6fe9d5aab498bf090db3e878c87">More...</a><br /></td></tr>
<tr class="separator:a8a9ca6fe9d5aab498bf090db3e878c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391c4b4ea9dc95fbcfbfdab8a49547a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a391c4b4ea9dc95fbcfbfdab8a49547a3">emitRemark</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message)</td></tr>
<tr class="separator:a391c4b4ea9dc95fbcfbfdab8a49547a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45deee4eed2b998fbde1d3573325bc6e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a45deee4eed2b998fbde1d3573325bc6e"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a45deee4eed2b998fbde1d3573325bc6e">emitOptionalError</a> (std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; loc, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a45deee4eed2b998fbde1d3573325bc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads of the above emission functions that take an optionally null location.  <a href="namespacemlir.html#a45deee4eed2b998fbde1d3573325bc6e">More...</a><br /></td></tr>
<tr class="separator:a45deee4eed2b998fbde1d3573325bc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03c4337fa32d3045568e4dc6eef60ca"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac03c4337fa32d3045568e4dc6eef60ca"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac03c4337fa32d3045568e4dc6eef60ca">emitOptionalWarning</a> (std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; loc, Args &amp;&amp;...args)</td></tr>
<tr class="separator:ac03c4337fa32d3045568e4dc6eef60ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5cd384eee5c5c8a7125233ade78eea"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a3f5cd384eee5c5c8a7125233ade78eea"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3f5cd384eee5c5c8a7125233ade78eea">emitOptionalRemark</a> (std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; loc, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a3f5cd384eee5c5c8a7125233ade78eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655bb0e17a21ea2c35194f7c822c9ca5"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a655bb0e17a21ea2c35194f7c822c9ca5">hash_value</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> arg)</td></tr>
<tr class="separator:a655bb0e17a21ea2c35194f7c822c9ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab097ddf5971ea2a3956fc814005f459f"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab097ddf5971ea2a3956fc814005f459f">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1Location.html">Location</a> &amp;loc)</td></tr>
<tr class="separator:ab097ddf5971ea2a3956fc814005f459f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6261878bc5197cfcc003e5b3fa735ea"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa6261878bc5197cfcc003e5b3fa735ea">hash_value</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> arg)</td></tr>
<tr class="separator:aa6261878bc5197cfcc003e5b3fa735ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad402a86ee4c9000c6fa1fceaddab560b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__op__matcher.html">detail::constant_op_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad402a86ee4c9000c6fa1fceaddab560b">m_Constant</a> ()</td></tr>
<tr class="memdesc:ad402a86ee4c9000c6fa1fceaddab560b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant foldable operation.  <a href="namespacemlir.html#ad402a86ee4c9000c6fa1fceaddab560b">More...</a><br /></td></tr>
<tr class="separator:ad402a86ee4c9000c6fa1fceaddab560b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d87ea3290be975b746704e58465017"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1AttrOpMatcher.html">detail::AttrOpMatcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a18d87ea3290be975b746704e58465017">m_Attr</a> (StringRef attrName)</td></tr>
<tr class="memdesc:a18d87ea3290be975b746704e58465017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a named attribute operation.  <a href="namespacemlir.html#a18d87ea3290be975b746704e58465017">More...</a><br /></td></tr>
<tr class="separator:a18d87ea3290be975b746704e58465017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b52f968271c9a4da1bc766ee083a9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1NameOpMatcher.html">detail::NameOpMatcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a69b52f968271c9a4da1bc766ee083a9c">m_Op</a> (StringRef opName)</td></tr>
<tr class="memdesc:a69b52f968271c9a4da1bc766ee083a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a named operation.  <a href="namespacemlir.html#a69b52f968271c9a4da1bc766ee083a9c">More...</a><br /></td></tr>
<tr class="separator:a69b52f968271c9a4da1bc766ee083a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b6da5781fbe1b019fcb64dcd6921dd"><td class="memTemplParams" colspan="2">template&lt;typename AttrT &gt; </td></tr>
<tr class="memitem:a10b6da5781fbe1b019fcb64dcd6921dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__op__binder.html">detail::constant_op_binder</a>&lt; AttrT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a10b6da5781fbe1b019fcb64dcd6921dd">m_Constant</a> (AttrT *bind_value)</td></tr>
<tr class="memdesc:a10b6da5781fbe1b019fcb64dcd6921dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a value from a constant foldable operation and writes the value to bind_value.  <a href="namespacemlir.html#a10b6da5781fbe1b019fcb64dcd6921dd">More...</a><br /></td></tr>
<tr class="separator:a10b6da5781fbe1b019fcb64dcd6921dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3132b68de242f1e938904d71be736db8"><td class="memTemplParams" colspan="2">template&lt;typename AttrT &gt; </td></tr>
<tr class="memitem:a3132b68de242f1e938904d71be736db8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1AttrOpBinder.html">detail::AttrOpBinder</a>&lt; AttrT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3132b68de242f1e938904d71be736db8">m_Attr</a> (StringRef attrName, AttrT *bindValue)</td></tr>
<tr class="memdesc:a3132b68de242f1e938904d71be736db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a named attribute operation and writes the value to bind_value.  <a href="namespacemlir.html#a3132b68de242f1e938904d71be736db8">More...</a><br /></td></tr>
<tr class="separator:a3132b68de242f1e938904d71be736db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea33aa665368d4f2108eb2d41c85111"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8ea33aa665368d4f2108eb2d41c85111">m_AnyZeroFloat</a> ()</td></tr>
<tr class="memdesc:a8ea33aa665368d4f2108eb2d41c85111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float (both positive and negative) zero.  <a href="namespacemlir.html#a8ea33aa665368d4f2108eb2d41c85111">More...</a><br /></td></tr>
<tr class="separator:a8ea33aa665368d4f2108eb2d41c85111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774a1ae971f4ef00eb57389293dfe617"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a774a1ae971f4ef00eb57389293dfe617">m_PosZeroFloat</a> ()</td></tr>
<tr class="memdesc:a774a1ae971f4ef00eb57389293dfe617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float positive zero.  <a href="namespacemlir.html#a774a1ae971f4ef00eb57389293dfe617">More...</a><br /></td></tr>
<tr class="separator:a774a1ae971f4ef00eb57389293dfe617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9eba8d1292854c0da6c062988ecac9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa9eba8d1292854c0da6c062988ecac9b">m_NegZeroFloat</a> ()</td></tr>
<tr class="memdesc:aa9eba8d1292854c0da6c062988ecac9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float negative zero.  <a href="namespacemlir.html#aa9eba8d1292854c0da6c062988ecac9b">More...</a><br /></td></tr>
<tr class="separator:aa9eba8d1292854c0da6c062988ecac9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0495d84f34cf3238a7741fa6974a485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af0495d84f34cf3238a7741fa6974a485">m_OneFloat</a> ()</td></tr>
<tr class="memdesc:af0495d84f34cf3238a7741fa6974a485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float ones.  <a href="namespacemlir.html#af0495d84f34cf3238a7741fa6974a485">More...</a><br /></td></tr>
<tr class="separator:af0495d84f34cf3238a7741fa6974a485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc93dfeaa35bda23b16591c462c335f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adc93dfeaa35bda23b16591c462c335f6">m_PosInfFloat</a> ()</td></tr>
<tr class="memdesc:adc93dfeaa35bda23b16591c462c335f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float positive infinity.  <a href="namespacemlir.html#adc93dfeaa35bda23b16591c462c335f6">More...</a><br /></td></tr>
<tr class="separator:adc93dfeaa35bda23b16591c462c335f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e89b015211525b010832d2d2c37650b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9e89b015211525b010832d2d2c37650b">m_NegInfFloat</a> ()</td></tr>
<tr class="memdesc:a9e89b015211525b010832d2d2c37650b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float negative infinity.  <a href="namespacemlir.html#a9e89b015211525b010832d2d2c37650b">More...</a><br /></td></tr>
<tr class="separator:a9e89b015211525b010832d2d2c37650b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5d8af15bd8994b1a7abeaaacfe1b06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7f5d8af15bd8994b1a7abeaaacfe1b06">m_Zero</a> ()</td></tr>
<tr class="memdesc:a7f5d8af15bd8994b1a7abeaaacfe1b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer zero.  <a href="namespacemlir.html#a7f5d8af15bd8994b1a7abeaaacfe1b06">More...</a><br /></td></tr>
<tr class="separator:a7f5d8af15bd8994b1a7abeaaacfe1b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bb42600b9be680591776fdc14a53cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a94bb42600b9be680591776fdc14a53cd">m_NonZero</a> ()</td></tr>
<tr class="memdesc:a94bb42600b9be680591776fdc14a53cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer that is any non-zero value.  <a href="namespacemlir.html#a94bb42600b9be680591776fdc14a53cd">More...</a><br /></td></tr>
<tr class="separator:a94bb42600b9be680591776fdc14a53cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe6d87f8ecb162173628bc66674ba72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__range__predicate__matcher.html">detail::constant_int_range_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afbe6d87f8ecb162173628bc66674ba72">m_IntRangeWithoutZeroU</a> ()</td></tr>
<tr class="memdesc:afbe6d87f8ecb162173628bc66674ba72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer or a unsigned integer range that does not contain zero.  <a href="namespacemlir.html#afbe6d87f8ecb162173628bc66674ba72">More...</a><br /></td></tr>
<tr class="separator:afbe6d87f8ecb162173628bc66674ba72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab744f07f6776a02e49c0851786db161a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__range__predicate__matcher.html">detail::constant_int_range_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab744f07f6776a02e49c0851786db161a">m_IntRangeWithoutZeroS</a> ()</td></tr>
<tr class="memdesc:ab744f07f6776a02e49c0851786db161a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer or a signed integer range that does not contain zero.  <a href="namespacemlir.html#ab744f07f6776a02e49c0851786db161a">More...</a><br /></td></tr>
<tr class="separator:ab744f07f6776a02e49c0851786db161a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4136ce33972b8eb3801f4c304f53acae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__range__predicate__matcher.html">detail::constant_int_range_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4136ce33972b8eb3801f4c304f53acae">m_IntRangeWithoutNegOneS</a> ()</td></tr>
<tr class="memdesc:a4136ce33972b8eb3801f4c304f53acae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer or a signed integer range that does not contain minus one.  <a href="namespacemlir.html#a4136ce33972b8eb3801f4c304f53acae">More...</a><br /></td></tr>
<tr class="separator:a4136ce33972b8eb3801f4c304f53acae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907f415a4c803b15ef57db37cc732f39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a907f415a4c803b15ef57db37cc732f39">m_One</a> ()</td></tr>
<tr class="memdesc:a907f415a4c803b15ef57db37cc732f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer one.  <a href="namespacemlir.html#a907f415a4c803b15ef57db37cc732f39">More...</a><br /></td></tr>
<tr class="separator:a907f415a4c803b15ef57db37cc732f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2418532386147bec2ca5aadf5414406"><td class="memTemplParams" colspan="2">template&lt;typename OpClass &gt; </td></tr>
<tr class="memitem:ac2418532386147bec2ca5aadf5414406"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">detail::op_matcher</a>&lt; OpClass &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac2418532386147bec2ca5aadf5414406">m_Op</a> ()</td></tr>
<tr class="memdesc:ac2418532386147bec2ca5aadf5414406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the given OpClass.  <a href="namespacemlir.html#ac2418532386147bec2ca5aadf5414406">More...</a><br /></td></tr>
<tr class="separator:ac2418532386147bec2ca5aadf5414406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0190228b09e7b51a4bc1e013c01d404c"><td class="memTemplParams" colspan="2">template&lt;typename Pattern &gt; </td></tr>
<tr class="memitem:a0190228b09e7b51a4bc1e013c01d404c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0190228b09e7b51a4bc1e013c01d404c">matchPattern</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;pattern)</td></tr>
<tr class="memdesc:a0190228b09e7b51a4bc1e013c01d404c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for matching a pattern over a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="namespacemlir.html#a0190228b09e7b51a4bc1e013c01d404c">More...</a><br /></td></tr>
<tr class="separator:a0190228b09e7b51a4bc1e013c01d404c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b97d57dcd6c08b495fbd3ef22aeda6f"><td class="memTemplParams" colspan="2">template&lt;typename Pattern &gt; </td></tr>
<tr class="memitem:a1b97d57dcd6c08b495fbd3ef22aeda6f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1b97d57dcd6c08b495fbd3ef22aeda6f">matchPattern</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;pattern)</td></tr>
<tr class="memdesc:a1b97d57dcd6c08b495fbd3ef22aeda6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for matching a pattern over an <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>.  <a href="namespacemlir.html#a1b97d57dcd6c08b495fbd3ef22aeda6f">More...</a><br /></td></tr>
<tr class="separator:a1b97d57dcd6c08b495fbd3ef22aeda6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77883d2221f5bdf428d745d778f90d49"><td class="memTemplParams" colspan="2">template&lt;typename Pattern &gt; </td></tr>
<tr class="memitem:a77883d2221f5bdf428d745d778f90d49"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a77883d2221f5bdf428d745d778f90d49">matchPattern</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;pattern)</td></tr>
<tr class="memdesc:a77883d2221f5bdf428d745d778f90d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for matching a pattern over an <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>.  <a href="namespacemlir.html#a77883d2221f5bdf428d745d778f90d49">More...</a><br /></td></tr>
<tr class="separator:a77883d2221f5bdf428d745d778f90d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefeea9b182f6e6e1a267b0bd157e7970"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__value__binder.html">detail::constant_float_value_binder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aefeea9b182f6e6e1a267b0bd157e7970">m_ConstantFloat</a> (FloatAttr::ValueType *bind_value)</td></tr>
<tr class="memdesc:aefeea9b182f6e6e1a267b0bd157e7970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant holding a scalar/vector/tensor float (splat) and writes the float value to bind_value.  <a href="namespacemlir.html#aefeea9b182f6e6e1a267b0bd157e7970">More...</a><br /></td></tr>
<tr class="separator:aefeea9b182f6e6e1a267b0bd157e7970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091c0686ba6d6f3ad4af9db1aea8063f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__value__binder.html">detail::constant_int_value_binder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a091c0686ba6d6f3ad4af9db1aea8063f">m_ConstantInt</a> (IntegerAttr::ValueType *bind_value)</td></tr>
<tr class="memdesc:a091c0686ba6d6f3ad4af9db1aea8063f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant holding a scalar/vector/tensor integer (splat) and writes the integer value to bind_value.  <a href="namespacemlir.html#a091c0686ba6d6f3ad4af9db1aea8063f">More...</a><br /></td></tr>
<tr class="separator:a091c0686ba6d6f3ad4af9db1aea8063f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecde76b07cd295bae0d6ef10d1c45d8"><td class="memTemplParams" colspan="2">template&lt;typename OpType , typename... Matchers&gt; </td></tr>
<tr class="memitem:a7ecde76b07cd295bae0d6ef10d1c45d8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7ecde76b07cd295bae0d6ef10d1c45d8">m_Op</a> (Matchers... matchers)</td></tr>
<tr class="separator:a7ecde76b07cd295bae0d6ef10d1c45d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5254079fbbd31a78a3430bff18df2d7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5254079fbbd31a78a3430bff18df2d7c">registerMLIRContextCLOptions</a> ()</td></tr>
<tr class="memdesc:a5254079fbbd31a78a3430bff18df2d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a set of useful command-line options that can be used to configure various flags within the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a>.  <a href="namespacemlir.html#a5254079fbbd31a78a3430bff18df2d7c">More...</a><br /></td></tr>
<tr class="separator:a5254079fbbd31a78a3430bff18df2d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb62375c248ed1a8f282211f5d0cedd8"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abb62375c248ed1a8f282211f5d0cedd8">convertFromAttribute</a> (int64_t &amp;storage, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="memdesc:abb62375c248ed1a8f282211f5d0cedd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an IntegerAttr attribute to an int64_t, or return an error if the attribute isn't an IntegerAttr.  <a href="namespacemlir.html#abb62375c248ed1a8f282211f5d0cedd8">More...</a><br /></td></tr>
<tr class="separator:abb62375c248ed1a8f282211f5d0cedd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81e61402439e0b78cd25dc4ad7eb591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab81e61402439e0b78cd25dc4ad7eb591">convertToAttribute</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, int64_t storage)</td></tr>
<tr class="memdesc:ab81e61402439e0b78cd25dc4ad7eb591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the provided int64_t to an IntegerAttr attribute.  <a href="namespacemlir.html#ab81e61402439e0b78cd25dc4ad7eb591">More...</a><br /></td></tr>
<tr class="separator:ab81e61402439e0b78cd25dc4ad7eb591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaaf50aca64f58a65c55414d3f3309d5"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abaaf50aca64f58a65c55414d3f3309d5">convertFromAttribute</a> (int32_t &amp;storage, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="memdesc:abaaf50aca64f58a65c55414d3f3309d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an IntegerAttr attribute to an int32_t, or return an error if the attribute isn't an IntegerAttr.  <a href="namespacemlir.html#abaaf50aca64f58a65c55414d3f3309d5">More...</a><br /></td></tr>
<tr class="separator:abaaf50aca64f58a65c55414d3f3309d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7fea0a3f8193ef3ab5dd53c78968f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adc7fea0a3f8193ef3ab5dd53c78968f6">convertToAttribute</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, int32_t storage)</td></tr>
<tr class="memdesc:adc7fea0a3f8193ef3ab5dd53c78968f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the provided int32_t to an IntegerAttr attribute.  <a href="namespacemlir.html#adc7fea0a3f8193ef3ab5dd53c78968f6">More...</a><br /></td></tr>
<tr class="separator:adc7fea0a3f8193ef3ab5dd53c78968f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9846d2959aaf3565b6e538b320b19c4a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9846d2959aaf3565b6e538b320b19c4a">convertFromAttribute</a> (std::string &amp;storage, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="memdesc:a9846d2959aaf3565b6e538b320b19c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the string from <code>attr</code> into <code>storage</code>.  <a href="namespacemlir.html#a9846d2959aaf3565b6e538b320b19c4a">More...</a><br /></td></tr>
<tr class="separator:a9846d2959aaf3565b6e538b320b19c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dfe2bb2693d4a826a40b0c0a7cc362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a68dfe2bb2693d4a826a40b0c0a7cc362">convertToAttribute</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, const std::string &amp;storage)</td></tr>
<tr class="memdesc:a68dfe2bb2693d4a826a40b0c0a7cc362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given string into a StringAttr.  <a href="namespacemlir.html#a68dfe2bb2693d4a826a40b0c0a7cc362">More...</a><br /></td></tr>
<tr class="separator:a68dfe2bb2693d4a826a40b0c0a7cc362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8def5e235dec49017ed2ab6ca765e96f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8def5e235dec49017ed2ab6ca765e96f">convertFromAttribute</a> (bool &amp;storage, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="memdesc:a8def5e235dec49017ed2ab6ca765e96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the boolean from <code>attr</code> into <code>storage</code>.  <a href="namespacemlir.html#a8def5e235dec49017ed2ab6ca765e96f">More...</a><br /></td></tr>
<tr class="separator:a8def5e235dec49017ed2ab6ca765e96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aad04a9375046387a3f9a4bea0293ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2aad04a9375046387a3f9a4bea0293ec">convertToAttribute</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, bool storage)</td></tr>
<tr class="memdesc:a2aad04a9375046387a3f9a4bea0293ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given string into a BooleanAttr.  <a href="namespacemlir.html#a2aad04a9375046387a3f9a4bea0293ec">More...</a><br /></td></tr>
<tr class="separator:a2aad04a9375046387a3f9a4bea0293ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7950ff8da3b75555e08167ea5ea94eed"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7950ff8da3b75555e08167ea5ea94eed">convertFromAttribute</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; int64_t &gt; storage, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="memdesc:a7950ff8da3b75555e08167ea5ea94eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a DenseI64ArrayAttr to the provided storage.  <a href="namespacemlir.html#a7950ff8da3b75555e08167ea5ea94eed">More...</a><br /></td></tr>
<tr class="separator:a7950ff8da3b75555e08167ea5ea94eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ed2f9952d1cb1a2eb02252768af95b"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a44ed2f9952d1cb1a2eb02252768af95b">convertFromAttribute</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; int32_t &gt; storage, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="memdesc:a44ed2f9952d1cb1a2eb02252768af95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a DenseI32ArrayAttr to the provided storage.  <a href="namespacemlir.html#a44ed2f9952d1cb1a2eb02252768af95b">More...</a><br /></td></tr>
<tr class="separator:a44ed2f9952d1cb1a2eb02252768af95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3dd8a9b554ad036fb40ec639db2b065"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae3dd8a9b554ad036fb40ec639db2b065">convertFromAttribute</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;storage, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="memdesc:ae3dd8a9b554ad036fb40ec639db2b065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a DenseI64ArrayAttr to the provided storage, which will be cleared before writing.  <a href="namespacemlir.html#ae3dd8a9b554ad036fb40ec639db2b065">More...</a><br /></td></tr>
<tr class="separator:ae3dd8a9b554ad036fb40ec639db2b065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588ba679548595723d4e190dd6dc80b9"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a588ba679548595723d4e190dd6dc80b9">convertFromAttribute</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int32_t &gt; &amp;storage, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="memdesc:a588ba679548595723d4e190dd6dc80b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a DenseI32ArrayAttr to the provided storage, which will be cleared before writing.  <a href="namespacemlir.html#a588ba679548595723d4e190dd6dc80b9">More...</a><br /></td></tr>
<tr class="separator:a588ba679548595723d4e190dd6dc80b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5c480f463f3ed7b6369caae8c8d366"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abd5c480f463f3ed7b6369caae8c8d366">convertToAttribute</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; storage)</td></tr>
<tr class="memdesc:abd5c480f463f3ed7b6369caae8c8d366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the provided <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;int64_t&gt;</a> to a DenseI64ArrayAttr attribute.  <a href="namespacemlir.html#abd5c480f463f3ed7b6369caae8c8d366">More...</a><br /></td></tr>
<tr class="separator:abd5c480f463f3ed7b6369caae8c8d366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4f129dda2c412845b5ec66a77325a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abc4f129dda2c412845b5ec66a77325a3">operator==</a> (<a class="el" href="classmlir_1_1OpState.html">OpState</a> lhs, <a class="el" href="classmlir_1_1OpState.html">OpState</a> rhs)</td></tr>
<tr class="separator:abc4f129dda2c412845b5ec66a77325a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee326f96469cd288efb48265e173295e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aee326f96469cd288efb48265e173295e">operator!=</a> (<a class="el" href="classmlir_1_1OpState.html">OpState</a> lhs, <a class="el" href="classmlir_1_1OpState.html">OpState</a> rhs)</td></tr>
<tr class="separator:aee326f96469cd288efb48265e173295e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c357b30f2e56803678fe5f7b75e80a1"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8c357b30f2e56803678fe5f7b75e80a1">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr)</td></tr>
<tr class="memdesc:a8c357b30f2e56803678fe5f7b75e80a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow printing to a stream.  <a href="namespacemlir.html#a8c357b30f2e56803678fe5f7b75e80a1">More...</a><br /></td></tr>
<tr class="separator:a8c357b30f2e56803678fe5f7b75e80a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07e7b01e09b3da975cc984b4e1c506d"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af07e7b01e09b3da975cc984b4e1c506d">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1OpState.html">OpState</a> op)</td></tr>
<tr class="memdesc:af07e7b01e09b3da975cc984b4e1c506d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow printing to a stream.  <a href="namespacemlir.html#af07e7b01e09b3da975cc984b4e1c506d">More...</a><br /></td></tr>
<tr class="separator:af07e7b01e09b3da975cc984b4e1c506d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dd71f700f3e4336e89a94f69ff28de"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab0dd71f700f3e4336e89a94f69ff28de">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op)</td></tr>
<tr class="separator:ab0dd71f700f3e4336e89a94f69ff28de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45dade5c2740697bc36ceb8d6554ee00"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a45dade5c2740697bc36ceb8d6554ee00">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1OperationName.html">OperationName</a> info)</td></tr>
<tr class="separator:a45dade5c2740697bc36ceb8d6554ee00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93109842c1b05424c5052d9bd9a4394"><td class="memItemLeft" align="right" valign="top">llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad93109842c1b05424c5052d9bd9a4394">hash_value</a> (<a class="el" href="classmlir_1_1OperationName.html">OperationName</a> arg)</td></tr>
<tr class="separator:ad93109842c1b05424c5052d9bd9a4394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af912da94236cff04e9076f6e052676b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af912da94236cff04e9076f6e052676b1">LLVM_ENABLE_BITMASK_ENUMS_IN_NAMESPACE</a> ()</td></tr>
<tr class="memdesc:af912da94236cff04e9076f6e052676b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Bitmask enums for <a class="el" href="structmlir_1_1OperationEquivalence.html#a292ebf6a0885a07fd4c94f9750587dfe">OperationEquivalence::Flags</a>.  <a href="namespacemlir.html#af912da94236cff04e9076f6e052676b1">More...</a><br /></td></tr>
<tr class="separator:af912da94236cff04e9076f6e052676b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac18c17aca8d8a8549fef55a52af5393"><td class="memItemLeft" align="right" valign="top">llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aac18c17aca8d8a8549fef55a52af5393">hash_value</a> (const <a class="el" href="classmlir_1_1AsmDialectResourceHandle.html">AsmDialectResourceHandle</a> &amp;param)</td></tr>
<tr class="separator:aac18c17aca8d8a8549fef55a52af5393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97986a4859106d3c96b089e726e26c7c"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT &gt; </td></tr>
<tr class="memitem:a97986a4859106d3c96b089e726e26c7c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a97986a4859106d3c96b089e726e26c7c">operator&lt;&lt;</a> (AsmPrinterT &amp;p, <a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="separator:a97986a4859106d3c96b089e726e26c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69273e2629a0b7e18af99582f687692"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT &gt; </td></tr>
<tr class="memitem:ab69273e2629a0b7e18af99582f687692"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab69273e2629a0b7e18af99582f687692">operator&lt;&lt;</a> (AsmPrinterT &amp;p, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="separator:ab69273e2629a0b7e18af99582f687692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424d21ac06bbb37dee5c29f22e9d261a"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT &gt; </td></tr>
<tr class="memitem:a424d21ac06bbb37dee5c29f22e9d261a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a424d21ac06bbb37dee5c29f22e9d261a">operator&lt;&lt;</a> (AsmPrinterT &amp;p, const APFloat &amp;value)</td></tr>
<tr class="separator:a424d21ac06bbb37dee5c29f22e9d261a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31efc2a6e3489b511bf1640b6e3b9eb"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT &gt; </td></tr>
<tr class="memitem:ac31efc2a6e3489b511bf1640b6e3b9eb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac31efc2a6e3489b511bf1640b6e3b9eb">operator&lt;&lt;</a> (AsmPrinterT &amp;p, float value)</td></tr>
<tr class="separator:ac31efc2a6e3489b511bf1640b6e3b9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad013c3d87cad19d6a7fa6ce16eb6bd58"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT &gt; </td></tr>
<tr class="memitem:ad013c3d87cad19d6a7fa6ce16eb6bd58"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad013c3d87cad19d6a7fa6ce16eb6bd58">operator&lt;&lt;</a> (AsmPrinterT &amp;p, double value)</td></tr>
<tr class="separator:ad013c3d87cad19d6a7fa6ce16eb6bd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462d4f34f404bcc705506899944185f6"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT , typename T , std::enable_if_t&lt;!std::is_convertible&lt; T &amp;, Value &amp; &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Type &amp; &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Attribute &amp; &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, ValueRange &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, APFloat &amp; &gt;::value &amp;&amp;!llvm::is_one_of&lt; T, bool, float, double &gt;::value, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a462d4f34f404bcc705506899944185f6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a462d4f34f404bcc705506899944185f6">operator&lt;&lt;</a> (AsmPrinterT &amp;p, const T &amp;other)</td></tr>
<tr class="separator:a462d4f34f404bcc705506899944185f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627aa7e5b958743b9a67a4ccbe1418c9"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT &gt; </td></tr>
<tr class="memitem:a627aa7e5b958743b9a67a4ccbe1418c9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a627aa7e5b958743b9a67a4ccbe1418c9">operator&lt;&lt;</a> (AsmPrinterT &amp;p, bool value)</td></tr>
<tr class="separator:a627aa7e5b958743b9a67a4ccbe1418c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ecef972faf3b5c78d8415d69a86728"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT , typename ValueRangeT &gt; </td></tr>
<tr class="memitem:a26ecef972faf3b5c78d8415d69a86728"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a26ecef972faf3b5c78d8415d69a86728">operator&lt;&lt;</a> (AsmPrinterT &amp;p, const <a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a>&lt; ValueRangeT &gt; &amp;types)</td></tr>
<tr class="separator:a26ecef972faf3b5c78d8415d69a86728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d69cef9b50344549afeaaa734f8172d"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT &gt; </td></tr>
<tr class="memitem:a4d69cef9b50344549afeaaa734f8172d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4d69cef9b50344549afeaaa734f8172d">operator&lt;&lt;</a> (AsmPrinterT &amp;p, const <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> &amp;types)</td></tr>
<tr class="separator:a4d69cef9b50344549afeaaa734f8172d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970e10cc4cef6e2f2dd48772041b4773"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT , typename T &gt; </td></tr>
<tr class="memitem:a970e10cc4cef6e2f2dd48772041b4773"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value &amp;&amp;std::is_convertible&lt; T &amp;, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a970e10cc4cef6e2f2dd48772041b4773">operator&lt;&lt;</a> (AsmPrinterT &amp;p, const T &amp;other)=delete</td></tr>
<tr class="separator:a970e10cc4cef6e2f2dd48772041b4773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d315bdf3396a4c2cac6ead94cfc0e26"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT , typename ElementT &gt; </td></tr>
<tr class="memitem:a6d315bdf3396a4c2cac6ead94cfc0e26"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::value, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6d315bdf3396a4c2cac6ead94cfc0e26">operator&lt;&lt;</a> (AsmPrinterT &amp;p, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; ElementT &gt; types)</td></tr>
<tr class="separator:a6d315bdf3396a4c2cac6ead94cfc0e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabdc4e9d44aae13942c9ea9b41b9a33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acabdc4e9d44aae13942c9ea9b41b9a33">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="separator:acabdc4e9d44aae13942c9ea9b41b9a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c02ebe7d299d1683ae658ea4e9352c"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; std::is_convertible&lt; T &amp;, ValueRange &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Value &amp; &gt;::value, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a58c02ebe7d299d1683ae658ea4e9352c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a58c02ebe7d299d1683ae658ea4e9352c">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, const T &amp;values)</td></tr>
<tr class="separator:a58c02ebe7d299d1683ae658ea4e9352c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad554d3204bdbdc4a87d291ed94c1e575"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad554d3204bdbdc4a87d291ed94c1e575">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Block.html">Block</a> *value)</td></tr>
<tr class="separator:ad554d3204bdbdc4a87d291ed94c1e575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ab168056505b09c113dda01ee42d5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a34ab168056505b09c113dda01ee42d5e">printDimensionList</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; dimensions)</td></tr>
<tr class="separator:a34ab168056505b09c113dda01ee42d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d828f0860b1c0863b1badf0fe06e30"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a12d828f0860b1c0863b1badf0fe06e30">parseDimensionList</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a> &amp;dimensions)</td></tr>
<tr class="separator:a12d828f0860b1c0863b1badf0fe06e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed40bd15766a7dff96f3d30577d8f87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5ed40bd15766a7dff96f3d30577d8f87">mayHaveSSADominance</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:a5ed40bd15766a7dff96f3d30577d8f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if the given region may have SSA dominance.  <a href="namespacemlir.html#a5ed40bd15766a7dff96f3d30577d8f87">More...</a><br /></td></tr>
<tr class="separator:a5ed40bd15766a7dff96f3d30577d8f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c318aa15564b0d662d9a699f74f8eea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5c318aa15564b0d662d9a699f74f8eea">mayBeGraphRegion</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:a5c318aa15564b0d662d9a699f74f8eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if the given region may be a graph region without SSA dominance.  <a href="namespacemlir.html#a5c318aa15564b0d662d9a699f74f8eea">More...</a><br /></td></tr>
<tr class="separator:a5c318aa15564b0d662d9a699f74f8eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78425f2c879f5b708f5c58af03931e9f"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a78425f2c879f5b708f5c58af03931e9f">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1SymbolTable.html#a4f1a6f39b93a08abe4e80a5c15fe32b8">SymbolTable::Visibility</a> visibility)</td></tr>
<tr class="separator:a78425f2c879f5b708f5c58af03931e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3083728e72d361c987c5e5a0e8d2f39a"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename FuncT &gt; </td></tr>
<tr class="memitem:a3083728e72d361c987c5e5a0e8d2f39a"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3083728e72d361c987c5e5a0e8d2f39a">failableParallelForEach</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, IteratorT begin, IteratorT end, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:a3083728e72d361c987c5e5a0e8d2f39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements between [begin, end) asynchronously.  <a href="namespacemlir.html#a3083728e72d361c987c5e5a0e8d2f39a">More...</a><br /></td></tr>
<tr class="separator:a3083728e72d361c987c5e5a0e8d2f39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98aa0f01173a481075d9d5a2ca50d8ab"><td class="memTemplParams" colspan="2">template&lt;typename RangeT , typename FuncT &gt; </td></tr>
<tr class="memitem:a98aa0f01173a481075d9d5a2ca50d8ab"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a98aa0f01173a481075d9d5a2ca50d8ab">failableParallelForEach</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, RangeT &amp;&amp;range, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:a98aa0f01173a481075d9d5a2ca50d8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements in the provided range asynchronously.  <a href="namespacemlir.html#a98aa0f01173a481075d9d5a2ca50d8ab">More...</a><br /></td></tr>
<tr class="separator:a98aa0f01173a481075d9d5a2ca50d8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5aa5179ec6f13db4eaa8fa255bde665"><td class="memTemplParams" colspan="2">template&lt;typename FuncT &gt; </td></tr>
<tr class="memitem:af5aa5179ec6f13db4eaa8fa255bde665"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af5aa5179ec6f13db4eaa8fa255bde665">failableParallelForEachN</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, size_t begin, size_t end, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:af5aa5179ec6f13db4eaa8fa255bde665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements between [begin, end) asynchronously.  <a href="namespacemlir.html#af5aa5179ec6f13db4eaa8fa255bde665">More...</a><br /></td></tr>
<tr class="separator:af5aa5179ec6f13db4eaa8fa255bde665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acf0c58d63da562112dd8f6a81b49e3"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename FuncT &gt; </td></tr>
<tr class="memitem:a7acf0c58d63da562112dd8f6a81b49e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7acf0c58d63da562112dd8f6a81b49e3">parallelForEach</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, IteratorT begin, IteratorT end, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:a7acf0c58d63da562112dd8f6a81b49e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements between [begin, end) asynchronously.  <a href="namespacemlir.html#a7acf0c58d63da562112dd8f6a81b49e3">More...</a><br /></td></tr>
<tr class="separator:a7acf0c58d63da562112dd8f6a81b49e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1232c5821e793866aa3cf2234e1ba93"><td class="memTemplParams" colspan="2">template&lt;typename RangeT , typename FuncT &gt; </td></tr>
<tr class="memitem:af1232c5821e793866aa3cf2234e1ba93"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af1232c5821e793866aa3cf2234e1ba93">parallelForEach</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, RangeT &amp;&amp;range, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:af1232c5821e793866aa3cf2234e1ba93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements in the provided range asynchronously.  <a href="namespacemlir.html#af1232c5821e793866aa3cf2234e1ba93">More...</a><br /></td></tr>
<tr class="separator:af1232c5821e793866aa3cf2234e1ba93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02ff92115796118c612bc82db603b7e"><td class="memTemplParams" colspan="2">template&lt;typename FuncT &gt; </td></tr>
<tr class="memitem:ad02ff92115796118c612bc82db603b7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad02ff92115796118c612bc82db603b7e">parallelFor</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, size_t begin, size_t end, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:ad02ff92115796118c612bc82db603b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements between [begin, end) asynchronously.  <a href="namespacemlir.html#ad02ff92115796118c612bc82db603b7e">More...</a><br /></td></tr>
<tr class="separator:ad02ff92115796118c612bc82db603b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb322b17530b4289c3e3ec1f4ad2ecce"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abb322b17530b4289c3e3ec1f4ad2ecce">hash_value</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> arg)</td></tr>
<tr class="memdesc:abb322b17530b4289c3e3ec1f4ad2ecce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="classmlir_1_1TypeRange.html" title="This class provides an abstraction over the various different ranges of value types.">TypeRange</a> hashable.  <a href="namespacemlir.html#abb322b17530b4289c3e3ec1f4ad2ecce">More...</a><br /></td></tr>
<tr class="separator:abb322b17530b4289c3e3ec1f4ad2ecce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e22b31f6f0d59955e0e73f0d387613"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a40e22b31f6f0d59955e0e73f0d387613">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> &amp;types)</td></tr>
<tr class="memdesc:a40e22b31f6f0d59955e0e73f0d387613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a type range to the given output stream.  <a href="namespacemlir.html#a40e22b31f6f0d59955e0e73f0d387613">More...</a><br /></td></tr>
<tr class="separator:a40e22b31f6f0d59955e0e73f0d387613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc3d1f66f267d9111234fac1effdfce"><td class="memTemplParams" colspan="2">template&lt;typename RangeT &gt; </td></tr>
<tr class="memitem:a8fc3d1f66f267d9111234fac1effdfce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8fc3d1f66f267d9111234fac1effdfce">operator==</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; lhs, const <a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a>&lt; RangeT &gt; &amp;rhs)</td></tr>
<tr class="separator:a8fc3d1f66f267d9111234fac1effdfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5bfd80339235fbb32a685ff75f4e16"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acd5bfd80339235fbb32a685ff75f4e16">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="separator:acd5bfd80339235fbb32a685ff75f4e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31eede9183d3fdae566e18d94a5ef51b"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a31eede9183d3fdae566e18d94a5ef51b">hash_value</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> arg)</td></tr>
<tr class="separator:a31eede9183d3fdae566e18d94a5ef51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82686ceb29eb0f78b59e29021f1b2cdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a82686ceb29eb0f78b59e29021f1b2cdd">getElementTypeOrSelf</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memdesc:a82686ceb29eb0f78b59e29021f1b2cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element type or return the type itself.  <a href="namespacemlir.html#a82686ceb29eb0f78b59e29021f1b2cdd">More...</a><br /></td></tr>
<tr class="separator:a82686ceb29eb0f78b59e29021f1b2cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252aee27751e05d584d0b1a8e793ecf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a252aee27751e05d584d0b1a8e793ecf0">getElementTypeOrSelf</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:a252aee27751e05d584d0b1a8e793ecf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element type or return the type itself.  <a href="namespacemlir.html#a252aee27751e05d584d0b1a8e793ecf0">More...</a><br /></td></tr>
<tr class="separator:a252aee27751e05d584d0b1a8e793ecf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81d443c449b61825fb2c2ec6aa90d35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae81d443c449b61825fb2c2ec6aa90d35">getElementTypeOrSelf</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="separator:ae81d443c449b61825fb2c2ec6aa90d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46bbb7497276c5ea7e8ed4ad1315bf40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, 10 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a46bbb7497276c5ea7e8ed4ad1315bf40">getFlattenedTypes</a> (TupleType t)</td></tr>
<tr class="memdesc:a46bbb7497276c5ea7e8ed4ad1315bf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the types within a nested Tuple.  <a href="namespacemlir.html#a46bbb7497276c5ea7e8ed4ad1315bf40">More...</a><br /></td></tr>
<tr class="separator:a46bbb7497276c5ea7e8ed4ad1315bf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd6b581b08699ce79d3e9f820c1ade9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4bd6b581b08699ce79d3e9f820c1ade9">isOpaqueTypeWithName</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, StringRef dialect, StringRef typeData)</td></tr>
<tr class="memdesc:a4bd6b581b08699ce79d3e9f820c1ade9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified type is an opaque type with the specified dialect and typeData.  <a href="namespacemlir.html#a4bd6b581b08699ce79d3e9f820c1ade9">More...</a><br /></td></tr>
<tr class="separator:a4bd6b581b08699ce79d3e9f820c1ade9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb414ad1d507c2ab841305c273f4deb8"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acb414ad1d507c2ab841305c273f4deb8">verifyCompatibleShape</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape1, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape2)</td></tr>
<tr class="memdesc:acb414ad1d507c2ab841305c273f4deb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns success if the given two shapes are compatible.  <a href="namespacemlir.html#acb414ad1d507c2ab841305c273f4deb8">More...</a><br /></td></tr>
<tr class="separator:acb414ad1d507c2ab841305c273f4deb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54e5e6c31f51ef648f7c03652a29ce6"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac54e5e6c31f51ef648f7c03652a29ce6">verifyCompatibleShape</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type1, <a class="el" href="classmlir_1_1Type.html">Type</a> type2)</td></tr>
<tr class="memdesc:ac54e5e6c31f51ef648f7c03652a29ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns success if the given two types have compatible shape.  <a href="namespacemlir.html#ac54e5e6c31f51ef648f7c03652a29ce6">More...</a><br /></td></tr>
<tr class="separator:ac54e5e6c31f51ef648f7c03652a29ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2801a1733326688cf0c9bee8d633f234"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2801a1733326688cf0c9bee8d633f234">verifyCompatibleShapes</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types1, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types2)</td></tr>
<tr class="memdesc:a2801a1733326688cf0c9bee8d633f234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns success if the given two arrays have the same number of elements and each pair wise entries have compatible shape.  <a href="namespacemlir.html#a2801a1733326688cf0c9bee8d633f234">More...</a><br /></td></tr>
<tr class="separator:a2801a1733326688cf0c9bee8d633f234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132fff065736d8e977fe8179f2e7086c"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a132fff065736d8e977fe8179f2e7086c">verifyCompatibleShapes</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types)</td></tr>
<tr class="memdesc:a132fff065736d8e977fe8179f2e7086c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns success if all given types have compatible shapes.  <a href="namespacemlir.html#a132fff065736d8e977fe8179f2e7086c">More...</a><br /></td></tr>
<tr class="separator:a132fff065736d8e977fe8179f2e7086c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961cf9926486f7d6e7160efa8f846d64"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a961cf9926486f7d6e7160efa8f846d64">verifyCompatibleDims</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; dims)</td></tr>
<tr class="memdesc:a961cf9926486f7d6e7160efa8f846d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimensions are compatible if all non-dynamic dims are equal.  <a href="namespacemlir.html#a961cf9926486f7d6e7160efa8f846d64">More...</a><br /></td></tr>
<tr class="separator:a961cf9926486f7d6e7160efa8f846d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae873ed9c30ada4ee5e87cf53a550c610"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae873ed9c30ada4ee5e87cf53a550c610">insertTypesInto</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> oldTypes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt; indices, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> newTypes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;storage)</td></tr>
<tr class="memdesc:ae873ed9c30ada4ee5e87cf53a550c610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a set of <code>newTypes</code> into <code>oldTypes</code> at the given <code>indices</code>.  <a href="namespacemlir.html#ae873ed9c30ada4ee5e87cf53a550c610">More...</a><br /></td></tr>
<tr class="separator:ae873ed9c30ada4ee5e87cf53a550c610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ceb7a2611f873431057e03992432701"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6ceb7a2611f873431057e03992432701">filterTypesOut</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types, const BitVector &amp;indices, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;storage)</td></tr>
<tr class="memdesc:a6ceb7a2611f873431057e03992432701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters out any elements referenced by <code>indices</code>.  <a href="namespacemlir.html#a6ceb7a2611f873431057e03992432701">More...</a><br /></td></tr>
<tr class="separator:a6ceb7a2611f873431057e03992432701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279adec3f964e12de632fa76060d2669"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a279adec3f964e12de632fa76060d2669">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1IRUnit.html">IRUnit</a> &amp;unit)</td></tr>
<tr class="separator:a279adec3f964e12de632fa76060d2669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df16c49c963cdc57cf6f9e7c3e9f822"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3df16c49c963cdc57cf6f9e7c3e9f822">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="separator:a3df16c49c963cdc57cf6f9e7c3e9f822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab710b1f6f21f3f35197575b609aae4b4"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab710b1f6f21f3f35197575b609aae4b4">hash_value</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> arg)</td></tr>
<tr class="memdesc:ab710b1f6f21f3f35197575b609aae4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> hashable.  <a href="namespacemlir.html#ab710b1f6f21f3f35197575b609aae4b4">More...</a><br /></td></tr>
<tr class="separator:ab710b1f6f21f3f35197575b609aae4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b1ba650fd43b50351e92bbb75bd4c0"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae4b1ba650fd43b50351e92bbb75bd4c0">verify</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, bool verifyRecursively=true)</td></tr>
<tr class="memdesc:ae4b1ba650fd43b50351e92bbb75bd4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform (potentially expensive) checks of invariants, used to detect compiler bugs, on this operation and any nested operations.  <a href="namespacemlir.html#ae4b1ba650fd43b50351e92bbb75bd4c0">More...</a><br /></td></tr>
<tr class="separator:ae4b1ba650fd43b50351e92bbb75bd4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f975095772c8ece0dbda8bf7f455eb"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab0f975095772c8ece0dbda8bf7f455eb">parseSourceFile</a> (const llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=nullptr)</td></tr>
<tr class="memdesc:ab0f975095772c8ece0dbda8bf7f455eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated SourceMgr and appends parsed operations to the given block.  <a href="namespacemlir.html#ab0f975095772c8ece0dbda8bf7f455eb">More...</a><br /></td></tr>
<tr class="separator:ab0f975095772c8ece0dbda8bf7f455eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537a80c31d8487a710f53cd9a38e390a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a537a80c31d8487a710f53cd9a38e390a">parseSourceFile</a> (const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;sourceMgr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=nullptr)</td></tr>
<tr class="memdesc:a537a80c31d8487a710f53cd9a38e390a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR).  <a href="namespacemlir.html#a537a80c31d8487a710f53cd9a38e390a">More...</a><br /></td></tr>
<tr class="separator:a537a80c31d8487a710f53cd9a38e390a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006a32917056b7f14d65e9ea5cc08392"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a006a32917056b7f14d65e9ea5cc08392">parseSourceFile</a> (llvm::StringRef filename, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=nullptr)</td></tr>
<tr class="memdesc:a006a32917056b7f14d65e9ea5cc08392"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated filename and appends parsed operations to the given block.  <a href="namespacemlir.html#a006a32917056b7f14d65e9ea5cc08392">More...</a><br /></td></tr>
<tr class="separator:a006a32917056b7f14d65e9ea5cc08392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ad011b0b3c1635c410fe60bfd557c2"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a13ad011b0b3c1635c410fe60bfd557c2">parseSourceFile</a> (llvm::StringRef filename, llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=nullptr)</td></tr>
<tr class="memdesc:a13ad011b0b3c1635c410fe60bfd557c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated filename using the provided SourceMgr and appends parsed operations to the given block.  <a href="namespacemlir.html#a13ad011b0b3c1635c410fe60bfd557c2">More...</a><br /></td></tr>
<tr class="separator:a13ad011b0b3c1635c410fe60bfd557c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54875232f3a58ed939964dc275d1e36f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a54875232f3a58ed939964dc275d1e36f">parseSourceFile</a> (llvm::StringRef filename, const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;sourceMgr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=nullptr)</td></tr>
<tr class="memdesc:a54875232f3a58ed939964dc275d1e36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR).  <a href="namespacemlir.html#a54875232f3a58ed939964dc275d1e36f">More...</a><br /></td></tr>
<tr class="separator:a54875232f3a58ed939964dc275d1e36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80178c9e23c4fd7db357124cbe19651a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a80178c9e23c4fd7db357124cbe19651a">parseSourceString</a> (llvm::StringRef sourceStr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config, StringRef sourceName=&quot;&quot;, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=nullptr)</td></tr>
<tr class="memdesc:a80178c9e23c4fd7db357124cbe19651a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the IR string and appends parsed operations to the given block.  <a href="namespacemlir.html#a80178c9e23c4fd7db357124cbe19651a">More...</a><br /></td></tr>
<tr class="separator:a80178c9e23c4fd7db357124cbe19651a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8735a3d1b2704c1497e7c4b8173e8d99"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT  = Operation *&gt; </td></tr>
<tr class="memitem:a8735a3d1b2704c1497e7c4b8173e8d99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8735a3d1b2704c1497e7c4b8173e8d99">parseSourceFile</a> (const llvm::SourceMgr &amp;sourceMgr, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config)</td></tr>
<tr class="memdesc:a8735a3d1b2704c1497e7c4b8173e8d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated SourceMgr.  <a href="namespacemlir.html#a8735a3d1b2704c1497e7c4b8173e8d99">More...</a><br /></td></tr>
<tr class="separator:a8735a3d1b2704c1497e7c4b8173e8d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9ed7461f16d832b9a3d5c1c444ff7e"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT  = Operation *&gt; </td></tr>
<tr class="memitem:a2b9ed7461f16d832b9a3d5c1c444ff7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2b9ed7461f16d832b9a3d5c1c444ff7e">parseSourceFile</a> (const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;sourceMgr, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config)</td></tr>
<tr class="memdesc:a2b9ed7461f16d832b9a3d5c1c444ff7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR).  <a href="namespacemlir.html#a2b9ed7461f16d832b9a3d5c1c444ff7e">More...</a><br /></td></tr>
<tr class="separator:a2b9ed7461f16d832b9a3d5c1c444ff7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731c3e653fe7b19e18f2ca619aa763fa"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT  = Operation *&gt; </td></tr>
<tr class="memitem:a731c3e653fe7b19e18f2ca619aa763fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a731c3e653fe7b19e18f2ca619aa763fa">parseSourceFile</a> (StringRef filename, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config)</td></tr>
<tr class="memdesc:a731c3e653fe7b19e18f2ca619aa763fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated filename.  <a href="namespacemlir.html#a731c3e653fe7b19e18f2ca619aa763fa">More...</a><br /></td></tr>
<tr class="separator:a731c3e653fe7b19e18f2ca619aa763fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f46d0b9658a27fa31f7ce98851ca7fe"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT  = Operation *&gt; </td></tr>
<tr class="memitem:a3f46d0b9658a27fa31f7ce98851ca7fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3f46d0b9658a27fa31f7ce98851ca7fe">parseSourceFile</a> (llvm::StringRef filename, llvm::SourceMgr &amp;sourceMgr, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config)</td></tr>
<tr class="memdesc:a3f46d0b9658a27fa31f7ce98851ca7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated filename using the provided SourceMgr.  <a href="namespacemlir.html#a3f46d0b9658a27fa31f7ce98851ca7fe">More...</a><br /></td></tr>
<tr class="separator:a3f46d0b9658a27fa31f7ce98851ca7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e06cd142a5019f145069349181e2e0"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT  = Operation *&gt; </td></tr>
<tr class="memitem:af9e06cd142a5019f145069349181e2e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af9e06cd142a5019f145069349181e2e0">parseSourceFile</a> (llvm::StringRef filename, const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;sourceMgr, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config)</td></tr>
<tr class="memdesc:af9e06cd142a5019f145069349181e2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR).  <a href="namespacemlir.html#af9e06cd142a5019f145069349181e2e0">More...</a><br /></td></tr>
<tr class="separator:af9e06cd142a5019f145069349181e2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfecc94be370f449013ec1f80818da8"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT  = Operation *&gt; </td></tr>
<tr class="memitem:a1bfecc94be370f449013ec1f80818da8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1bfecc94be370f449013ec1f80818da8">parseSourceString</a> (llvm::StringRef sourceStr, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config, StringRef sourceName=&quot;&quot;)</td></tr>
<tr class="memdesc:a1bfecc94be370f449013ec1f80818da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the provided string containing MLIR.  <a href="namespacemlir.html#a1bfecc94be370f449013ec1f80818da8">More...</a><br /></td></tr>
<tr class="separator:a1bfecc94be370f449013ec1f80818da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df3b51e6123c8ab9fb3809ba255e00b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4df3b51e6123c8ab9fb3809ba255e00b">makeReproducer</a> (StringRef anchorName, const <a class="el" href="classllvm_1_1iterator__range.html">llvm::iterator_range</a>&lt; <a class="el" href="classmlir_1_1OpPassManager.html#a84658003e9efeda5080172631ef41305">OpPassManager::pass_iterator</a> &gt; &amp;passes, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, StringRef outputFile, bool disableThreads=false, bool verifyPasses=false)</td></tr>
<tr class="separator:a4df3b51e6123c8ab9fb3809ba255e00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c4edce10b597637635af55bb162477"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa5c4edce10b597637635af55bb162477">registerPassManagerCLOptions</a> ()</td></tr>
<tr class="memdesc:aa5c4edce10b597637635af55bb162477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a set of useful command-line options that can be used to configure a pass manager.  <a href="namespacemlir.html#aa5c4edce10b597637635af55bb162477">More...</a><br /></td></tr>
<tr class="separator:aa5c4edce10b597637635af55bb162477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133398d008de5837d6df9b322b62f5f6"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a133398d008de5837d6df9b322b62f5f6">applyPassManagerCLOptions</a> (<a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;pm)</td></tr>
<tr class="memdesc:a133398d008de5837d6df9b322b62f5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply any values provided to the pass manager options that were registered with 'registerPassManagerOptions'.  <a href="namespacemlir.html#a133398d008de5837d6df9b322b62f5f6">More...</a><br /></td></tr>
<tr class="separator:a133398d008de5837d6df9b322b62f5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd78ebb9f95cfe7ea3856d9f9c46d030"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acd78ebb9f95cfe7ea3856d9f9c46d030">applyDefaultTimingPassManagerCLOptions</a> (<a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;pm)</td></tr>
<tr class="memdesc:acd78ebb9f95cfe7ea3856d9f9c46d030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply any values provided to the timing manager options that were registered with <code>registerDefaultTimingManagerOptions</code>.  <a href="namespacemlir.html#acd78ebb9f95cfe7ea3856d9f9c46d030">More...</a><br /></td></tr>
<tr class="separator:acd78ebb9f95cfe7ea3856d9f9c46d030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d5e525ca50e6257e78416957f7778c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a41d5e525ca50e6257e78416957f7778c">printRegisteredPasses</a> ()</td></tr>
<tr class="memdesc:a41d5e525ca50e6257e78416957f7778c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the passes that were previously registered and stored in passRegistry.  <a href="namespacemlir.html#a41d5e525ca50e6257e78416957f7778c">More...</a><br /></td></tr>
<tr class="separator:a41d5e525ca50e6257e78416957f7778c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83965c855ad737422194336251348893"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a83965c855ad737422194336251348893">registerPassPipeline</a> (StringRef arg, StringRef description, const <a class="el" href="namespacemlir.html#af4ccb1e7accf2ec0c57b1aea967ccd02">PassRegistryFunction</a> &amp;function, std::function&lt; void(<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(const <a class="el" href="classmlir_1_1detail_1_1PassOptions.html">detail::PassOptions</a> &amp;)&gt;)&gt; optHandler)</td></tr>
<tr class="memdesc:a83965c855ad737422194336251348893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a specific dialect pipeline registry function with the system, typically used through the <a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> template.  <a href="namespacemlir.html#a83965c855ad737422194336251348893">More...</a><br /></td></tr>
<tr class="separator:a83965c855ad737422194336251348893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4626059212aef6f3aa5fa7088ce667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5a4626059212aef6f3aa5fa7088ce667">registerPass</a> (const <a class="el" href="namespacemlir.html#a48db7fd5d49bfa7ca8c81e5a6a058683">PassAllocatorFunction</a> &amp;function)</td></tr>
<tr class="memdesc:a5a4626059212aef6f3aa5fa7088ce667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a specific dialect pass allocator function with the system, typically used through the <a class="el" href="structmlir_1_1PassRegistration.html" title="PassRegistration provides a global initializer that registers a Pass allocation routine for a concret...">PassRegistration</a> template.  <a href="namespacemlir.html#a5a4626059212aef6f3aa5fa7088ce667">More...</a><br /></td></tr>
<tr class="separator:a5a4626059212aef6f3aa5fa7088ce667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d10077c7edf58c1152a1170257d739"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad8d10077c7edf58c1152a1170257d739">parsePassPipeline</a> (StringRef pipeline, <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;pm, raw_ostream &amp;errorStream=llvm::errs())</td></tr>
<tr class="memdesc:ad8d10077c7edf58c1152a1170257d739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the textual representation of a pass pipeline, adding the result to 'pm' on success.  <a href="namespacemlir.html#ad8d10077c7edf58c1152a1170257d739">More...</a><br /></td></tr>
<tr class="separator:ad8d10077c7edf58c1152a1170257d739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5abaea7950d9dc385a018dbbb40d0b"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aef5abaea7950d9dc385a018dbbb40d0b">parsePassPipeline</a> (StringRef pipeline, raw_ostream &amp;errorStream=llvm::errs())</td></tr>
<tr class="memdesc:aef5abaea7950d9dc385a018dbbb40d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the given textual representation of a pass pipeline, and return the parsed pipeline on success.  <a href="namespacemlir.html#aef5abaea7950d9dc385a018dbbb40d0b">More...</a><br /></td></tr>
<tr class="separator:aef5abaea7950d9dc385a018dbbb40d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed5140e30c6e204e8bdc35d08d0eb08"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4ed5140e30c6e204e8bdc35d08d0eb08">createReductionTreePass</a> ()</td></tr>
<tr class="separator:a4ed5140e30c6e204e8bdc35d08d0eb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87060fc8d3ef747e189053c6bd556a5a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a87060fc8d3ef747e189053c6bd556a5a">createOptReductionPass</a> ()</td></tr>
<tr class="separator:a87060fc8d3ef747e189053c6bd556a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54881321f630a119cdee5af076de868d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a54881321f630a119cdee5af076de868d"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a54881321f630a119cdee5af076de868d">debugString</a> (T &amp;&amp;op)</td></tr>
<tr class="separator:a54881321f630a119cdee5af076de868d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2eb0b34f6d7e90435b0a6ce3d8ffaf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::MemoryBuffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0c2eb0b34f6d7e90435b0a6ce3d8ffaf">openInputFile</a> (llvm::StringRef inputFilename, std::string *errorMessage=nullptr)</td></tr>
<tr class="memdesc:a0c2eb0b34f6d7e90435b0a6ce3d8ffaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the file specified by its name for reading.  <a href="namespacemlir.html#a0c2eb0b34f6d7e90435b0a6ce3d8ffaf">More...</a><br /></td></tr>
<tr class="separator:a0c2eb0b34f6d7e90435b0a6ce3d8ffaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec63c3f9b9b50f77b7cc8b92f506204"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::MemoryBuffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4ec63c3f9b9b50f77b7cc8b92f506204">openInputFile</a> (llvm::StringRef inputFilename, llvm::Align alignment, std::string *errorMessage=nullptr)</td></tr>
<tr class="memdesc:a4ec63c3f9b9b50f77b7cc8b92f506204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the file specified by its name for reading, with the given buffer alignment constraint.  <a href="namespacemlir.html#a4ec63c3f9b9b50f77b7cc8b92f506204">More...</a><br /></td></tr>
<tr class="separator:a4ec63c3f9b9b50f77b7cc8b92f506204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8c9750d9c8efdbcc7542f3b1564d8d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::ToolOutputFile &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4c8c9750d9c8efdbcc7542f3b1564d8d">openOutputFile</a> (llvm::StringRef outputFilename, std::string *errorMessage=nullptr)</td></tr>
<tr class="memdesc:a4c8c9750d9c8efdbcc7542f3b1564d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the file specified by its name for writing.  <a href="namespacemlir.html#a4c8c9750d9c8efdbcc7542f3b1564d8d">More...</a><br /></td></tr>
<tr class="separator:a4c8c9750d9c8efdbcc7542f3b1564d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa109c04ae9443b1c88bd605dec0fa9b6"><td class="memItemLeft" align="right" valign="top">llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa109c04ae9443b1c88bd605dec0fa9b6">thread_safe_nulls</a> ()</td></tr>
<tr class="memdesc:aa109c04ae9443b1c88bd605dec0fa9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a raw output stream that simply discards the output, but in a thread-safe manner.  <a href="namespacemlir.html#aa109c04ae9443b1c88bd605dec0fa9b6">More...</a><br /></td></tr>
<tr class="separator:aa109c04ae9443b1c88bd605dec0fa9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da5a75b8bc3193908b0e222a6da1d85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1da5a75b8bc3193908b0e222a6da1d85">registerDefaultTimingManagerCLOptions</a> ()</td></tr>
<tr class="memdesc:a1da5a75b8bc3193908b0e222a6da1d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a set of useful command-line options that can be used to configure a <code><a class="el" href="classmlir_1_1DefaultTimingManager.html" title="Facilities for time measurement and report printing to an output stream.">DefaultTimingManager</a></code>.  <a href="namespacemlir.html#a1da5a75b8bc3193908b0e222a6da1d85">More...</a><br /></td></tr>
<tr class="separator:a1da5a75b8bc3193908b0e222a6da1d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41920e66a206248f862766a705125d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab41920e66a206248f862766a705125d1">applyDefaultTimingManagerCLOptions</a> (<a class="el" href="classmlir_1_1DefaultTimingManager.html">DefaultTimingManager</a> &amp;tm)</td></tr>
<tr class="memdesc:ab41920e66a206248f862766a705125d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply any values that were registered with 'registerDefaultTimingManagerOptions' to a <code><a class="el" href="classmlir_1_1DefaultTimingManager.html" title="Facilities for time measurement and report printing to an output stream.">DefaultTimingManager</a></code>.  <a href="namespacemlir.html#ab41920e66a206248f862766a705125d1">More...</a><br /></td></tr>
<tr class="separator:ab41920e66a206248f862766a705125d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715b8c35aa2d5155832ef2f0c09db693"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a715b8c35aa2d5155832ef2f0c09db693">splitAndProcessBuffer</a> (std::unique_ptr&lt; llvm::MemoryBuffer &gt; originalBuffer, <a class="el" href="namespacemlir.html#aafb0c2458571cd80ebb876d979e24346">ChunkBufferHandler</a> processChunkBuffer, raw_ostream &amp;os, llvm::StringRef inputSplitMarker=<a class="el" href="namespacemlir.html#a1349a176f4860c35697f441e414bf358">kDefaultSplitMarker</a>, llvm::StringRef outputSplitMarker=&quot;&quot;)</td></tr>
<tr class="memdesc:a715b8c35aa2d5155832ef2f0c09db693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the specified buffer on a marker (<code>// -----</code> by default), processes each chunk independently according to the normal <code>processChunkBuffer</code> logic, and writes all results to <code>os</code>.  <a href="namespacemlir.html#a715b8c35aa2d5155832ef2f0c09db693">More...</a><br /></td></tr>
<tr class="separator:a715b8c35aa2d5155832ef2f0c09db693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb3bcc9d23b2cfd1367b84f5b00b7c1"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aafb3bcc9d23b2cfd1367b84f5b00b7c1">hash_value</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> id)</td></tr>
<tr class="memdesc:aafb3bcc9d23b2cfd1367b84f5b00b7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable hashing <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a>.  <a href="namespacemlir.html#aafb3bcc9d23b2cfd1367b84f5b00b7c1">More...</a><br /></td></tr>
<tr class="separator:aafb3bcc9d23b2cfd1367b84f5b00b7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e68be8ebf61b3be9572769e19bc467"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad1e68be8ebf61b3be9572769e19bc467">registerAllToLLVMIRTranslations</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ad1e68be8ebf61b3be9572769e19bc467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers all dialects that can be translated to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR and the corresponding translation interfaces.  <a href="namespacemlir.html#ad1e68be8ebf61b3be9572769e19bc467">More...</a><br /></td></tr>
<tr class="separator:ad1e68be8ebf61b3be9572769e19bc467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f90059c48bfaae011de1a44d1d80683"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6f90059c48bfaae011de1a44d1d80683">registerAllGPUToLLVMIRTranslations</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a6f90059c48bfaae011de1a44d1d80683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers all the translations to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR required by GPU passes.  <a href="namespacemlir.html#a6f90059c48bfaae011de1a44d1d80683">More...</a><br /></td></tr>
<tr class="separator:a6f90059c48bfaae011de1a44d1d80683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b51fcb4b20988958223a34812c119a3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5b51fcb4b20988958223a34812c119a3">registerAllFromLLVMIRTranslations</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a5b51fcb4b20988958223a34812c119a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers all dialects that can be translated from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR and the corresponding translation interfaces.  <a href="namespacemlir.html#a5b51fcb4b20988958223a34812c119a3">More...</a><br /></td></tr>
<tr class="separator:a5b51fcb4b20988958223a34812c119a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0465249a74e23df5fdc548001933239c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0465249a74e23df5fdc548001933239c">registerAMXDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a0465249a74e23df5fdc548001933239c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the AMX dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="namespacemlir.html#a0465249a74e23df5fdc548001933239c">More...</a><br /></td></tr>
<tr class="separator:a0465249a74e23df5fdc548001933239c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a637ec7428727c66f27117b9892f1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa4a637ec7428727c66f27117b9892f1e">registerAMXDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:aa4a637ec7428727c66f27117b9892f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the AMX dialect and the translation from it in the registry associated with the given context.  <a href="namespacemlir.html#aa4a637ec7428727c66f27117b9892f1e">More...</a><br /></td></tr>
<tr class="separator:aa4a637ec7428727c66f27117b9892f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad">registerArmNeonDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the ArmNeon dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="namespacemlir.html#ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad">More...</a><br /></td></tr>
<tr class="separator:ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559f20bb41c97729f2d089e6f7a72e4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a559f20bb41c97729f2d089e6f7a72e4e">registerArmNeonDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a559f20bb41c97729f2d089e6f7a72e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the ArmNeon dialect and the translation from it in the registry associated with the given context.  <a href="namespacemlir.html#a559f20bb41c97729f2d089e6f7a72e4e">More...</a><br /></td></tr>
<tr class="separator:a559f20bb41c97729f2d089e6f7a72e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e3d0ed9dee8abc1c1da567b31f3520"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a44e3d0ed9dee8abc1c1da567b31f3520">registerArmSMEDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a44e3d0ed9dee8abc1c1da567b31f3520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the ArmSME dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="namespacemlir.html#a44e3d0ed9dee8abc1c1da567b31f3520">More...</a><br /></td></tr>
<tr class="separator:a44e3d0ed9dee8abc1c1da567b31f3520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8ba95f7e3fc0b3d4885f3ae1b2926e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7e8ba95f7e3fc0b3d4885f3ae1b2926e">registerArmSMEDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a7e8ba95f7e3fc0b3d4885f3ae1b2926e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the ArmSME dialect and the translation from it in the registry associated with the given context.  <a href="namespacemlir.html#a7e8ba95f7e3fc0b3d4885f3ae1b2926e">More...</a><br /></td></tr>
<tr class="separator:a7e8ba95f7e3fc0b3d4885f3ae1b2926e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53be2d34e1d4e96ea100bbf93af35a2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a53be2d34e1d4e96ea100bbf93af35a2c">registerArmSVEDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a53be2d34e1d4e96ea100bbf93af35a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the ArmSVE dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="namespacemlir.html#a53be2d34e1d4e96ea100bbf93af35a2c">More...</a><br /></td></tr>
<tr class="separator:a53be2d34e1d4e96ea100bbf93af35a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9c160fac7074517c6f013864acee68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afc9c160fac7074517c6f013864acee68">registerArmSVEDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:afc9c160fac7074517c6f013864acee68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the ArmSVE dialect and the translation from it in the registry associated with the given context.  <a href="namespacemlir.html#afc9c160fac7074517c6f013864acee68">More...</a><br /></td></tr>
<tr class="separator:afc9c160fac7074517c6f013864acee68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857314125d33fcc46a38cd3aca4d1d12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a857314125d33fcc46a38cd3aca4d1d12">registerBuiltinDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a857314125d33fcc46a38cd3aca4d1d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the translation from the builtin dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry.  <a href="namespacemlir.html#a857314125d33fcc46a38cd3aca4d1d12">More...</a><br /></td></tr>
<tr class="separator:a857314125d33fcc46a38cd3aca4d1d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af1c7f18bef740745581f7130c8c46e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1af1c7f18bef740745581f7130c8c46e">registerBuiltinDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a1af1c7f18bef740745581f7130c8c46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the translation from the builtin dialect in the registry associated with the given context.  <a href="namespacemlir.html#a1af1c7f18bef740745581f7130c8c46e">More...</a><br /></td></tr>
<tr class="separator:a1af1c7f18bef740745581f7130c8c46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9427230420827cff7cd15f78924cdb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa9427230420827cff7cd15f78924cdb4">registerGPUDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:aa9427230420827cff7cd15f78924cdb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the GPU dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="namespacemlir.html#aa9427230420827cff7cd15f78924cdb4">More...</a><br /></td></tr>
<tr class="separator:aa9427230420827cff7cd15f78924cdb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe90c6efbbc0e7e7469f14619fd7445b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afe90c6efbbc0e7e7469f14619fd7445b">registerGPUDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:afe90c6efbbc0e7e7469f14619fd7445b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the GPU dialect and the translation from it in the registry associated with the given context.  <a href="namespacemlir.html#afe90c6efbbc0e7e7469f14619fd7445b">More...</a><br /></td></tr>
<tr class="separator:afe90c6efbbc0e7e7469f14619fd7445b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01617995d72a114db65ee711b2422d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab01617995d72a114db65ee711b2422d5">registerLLVMDialectImport</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ab01617995d72a114db65ee711b2422d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and its import from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry.  <a href="namespacemlir.html#ab01617995d72a114db65ee711b2422d5">More...</a><br /></td></tr>
<tr class="separator:ab01617995d72a114db65ee711b2422d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0110d23914c27f0140d63a8bb934d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4a0110d23914c27f0140d63a8bb934d4">registerLLVMDialectImport</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a4a0110d23914c27f0140d63a8bb934d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and its import from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR with the given context.  <a href="namespacemlir.html#a4a0110d23914c27f0140d63a8bb934d4">More...</a><br /></td></tr>
<tr class="separator:a4a0110d23914c27f0140d63a8bb934d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9759ca57d83ec47b341d58d966b9e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8b9759ca57d83ec47b341d58d966b9e8">registerLLVMDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a8b9759ca57d83ec47b341d58d966b9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="namespacemlir.html#a8b9759ca57d83ec47b341d58d966b9e8">More...</a><br /></td></tr>
<tr class="separator:a8b9759ca57d83ec47b341d58d966b9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74024a3b8ec9af8d50db598772774a96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a74024a3b8ec9af8d50db598772774a96">registerLLVMDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a74024a3b8ec9af8d50db598772774a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and the translation from it in the registry associated with the given context.  <a href="namespacemlir.html#a74024a3b8ec9af8d50db598772774a96">More...</a><br /></td></tr>
<tr class="separator:a74024a3b8ec9af8d50db598772774a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59faf81890b27fbd773f3ae78f47a07b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a59faf81890b27fbd773f3ae78f47a07b">registerNVVMDialectImport</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a59faf81890b27fbd773f3ae78f47a07b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and its import from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry.  <a href="namespacemlir.html#a59faf81890b27fbd773f3ae78f47a07b">More...</a><br /></td></tr>
<tr class="separator:a59faf81890b27fbd773f3ae78f47a07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add91ee93d64f27e24f1d6e1856893c5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#add91ee93d64f27e24f1d6e1856893c5b">registerNVVMDialectImport</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:add91ee93d64f27e24f1d6e1856893c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and its import from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR with the given context.  <a href="namespacemlir.html#add91ee93d64f27e24f1d6e1856893c5b">More...</a><br /></td></tr>
<tr class="separator:add91ee93d64f27e24f1d6e1856893c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2989267e0da323d644b3316b85b3942f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2989267e0da323d644b3316b85b3942f">registerNVVMDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a2989267e0da323d644b3316b85b3942f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="namespacemlir.html#a2989267e0da323d644b3316b85b3942f">More...</a><br /></td></tr>
<tr class="separator:a2989267e0da323d644b3316b85b3942f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d03cc4e706acdb35969f4d4e78142a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a00d03cc4e706acdb35969f4d4e78142a">registerNVVMDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a00d03cc4e706acdb35969f4d4e78142a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and the translation from it in the registry associated with the given context.  <a href="namespacemlir.html#a00d03cc4e706acdb35969f4d4e78142a">More...</a><br /></td></tr>
<tr class="separator:a00d03cc4e706acdb35969f4d4e78142a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bc345c5d25bda3847f7ddf6cebe9bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae9bc345c5d25bda3847f7ddf6cebe9bc">registerOpenACCDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ae9bc345c5d25bda3847f7ddf6cebe9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the OpenACC dialect and the translation to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="namespacemlir.html#ae9bc345c5d25bda3847f7ddf6cebe9bc">More...</a><br /></td></tr>
<tr class="separator:ae9bc345c5d25bda3847f7ddf6cebe9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889d8518a5c67b981e76d27c9a256d86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a889d8518a5c67b981e76d27c9a256d86">registerOpenACCDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a889d8518a5c67b981e76d27c9a256d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the OpenACC dialect and the translation in the registry associated with the given context.  <a href="namespacemlir.html#a889d8518a5c67b981e76d27c9a256d86">More...</a><br /></td></tr>
<tr class="separator:a889d8518a5c67b981e76d27c9a256d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea20d97a32efd36c02468e54db4b2e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6ea20d97a32efd36c02468e54db4b2e7">registerOpenMPDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a6ea20d97a32efd36c02468e54db4b2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the OpenMP dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="namespacemlir.html#a6ea20d97a32efd36c02468e54db4b2e7">More...</a><br /></td></tr>
<tr class="separator:a6ea20d97a32efd36c02468e54db4b2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa35b353841b70d090e1ead360536308"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aaa35b353841b70d090e1ead360536308">registerOpenMPDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:aaa35b353841b70d090e1ead360536308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the OpenMP dialect and the translation from it in the registry associated with the given context.  <a href="namespacemlir.html#aaa35b353841b70d090e1ead360536308">More...</a><br /></td></tr>
<tr class="separator:aaa35b353841b70d090e1ead360536308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab895c88d57833ccee805eb3233c04ca6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab895c88d57833ccee805eb3233c04ca6">registerROCDLDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ab895c88d57833ccee805eb3233c04ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="namespacemlir.html#ab895c88d57833ccee805eb3233c04ca6">More...</a><br /></td></tr>
<tr class="separator:ab895c88d57833ccee805eb3233c04ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e522221c6652cb1450a6a3803125534"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4e522221c6652cb1450a6a3803125534">registerROCDLDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a4e522221c6652cb1450a6a3803125534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> dialect and the translation from it in the registry associated with the given context.  <a href="namespacemlir.html#a4e522221c6652cb1450a6a3803125534">More...</a><br /></td></tr>
<tr class="separator:a4e522221c6652cb1450a6a3803125534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6971e37634f3b392e868dc60aefab9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad6971e37634f3b392e868dc60aefab9a">registerSPIRVDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ad6971e37634f3b392e868dc60aefab9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the SPIR-V dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="namespacemlir.html#ad6971e37634f3b392e868dc60aefab9a">More...</a><br /></td></tr>
<tr class="separator:ad6971e37634f3b392e868dc60aefab9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74395e0d79520f9e47d1467c7d4dcb25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a74395e0d79520f9e47d1467c7d4dcb25">registerSPIRVDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a74395e0d79520f9e47d1467c7d4dcb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the SPIR-V dialect and the translation from it in the registry associated with the given context.  <a href="namespacemlir.html#a74395e0d79520f9e47d1467c7d4dcb25">More...</a><br /></td></tr>
<tr class="separator:a74395e0d79520f9e47d1467c7d4dcb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea099d5836b931b596ca22c70878760"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8ea099d5836b931b596ca22c70878760">registerVCIXDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a8ea099d5836b931b596ca22c70878760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the VCIX dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry.  <a href="namespacemlir.html#a8ea099d5836b931b596ca22c70878760">More...</a><br /></td></tr>
<tr class="separator:a8ea099d5836b931b596ca22c70878760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134adbd787b504667bef30d219adfed8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a134adbd787b504667bef30d219adfed8">registerVCIXDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a134adbd787b504667bef30d219adfed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the VCIX dialect and the translation from it in the registry associated with the given context.  <a href="namespacemlir.html#a134adbd787b504667bef30d219adfed8">More...</a><br /></td></tr>
<tr class="separator:a134adbd787b504667bef30d219adfed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a06304b237de21b74a8c5b3251ac35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a06a06304b237de21b74a8c5b3251ac35">registerX86VectorDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a06a06304b237de21b74a8c5b3251ac35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the X86Vector dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="namespacemlir.html#a06a06304b237de21b74a8c5b3251ac35">More...</a><br /></td></tr>
<tr class="separator:a06a06304b237de21b74a8c5b3251ac35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087d9cf09c9d93a0bf0f287509afc5b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a087d9cf09c9d93a0bf0f287509afc5b4">registerX86VectorDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a087d9cf09c9d93a0bf0f287509afc5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the X86Vector dialect and the translation from it in the registry associated with the given context.  <a href="namespacemlir.html#a087d9cf09c9d93a0bf0f287509afc5b4">More...</a><br /></td></tr>
<tr class="separator:a087d9cf09c9d93a0bf0f287509afc5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077184b26527c49e3469c2c25ff73861"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a077184b26527c49e3469c2c25ff73861">translateModuleToLLVMIR</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *module, llvm::LLVMContext &amp;llvmContext, llvm::StringRef name=&quot;LLVMDialectModule&quot;, bool disableVerification=false)</td></tr>
<tr class="memdesc:a077184b26527c49e3469c2c25ff73861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a given <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect <code>module</code> into an <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR module living in the given context.  <a href="namespacemlir.html#a077184b26527c49e3469c2c25ff73861">More...</a><br /></td></tr>
<tr class="separator:a077184b26527c49e3469c2c25ff73861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1617ff95451ab9fa7888fbbe841e8193"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1617ff95451ab9fa7888fbbe841e8193">translateLLVMIRToModule</a> (std::unique_ptr&lt; llvm::Module &gt; llvmModule, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, bool emitExpensiveWarnings=true, bool dropDICompositeTypeElements=false)</td></tr>
<tr class="memdesc:a1617ff95451ab9fa7888fbbe841e8193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> module into an MLIR module living in the given context.  <a href="namespacemlir.html#a1617ff95451ab9fa7888fbbe841e8193">More...</a><br /></td></tr>
<tr class="separator:a1617ff95451ab9fa7888fbbe841e8193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f93379e5dbb5551bbe57170230a1d92"><td class="memItemLeft" align="right" valign="top">DataLayoutSpecInterface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2f93379e5dbb5551bbe57170230a1d92">translateDataLayout</a> (const llvm::DataLayout &amp;dataLayout, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a2f93379e5dbb5551bbe57170230a1d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate the given <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> data layout into an MLIR equivalent using the DLTI dialect.  <a href="namespacemlir.html#a2f93379e5dbb5551bbe57170230a1d92">More...</a><br /></td></tr>
<tr class="separator:a2f93379e5dbb5551bbe57170230a1d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ad163144fafb93cf9814b2235ccf59"><td class="memItemLeft" align="right" valign="top">llvm::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af3ad163144fafb93cf9814b2235ccf59">MlirLspServerMain</a> (int argc, char **argv, <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:af3ad163144fafb93cf9814b2235ccf59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for tools like <code>mlir-lsp-server</code>.  <a href="namespacemlir.html#af3ad163144fafb93cf9814b2235ccf59">More...</a><br /></td></tr>
<tr class="separator:af3ad163144fafb93cf9814b2235ccf59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad495fac45c73eb07003f55e4c3c82ca2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad495fac45c73eb07003f55e4c3c82ca2">registerAndParseCLIOptions</a> (int argc, char **argv, llvm::StringRef toolName, <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ad495fac45c73eb07003f55e4c3c82ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register and parse command line options.  <a href="namespacemlir.html#ad495fac45c73eb07003f55e4c3c82ca2">More...</a><br /></td></tr>
<tr class="separator:ad495fac45c73eb07003f55e4c3c82ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440508357b9fe36f36010043c99e2f22"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a440508357b9fe36f36010043c99e2f22">MlirOptMain</a> (llvm::raw_ostream &amp;outputStream, std::unique_ptr&lt; llvm::MemoryBuffer &gt; buffer, <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry, const <a class="el" href="classmlir_1_1MlirOptMainConfig.html">MlirOptMainConfig</a> &amp;config)</td></tr>
<tr class="memdesc:a440508357b9fe36f36010043c99e2f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the core processing behind <code>mlir-opt</code>.  <a href="namespacemlir.html#a440508357b9fe36f36010043c99e2f22">More...</a><br /></td></tr>
<tr class="separator:a440508357b9fe36f36010043c99e2f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6b96254b4e476bf34403287c27825a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1f6b96254b4e476bf34403287c27825a">MlirOptMain</a> (int argc, char **argv, llvm::StringRef toolName, <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a1f6b96254b4e476bf34403287c27825a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for tools like <code>mlir-opt</code>.  <a href="namespacemlir.html#a1f6b96254b4e476bf34403287c27825a">More...</a><br /></td></tr>
<tr class="separator:a1f6b96254b4e476bf34403287c27825a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af142b3ef60201e867dd545860bf1f71d"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af142b3ef60201e867dd545860bf1f71d">MlirOptMain</a> (int argc, char **argv, llvm::StringRef inputFilename, llvm::StringRef outputFilename, <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:af142b3ef60201e867dd545860bf1f71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for tools like <code>mlir-opt</code>.  <a href="namespacemlir.html#af142b3ef60201e867dd545860bf1f71d">More...</a><br /></td></tr>
<tr class="separator:af142b3ef60201e867dd545860bf1f71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1168f4877a1008569deabfdab07fbb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3d1168f4877a1008569deabfdab07fbb">asMainReturnCode</a> (LogicalResult r)</td></tr>
<tr class="memdesc:a3d1168f4877a1008569deabfdab07fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper wrapper to return the result of MlirOptMain directly from main.  <a href="namespacemlir.html#a3d1168f4877a1008569deabfdab07fbb">More...</a><br /></td></tr>
<tr class="separator:a3d1168f4877a1008569deabfdab07fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf1fa346908020b9dbc2009bb3630ce"><td class="memItemLeft" align="right" valign="top">llvm::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afcf1fa346908020b9dbc2009bb3630ce">MlirPdllLspServerMain</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:afcf1fa346908020b9dbc2009bb3630ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for tools like <code>mlir-pdll-lsp-server</code>.  <a href="namespacemlir.html#afcf1fa346908020b9dbc2009bb3630ce">More...</a><br /></td></tr>
<tr class="separator:afcf1fa346908020b9dbc2009bb3630ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7810268d0608849708e435fcb9791bb1"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7810268d0608849708e435fcb9791bb1">mlirQueryMain</a> (int argc, char **argv, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context, const <a class="el" href="classmlir_1_1query_1_1matcher_1_1Registry.html">mlir::query::matcher::Registry</a> &amp;matcherRegistry)</td></tr>
<tr class="separator:a7810268d0608849708e435fcb9791bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab515fd3b6aebea7df681f094b42d9e71"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab515fd3b6aebea7df681f094b42d9e71">mlirReduceMain</a> (int argc, char **argv, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="separator:ab515fd3b6aebea7df681f094b42d9e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4175a8043cece857c2779663ef3ba91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad4175a8043cece857c2779663ef3ba91">MlirTblgenMain</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:ad4175a8043cece857c2779663ef3ba91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main Program for tools like 'mlir-tblgen' with custom backends.  <a href="namespacemlir.html#ad4175a8043cece857c2779663ef3ba91">More...</a><br /></td></tr>
<tr class="separator:ad4175a8043cece857c2779663ef3ba91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab673e648679ec83d87417b04baf281dd"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab673e648679ec83d87417b04baf281dd">mlirTranslateMain</a> (int argc, char **argv, StringRef toolName)</td></tr>
<tr class="memdesc:ab673e648679ec83d87417b04baf281dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate to/from an MLIR module from/to an external representation (e.g.  <a href="namespacemlir.html#ab673e648679ec83d87417b04baf281dd">More...</a><br /></td></tr>
<tr class="separator:ab673e648679ec83d87417b04baf281dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a41d372a37300e7b09f82fbd8b2d425"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3a41d372a37300e7b09f82fbd8b2d425">registerTranslationCLOptions</a> ()</td></tr>
<tr class="memdesc:a3a41d372a37300e7b09f82fbd8b2d425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register command-line options used by the translation registry.  <a href="namespacemlir.html#a3a41d372a37300e7b09f82fbd8b2d425">More...</a><br /></td></tr>
<tr class="separator:a3a41d372a37300e7b09f82fbd8b2d425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718d37dc4122f9a0851238684eb13a39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a718d37dc4122f9a0851238684eb13a39">parseSourceFileForTool</a> (const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;sourceMgr, const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;config, bool insertImplicitModule)</td></tr>
<tr class="memdesc:a718d37dc4122f9a0851238684eb13a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated SourceMgr.  <a href="namespacemlir.html#a718d37dc4122f9a0851238684eb13a39">More...</a><br /></td></tr>
<tr class="separator:a718d37dc4122f9a0851238684eb13a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71592b6a57d95558cc2094b140ec445"><td class="memItemLeft" align="right" valign="top">llvm::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae71592b6a57d95558cc2094b140ec445">TableGenLspServerMain</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:ae71592b6a57d95558cc2094b140ec445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for tools like <code>tblgen-lsp-server</code>.  <a href="namespacemlir.html#ae71592b6a57d95558cc2094b140ec445">More...</a><br /></td></tr>
<tr class="separator:ae71592b6a57d95558cc2094b140ec445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9887613b4e793d34591b00a9732c03"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7c9887613b4e793d34591b00a9732c03">transformCFGToSCF</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1CFGToSCFInterface.html">CFGToSCFInterface</a> &amp;interface, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;dominanceInfo)</td></tr>
<tr class="memdesc:a7c9887613b4e793d34591b00a9732c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation lifting any dialect implementing control flow graph operations to a dialect implementing structured control flow operations.  <a href="namespacemlir.html#a7c9887613b4e793d34591b00a9732c03">More...</a><br /></td></tr>
<tr class="separator:a7c9887613b4e793d34591b00a9732c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6657dab425bc62dafe146c813979dc2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6657dab425bc62dafe146c813979dc2b">populateCommutativityUtilsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a6657dab425bc62dafe146c813979dc2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the commutativity utility patterns.  <a href="namespacemlir.html#a6657dab425bc62dafe146c813979dc2b">More...</a><br /></td></tr>
<tr class="separator:a6657dab425bc62dafe146c813979dc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e826b7dff0a2629197a20d859cd4c7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac6e826b7dff0a2629197a20d859cd4c7">controlFlowSink</a> (<a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a> regions, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; shouldMoveIntoRegion, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; moveIntoRegion)</td></tr>
<tr class="memdesc:ac6e826b7dff0a2629197a20d859cd4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of regions, perform control flow sinking on them.  <a href="namespacemlir.html#ac6e826b7dff0a2629197a20d859cd4c7">More...</a><br /></td></tr>
<tr class="separator:ac6e826b7dff0a2629197a20d859cd4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03521cb5a2e00b91574ef1df705310bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a03521cb5a2e00b91574ef1df705310bd">getSinglyExecutedRegionsToSink</a> (RegionBranchOpInterface branch, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> * &gt; &amp;regions)</td></tr>
<tr class="memdesc:a03521cb5a2e00b91574ef1df705310bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>regions</code> with regions of the provided region branch op that are executed at most once at that are reachable given the current operands of the op.  <a href="namespacemlir.html#a03521cb5a2e00b91574ef1df705310bd">More...</a><br /></td></tr>
<tr class="separator:a03521cb5a2e00b91574ef1df705310bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05e50dddc61ab840dee2a99add961d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab05e50dddc61ab840dee2a99add961d8">eliminateCommonSubExpressions</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, bool *changed=nullptr)</td></tr>
<tr class="memdesc:ab05e50dddc61ab840dee2a99add961d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate common subexpressions within the given operation.  <a href="namespacemlir.html#ab05e50dddc61ab840dee2a99add961d8">More...</a><br /></td></tr>
<tr class="separator:ab05e50dddc61ab840dee2a99add961d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823e1a3f23ee77e276bee93e6313abb1"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a823e1a3f23ee77e276bee93e6313abb1">convertOpResultTypes</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1ConversionPatternRewriter.html">ConversionPatternRewriter</a> &amp;rewriter)</td></tr>
<tr class="memdesc:a823e1a3f23ee77e276bee93e6313abb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic utility to convert op result types according to type converter without knowing exact op type.  <a href="namespacemlir.html#a823e1a3f23ee77e276bee93e6313abb1">More...</a><br /></td></tr>
<tr class="separator:a823e1a3f23ee77e276bee93e6313abb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f92d5c679a9826ca11750ddfc2eef2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0f92d5c679a9826ca11750ddfc2eef2f">populateFunctionOpInterfaceTypeConversionPattern</a> (StringRef functionLikeOpName, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="memdesc:a0f92d5c679a9826ca11750ddfc2eef2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pattern to the given pattern list to convert the signature of a FunctionOpInterface op with the given type converter.  <a href="namespacemlir.html#a0f92d5c679a9826ca11750ddfc2eef2f">More...</a><br /></td></tr>
<tr class="separator:a0f92d5c679a9826ca11750ddfc2eef2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9dfe9dd627a507aeeb36b66e8bd9fb"><td class="memTemplParams" colspan="2">template&lt;typename FuncOpT &gt; </td></tr>
<tr class="memitem:a2a9dfe9dd627a507aeeb36b66e8bd9fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2a9dfe9dd627a507aeeb36b66e8bd9fb">populateFunctionOpInterfaceTypeConversionPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="separator:a2a9dfe9dd627a507aeeb36b66e8bd9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ee9c5848e5edb1b56af1c937f9bb07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a16ee9c5848e5edb1b56af1c937f9bb07">populateAnyFunctionOpInterfaceTypeConversionPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="separator:a16ee9c5848e5edb1b56af1c937f9bb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53cd627dc538a8da5a61d8ba621e603"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae53cd627dc538a8da5a61d8ba621e603">registerConversionPDLFunctions</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ae53cd627dc538a8da5a61d8ba621e603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the dialect conversion PDL functions with the given pattern set.  <a href="namespacemlir.html#ae53cd627dc538a8da5a61d8ba621e603">More...</a><br /></td></tr>
<tr class="separator:ae53cd627dc538a8da5a61d8ba621e603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf251298609435109217ec8cfa535642"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aaf251298609435109217ec8cfa535642">reconcileUnrealizedCasts</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; UnrealizedConversionCastOp &gt; castOps, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; UnrealizedConversionCastOp &gt; *remainingCastOps=nullptr)</td></tr>
<tr class="memdesc:aaf251298609435109217ec8cfa535642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to reconcile all given UnrealizedConversionCastOps and store the left-over ops in <code>remainingCastOps</code> (if provided).  <a href="namespacemlir.html#aaf251298609435109217ec8cfa535642">More...</a><br /></td></tr>
<tr class="separator:aaf251298609435109217ec8cfa535642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfc0e59e43a9e754aa5d70d91eb5a28"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aecfc0e59e43a9e754aa5d70d91eb5a28">applyPartialConversion</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; ops, const <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, <a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a> config=<a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a>())</td></tr>
<tr class="memdesc:aecfc0e59e43a9e754aa5d70d91eb5a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Below we define several entry points for operation conversion.  <a href="namespacemlir.html#aecfc0e59e43a9e754aa5d70d91eb5a28">More...</a><br /></td></tr>
<tr class="separator:aecfc0e59e43a9e754aa5d70d91eb5a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad706ae09aa9236e1c0e386edc4040efc"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad706ae09aa9236e1c0e386edc4040efc">applyPartialConversion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, <a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a> config=<a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a>())</td></tr>
<tr class="separator:ad706ae09aa9236e1c0e386edc4040efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5763e1af1116086ca3b5921ea2e3895b"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5763e1af1116086ca3b5921ea2e3895b">applyFullConversion</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; ops, const <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, <a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a> config=<a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a>())</td></tr>
<tr class="memdesc:a5763e1af1116086ca3b5921ea2e3895b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a complete conversion on the given operations, and all nested operations.  <a href="namespacemlir.html#a5763e1af1116086ca3b5921ea2e3895b">More...</a><br /></td></tr>
<tr class="separator:a5763e1af1116086ca3b5921ea2e3895b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8530ef21d546fc07d7313b687ca89f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1d8530ef21d546fc07d7313b687ca89f">applyFullConversion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, <a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a> config=<a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a>())</td></tr>
<tr class="separator:a1d8530ef21d546fc07d7313b687ca89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906c1d91c48bb67c936b1cca34525b98"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a906c1d91c48bb67c936b1cca34525b98">applyAnalysisConversion</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; ops, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, <a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a> config=<a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a>())</td></tr>
<tr class="memdesc:a906c1d91c48bb67c936b1cca34525b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an analysis conversion on the given operations, and all nested operations.  <a href="namespacemlir.html#a906c1d91c48bb67c936b1cca34525b98">More...</a><br /></td></tr>
<tr class="separator:a906c1d91c48bb67c936b1cca34525b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f5c95a994f04b659b630dbf0fc9134"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af7f5c95a994f04b659b630dbf0fc9134">applyAnalysisConversion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, <a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a> config=<a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a>())</td></tr>
<tr class="separator:af7f5c95a994f04b659b630dbf0fc9134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d1a56c5c6dd1c979fb0b0b9abf705f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a98d1a56c5c6dd1c979fb0b0b9abf705f">applyPatternsAndFoldGreedily</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> config=<a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>(), bool *changed=nullptr)</td></tr>
<tr class="memdesc:a98d1a56c5c6dd1c979fb0b0b9abf705f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite ops in the given region, which must be isolated from above, by repeatedly applying the highest benefit patterns in a greedy worklist driven manner until a fixpoint is reached.  <a href="namespacemlir.html#a98d1a56c5c6dd1c979fb0b0b9abf705f">More...</a><br /></td></tr>
<tr class="separator:a98d1a56c5c6dd1c979fb0b0b9abf705f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b83dd66e74f4184340fe7684edaf070"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7b83dd66e74f4184340fe7684edaf070">applyPatternsAndFoldGreedily</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> config=<a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>(), bool *changed=nullptr)</td></tr>
<tr class="memdesc:a7b83dd66e74f4184340fe7684edaf070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite ops nested under the given operation, which must be isolated from above, by repeatedly applying the highest benefit patterns in a greedy worklist driven manner until a fixpoint is reached.  <a href="namespacemlir.html#a7b83dd66e74f4184340fe7684edaf070">More...</a><br /></td></tr>
<tr class="separator:a7b83dd66e74f4184340fe7684edaf070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b86ede77ff793a77a2f26ac8755313"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a10b86ede77ff793a77a2f26ac8755313">applyOpPatternsAndFold</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; ops, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> config=<a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>(), bool *changed=nullptr, bool *allErased=nullptr)</td></tr>
<tr class="memdesc:a10b86ede77ff793a77a2f26ac8755313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the specified ops by repeatedly applying the highest benefit patterns in a greedy worklist driven manner until a fixpoint is reached.  <a href="namespacemlir.html#a10b86ede77ff793a77a2f26ac8755313">More...</a><br /></td></tr>
<tr class="separator:a10b86ede77ff793a77a2f26ac8755313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754f32a9d62efdcb48e4e0a2f3da1576"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a754f32a9d62efdcb48e4e0a2f3da1576">inlineRegion</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *inlinePoint, <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;mapper, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> resultsToReplace, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> regionResultTypes, std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; inlineLoc=std::nullopt, bool shouldCloneInlinedRegion=true)</td></tr>
<tr class="memdesc:a754f32a9d62efdcb48e4e0a2f3da1576"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inlines a region, 'src', into another.  <a href="namespacemlir.html#a754f32a9d62efdcb48e4e0a2f3da1576">More...</a><br /></td></tr>
<tr class="separator:a754f32a9d62efdcb48e4e0a2f3da1576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1236e68e2c467729ae0f0c6189e3d55"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad1236e68e2c467729ae0f0c6189e3d55">inlineRegion</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Block.html">Block</a> *inlineBlock, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> inlinePoint, <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;mapper, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> resultsToReplace, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> regionResultTypes, std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; inlineLoc=std::nullopt, bool shouldCloneInlinedRegion=true)</td></tr>
<tr class="separator:ad1236e68e2c467729ae0f0c6189e3d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16442f718030c48c28c7ae986fa39acf"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a16442f718030c48c28c7ae986fa39acf">inlineRegion</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *inlinePoint, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inlinedOperands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> resultsToReplace, std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; inlineLoc=std::nullopt, bool shouldCloneInlinedRegion=true)</td></tr>
<tr class="memdesc:a16442f718030c48c28c7ae986fa39acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is an overload of the above 'inlineRegion' that allows for providing the set of operands ('inlinedOperands') that should be used in-favor of the region arguments when inlining.  <a href="namespacemlir.html#a16442f718030c48c28c7ae986fa39acf">More...</a><br /></td></tr>
<tr class="separator:a16442f718030c48c28c7ae986fa39acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1be5dbac3676f88a7f87669ec0f2484"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad1be5dbac3676f88a7f87669ec0f2484">inlineRegion</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Block.html">Block</a> *inlineBlock, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> inlinePoint, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inlinedOperands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> resultsToReplace, std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; inlineLoc=std::nullopt, bool shouldCloneInlinedRegion=true)</td></tr>
<tr class="separator:ad1be5dbac3676f88a7f87669ec0f2484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa82b2f82348c0eacc76f1c4a862a796"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afa82b2f82348c0eacc76f1c4a862a796">inlineCall</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, CallOpInterface call, CallableOpInterface callable, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, bool shouldCloneInlinedRegion=true)</td></tr>
<tr class="memdesc:afa82b2f82348c0eacc76f1c4a862a796"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inlines a given region, 'src', of a callable operation, 'callable', into the location defined by the given call operation.  <a href="namespacemlir.html#afa82b2f82348c0eacc76f1c4a862a796">More...</a><br /></td></tr>
<tr class="separator:afa82b2f82348c0eacc76f1c4a862a796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3bd1afbf84ef9cca6c336a104d7280"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2d3bd1afbf84ef9cca6c336a104d7280">generateLocationsFromIR</a> (raw_ostream &amp;os, StringRef fileName, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags)</td></tr>
<tr class="memdesc:a2d3bd1afbf84ef9cca6c336a104d7280"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates new locations from the given IR by snapshotting the IR to the given stream, and using the printed locations within that stream.  <a href="namespacemlir.html#a2d3bd1afbf84ef9cca6c336a104d7280">More...</a><br /></td></tr>
<tr class="separator:a2d3bd1afbf84ef9cca6c336a104d7280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16c6823f94d6ce99fa7da7547658345"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af16c6823f94d6ce99fa7da7547658345">generateLocationsFromIR</a> (StringRef fileName, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags)</td></tr>
<tr class="memdesc:af16c6823f94d6ce99fa7da7547658345"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates new locations from the given IR by snapshotting the IR to the given file, and using the printed locations within that file.  <a href="namespacemlir.html#af16c6823f94d6ce99fa7da7547658345">More...</a><br /></td></tr>
<tr class="separator:af16c6823f94d6ce99fa7da7547658345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e9bde94caabba0feba96a044a09afc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a94e9bde94caabba0feba96a044a09afc">generateLocationsFromIR</a> (raw_ostream &amp;os, StringRef fileName, StringRef tag, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags)</td></tr>
<tr class="memdesc:a94e9bde94caabba0feba96a044a09afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates new locations from the given IR by snapshotting the IR to the given stream, and using the printed locations within that stream.  <a href="namespacemlir.html#a94e9bde94caabba0feba96a044a09afc">More...</a><br /></td></tr>
<tr class="separator:a94e9bde94caabba0feba96a044a09afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab170389f5f17475f89037e332018b4f8"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab170389f5f17475f89037e332018b4f8">generateLocationsFromIR</a> (StringRef fileName, StringRef tag, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags)</td></tr>
<tr class="memdesc:ab170389f5f17475f89037e332018b4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates new locations from the given IR by snapshotting the IR to the given file, and using the printed locations within that file.  <a href="namespacemlir.html#ab170389f5f17475f89037e332018b4f8">More...</a><br /></td></tr>
<tr class="separator:ab170389f5f17475f89037e332018b4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415fbf6253902c584461fa6a43a59ad5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a415fbf6253902c584461fa6a43a59ad5">createLocationSnapshotPass</a> (<a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags, StringRef fileName=&quot;&quot;, StringRef tag=&quot;&quot;)</td></tr>
<tr class="memdesc:a415fbf6253902c584461fa6a43a59ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to generate new locations by snapshotting the IR to the given file, and using the printed locations within that file.  <a href="namespacemlir.html#a415fbf6253902c584461fa6a43a59ad5">More...</a><br /></td></tr>
<tr class="separator:a415fbf6253902c584461fa6a43a59ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0bdadbeb0d7f5b8cef57668447640b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abb0bdadbeb0d7f5b8cef57668447640b">createLocationSnapshotPass</a> ()</td></tr>
<tr class="memdesc:abb0bdadbeb0d7f5b8cef57668447640b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload utilizing pass options for initialization.  <a href="namespacemlir.html#abb0bdadbeb0d7f5b8cef57668447640b">More...</a><br /></td></tr>
<tr class="separator:abb0bdadbeb0d7f5b8cef57668447640b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79a420cd75e576fa80212258d3de025"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af79a420cd75e576fa80212258d3de025">moveLoopInvariantCode</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> * &gt; regions, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; isDefinedOutsideRegion, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; shouldMoveOutOfRegion, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; moveOutOfRegion)</td></tr>
<tr class="memdesc:af79a420cd75e576fa80212258d3de025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of regions, perform loop-invariant code motion.  <a href="namespacemlir.html#af79a420cd75e576fa80212258d3de025">More...</a><br /></td></tr>
<tr class="separator:af79a420cd75e576fa80212258d3de025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b9f2d2e0330c53880b673633907ac6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a56b9f2d2e0330c53880b673633907ac6">moveLoopInvariantCode</a> (LoopLikeOpInterface loopLike)</td></tr>
<tr class="memdesc:a56b9f2d2e0330c53880b673633907ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move side-effect free loop invariant code out of a loop-like op using methods provided by the interface.  <a href="namespacemlir.html#a56b9f2d2e0330c53880b673633907ac6">More...</a><br /></td></tr>
<tr class="separator:a56b9f2d2e0330c53880b673633907ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249488f6fe37fa1e0175eed93494136d"><td class="memItemLeft" align="right" valign="top">LoopLikeOpInterface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a249488f6fe37fa1e0175eed93494136d">hoistLoopInvariantSubsets</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LoopLikeOpInterface loopLike)</td></tr>
<tr class="memdesc:a249488f6fe37fa1e0175eed93494136d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoist loop-invariant tensor subsets (subset extraction and subset insertion ops) from loop-like ops.  <a href="namespacemlir.html#a249488f6fe37fa1e0175eed93494136d">More...</a><br /></td></tr>
<tr class="separator:a249488f6fe37fa1e0175eed93494136d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2434626306ac343fdef7bf1e3c10459"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae2434626306ac343fdef7bf1e3c10459">tryToPromoteMemorySlots</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; PromotableAllocationOpInterface &gt; allocators, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;dominance, <a class="el" href="structmlir_1_1Mem2RegStatistics.html">Mem2RegStatistics</a> statistics={})</td></tr>
<tr class="memdesc:ae2434626306ac343fdef7bf1e3c10459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to promote the memory slots of the provided allocators.  <a href="namespacemlir.html#ae2434626306ac343fdef7bf1e3c10459">More...</a><br /></td></tr>
<tr class="separator:ae2434626306ac343fdef7bf1e3c10459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32067eb3e1b98572873f7cce08848080"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a32067eb3e1b98572873f7cce08848080">applyPartialOneToNConversion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OneToNTypeConverter.html">OneToNTypeConverter</a> &amp;typeConverter, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a32067eb3e1b98572873f7cce08848080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given set of patterns recursively on the given op and adds user materializations where necessary.  <a href="namespacemlir.html#a32067eb3e1b98572873f7cce08848080">More...</a><br /></td></tr>
<tr class="separator:a32067eb3e1b98572873f7cce08848080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5920e66163417e3c13208bcdcd8a47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aea5920e66163417e3c13208bcdcd8a47">populateOneToNFunctionOpInterfaceTypeConversionPattern</a> (StringRef functionLikeOpName, const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aea5920e66163417e3c13208bcdcd8a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pattern to the given pattern list to convert the signature of a FunctionOpInterface op with the given type converter.  <a href="namespacemlir.html#aea5920e66163417e3c13208bcdcd8a47">More...</a><br /></td></tr>
<tr class="separator:aea5920e66163417e3c13208bcdcd8a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78dbe1e49d3c836bbd8af92cbdfd1cdd"><td class="memTemplParams" colspan="2">template&lt;typename FuncOpT &gt; </td></tr>
<tr class="memitem:a78dbe1e49d3c836bbd8af92cbdfd1cdd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a78dbe1e49d3c836bbd8af92cbdfd1cdd">populateOneToNFunctionOpInterfaceTypeConversionPattern</a> (const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a78dbe1e49d3c836bbd8af92cbdfd1cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0069355214b578476e81bc909f7f13"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aab0069355214b578476e81bc909f7f13">createCanonicalizerPass</a> ()</td></tr>
<tr class="memdesc:aab0069355214b578476e81bc909f7f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the Canonicalizer pass, configured with default settings (which can be overridden by pass options on the command line).  <a href="namespacemlir.html#aab0069355214b578476e81bc909f7f13">More...</a><br /></td></tr>
<tr class="separator:aab0069355214b578476e81bc909f7f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c145cb37ca2bf4e90ceaff2231652f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a93c145cb37ca2bf4e90ceaff2231652f">createCanonicalizerPass</a> (const <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> &amp;config, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt; disabledPatterns=std::nullopt, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt; enabledPatterns=std::nullopt)</td></tr>
<tr class="memdesc:a93c145cb37ca2bf4e90ceaff2231652f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the Canonicalizer pass with the specified config.  <a href="namespacemlir.html#a93c145cb37ca2bf4e90ceaff2231652f">More...</a><br /></td></tr>
<tr class="separator:a93c145cb37ca2bf4e90ceaff2231652f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f1d125e949d2172433639f2f31d3e6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac1f1d125e949d2172433639f2f31d3e6">createControlFlowSinkPass</a> ()</td></tr>
<tr class="memdesc:ac1f1d125e949d2172433639f2f31d3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to perform control-flow sinking.  <a href="namespacemlir.html#ac1f1d125e949d2172433639f2f31d3e6">More...</a><br /></td></tr>
<tr class="separator:ac1f1d125e949d2172433639f2f31d3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14895da9723acd9c7f910c2694ff9f65"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a14895da9723acd9c7f910c2694ff9f65">createCSEPass</a> ()</td></tr>
<tr class="memdesc:a14895da9723acd9c7f910c2694ff9f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to perform common sub expression elimination.  <a href="namespacemlir.html#a14895da9723acd9c7f910c2694ff9f65">More...</a><br /></td></tr>
<tr class="separator:a14895da9723acd9c7f910c2694ff9f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a84c3fae02e7540b0db48350b738be1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0a84c3fae02e7540b0db48350b738be1">createPrintIRPass</a> (const PrintIRPassOptions &amp;={})</td></tr>
<tr class="memdesc:a0a84c3fae02e7540b0db48350b738be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to print IR on the debug stream.  <a href="namespacemlir.html#a0a84c3fae02e7540b0db48350b738be1">More...</a><br /></td></tr>
<tr class="separator:a0a84c3fae02e7540b0db48350b738be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdd2528f381177f9ded6de5eba9900b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6fdd2528f381177f9ded6de5eba9900b">createGenerateRuntimeVerificationPass</a> ()</td></tr>
<tr class="memdesc:a6fdd2528f381177f9ded6de5eba9900b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that generates IR to verify ops at runtime.  <a href="namespacemlir.html#a6fdd2528f381177f9ded6de5eba9900b">More...</a><br /></td></tr>
<tr class="separator:a6fdd2528f381177f9ded6de5eba9900b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319fde65e573dbc3a947d58196cb2b3a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a319fde65e573dbc3a947d58196cb2b3a">createLoopInvariantCodeMotionPass</a> ()</td></tr>
<tr class="memdesc:a319fde65e573dbc3a947d58196cb2b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop invariant code motion pass that hoists loop invariant instructions out of the loop.  <a href="namespacemlir.html#a319fde65e573dbc3a947d58196cb2b3a">More...</a><br /></td></tr>
<tr class="separator:a319fde65e573dbc3a947d58196cb2b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf61282117a610660819cb15624637d6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acf61282117a610660819cb15624637d6">createLoopInvariantSubsetHoistingPass</a> ()</td></tr>
<tr class="memdesc:acf61282117a610660819cb15624637d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that hoists loop-invariant subset ops.  <a href="namespacemlir.html#acf61282117a610660819cb15624637d6">More...</a><br /></td></tr>
<tr class="separator:acf61282117a610660819cb15624637d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b152134b4d44a148dac8bfc24070dcd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3b152134b4d44a148dac8bfc24070dcd">createStripDebugInfoPass</a> ()</td></tr>
<tr class="memdesc:a3b152134b4d44a148dac8bfc24070dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to strip debug information from a function.  <a href="namespacemlir.html#a3b152134b4d44a148dac8bfc24070dcd">More...</a><br /></td></tr>
<tr class="separator:a3b152134b4d44a148dac8bfc24070dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56d49b89c1f203d6fa20f126bf4d900"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab56d49b89c1f203d6fa20f126bf4d900">createPrintOpStatsPass</a> (raw_ostream &amp;os=llvm::errs())</td></tr>
<tr class="memdesc:ab56d49b89c1f203d6fa20f126bf4d900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which prints the list of ops and the number of occurrences in the module.  <a href="namespacemlir.html#ab56d49b89c1f203d6fa20f126bf4d900">More...</a><br /></td></tr>
<tr class="separator:ab56d49b89c1f203d6fa20f126bf4d900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738190b0f29ddc52ba6847cb310eb60d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a738190b0f29ddc52ba6847cb310eb60d">createPrintOpStatsPass</a> (raw_ostream &amp;os, bool printAsJSON)</td></tr>
<tr class="memdesc:a738190b0f29ddc52ba6847cb310eb60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which prints the list of ops and the number of occurrences in the module with the output format option.  <a href="namespacemlir.html#a738190b0f29ddc52ba6847cb310eb60d">More...</a><br /></td></tr>
<tr class="separator:a738190b0f29ddc52ba6847cb310eb60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6ad0644a283c257d1fbc15be6adc18"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6c6ad0644a283c257d1fbc15be6adc18">createInlinerPass</a> ()</td></tr>
<tr class="memdesc:a6c6ad0644a283c257d1fbc15be6adc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which inlines calls and callable operations as defined by the <a class="el" href="classmlir_1_1CallGraph.html">CallGraph</a>.  <a href="namespacemlir.html#a6c6ad0644a283c257d1fbc15be6adc18">More...</a><br /></td></tr>
<tr class="separator:a6c6ad0644a283c257d1fbc15be6adc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1372ce1294d9b98b652930aa6baf1386"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1372ce1294d9b98b652930aa6baf1386">createInlinerPass</a> (llvm::StringMap&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt; opPipelines)</td></tr>
<tr class="memdesc:a1372ce1294d9b98b652930aa6baf1386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the inliner pass, and use the provided pass managers when optimizing callable operations with names matching the key type.  <a href="namespacemlir.html#a1372ce1294d9b98b652930aa6baf1386">More...</a><br /></td></tr>
<tr class="separator:a1372ce1294d9b98b652930aa6baf1386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282d4666d1a10f4c41e6b114bf5e6a7f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a282d4666d1a10f4c41e6b114bf5e6a7f">createInlinerPass</a> (llvm::StringMap&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt; opPipelines, std::function&lt; void(<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;)&gt; defaultPipelineBuilder)</td></tr>
<tr class="memdesc:a282d4666d1a10f4c41e6b114bf5e6a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the inliner pass, and use the provided pass managers when optimizing callable operations with names matching the key type.  <a href="namespacemlir.html#a282d4666d1a10f4c41e6b114bf5e6a7f">More...</a><br /></td></tr>
<tr class="separator:a282d4666d1a10f4c41e6b114bf5e6a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17b2f115a7d8025fb9d5eacf14368b3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab17b2f115a7d8025fb9d5eacf14368b3">createRemoveDeadValuesPass</a> ()</td></tr>
<tr class="memdesc:ab17b2f115a7d8025fb9d5eacf14368b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an optimization pass to remove dead values.  <a href="namespacemlir.html#ab17b2f115a7d8025fb9d5eacf14368b3">More...</a><br /></td></tr>
<tr class="separator:ab17b2f115a7d8025fb9d5eacf14368b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6119493f8c83de427f34658e5e39cbfe"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6119493f8c83de427f34658e5e39cbfe">createSCCPPass</a> ()</td></tr>
<tr class="memdesc:a6119493f8c83de427f34658e5e39cbfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which performs sparse conditional constant propagation over nested operations.  <a href="namespacemlir.html#a6119493f8c83de427f34658e5e39cbfe">More...</a><br /></td></tr>
<tr class="separator:a6119493f8c83de427f34658e5e39cbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69605e45210627de9b7fde4644fa50c1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a69605e45210627de9b7fde4644fa50c1">createSymbolDCEPass</a> ()</td></tr>
<tr class="memdesc:a69605e45210627de9b7fde4644fa50c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which delete symbol operations that are unreachable.  <a href="namespacemlir.html#a69605e45210627de9b7fde4644fa50c1">More...</a><br /></td></tr>
<tr class="separator:a69605e45210627de9b7fde4644fa50c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b0f8a089ed821a240c7dd4e5573573"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae0b0f8a089ed821a240c7dd4e5573573">createSymbolPrivatizePass</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt; excludeSymbols={})</td></tr>
<tr class="memdesc:ae0b0f8a089ed821a240c7dd4e5573573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which marks top-level symbol operations as <code>private</code> unless listed in <code>excludeSymbols</code>.  <a href="namespacemlir.html#ae0b0f8a089ed821a240c7dd4e5573573">More...</a><br /></td></tr>
<tr class="separator:ae0b0f8a089ed821a240c7dd4e5573573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4480ae6dd145482f88ec81d28df3bca8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4480ae6dd145482f88ec81d28df3bca8">createTopologicalSortPass</a> ()</td></tr>
<tr class="memdesc:a4480ae6dd145482f88ec81d28df3bca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that recursively sorts nested regions without SSA dominance topologically such that, as much as possible, users of values appear after their producers.  <a href="namespacemlir.html#a4480ae6dd145482f88ec81d28df3bca8">More...</a><br /></td></tr>
<tr class="separator:a4480ae6dd145482f88ec81d28df3bca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60273f83d83a8fb7e5a1ceebb7a8d4a6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a60273f83d83a8fb7e5a1ceebb7a8d4a6">createCompositeFixedPointPass</a> (std::string name, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;)&gt; populateFunc, int maxIterations=10)</td></tr>
<tr class="memdesc:a60273f83d83a8fb7e5a1ceebb7a8d4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create composite pass, which runs provided set of passes until fixed point or maximum number of iterations reached.  <a href="namespacemlir.html#a60273f83d83a8fb7e5a1ceebb7a8d4a6">More...</a><br /></td></tr>
<tr class="separator:a60273f83d83a8fb7e5a1ceebb7a8d4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac680df79552c596c048cd9cb27638c5f"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:ac680df79552c596c048cd9cb27638c5f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac680df79552c596c048cd9cb27638c5f">areValuesDefinedAbove</a> (<a class="el" href="structmlir_1_1Range.html">Range</a> values, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;limit)</td></tr>
<tr class="memdesc:ac680df79552c596c048cd9cb27638c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all values in the provided range are defined above the <code>limit</code> region.  <a href="namespacemlir.html#ac680df79552c596c048cd9cb27638c5f">More...</a><br /></td></tr>
<tr class="separator:ac680df79552c596c048cd9cb27638c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a5d204dd78ac563241168e6b2e40eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a15a5d204dd78ac563241168e6b2e40eb">replaceAllUsesInRegionWith</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> orig, <a class="el" href="classmlir_1_1Value.html">Value</a> replacement, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:a15a5d204dd78ac563241168e6b2e40eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all uses of <code>orig</code> within the given region with <code>replacement</code>.  <a href="namespacemlir.html#a15a5d204dd78ac563241168e6b2e40eb">More...</a><br /></td></tr>
<tr class="separator:a15a5d204dd78ac563241168e6b2e40eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae644ec0854505ef60f12c23b96de595b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae644ec0854505ef60f12c23b96de595b">visitUsedValuesDefinedAbove</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;limit, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt; callback)</td></tr>
<tr class="memdesc:ae644ec0854505ef60f12c23b96de595b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code>callback</code> for each use of a value within <code>region</code> or its descendants that was defined at the ancestors of the <code>limit</code>.  <a href="namespacemlir.html#ae644ec0854505ef60f12c23b96de595b">More...</a><br /></td></tr>
<tr class="separator:ae644ec0854505ef60f12c23b96de595b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036e7ce3c7c3bf73fc0a653cd98bb7c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a036e7ce3c7c3bf73fc0a653cd98bb7c0">visitUsedValuesDefinedAbove</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt; callback)</td></tr>
<tr class="memdesc:a036e7ce3c7c3bf73fc0a653cd98bb7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code>callback</code> for each use of a value within any of the regions provided that was defined in one of the ancestors.  <a href="namespacemlir.html#a036e7ce3c7c3bf73fc0a653cd98bb7c0">More...</a><br /></td></tr>
<tr class="separator:a036e7ce3c7c3bf73fc0a653cd98bb7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f08e970a346cd42559db87f97f0b91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a98f08e970a346cd42559db87f97f0b91">getUsedValuesDefinedAbove</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;limit, <a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:a98f08e970a346cd42559db87f97f0b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill <code>values</code> with a list of values defined at the ancestors of the <code>limit</code> region and used within <code>region</code> or its descendants.  <a href="namespacemlir.html#a98f08e970a346cd42559db87f97f0b91">More...</a><br /></td></tr>
<tr class="separator:a98f08e970a346cd42559db87f97f0b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c45b388f069e9396c50660f41a7eacf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2c45b388f069e9396c50660f41a7eacf">getUsedValuesDefinedAbove</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions, <a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:a2c45b388f069e9396c50660f41a7eacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill <code>values</code> with a list of values used within any of the regions provided but defined in one of the ancestors.  <a href="namespacemlir.html#a2c45b388f069e9396c50660f41a7eacf">More...</a><br /></td></tr>
<tr class="separator:a2c45b388f069e9396c50660f41a7eacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d806144c2d33e56f341109c75c3d277"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7d806144c2d33e56f341109c75c3d277">makeRegionIsolatedFromAbove</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; cloneOperationIntoRegion=[](<a class="el" href="classmlir_1_1Operation.html">Operation</a> *) { return false;})</td></tr>
<tr class="memdesc:a7d806144c2d33e56f341109c75c3d277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a region isolated from above.  <a href="namespacemlir.html#a7d806144c2d33e56f341109c75c3d277">More...</a><br /></td></tr>
<tr class="separator:a7d806144c2d33e56f341109c75c3d277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38fea8480dfb78d9d3bd0736ccbfa2e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad38fea8480dfb78d9d3bd0736ccbfa2e">simplifyRegions</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions, bool mergeBlocks=true)</td></tr>
<tr class="memdesc:ad38fea8480dfb78d9d3bd0736ccbfa2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a set of structural simplifications over the given regions.  <a href="namespacemlir.html#ad38fea8480dfb78d9d3bd0736ccbfa2e">More...</a><br /></td></tr>
<tr class="separator:ad38fea8480dfb78d9d3bd0736ccbfa2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab9585c8607c12142232e0f58ebcc8b"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6ab9585c8607c12142232e0f58ebcc8b">eraseUnreachableBlocks</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions)</td></tr>
<tr class="memdesc:a6ab9585c8607c12142232e0f58ebcc8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the unreachable blocks within the provided regions.  <a href="namespacemlir.html#a6ab9585c8607c12142232e0f58ebcc8b">More...</a><br /></td></tr>
<tr class="separator:a6ab9585c8607c12142232e0f58ebcc8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb183dcb73d44f0e0aedb09b73c7fd7"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9eb183dcb73d44f0e0aedb09b73c7fd7">runRegionDCE</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions)</td></tr>
<tr class="memdesc:a9eb183dcb73d44f0e0aedb09b73c7fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns success if any operations or arguments were deleted, failure otherwise.  <a href="namespacemlir.html#a9eb183dcb73d44f0e0aedb09b73c7fd7">More...</a><br /></td></tr>
<tr class="separator:a9eb183dcb73d44f0e0aedb09b73c7fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4695076b1d2f75930c85058c6b42084"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad4695076b1d2f75930c85058c6b42084">tryToDestructureMemorySlots</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DestructurableAllocationOpInterface &gt; allocators, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="structmlir_1_1SROAStatistics.html">SROAStatistics</a> statistics={})</td></tr>
<tr class="memdesc:ad4695076b1d2f75930c85058c6b42084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to destructure the slots of destructurable allocators.  <a href="namespacemlir.html#ad4695076b1d2f75930c85058c6b42084">More...</a><br /></td></tr>
<tr class="separator:ad4695076b1d2f75930c85058c6b42084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045e1f32a8d90260d292aad61149c0ef"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a045e1f32a8d90260d292aad61149c0ef">createPrintOpGraphPass</a> (raw_ostream &amp;os=llvm::errs())</td></tr>
<tr class="memdesc:a045e1f32a8d90260d292aad61149c0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to print op graphs.  <a href="namespacemlir.html#a045e1f32a8d90260d292aad61149c0ef">More...</a><br /></td></tr>
<tr class="separator:a045e1f32a8d90260d292aad61149c0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4ce1ebc47dbd367b9b8b19ceeafcb3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7c4ce1ebc47dbd367b9b8b19ceeafcb3">createElementwiseOp</a> (<a class="el" href="classmlir_1_1ConversionPatternRewriter.html">ConversionPatternRewriter</a> &amp;builder, gpu::SubgroupMmaElementwiseOp op, <a class="el" href="classmlir_1_1Type.html">Type</a> coopType, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands)</td></tr>
<tr class="memdesc:a7c4ce1ebc47dbd367b9b8b19ceeafcb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a SPIR-V op to replace the given GPU subgroup mma elementwise op when the elementwise op directly supports with cooperative matrix type.  <a href="namespacemlir.html#a7c4ce1ebc47dbd367b9b8b19ceeafcb3">More...</a><br /></td></tr>
<tr class="separator:a7c4ce1ebc47dbd367b9b8b19ceeafcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf43b39cbc5116796f9b6550f99dee0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aaf43b39cbc5116796f9b6550f99dee0d">allOperandsHaveSameCoopMatrixType</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands)</td></tr>
<tr class="separator:aaf43b39cbc5116796f9b6550f99dee0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1058014e7cd14312242383156c0d174"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab1058014e7cd14312242383156c0d174">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a> &amp;printer, <a class="el" href="namespacemlir.html#acefb76d43733fcaa50b62e0962d9c463">DeviceIDTargetDeviceSpecPair</a> param)</td></tr>
<tr class="separator:ab1058014e7cd14312242383156c0d174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173b0b96100cbcbab8373ad93e33c86d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a173b0b96100cbcbab8373ad93e33c86d">convertToAttribute</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, IntegerOverflowFlags flags)</td></tr>
<tr class="separator:a173b0b96100cbcbab8373ad93e33c86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd22462e9e020181df531dfa5f8164e"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4bd22462e9e020181df531dfa5f8164e">convertFromAttribute</a> (IntegerOverflowFlags &amp;flags, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="separator:a4bd22462e9e020181df531dfa5f8164e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9994bf5e77db2932598481cf8e46fb"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:aaf9994bf5e77db2932598481cf8e46fb"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aaf9994bf5e77db2932598481cf8e46fb">getValuesSortedByKeyImpl</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; K &gt; keys, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; V &gt; values, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(K, K)&gt; compare)</td></tr>
<tr class="memdesc:aaf9994bf5e77db2932598481cf8e46fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to sort <code>values</code> according to matching <code>keys</code>.  <a href="namespacemlir.html#aaf9994bf5e77db2932598481cf8e46fb">More...</a><br /></td></tr>
<tr class="separator:aaf9994bf5e77db2932598481cf8e46fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b336390b16983a364b2d95bd2a64a2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2b336390b16983a364b2d95bd2a64a2f">registerTestRoundtripSPIRV</a> ()</td></tr>
<tr class="separator:a2b336390b16983a364b2d95bd2a64a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed913befc935e3b4b3e622838655b30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9ed913befc935e3b4b3e622838655b30">registerTestRoundtripDebugSPIRV</a> ()</td></tr>
<tr class="separator:a9ed913befc935e3b4b3e622838655b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2887883f00b094c5ca61c631d7b093a0"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2887883f00b094c5ca61c631d7b093a0">kDeriveIndexBitwidthFromDataLayout</a> = 0</td></tr>
<tr class="memdesc:a2887883f00b094c5ca61c631d7b093a0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> to pass as bitwidth for the index type when the converter is expected to derive the bitwidth from the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> data layout.  <a href="namespacemlir.html#a2887883f00b094c5ca61c631d7b093a0">More...</a><br /></td></tr>
<tr class="separator:a2887883f00b094c5ca61c631d7b093a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f52f0c5e268decd5b4ff95c42ea054"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a52f52f0c5e268decd5b4ff95c42ea054"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a52f52f0c5e268decd5b4ff95c42ea054">has_sub_attr_or_type_v</a></td></tr>
<tr class="separator:a52f52f0c5e268decd5b4ff95c42ea054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1349a176f4860c35697f441e414bf358"><td class="memItemLeft" align="right" valign="top">const char *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1349a176f4860c35697f441e414bf358">kDefaultSplitMarker</a> = &quot;// -----&quot;</td></tr>
<tr class="separator:a1349a176f4860c35697f441e414bf358"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Include the generated interface declarations. </p>
<p>Part of the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> Project, under the Apache License v2.0 with <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> Exceptions.</p>
<p>The pass expands memref operations that modify the metadata of a memref (sizes, offset, strides) into a sequence of easier to analyze constructs.</p>
<p>This header declares functions that assist transformations in the MemRef dialect.</p>
<p>In particular, this pass transforms operations into explicit sequence of operations that model the effect of this operation on the different metadata. This pass uses affine constructs to materialize these effects.</p>
<p>See <a href="https://llvm.org/LICENSE.txt">https://llvm.org/LICENSE.txt</a> for license information. SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ac9afb3b6f82b256aea9f20e913e8afd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9afb3b6f82b256aea9f20e913e8afd5">&#9670;&nbsp;</a></span>AllocFunType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ac9afb3b6f82b256aea9f20e913e8afd5">mlir::AllocFunType</a> = typedef <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;void *(size_t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00037">37</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

</div>
</div>
<a id="aad8f5011648c4f698028afb8a96b31ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8f5011648c4f698028afb8a96b31ce">&#9670;&nbsp;</a></span>AttributeStorageAllocator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aad8f5011648c4f698028afb8a96b31ce">mlir::AttributeStorageAllocator</a> = typedef <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttributeSupport_8h_source.html#l00207">207</a> of file <a class="el" href="AttributeSupport_8h_source.html">AttributeSupport.h</a>.</p>

</div>
</div>
<a id="a16ea1893e6ad27965d15e12d6f545008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ea1893e6ad27965d15e12d6f545008">&#9670;&nbsp;</a></span>AttrSubElementReplacements</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a16ea1893e6ad27965d15e12d6f545008">mlir::AttrSubElementReplacements</a> = typedef <a class="el" href="classmlir_1_1AttrTypeSubElementReplacements.html">AttrTypeSubElementReplacements</a>&lt;<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00373">373</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

</div>
</div>
<a id="aafb0c2458571cd80ebb876d979e24346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb0c2458571cd80ebb876d979e24346">&#9670;&nbsp;</a></span>ChunkBufferHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aafb0c2458571cd80ebb876d979e24346">mlir::ChunkBufferHandler</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;LogicalResult( std::unique_ptr&lt;llvm::MemoryBuffer&gt; chunkBuffer, raw_ostream &amp;os)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ToolUtilities_8h_source.html#l00027">27</a> of file <a class="el" href="ToolUtilities_8h_source.html">ToolUtilities.h</a>.</p>

</div>
</div>
<a id="a33732a3813b186ef51131421fac26f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33732a3813b186ef51131421fac26f4a">&#9670;&nbsp;</a></span>DataLayoutEntryKey</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a33732a3813b186ef51131421fac26f4a">mlir::DataLayoutEntryKey</a> = typedef <a class="el" href="classllvm_1_1PointerUnion.html">llvm::PointerUnion</a>&lt;<a class="el" href="classmlir_1_1Type.html">Type</a>, StringAttr&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8h_source.html#l00029">29</a> of file <a class="el" href="DataLayoutInterfaces_8h_source.html">DataLayoutInterfaces.h</a>.</p>

</div>
</div>
<a id="a72a4f77607d05cf551b24ceb9362c034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a4f77607d05cf551b24ceb9362c034">&#9670;&nbsp;</a></span>DataLayoutEntryList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a72a4f77607d05cf551b24ceb9362c034">mlir::DataLayoutEntryList</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">llvm::SmallVector</a>&lt;DataLayoutEntryInterface, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8h_source.html#l00032">32</a> of file <a class="el" href="DataLayoutInterfaces_8h_source.html">DataLayoutInterfaces.h</a>.</p>

</div>
</div>
<a id="a577834e9b93afb653df29d66a6975ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577834e9b93afb653df29d66a6975ecf">&#9670;&nbsp;</a></span>DataLayoutEntryListRef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">mlir::DataLayoutEntryListRef</a> = typedef <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt;DataLayoutEntryInterface&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8h_source.html#l00033">33</a> of file <a class="el" href="DataLayoutInterfaces_8h_source.html">DataLayoutInterfaces.h</a>.</p>

</div>
</div>
<a id="a759bdae349015b16ce375bdd46c1e16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759bdae349015b16ce375bdd46c1e16c">&#9670;&nbsp;</a></span>DefaultAttributeStorage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a759bdae349015b16ce375bdd46c1e16c">mlir::DefaultAttributeStorage</a> = typedef <a class="el" href="classmlir_1_1AttributeStorage.html">AttributeStorage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default storage type for attributes that require no additional initialization or storage. </p>

<p class="definition">Definition at line <a class="el" href="AttributeSupport_8h_source.html#l00199">199</a> of file <a class="el" href="AttributeSupport_8h_source.html">AttributeSupport.h</a>.</p>

</div>
</div>
<a id="a8b36f0e85767ed4e793d86f40bd8fe55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b36f0e85767ed4e793d86f40bd8fe55">&#9670;&nbsp;</a></span>DefaultTypeStorage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a8b36f0e85767ed4e793d86f40bd8fe55">mlir::DefaultTypeStorage</a> = typedef <a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default storage type for types that require no additional initialization or storage. </p>

<p class="definition">Definition at line <a class="el" href="TypeSupport_8h_source.html#l00194">194</a> of file <a class="el" href="TypeSupport_8h_source.html">TypeSupport.h</a>.</p>

</div>
</div>
<a id="a7dffb2feeebaff96012a0f11534ecb42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dffb2feeebaff96012a0f11534ecb42">&#9670;&nbsp;</a></span>DenseBoolArrayAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a7dffb2feeebaff96012a0f11534ecb42">mlir::DenseBoolArrayAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;bool&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00765">765</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a1691413cd0a4f426cddf9c9ec13c0523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1691413cd0a4f426cddf9c9ec13c0523">&#9670;&nbsp;</a></span>DenseBoolResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a1691413cd0a4f426cddf9c9ec13c0523">mlir::DenseBoolResourceElementsAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt;bool&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00815">815</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a057c3db4d18f7bc0ebd0e5943ab4f6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057c3db4d18f7bc0ebd0e5943ab4f6f8">&#9670;&nbsp;</a></span>DenseF32ArrayAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a057c3db4d18f7bc0ebd0e5943ab4f6f8">mlir::DenseF32ArrayAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00770">770</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="af658dc01559125b6634401cc7a8128d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af658dc01559125b6634401cc7a8128d1">&#9670;&nbsp;</a></span>DenseF32ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#af658dc01559125b6634401cc7a8128d1">mlir::DenseF32ResourceElementsAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00833">833</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="accd8e5d82c207ff36cbbf5abad9ca288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd8e5d82c207ff36cbbf5abad9ca288">&#9670;&nbsp;</a></span>DenseF64ArrayAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#accd8e5d82c207ff36cbbf5abad9ca288">mlir::DenseF64ArrayAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00771">771</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="af761c00f33889d6ec2a2247517748327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af761c00f33889d6ec2a2247517748327">&#9670;&nbsp;</a></span>DenseF64ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#af761c00f33889d6ec2a2247517748327">mlir::DenseF64ResourceElementsAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00835">835</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a684fa3991fcdc7c970ec8a74aa461a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684fa3991fcdc7c970ec8a74aa461a77">&#9670;&nbsp;</a></span>DenseI16ArrayAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a684fa3991fcdc7c970ec8a74aa461a77">mlir::DenseI16ArrayAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;int16_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00767">767</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a313e0d370789a4ea8efc263c0212e445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313e0d370789a4ea8efc263c0212e445">&#9670;&nbsp;</a></span>DenseI16ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a313e0d370789a4ea8efc263c0212e445">mlir::DenseI16ResourceElementsAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt;int16_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00819">819</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="ace9107ae5cb34fa1aa00e0fd1377ad89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9107ae5cb34fa1aa00e0fd1377ad89">&#9670;&nbsp;</a></span>DenseI32ArrayAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ace9107ae5cb34fa1aa00e0fd1377ad89">mlir::DenseI32ArrayAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;int32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00768">768</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a82486c15d0b4b7a7c6aeaf299655cae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82486c15d0b4b7a7c6aeaf299655cae4">&#9670;&nbsp;</a></span>DenseI32ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a82486c15d0b4b7a7c6aeaf299655cae4">mlir::DenseI32ResourceElementsAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt;int32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00821">821</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a50858f49b4d3e313809688de651162e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50858f49b4d3e313809688de651162e3">&#9670;&nbsp;</a></span>DenseI64ArrayAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">mlir::DenseI64ArrayAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;int64_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00769">769</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a702b9fea87b463a5d46d215e2a41b434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a702b9fea87b463a5d46d215e2a41b434">&#9670;&nbsp;</a></span>DenseI64ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a702b9fea87b463a5d46d215e2a41b434">mlir::DenseI64ResourceElementsAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt;int64_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00823">823</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="ab90796fd9f1813081632c1402c9ab0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90796fd9f1813081632c1402c9ab0f5">&#9670;&nbsp;</a></span>DenseI8ArrayAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ab90796fd9f1813081632c1402c9ab0f5">mlir::DenseI8ArrayAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">detail::DenseArrayAttrImpl</a>&lt;int8_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00766">766</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a80c8652ae83dca72bfa8476f790a779e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c8652ae83dca72bfa8476f790a779e">&#9670;&nbsp;</a></span>DenseI8ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a80c8652ae83dca72bfa8476f790a779e">mlir::DenseI8ResourceElementsAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt;int8_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00817">817</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="ad7f731697783a754f6f0e3821d1264b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f731697783a754f6f0e3821d1264b2">&#9670;&nbsp;</a></span>DenseMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename KeyInfoT  = DenseMapInfo&lt;KeyT&gt;, typename BucketT  = llvm::detail::DenseMapPair&lt;KeyT, ValueT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">mlir::DenseMap</a> = typedef <a class="el" href="classllvm_1_1DenseMap.html">llvm::DenseMap</a>&lt;KeyT, ValueT, KeyInfoT, BucketT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00126">126</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a087da824f0d25f4e19913ab4f2688c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087da824f0d25f4e19913ab4f2688c7b">&#9670;&nbsp;</a></span>DenseMapInfo</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Enable  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a087da824f0d25f4e19913ab4f2688c7b">DenseMapInfo</a>&lt; <a class="el" href="classmlir_1_1RegisteredOperationName.html">mlir::RegisteredOperationName</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00122">122</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a6841368c88bd98143c5b7fc3174fc663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6841368c88bd98143c5b7fc3174fc663">&#9670;&nbsp;</a></span>DenseResourceElementsHandle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a6841368c88bd98143c5b7fc3174fc663">mlir::DenseResourceElementsHandle</a> = typedef <a class="el" href="structmlir_1_1DialectResourceBlobHandle.html">DialectResourceBlobHandle</a>&lt;BuiltinDialect&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00702">702</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a59d6aae8a616cd9d13c8b1edb1095948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d6aae8a616cd9d13c8b1edb1095948">&#9670;&nbsp;</a></span>DenseSet</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , typename ValueInfoT  = DenseMapInfo&lt;ValueT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">mlir::DenseSet</a> = typedef <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt;ValueT, ValueInfoT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00128">128</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a9d38dcceb11bdea46ed3a87eae2c0e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d38dcceb11bdea46ed3a87eae2c0e4e">&#9670;&nbsp;</a></span>DenseUI16ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a9d38dcceb11bdea46ed3a87eae2c0e4e">mlir::DenseUI16ResourceElementsAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt;uint16_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00827">827</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="ad62ce2fff3156992f2755bc853f1f85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62ce2fff3156992f2755bc853f1f85f">&#9670;&nbsp;</a></span>DenseUI32ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ad62ce2fff3156992f2755bc853f1f85f">mlir::DenseUI32ResourceElementsAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt;uint32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00829">829</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="aac2b788b2acc9e11d299d1bdfc6ab941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2b788b2acc9e11d299d1bdfc6ab941">&#9670;&nbsp;</a></span>DenseUI64ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aac2b788b2acc9e11d299d1bdfc6ab941">mlir::DenseUI64ResourceElementsAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt;uint64_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00831">831</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a0be9cf4f237c5eb1d4ae5ceedca018e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be9cf4f237c5eb1d4ae5ceedca018e8">&#9670;&nbsp;</a></span>DenseUI8ResourceElementsAttr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a0be9cf4f237c5eb1d4ae5ceedca018e8">mlir::DenseUI8ResourceElementsAttr</a> = typedef <a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">detail::DenseResourceElementsAttrBase</a>&lt;uint8_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00825">825</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="acefb76d43733fcaa50b62e0962d9c463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acefb76d43733fcaa50b62e0962d9c463">&#9670;&nbsp;</a></span>DeviceIDTargetDeviceSpecPair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#acefb76d43733fcaa50b62e0962d9c463">mlir::DeviceIDTargetDeviceSpecPair</a> = typedef std::pair&lt;StringAttr, TargetDeviceSpecInterface&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8h_source.html#l00035">35</a> of file <a class="el" href="DataLayoutInterfaces_8h_source.html">DataLayoutInterfaces.h</a>.</p>

</div>
</div>
<a id="ac52075acbb1e5eb0da479dc2b7d864a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52075acbb1e5eb0da479dc2b7d864a4">&#9670;&nbsp;</a></span>DeviceIDTargetDeviceSpecPairListRef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ac52075acbb1e5eb0da479dc2b7d864a4">mlir::DeviceIDTargetDeviceSpecPairListRef</a> = typedef <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt;<a class="el" href="namespacemlir.html#acefb76d43733fcaa50b62e0962d9c463">DeviceIDTargetDeviceSpecPair</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8h_source.html#l00037">37</a> of file <a class="el" href="DataLayoutInterfaces_8h_source.html">DataLayoutInterfaces.h</a>.</p>

</div>
</div>
<a id="a2e943fa4f63d44d69d846e504c16d5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e943fa4f63d44d69d846e504c16d5f6">&#9670;&nbsp;</a></span>DialectAllocatorFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a2e943fa4f63d44d69d846e504c16d5f6">mlir::DialectAllocatorFunction</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1Dialect.html">Dialect</a> *(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectRegistry_8h_source.html#l00027">27</a> of file <a class="el" href="DialectRegistry_8h_source.html">DialectRegistry.h</a>.</p>

</div>
</div>
<a id="a6ffd752ab3a9dd88587958c328e34e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffd752ab3a9dd88587958c328e34e70">&#9670;&nbsp;</a></span>DialectAllocatorFunctionRef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a6ffd752ab3a9dd88587958c328e34e70">mlir::DialectAllocatorFunctionRef</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;<a class="el" href="classmlir_1_1Dialect.html">Dialect</a> *(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectRegistry_8h_source.html#l00028">28</a> of file <a class="el" href="DialectRegistry_8h_source.html">DialectRegistry.h</a>.</p>

</div>
</div>
<a id="a4308db4537fab4bd6031bf3ba2206525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4308db4537fab4bd6031bf3ba2206525">&#9670;&nbsp;</a></span>DialectRegistrationFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a4308db4537fab4bd6031bf3ba2206525">mlir::DialectRegistrationFunction</a> = typedef std::function&lt;void(<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that adds all dialects and dialect extensions used for the translation to the given <a class="el" href="classmlir_1_1DialectRegistry.html" title="The DialectRegistry maps a dialect namespace to a constructor for the matching dialect.">DialectRegistry</a>. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00057">57</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="aedbc3d0362a57c5175f05dd95fb59641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedbc3d0362a57c5175f05dd95fb59641">&#9670;&nbsp;</a></span>DominanceInfoNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aedbc3d0362a57c5175f05dd95fb59641">mlir::DominanceInfoNode</a> = typedef llvm::DomTreeNodeBase&lt;<a class="el" href="classmlir_1_1Block.html">Block</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dominance_8h_source.html#l00030">30</a> of file <a class="el" href="Dominance_8h_source.html">Dominance.h</a>.</p>

</div>
</div>
<a id="a226a6f936696eac398cee8be0368046b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226a6f936696eac398cee8be0368046b">&#9670;&nbsp;</a></span>DynamicDialectPopulationFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a226a6f936696eac398cee8be0368046b">mlir::DynamicDialectPopulationFunction</a> = typedef std::function&lt;void(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *, <a class="el" href="classmlir_1_1DynamicDialect.html">DynamicDialect</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectRegistry_8h_source.html#l00029">29</a> of file <a class="el" href="DialectRegistry_8h_source.html">DialectRegistry.h</a>.</p>

</div>
</div>
<a id="ae076c6e0e79ca32d89266007db06f358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae076c6e0e79ca32d89266007db06f358">&#9670;&nbsp;</a></span>ElementWiseVisitor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ae076c6e0e79ca32d89266007db06f358">mlir::ElementWiseVisitor</a> = typedef <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;void(T &amp;ptr, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;int64_t&gt;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient callback to "visit" a memref element by element. </p>
<p>This takes a reference to an individual element as well as the coordinates. It can be used in conjuction with a <a class="el" href="classStridedMemrefIterator.html" title="Iterate over all elements in a strided memref.">StridedMemrefIterator</a>. </p>

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00130">130</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

</div>
</div>
<a id="a5bbb33912ce41da593598188d8bcc13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbb33912ce41da593598188d8bcc13a">&#9670;&nbsp;</a></span>ForwardSliceOptions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a5bbb33912ce41da593598188d8bcc13a">mlir::ForwardSliceOptions</a> = typedef <a class="el" href="structmlir_1_1SliceOptions.html">SliceOptions</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8h_source.html#l00052">52</a> of file <a class="el" href="SliceAnalysis_8h_source.html">SliceAnalysis.h</a>.</p>

</div>
</div>
<a id="a0bff6226b7c81b6134b8c1130403a172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bff6226b7c81b6134b8c1130403a172">&#9670;&nbsp;</a></span>function_ref</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">mlir::function_ref</a> = typedef <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;Fn&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00152">152</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a3ff1d39837ac221ad45acd865c73c83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff1d39837ac221ad45acd865c73c83e">&#9670;&nbsp;</a></span>GenFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a3ff1d39837ac221ad45acd865c73c83e">mlir::GenFunction</a> = typedef std::function&lt;bool(const llvm::RecordKeeper &amp;records, raw_ostream &amp;os)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generator function to invoke. </p>

<p class="definition">Definition at line <a class="el" href="GenInfo_8h_source.html#l00024">24</a> of file <a class="el" href="GenInfo_8h_source.html">GenInfo.h</a>.</p>

</div>
</div>
<a id="ad5c8735b67af7a64e4deff16477a06eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c8735b67af7a64e4deff16477a06eb">&#9670;&nbsp;</a></span>Loops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">mlir::Loops</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;scf::ForOp, 8&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile a nest of standard for loops rooted at <code>rootForOp</code> by finding such parametric tile sizes that the outer loops have a fixed number of iterations as defined in <code>sizes</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html#l00144">144</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a594a45ae9aa1ccffd960f369da94d156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594a45ae9aa1ccffd960f369da94d156">&#9670;&nbsp;</a></span>LoweringCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a594a45ae9aa1ccffd960f369da94d156">mlir::LoweringCallback</a> = typedef std::function&lt;std::unique_ptr&lt;llvm::Module&gt;( <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, llvm::LLVMContext &amp;, StringRef)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GPUCommonPass_8h_source.html#l00048">48</a> of file <a class="el" href="GPUCommonPass_8h_source.html">GPUCommonPass.h</a>.</p>

</div>
</div>
<a id="a2cc8d74e74ce84649cf5ee6135cd09a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc8d74e74ce84649cf5ee6135cd09a4">&#9670;&nbsp;</a></span>MemorySpaceMapping</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a2cc8d74e74ce84649cf5ee6135cd09a4">mlir::MemorySpaceMapping</a> = typedef std::function&lt;unsigned(gpu::AddressSpace)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that maps a MemorySpace enum to a target-specific integer value. </p>

<p class="definition">Definition at line <a class="el" href="GPUCommonPass_8h_source.html#l00070">70</a> of file <a class="el" href="GPUCommonPass_8h_source.html">GPUCommonPass.h</a>.</p>

</div>
</div>
<a id="a7f8ab57590177d757d89848504dd7c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f8ab57590177d757d89848504dd7c5f">&#9670;&nbsp;</a></span>MemrefValue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a7f8ab57590177d757d89848504dd7c5f">mlir::MemrefValue</a> = typedef <a class="el" href="namespacemlir.html#a39768b5816332d4970911da09de5cec4">TypedValue</a>&lt;<a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A value with a memref type. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Utils_2MemRefUtils_8h_source.html#l00026">26</a> of file <a class="el" href="Dialect_2MemRef_2Utils_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

</div>
</div>
<a id="a70a2f522a6f1ebf6ac3b3ba85a12b9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a2f522a6f1ebf6ac3b3ba85a12b9e4">&#9670;&nbsp;</a></span>NewYieldValuesFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a70a2f522a6f1ebf6ac3b3ba85a12b9e4">mlir::NewYieldValuesFn</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;( <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a>&gt; newBbArgs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that returns the additional yielded values during <code>replaceWithAdditionalYields</code>. </p>
<p><code>newBbArgs</code> are the newly added region iter_args. This function should return as many values as there are block arguments in <code>newBbArgs</code>. </p>

<p class="definition">Definition at line <a class="el" href="LoopLikeInterface_8h_source.html#l00025">25</a> of file <a class="el" href="LoopLikeInterface_8h_source.html">LoopLikeInterface.h</a>.</p>

</div>
</div>
<a id="af2d45da2e2b2d5f705d618b778e36d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d45da2e2b2d5f705d618b778e36d52">&#9670;&nbsp;</a></span>OpAsmSetBlockNameFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#af2d45da2e2b2d5f705d618b778e36d52">mlir::OpAsmSetBlockNameFn</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;void(<a class="el" href="classmlir_1_1Block.html">Block</a> *, StringRef)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A functor used to set the name of blocks in regions directly nested under an operation. </p>

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l01733">1733</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="ab0887111bf825d1f766ef9e0911394d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0887111bf825d1f766ef9e0911394d5">&#9670;&nbsp;</a></span>OpAsmSetValueNameFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ab0887111bf825d1f766ef9e0911394d5">mlir::OpAsmSetValueNameFn</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;void(<a class="el" href="classmlir_1_1Value.html">Value</a>, StringRef)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A functor used to set the name of the start of a result group of an operation. </p>
<p>See 'getAsmResultNames' below for more details. </p>

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l01729">1729</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a3789e28c54bcaf5d2c3baf5f99eb615f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3789e28c54bcaf5d2c3baf5f99eb615f">&#9670;&nbsp;</a></span>OperandElementTypeRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a3789e28c54bcaf5d2c3baf5f99eb615f">mlir::OperandElementTypeRange</a> = typedef <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt;<a class="el" href="classmlir_1_1OperandElementTypeIterator.html">OperandElementTypeIterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8h_source.html#l00097">97</a> of file <a class="el" href="TypeUtilities_8h_source.html">TypeUtilities.h</a>.</p>

</div>
</div>
<a id="a48db7fd5d49bfa7ca8c81e5a6a058683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48db7fd5d49bfa7ca8c81e5a6a058683">&#9670;&nbsp;</a></span>PassAllocatorFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a48db7fd5d49bfa7ca8c81e5a6a058683">mlir::PassAllocatorFunction</a> = typedef std::function&lt;std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">Pass</a>&gt;()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PassRegistry_8h_source.html#l00041">41</a> of file <a class="el" href="PassRegistry_8h_source.html">PassRegistry.h</a>.</p>

</div>
</div>
<a id="aa22124ccf5219095aee552486366ccc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22124ccf5219095aee552486366ccc0">&#9670;&nbsp;</a></span>PassPipelineFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aa22124ccf5219095aee552486366ccc0">mlir::PassPipelineFn</a> = typedef <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;LogicalResult(<a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;pm)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This defines the function type used to setup the pass manager. </p>
<p>This can be used to pass in a callback to setup a default pass pipeline to be applied on the loaded IR. </p>

<p class="definition">Definition at line <a class="el" href="MlirOptMain_8h_source.html#l00265">265</a> of file <a class="el" href="MlirOptMain_8h_source.html">MlirOptMain.h</a>.</p>

</div>
</div>
<a id="af4ccb1e7accf2ec0c57b1aea967ccd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ccb1e7accf2ec0c57b1aea967ccd02">&#9670;&nbsp;</a></span>PassRegistryFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#af4ccb1e7accf2ec0c57b1aea967ccd02">mlir::PassRegistryFunction</a> = typedef std::function&lt;LogicalResult( <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;, StringRef <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;LogicalResult(const Twine &amp;)&gt; errorHandler)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A registry function that adds passes to the given pass manager. </p>
<p>This should also parse options and return success() if parsing succeeded. <code>errorHandler</code> is a functor used to emit errors during parsing. parameter corresponds to the raw location within the pipeline string. This should always return failure. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8h_source.html#l00038">38</a> of file <a class="el" href="PassRegistry_8h_source.html">PassRegistry.h</a>.</p>

</div>
</div>
<a id="ae5cf0e24a954fa30fb469105d4ca5dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5cf0e24a954fa30fb469105d4ca5dd8">&#9670;&nbsp;</a></span>ReassociationExprs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ae5cf0e24a954fa30fb469105d4ca5dd8">mlir::ReassociationExprs</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00028">28</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

</div>
</div>
<a id="af66e7b63d5fa8a2a0339c23648a51fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66e7b63d5fa8a2a0339c23648a51fbe">&#9670;&nbsp;</a></span>ReassociationIndices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 2 &gt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">mlir::ReassociationIndices</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8h_source.html#l00027">27</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a7ed845b40509fa999492a04654211321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed845b40509fa999492a04654211321">&#9670;&nbsp;</a></span>ReassociationIndicesRef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a7ed845b40509fa999492a04654211321">mlir::ReassociationIndicesRef</a> = typedef <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;int64_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00027">27</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

</div>
</div>
<a id="a0a5ee68dc80640e6ac9c4a6011d18bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5ee68dc80640e6ac9c4a6011d18bc1">&#9670;&nbsp;</a></span>ReifiedRankedShapedTypeDims</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a0a5ee68dc80640e6ac9c4a6011d18bc1">mlir::ReifiedRankedShapedTypeDims</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InferTypeOpInterface_8h_source.html#l00029">29</a> of file <a class="el" href="InferTypeOpInterface_8h_source.html">InferTypeOpInterface.h</a>.</p>

</div>
</div>
<a id="a52947e76a1893a1429c9219d1c96fd20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52947e76a1893a1429c9219d1c96fd20">&#9670;&nbsp;</a></span>ReproducerStreamFactory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a52947e76a1893a1429c9219d1c96fd20">mlir::ReproducerStreamFactory</a> = typedef std::function&lt;std::unique_ptr&lt;<a class="el" href="structmlir_1_1ReproducerStream.html">ReproducerStream</a>&gt;(std::string &amp;error)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method type for constructing <a class="el" href="structmlir_1_1ReproducerStream.html" title="Streams on which to output crash reproducer.">ReproducerStream</a>. </p>

<p class="definition">Definition at line <a class="el" href="PassManager_8h_source.html#l00221">221</a> of file <a class="el" href="PassManager_8h_source.html">PassManager.h</a>.</p>

</div>
</div>
<a id="a253b95ef2aaf79bdc612ae40fddc0732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253b95ef2aaf79bdc612ae40fddc0732">&#9670;&nbsp;</a></span>ResultElementTypeRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a253b95ef2aaf79bdc612ae40fddc0732">mlir::ResultElementTypeRange</a> = typedef <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt;<a class="el" href="classmlir_1_1ResultElementTypeIterator.html">ResultElementTypeIterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8h_source.html#l00110">110</a> of file <a class="el" href="TypeUtilities_8h_source.html">TypeUtilities.h</a>.</p>

</div>
</div>
<a id="a426e7736067d3718883782ec71f12d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426e7736067d3718883782ec71f12d49">&#9670;&nbsp;</a></span>SetIntLatticeFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a426e7736067d3718883782ec71f12d49">mlir::SetIntLatticeFn</a> = typedef <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;void(<a class="el" href="classmlir_1_1Value.html">Value</a>, const <a class="el" href="classmlir_1_1IntegerValueRange.html">IntegerValueRange</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to SetIntRangeFn, but operating on <a class="el" href="classmlir_1_1IntegerValueRange.html" title="This lattice value represents the integer range of an SSA value.">IntegerValueRange</a> lattice values. </p>
<p>This is the <code>setResultRanges</code> callback for the <a class="el" href="classmlir_1_1IntegerValueRange.html" title="This lattice value represents the integer range of an SSA value.">IntegerValueRange</a> based interface method. </p>

<p class="definition">Definition at line <a class="el" href="InferIntRangeInterface_8h_source.html#l00167">167</a> of file <a class="el" href="InferIntRangeInterface_8h_source.html">InferIntRangeInterface.h</a>.</p>

</div>
</div>
<a id="abf5c1ae42afa0427a3f833888eef1a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5c1ae42afa0427a3f833888eef1a97">&#9670;&nbsp;</a></span>SetIntRangeFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#abf5c1ae42afa0427a3f833888eef1a97">mlir::SetIntRangeFn</a> = typedef <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;void(<a class="el" href="classmlir_1_1Value.html">Value</a>, const <a class="el" href="classmlir_1_1ConstantIntRanges.html">ConstantIntRanges</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the <code>setResultRanges</code> callback provided to ops implementing InferIntRangeInterface. </p>
<p>It should be called once for each integer result value and be passed the <a class="el" href="classmlir_1_1ConstantIntRanges.html" title="A set of arbitrary-precision integers representing bounds on a given integer value.">ConstantIntRanges</a> corresponding to that value. </p>

<p class="definition">Definition at line <a class="el" href="InferIntRangeInterface_8h_source.html#l00161">161</a> of file <a class="el" href="InferIntRangeInterface_8h_source.html">InferIntRangeInterface.h</a>.</p>

</div>
</div>
<a id="a1ee6ce60684197b50504a1df1f9214f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee6ce60684197b50504a1df1f9214f2">&#9670;&nbsp;</a></span>SetVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Vector  = llvm::SmallVector&lt;T, 0&gt;, typename Set  = DenseSet&lt;T&gt;, unsigned N = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">mlir::SetVector</a> = typedef <a class="el" href="classllvm_1_1SetVector.html">llvm::SetVector</a>&lt;T, <a class="el" href="structVector.html">Vector</a>, Set, N&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00131">131</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="ac2b3592ab67f8512cb18e62375d7ff4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b3592ab67f8512cb18e62375d7ff4b">&#9670;&nbsp;</a></span>StringSet</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorTy  = llvm::MallocAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ac2b3592ab67f8512cb18e62375d7ff4b">mlir::StringSet</a> = typedef <a class="el" href="classllvm_1_1StringSet.html">llvm::StringSet</a>&lt;AllocatorTy&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00133">133</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="ac474b9f30a56412e090d9919e4dd8b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac474b9f30a56412e090d9919e4dd8b34">&#9670;&nbsp;</a></span>StringSwitch</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ac474b9f30a56412e090d9919e4dd8b34">mlir::StringSwitch</a> = typedef <a class="el" href="classllvm_1_1StringSwitch.html">llvm::StringSwitch</a>&lt;T, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00141">141</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="aa90f8dcaf13650935b7e9a32ccf0c055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90f8dcaf13650935b7e9a32ccf0c055">&#9670;&nbsp;</a></span>TargetDeviceSpecListRef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aa90f8dcaf13650935b7e9a32ccf0c055">mlir::TargetDeviceSpecListRef</a> = typedef <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt;TargetDeviceSpecInterface&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8h_source.html#l00034">34</a> of file <a class="el" href="DataLayoutInterfaces_8h_source.html">DataLayoutInterfaces.h</a>.</p>

</div>
</div>
<a id="a3f0d45d0562d47acc2c42934ccbfea19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0d45d0562d47acc2c42934ccbfea19">&#9670;&nbsp;</a></span>TileLoops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a3f0d45d0562d47acc2c42934ccbfea19">mlir::TileLoops</a> = typedef std::pair&lt;<a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>, <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html#l00145">145</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a2b41c5a75264460202bc6e5da0518c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b41c5a75264460202bc6e5da0518c15">&#9670;&nbsp;</a></span>TransitiveFilter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a2b41c5a75264460202bc6e5da0518c15">mlir::TransitiveFilter</a> = typedef <a class="el" href="structmlir_1_1SliceOptions.html#a667b0cbe189fd8ce9af2f0475a14b602">SliceOptions::TransitiveFilter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8h_source.html#l00041">41</a> of file <a class="el" href="SliceAnalysis_8h_source.html">SliceAnalysis.h</a>.</p>

</div>
</div>
<a id="a86f6096a57734eed0290d2ab34ad5e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f6096a57734eed0290d2ab34ad5e79">&#9670;&nbsp;</a></span>TranslateFromMLIRFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a86f6096a57734eed0290d2ab34ad5e79">mlir::TranslateFromMLIRFunction</a> = typedef std::function&lt;LogicalResult(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, llvm::raw_ostream &amp;output)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that translates MLIR to a different format and outputs the result to a stream. </p>
<p>It is allowed to modify the operation. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00043">43</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="a0a36971a2ce3497d801451c71cabd7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a36971a2ce3497d801451c71cabd7f0">&#9670;&nbsp;</a></span>TranslateFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a0a36971a2ce3497d801451c71cabd7f0">mlir::TranslateFunction</a> = typedef std::function&lt;LogicalResult( const std::shared_ptr&lt;llvm::SourceMgr&gt; &amp;sourceMgr, llvm::raw_ostream &amp;output, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that performs file-to-file translation involving MLIR. </p>
<p>The input file is held in the given MemoryBuffer; the output file should be written to the given raw_ostream. The implementation should create all MLIR constructs needed during the process inside the given context. This can be used for round-tripping external formats through the MLIR system. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00051">51</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="a2e66fd933b3c9e825ff92ccea2450120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e66fd933b3c9e825ff92ccea2450120">&#9670;&nbsp;</a></span>TranslateRawSourceMgrToMLIRFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a2e66fd933b3c9e825ff92ccea2450120">mlir::TranslateRawSourceMgrToMLIRFunction</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;(llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00030">30</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="ab2fc3e0eaaa708d4f579d33d914aafb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2fc3e0eaaa708d4f579d33d914aafb4">&#9670;&nbsp;</a></span>TranslateSourceMgrToMLIRFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ab2fc3e0eaaa708d4f579d33d914aafb4">mlir::TranslateSourceMgrToMLIRFunction</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;( const std::shared_ptr&lt;llvm::SourceMgr&gt; &amp;sourceMgr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that translates the sources managed by <code>sourceMgr</code> to MLIR. </p>
<p>The source manager has at least one buffer. The implementation should create a new MLIR <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> in the given context and return a pointer to it, or a nullptr in case of any error. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00028">28</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="a9e7afe9f2206cbd31d4c274a8a496fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7afe9f2206cbd31d4c274a8a496fcc">&#9670;&nbsp;</a></span>TranslateStringRefToMLIRFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a9e7afe9f2206cbd31d4c274a8a496fcc">mlir::TranslateStringRefToMLIRFunction</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;(llvm::StringRef, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that translates the given string to MLIR. </p>
<p>The implementation should create a new MLIR <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> in the given context. If source-related error reporting is required from within the function, use TranslateSourceMgrToMLIRFunction instead. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00038">38</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="a39768b5816332d4970911da09de5cec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39768b5816332d4970911da09de5cec4">&#9670;&nbsp;</a></span>TypedValue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ty , typename Value  = mlir::Value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a39768b5816332d4970911da09de5cec4">mlir::TypedValue</a> = typedef std::conditional_t&lt;std::is_same_v&lt;Ty, <a class="el" href="classmlir_1_1Type.html">mlir::Type</a>&gt;, <a class="el" href="classmlir_1_1Value.html">mlir::Value</a>, <a class="el" href="structmlir_1_1detail_1_1TypedValue.html">detail::TypedValue</a>&lt;Ty&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If Ty is <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">mlir::Type</a> this will select <code><a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a></code> instead of having a wrapper around it. </p>
<p>This helps resolve ambiguous conversion issues. </p>

<p class="definition">Definition at line <a class="el" href="Value_8h_source.html#l00497">497</a> of file <a class="el" href="Value_8h_source.html">Value.h</a>.</p>

</div>
</div>
<a id="a3bff85dd5cf397b62e521086d55e2d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bff85dd5cf397b62e521086d55e2d37">&#9670;&nbsp;</a></span>TypeRangeRangeIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a3bff85dd5cf397b62e521086d55e2d37">mlir::TypeRangeRangeIterator</a> = typedef llvm::mapped_iterator&lt;llvm::iota_range&lt;unsigned&gt;::iterator, std::function&lt;<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>(unsigned)&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeRange_8h_source.html#l00085">85</a> of file <a class="el" href="TypeRange_8h_source.html">TypeRange.h</a>.</p>

</div>
</div>
<a id="a01e9069ef9040ccc727d541c02d49ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e9069ef9040ccc727d541c02d49ecd">&#9670;&nbsp;</a></span>TypeStorageAllocator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a01e9069ef9040ccc727d541c02d49ecd">mlir::TypeStorageAllocator</a> = typedef <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a utility allocator used to allocate memory for instances of derived Types. </p>

<p class="definition">Definition at line <a class="el" href="TypeSupport_8h_source.html#l00202">202</a> of file <a class="el" href="TypeSupport_8h_source.html">TypeSupport.h</a>.</p>

</div>
</div>
<a id="a9cdd84a4516a711493014c535e027b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdd84a4516a711493014c535e027b86">&#9670;&nbsp;</a></span>TypeSubElementReplacements</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a9cdd84a4516a711493014c535e027b86">mlir::TypeSubElementReplacements</a> = typedef <a class="el" href="classmlir_1_1AttrTypeSubElementReplacements.html">AttrTypeSubElementReplacements</a>&lt;<a class="el" href="classmlir_1_1Type.html">Type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00374">374</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

</div>
</div>
<a id="abcf44d03780c99376ac0c1dd1caed0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf44d03780c99376ac0c1dd1caed0f4">&#9670;&nbsp;</a></span>TypeSwitch</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ResultT  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#abcf44d03780c99376ac0c1dd1caed0f4">mlir::TypeSwitch</a> = typedef <a class="el" href="classllvm_1_1TypeSwitch.html">llvm::TypeSwitch</a>&lt;T, ResultT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Support_2LLVM_8h_source.html#l00144">144</a> of file <a class="el" href="mlir_2Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a9c852d22f676b319b260b86ad21499ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c852d22f676b319b260b86ad21499ac">&#9670;&nbsp;</a></span>ValueDimList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a9c852d22f676b319b260b86ad21499ac">mlir::ValueDimList</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;std::pair&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, std::optional&lt;int64_t&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00051">51</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

</div>
</div>
<a id="afb40c25041db8d506e4b23fb8c86d5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb40c25041db8d506e4b23fb8c86d5c6">&#9670;&nbsp;</a></span>WalkCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#afb40c25041db8d506e4b23fb8c86d5c6">mlir::WalkCallback</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">mlir::function_ref</a>&lt;<a class="el" href="classmlir_1_1WalkContinuation.html">WalkContinuation</a>(<a class="el" href="classmlir_1_1Value.html">mlir::Value</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback that is invoked for each value encountered during the walk of the slice. </p>
<p>The callback takes the current value, and returns the walk continuation, which determines if the walk should proceed and if yes, with which values. </p>

<p class="definition">Definition at line <a class="el" href="SliceWalk_8h_source.html#l00081">81</a> of file <a class="el" href="SliceWalk_8h_source.html">SliceWalk.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a6d3b7fd763c24274db6c115579084133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3b7fd763c24274db6c115579084133">&#9670;&nbsp;</a></span>AffineExprKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">mlir::AffineExprKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133aec211f7c20af43e742bf2570c3cb84f9"></a>Add&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a62b6d55816cf737bfc6f42e60df1a3f2"></a>Mul&#160;</td><td class="fielddoc"><p>RHS of mul is always a constant or a symbolic expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a7aeb0277500c86e4aa6bd23f9a737942"></a>Mod&#160;</td><td class="fielddoc"><p>RHS of mod is always a constant or a symbolic expression with a positive value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133abaa422535e7ce48b442cc07089e64e7a"></a>FloorDiv&#160;</td><td class="fielddoc"><p>RHS of floordiv is always a constant or a symbolic expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a30c212eb3184a5ed41f01a25c8124e8a"></a>CeilDiv&#160;</td><td class="fielddoc"><p>RHS of ceildiv is always a constant or a symbolic expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a4be6ccd8c4af006587a76a5fd3e7dc24"></a>LAST_AFFINE_BINARY_OP&#160;</td><td class="fielddoc"><p>This is a marker for the last affine binary op. </p>
<p>The range of binary op's is expected to be this element and earlier. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255"></a>Constant&#160;</td><td class="fielddoc"><p>Constant integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133ab49b848e4bb608f4d5650e4b2817c641"></a>DimId&#160;</td><td class="fielddoc"><p>Dimensional identifier. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133aea00d3c6059a4ff11d351696747fc7ff"></a>SymbolId&#160;</td><td class="fielddoc"><p>Symbolic identifier. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00040">40</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

</div>
</div>
<a id="ac84871bcca0aaa0176d43dbdbffe9a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84871bcca0aaa0176d43dbdbffe9a6c">&#9670;&nbsp;</a></span>AsmResourceEntryKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#ac84871bcca0aaa0176d43dbdbffe9a6c">mlir::AsmResourceEntryKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This enum represents the different kinds of resource values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac84871bcca0aaa0176d43dbdbffe9a6cae8016c85ada38bdc5fac616ec1318047"></a>Blob&#160;</td><td class="fielddoc"><p>A blob of data with an accompanying alignment. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac84871bcca0aaa0176d43dbdbffe9a6cac26f15e86e3de4c398a8273272aba034"></a>Bool&#160;</td><td class="fielddoc"><p>A boolean value. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac84871bcca0aaa0176d43dbdbffe9a6ca27118326006d3829667a400ad23d5d98"></a>String&#160;</td><td class="fielddoc"><p>A string value. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="AsmState_8h_source.html#l00272">272</a> of file <a class="el" href="AsmState_8h_source.html">AsmState.h</a>.</p>

</div>
</div>
<a id="a2c02a386e5ba59c4c88f83ac471f999d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c02a386e5ba59c4c88f83ac471f999d">&#9670;&nbsp;</a></span>ChangeResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">mlir::ChangeResult</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A result type used to indicate if a change happened. </p>
<p>Boolean operations on ChangeResult behave as though <code>Change</code> is truth. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2c02a386e5ba59c4c88f83ac471f999da4bac8cdf0a968472b519b3b295d0d48b"></a>NoChange&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2c02a386e5ba59c4c88f83ac471f999daf4ec5f57bd4d31b803312d873be40da9"></a>Change&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="DataFlowFramework_8h_source.html#l00034">34</a> of file <a class="el" href="DataFlowFramework_8h_source.html">DataFlowFramework.h</a>.</p>

</div>
</div>
<a id="a98b49fcd2b613b6c30ffc13f35b8675c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b49fcd2b613b6c30ffc13f35b8675c">&#9670;&nbsp;</a></span>DeletionKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a98b49fcd2b613b6c30ffc13f35b8675c">mlir::DeletionKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returned by operation promotion logic requesting the deletion of an operation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a98b49fcd2b613b6c30ffc13f35b8675ca02bce93bff905887ad2233110bf9c49e"></a>Keep&#160;</td><td class="fielddoc"><p>Keep the operation after promotion. </p>
</td></tr>
<tr><td class="fieldname"><a id="a98b49fcd2b613b6c30ffc13f35b8675caf2a6c498fb90ee345d997f888fce3b18"></a>Delete&#160;</td><td class="fielddoc"><p>Delete the operation after promotion. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="MemorySlotInterfaces_8h_source.html#l00035">35</a> of file <a class="el" href="MemorySlotInterfaces_8h_source.html">MemorySlotInterfaces.h</a>.</p>

</div>
</div>
<a id="a247bc9a6d1f1577f2d876cb55e2ea752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247bc9a6d1f1577f2d876cb55e2ea752">&#9670;&nbsp;</a></span>DiagnosticSeverity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752">mlir::DiagnosticSeverity</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines the different supported severity of a diagnostic. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a3b0649c72650c313a357338dcdfb64ec"></a>Note&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a0eaadb4fcb48a0a0ed7bc9868be9fbaa"></a>Warning&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd"></a>Error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a91921ada405fd6ba65dff028df047cb6"></a>Remark&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00040">40</a> of file <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

</div>
</div>
<a id="acbb0dcd5ae75936e3c6f177223c9d5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb0dcd5ae75936e3c6f177223c9d5eb">&#9670;&nbsp;</a></span>GreedyRewriteStrictness</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#acbb0dcd5ae75936e3c6f177223c9d5eb">mlir::GreedyRewriteStrictness</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This enum controls which ops are put on the worklist during a greedy pattern rewrite. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acbb0dcd5ae75936e3c6f177223c9d5eba97d3def284d4e3d3bef99205c339fceb"></a>AnyOp&#160;</td><td class="fielddoc"><p>No restrictions wrt. which ops are processed. </p>
</td></tr>
<tr><td class="fieldname"><a id="acbb0dcd5ae75936e3c6f177223c9d5eba8fc95fc7cfbd316cce7d887ab38f6120"></a>ExistingAndNewOps&#160;</td><td class="fielddoc"><p>Only pre-existing and newly created ops are processed. </p>
</td></tr>
<tr><td class="fieldname"><a id="acbb0dcd5ae75936e3c6f177223c9d5eba475f4ba4004dc37c3764009114b6e69b"></a>ExistingOps&#160;</td><td class="fielddoc"><p>Only pre-existing ops are processed. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00023">23</a> of file <a class="el" href="GreedyPatternRewriteDriver_8h_source.html">GreedyPatternRewriteDriver.h</a>.</p>

</div>
</div>
<a id="a2aef2e1e7dac5cf18273429ca58e3f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aef2e1e7dac5cf18273429ca58e3f4f">&#9670;&nbsp;</a></span>GreedySimplifyRegionLevel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a2aef2e1e7dac5cf18273429ca58e3f4f">mlir::GreedySimplifyRegionLevel</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2aef2e1e7dac5cf18273429ca58e3f4fab9f5c797ebbf55adccdd8539a65a0241"></a>Disabled&#160;</td><td class="fielddoc"><p>Disable region control-flow simplification. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2aef2e1e7dac5cf18273429ca58e3f4fa960b44c579bc2f6818d2daaf9e4c16f0"></a>Normal&#160;</td><td class="fielddoc"><p>Run the normal simplification (e.g. dead args elimination). </p>
</td></tr>
<tr><td class="fieldname"><a id="a2aef2e1e7dac5cf18273429ca58e3f4fa389a96d0d9b3feb46b8c9d941566a4ae"></a>Aggressive&#160;</td><td class="fielddoc"><p>Run extra simplificiations (e.g. </p>
<p>block merging), these can be more costly or have some tradeoffs associated. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00032">32</a> of file <a class="el" href="GreedyPatternRewriteDriver_8h_source.html">GreedyPatternRewriteDriver.h</a>.</p>

</div>
</div>
<a id="a6e07796c43d9bdf22c519ff44150daaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e07796c43d9bdf22c519ff44150daaf">&#9670;&nbsp;</a></span>HoistingKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a6e07796c43d9bdf22c519ff44150daaf">mlir::HoistingKind</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6e07796c43d9bdf22c519ff44150daafa6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6e07796c43d9bdf22c519ff44150daafa89d7b10cb4238977d2b523dfd9ea7745"></a>Loop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6e07796c43d9bdf22c519ff44150daafae1e4c8c9ccd9fc39c391da4bcd093fb2"></a>Block&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="AllocationOpInterface_8h_source.html#l00021">21</a> of file <a class="el" href="AllocationOpInterface_8h_source.html">AllocationOpInterface.h</a>.</p>

</div>
</div>
<a id="ab64460ede39d8480e398fd2e6810d95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64460ede39d8480e398fd2e6810d95b">&#9670;&nbsp;</a></span>PassDisplayMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95b">mlir::PassDisplayMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enum describing the different display modes for the information within the pass manager. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab64460ede39d8480e398fd2e6810d95ba4ee29ca12c7d126654bd0e5275de6135"></a>List&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab64460ede39d8480e398fd2e6810d95baaeaeaec51b4e6b88122f10ad96a8de72"></a>Pipeline&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="PassManager_8h_source.html#l00198">198</a> of file <a class="el" href="PassManager_8h_source.html">PassManager.h</a>.</p>

</div>
</div>
<a id="abeb30aa1b062bf437bf3ea2b843a2ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb30aa1b062bf437bf3ea2b843a2ae1">&#9670;&nbsp;</a></span>RegionKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#abeb30aa1b062bf437bf3ea2b843a2ae1">mlir::RegionKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The kinds of regions contained in an operation. </p>
<p>SSACFG regions require the SSA-Dominance property to hold. Graph regions do not require SSA-Dominance. If a registered operation does not implement RegionKindInterface, then any regions it contains are assumed to be SSACFG regions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abeb30aa1b062bf437bf3ea2b843a2ae1abfd486e5c2cad6a0ba13ec4e1951815b"></a>SSACFG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abeb30aa1b062bf437bf3ea2b843a2ae1a4cdbd2bafa8193091ba09509cedf94fd"></a>Graph&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="RegionKindInterface_8h_source.html#l00026">26</a> of file <a class="el" href="RegionKindInterface_8h_source.html">RegionKindInterface.h</a>.</p>

</div>
</div>
<a id="a855a7d93430958efaaf3a6f69e3dac1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855a7d93430958efaaf3a6f69e3dac1c">&#9670;&nbsp;</a></span>ReinterpretMapScope</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a855a7d93430958efaaf3a6f69e3dac1c">mlir::ReinterpretMapScope</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a scope for reinterpret map pass. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a855a7d93430958efaaf3a6f69e3dac1ca34bdbffdb1c0e1b603f58fc0d49548b6"></a>kAll&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a855a7d93430958efaaf3a6f69e3dac1cafb396f5b35d10c817b375435e3432d4b"></a>kGenericOnly&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a855a7d93430958efaaf3a6f69e3dac1ca301ae8b60ff2983a1038cc11eb53089b"></a>kExceptGeneric&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l00045">45</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ade54ec9589eb0733abcaed08e634be01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade54ec9589eb0733abcaed08e634be01">&#9670;&nbsp;</a></span>ReshapeOpKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#ade54ec9589eb0733abcaed08e634be01">mlir::ReshapeOpKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ade54ec9589eb0733abcaed08e634be01a95e20eb827cd738ef3a2b9551135da09"></a>kExpand&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ade54ec9589eb0733abcaed08e634be01a76fd6a1e50a2e2a0b5579d446b01a5da"></a>kCollapse&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00184">184</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

</div>
</div>
<a id="a11353e6611651b85531ad95629c57d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11353e6611651b85531ad95629c57d75">&#9670;&nbsp;</a></span>SliceVerificationResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">mlir::SliceVerificationResult</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum that captures information related to verifier error conditions on slice insert/extract type of ops. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a505a83f220c02df2f85c3810cd9ceb38"></a>Success&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a780dd32ee9af184442cea3f2a2a75271"></a>RankTooLarge&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a87c69361ccd090c9c844e19d08432a26"></a>SizeMismatch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a6341e1bfc09d56fa49bb1b9400459d8e"></a>ElemTypeMismatch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a36a2220daadd84aaba239b031cf4cd23"></a>MemSpaceMismatch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a36297823a9892f9936fba1805a1c52ca"></a>LayoutMismatch&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00387">387</a> of file <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html">BuiltinTypes.h</a>.</p>

</div>
</div>
<a id="a90f3feaa61d2ade78f26489cc92061c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f3feaa61d2ade78f26489cc92061c9">&#9670;&nbsp;</a></span>SparseEmitStrategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a90f3feaa61d2ade78f26489cc92061c9">mlir::SparseEmitStrategy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a scope for reinterpret map pass. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a90f3feaa61d2ade78f26489cc92061c9a2396498c3d09ffee6d390b4dc4939025"></a>kFunctional&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a90f3feaa61d2ade78f26489cc92061c9a6a8bfeffa090dea6b9365e13b07de8f5"></a>kSparseIterator&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a90f3feaa61d2ade78f26489cc92061c9a1f8ee8266ac6831bf04f91a30d755554"></a>kDebugInterface&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l00052">52</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a781474aef998ccce168b69ae973cd832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781474aef998ccce168b69ae973cd832">&#9670;&nbsp;</a></span>SparseParallelizationStrategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832">mlir::SparseParallelizationStrategy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a parallelization strategy. </p>
<p>Any independent loop is a candidate for parallelization. The loop is made parallel if (1) allowed by the strategy (e.g., AnyStorageOuterLoop considers either a dense or sparse outermost loop only), and (2) the generated code is an actual for-loop (and not a co-iterating while-loop). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a781474aef998ccce168b69ae973cd832a35c3ace1970663a16e5c65baa5941b13"></a>kNone&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a781474aef998ccce168b69ae973cd832a09e4a3d1c3e70c9426528f102480e6e7"></a>kDenseOuterLoop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a781474aef998ccce168b69ae973cd832afe3590ad05890d8754eef93504f9b7af"></a>kAnyStorageOuterLoop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a781474aef998ccce168b69ae973cd832a0d7778373362fd80feddcb9b38a354b8"></a>kDenseAnyLoop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a781474aef998ccce168b69ae973cd832a3b1257bf6747bc07f90c215e9aafd4a7"></a>kAnyStorageAnyLoop&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l00036">36</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a399e164b35d18e1a77053d39719844de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399e164b35d18e1a77053d39719844de">&#9670;&nbsp;</a></span>SPIRVSubByteTypeStorage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a399e164b35d18e1a77053d39719844de">mlir::SPIRVSubByteTypeStorage</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How sub-byte values are storaged in memory. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a399e164b35d18e1a77053d39719844deaa1977c3f68d4d3bbfe14d0e51a575482"></a>Packed&#160;</td><td class="fielddoc"><p>Sub-byte values are tightly packed without any padding, e.g., 4xi2 -&gt; i8. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8h_source.html#l00034">34</a> of file <a class="el" href="SPIRVConversion_8h_source.html">SPIRVConversion.h</a>.</p>

</div>
</div>
<a id="a9e4d5a3d224089fd8a2ebc3e933d08b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4d5a3d224089fd8a2ebc3e933d08b5">&#9670;&nbsp;</a></span>TraversalMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5">mlir::TraversalMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the traversal method options to be used in the reduction tree traversal. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9e4d5a3d224089fd8a2ebc3e933d08b5ab8166871d66f03feaa6948b3f5727c96"></a>SinglePath&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9e4d5a3d224089fd8a2ebc3e933d08b5ad4f6ed581fb2f9d06c062711e30c13e1"></a>Backtrack&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9e4d5a3d224089fd8a2ebc3e933d08b5a9addc7d66f740728689b7f9abde66593"></a>MultiPath&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ReductionNode_8h_source.html#l00036">36</a> of file <a class="el" href="ReductionNode_8h_source.html">ReductionNode.h</a>.</p>

</div>
</div>
<a id="a59fa9dd53c74f1ca73aa7ef263c94adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59fa9dd53c74f1ca73aa7ef263c94adc">&#9670;&nbsp;</a></span>WalkOrder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">mlir::WalkOrder</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traversal order for region, block and operation walk utilities. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc"></a>PreOrder&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163"></a>PostOrder&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00062">62</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a51a6eaafe741bc1b5aaef4e3e188e868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a6eaafe741bc1b5aaef4e3e188e868">&#9670;&nbsp;</a></span>addressSpaceToStorageClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spirv::StorageClass mlir::addressSpaceToStorageClass </td>
          <td>(</td>
          <td class="paramtype">gpu::AddressSpace&#160;</td>
          <td class="paramname"><em>addressSpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttrToSPIRVConverter_8cpp_source.html#l00012">12</a> of file <a class="el" href="AttrToSPIRVConverter_8cpp_source.html">AttrToSPIRVConverter.cpp</a>.</p>

</div>
</div>
<a id="a5bcc9dc786aa8f64a60f1d51cdad3361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bcc9dc786aa8f64a60f1d51cdad3361">&#9670;&nbsp;</a></span>alignAffineMapWithValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::alignAffineMapWithValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>syms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>newSyms</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-indexes the dimensions and symbols of an affine map with given <code>operands</code> values to align with <code>dims</code> and <code>syms</code> values. </p>
<p>Each dimension/symbol of the map, bound to an operand <code>o</code>, is replaced with dimension <code>i</code>, where <code>i</code> is the position of <code>o</code> within <code>dims</code>. If <code>o</code> is not in <code>dims</code>, replace it with symbol <code>i</code>, where <code>i</code> is the position of <code>o</code> within <code>syms</code>. If <code>o</code> is not in <code>syms</code> either, replace it with a new symbol.</p>
<p>Note: If a value appears multiple times as a dimension/symbol (or both), all corresponding dim/sym expressions are replaced with the first dimension bound to that value (or first symbol if no such dimension exists).</p>
<p>The resulting affine map has <code>dims.size()</code> many dimensions and at least <code>syms.size()</code> many symbols.</p>
<p>The SSA values of the symbols of the resulting map are optionally returned via <code>newSyms</code>. This is a concatenation of <code>syms</code> with the SSA values of the newly added symbols.</p>
<p>Note: As part of this re-indexing, dimensions may turn into symbols, or vice versa. </p>

<p class="definition">Definition at line <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01260">1260</a> of file <a class="el" href="FlatLinearValueConstraints_8cpp_source.html">FlatLinearValueConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="Builders_8cpp_source.html#l00395">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00399">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00343">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00500">mlir::AffineMap::replaceDimsAndSymbols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02006">alignAndAddBound()</a>, and <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01140">mlir::FlatLinearValueConstraints::computeAlignedMap()</a>.</p>

</div>
</div>
<a id="aaf43b39cbc5116796f9b6550f99dee0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf43b39cbc5116796f9b6550f99dee0d">&#9670;&nbsp;</a></span>allOperandsHaveSameCoopMatrixType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::allOperandsHaveSameCoopMatrixType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html#l00085">85</a> of file <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html">WmmaOpsToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00129">mlir::Value::getType()</a>, and <a class="el" href="classmlir_1_1ValueRange.html#aafdd7203c9b5d449b1b1a3b647845cf2">mlir::ValueRange::getType()</a>.</p>

</div>
</div>
<a id="a906c1d91c48bb67c936b1cca34525b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906c1d91c48bb67c936b1cca34525b98">&#9670;&nbsp;</a></span>applyAnalysisConversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::applyAnalysisConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a>&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply an analysis conversion on the given operations, and all nested operations. </p>
<p>This method analyzes which operations would be successfully converted to the target if a conversion was applied. All operations that were found to be legalizable to the given 'target' are placed within the provided 'config.legalizableOps' set; note that no actual rewrites are applied to the operations on success. This method only returns failure if there are unreachable blocks in any of the regions nested within 'ops'. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03247">3247</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00717">mlir::Operation::clone()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03216">findCommonAncestor()</a>, <a class="el" href="IRMapping_8h_source.html#l00088">mlir::IRMapping::getOperationMap()</a>, and <a class="el" href="DialectConversion_8h_source.html#l01092">mlir::ConversionConfig::legalizableOps</a>.</p>

</div>
</div>
<a id="af7f5c95a994f04b659b630dbf0fc9134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f5c95a994f04b659b630dbf0fc9134">&#9670;&nbsp;</a></span>applyAnalysisConversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::applyAnalysisConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a>&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03286">3286</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

</div>
</div>
<a id="ab41920e66a206248f862766a705125d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41920e66a206248f862766a705125d1">&#9670;&nbsp;</a></span>applyDefaultTimingManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::applyDefaultTimingManagerCLOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DefaultTimingManager.html">DefaultTimingManager</a> &amp;&#160;</td>
          <td class="paramname"><em>tm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply any values that were registered with 'registerDefaultTimingManagerOptions' to a <code><a class="el" href="classmlir_1_1DefaultTimingManager.html" title="Facilities for time measurement and report printing to an output stream.">DefaultTimingManager</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="Timing_8cpp_source.html#l00619">619</a> of file <a class="el" href="Timing_8cpp_source.html">Timing.cpp</a>.</p>

<p class="reference">References <a class="el" href="Timing_8cpp_source.html#l00612">options</a>, <a class="el" href="Timing_8cpp_source.html#l00516">mlir::DefaultTimingManager::setDisplayMode()</a>, <a class="el" href="Timing_8cpp_source.html#l00510">mlir::DefaultTimingManager::setEnabled()</a>, and <a class="el" href="Timing_8cpp_source.html#l00526">mlir::DefaultTimingManager::setOutput()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassManagerOptions_8cpp_source.html#l00170">applyDefaultTimingPassManagerCLOptions()</a>, and <a class="el" href="MlirOptMain_8cpp_source.html#l00362">performActions()</a>.</p>

</div>
</div>
<a id="acd78ebb9f95cfe7ea3856d9f9c46d030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd78ebb9f95cfe7ea3856d9f9c46d030">&#9670;&nbsp;</a></span>applyDefaultTimingPassManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::applyDefaultTimingPassManagerCLOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply any values provided to the timing manager options that were registered with <code>registerDefaultTimingManagerOptions</code>. </p>
<p>This is a handy helper function if you do not want to bother creating your own timing manager and passing it to the pass manager. </p>

<p class="definition">Definition at line <a class="el" href="PassManagerOptions_8cpp_source.html#l00170">170</a> of file <a class="el" href="PassManagerOptions_8cpp_source.html">PassManagerOptions.cpp</a>.</p>

<p class="reference">References <a class="el" href="Timing_8cpp_source.html#l00619">applyDefaultTimingManagerCLOptions()</a>, and <a class="el" href="PassTiming_8cpp_source.html#l00148">mlir::PassManager::enableTiming()</a>.</p>

</div>
</div>
<a id="a5763e1af1116086ca3b5921ea2e3895b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5763e1af1116086ca3b5921ea2e3895b">&#9670;&nbsp;</a></span>applyFullConversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::applyFullConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a>&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a complete conversion on the given operations, and all nested operations. </p>
<p>This method returns failure if the conversion of any operation fails, or if there are unreachable blocks in any of the regions nested within 'ops'. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03195">3195</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02436">mlir::OperationConverter::convertOperations()</a>.</p>

</div>
</div>
<a id="a1d8530ef21d546fc07d7313b687ca89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8530ef21d546fc07d7313b687ca89f">&#9670;&nbsp;</a></span>applyFullConversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::applyFullConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a>&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03203">3203</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

</div>
</div>
<a id="a10b86ede77ff793a77a2f26ac8755313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b86ede77ff793a77a2f26ac8755313">&#9670;&nbsp;</a></span>applyOpPatternsAndFold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::applyOpPatternsAndFold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>changed</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>allErased</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the specified ops by repeatedly applying the highest benefit patterns in a greedy worklist driven manner until a fixpoint is reached. </p>
<p>The greedy rewrite may prematurely stop after a maximum number of iterations, which can be configured in the configuration parameter.</p>
<p>Also performs folding and simple dead-code elimination before attempting to match any of the provided patterns.</p>
<p>Newly created ops and other pre-existing ops that use results of rewritten ops or supply operands to such ops are also processed, unless such ops are excluded via <code>config.strictMode</code>. Any other ops remain unmodified (i.e., regardless of <code>strictMode</code>).</p>
<p>In addition to strictness, a region scope can be specified. Only ops within the scope are simplified. This is similar to <code>applyPatternsAndFoldGreedily</code>, where only ops within the given region/op are simplified by default. If no scope is specified, it is assumed to be the first common enclosing region of the given ops.</p>
<p>Note that ops in <code>ops</code> could be erased as result of folding, becoming dead, or via pattern rewrites. If more far reaching simplification is desired, <code>applyPatternsAndFoldGreedily</code> should be used.</p>
<p>Returns "success" if the iterative process converged (i.e., fixpoint was reached) and no more patterns can be matched. <code>changed</code> is set to "true" if the IR was modified at all. <code>allOpsErased</code> is set to "true" if all ops in <code>ops</code> were erased. </p>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l01015">1015</a> of file <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html">GreedyPatternRewriteDriver.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00990">findCommonAncestor()</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00078">mlir::GreedyRewriteConfig::scope</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00410">mlir::affine::hoistAffineIfOp()</a>.</p>

</div>
</div>
<a id="aecfc0e59e43a9e754aa5d70d91eb5a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecfc0e59e43a9e754aa5d70d91eb5a28">&#9670;&nbsp;</a></span>applyPartialConversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::applyPartialConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a>&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Below we define several entry points for operation conversion. </p>
<p>It is important to note that the patterns provided to the conversion framework may have additional constraints. See the <code><a class="el" href="classmlir_1_1PatternRewriter.html" title="A special type of RewriterBase that coordinates the application of a rewrite pattern on the current I...">PatternRewriter</a> Hooks</code> section of the <a class="el" href="classmlir_1_1ConversionPatternRewriter.html" title="This class implements a pattern rewriter for use with ConversionPatterns.">ConversionPatternRewriter</a>, to see what additional constraints are imposed on the use of the <a class="el" href="classmlir_1_1PatternRewriter.html" title="A special type of RewriterBase that coordinates the application of a rewrite pattern on the current I...">PatternRewriter</a>. Apply a partial conversion on the given operations and all nested operations. This method converts as many operations to the target as possible, ignoring operations that failed to legalize. This method only returns failure if there ops explicitly marked as illegal. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03178">3178</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02436">mlir::OperationConverter::convertOperations()</a>.</p>

</div>
</div>
<a id="ad706ae09aa9236e1c0e386edc4040efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad706ae09aa9236e1c0e386edc4040efc">&#9670;&nbsp;</a></span>applyPartialConversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::applyPartialConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a>&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="structmlir_1_1ConversionConfig.html">ConversionConfig</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03186">3186</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

</div>
</div>
<a id="a32067eb3e1b98572873f7cce08848080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32067eb3e1b98572873f7cce08848080">&#9670;&nbsp;</a></span>applyPartialOneToNConversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::applyPartialOneToNConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OneToNTypeConverter.html">OneToNTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given set of patterns recursively on the given op and adds user materializations where necessary. </p>
<p>The patterns are expected to be <code><a class="el" href="classmlir_1_1OneToNConversionPattern.html" title="Base class for patterns with 1:N type conversions.">OneToNConversionPattern</a></code>, which help converting the types of the operands and results of the matched ops. The provided type converter is used to convert the operands of matched ops from their original types to operands with different types. Unlike in <code>DialectConversion</code>, this supports 1:N type conversions. Those conversions at the "boundary" of the pattern application, where converted results are not consumed by replaced ops that expect the converted operands or vice versa, the function inserts user materializations from the type converter. Also unlike <code>DialectConversion</code>, there are no legal or illegal types; the function simply applies the given patterns and does not fail if some ops or types remain unconverted (i.e., the conversion is only "partial"). </p>

<p class="definition">Definition at line <a class="el" href="Transforms_2Utils_2OneToNTypeConversion_8cpp_source.html#l00321">321</a> of file <a class="el" href="Transforms_2Utils_2OneToNTypeConversion_8cpp_source.html">OneToNTypeConversion.cpp</a>.</p>

</div>
</div>
<a id="a133398d008de5837d6df9b322b62f5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133398d008de5837d6df9b322b62f5f6">&#9670;&nbsp;</a></span>applyPassManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::applyPassManagerCLOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply any values provided to the pass manager options that were registered with 'registerPassManagerOptions'. </p>

<p class="definition">Definition at line <a class="el" href="PassManagerOptions_8cpp_source.html#l00145">145</a> of file <a class="el" href="PassManagerOptions_8cpp_source.html">PassManagerOptions.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">emitError()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00463">mlir::PassManager::enableCrashReproducerGeneration()</a>, <a class="el" href="PassStatistics_8cpp_source.html#l00250">mlir::PassManager::enableStatistics()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">get()</a>, <a class="el" href="PassManager_8h_source.html#l00256">mlir::PassManager::getContext()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00602">mlir::MLIRContext::isMultithreadingEnabled()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a7b83dd66e74f4184340fe7684edaf070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b83dd66e74f4184340fe7684edaf070">&#9670;&nbsp;</a></span>applyPatternsAndFoldGreedily() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::applyPatternsAndFoldGreedily </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>changed</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rewrite ops nested under the given operation, which must be isolated from above, by repeatedly applying the highest benefit patterns in a greedy worklist driven manner until a fixpoint is reached. </p>
<p>The greedy rewrite may prematurely stop after a maximum number of iterations, which can be configured in the configuration parameter.</p>
<p>Also performs folding and simple dead-code elimination before attempting to match any of the provided patterns.</p>
<p>This overload runs a separate greedy rewrite for each region of the specified op. A region scope can be set in the configuration parameter. By default, the scope is set to the region of the current greedy rewrite. Only in-scope ops are added to the worklist and only in-scope ops and the specified op itself are allowed to be modified by the patterns.</p>
<p>Note: The specified op may be modified, but it may not be removed by the patterns.</p>
<p>Returns "success" if the iterative process converged (i.e., fixpoint was reached) and no more patterns can be matched within the region. <code>changed</code> is set to "true" if the IR was modified at all.</p>
<p>Note: This method does not apply patterns to the given operation itself. </p>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00150">150</a> of file <a class="el" href="GreedyPatternRewriteDriver_8h_source.html">GreedyPatternRewriteDriver.h</a>.</p>

</div>
</div>
<a id="a98d1a56c5c6dd1c979fb0b0b9abf705f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d1a56c5c6dd1c979fb0b0b9abf705f">&#9670;&nbsp;</a></span>applyPatternsAndFoldGreedily() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::applyPatternsAndFoldGreedily </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>changed</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite ops in the given region, which must be isolated from above, by repeatedly applying the highest benefit patterns in a greedy worklist driven manner until a fixpoint is reached. </p>
<p>The greedy rewrite may prematurely stop after a maximum number of iterations, which can be configured in the configuration parameter.</p>
<p>Also performs folding and simple dead-code elimination before attempting to match any of the provided patterns.</p>
<p>A region scope can be set in the configuration parameter. By default, the scope is set to the specified region. Only in-scope ops are added to the worklist and only in-scope ops are allowed to be modified by the patterns.</p>
<p>Returns "success" if the iterative process converged (i.e., fixpoint was reached) and no more patterns can be matched within the region. <code>changed</code> is set to "true" if the IR was modified at all.</p>
<p>Note: This method does not apply patterns to the region's parent operation. </p>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00897">897</a> of file <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html">GreedyPatternRewriteDriver.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8cpp_source.html#l00024">mlir::Region::getContext()</a>, <a class="el" href="IR_2Region_8h_source.html#l00200">mlir::Region::getParentOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00745">mlir::Operation::hasTrait()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00066">mlir::GreedyRewriteConfig::maxIterations</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00078">mlir::GreedyRewriteConfig::scope</a>, and <a class="el" href="Verifier_8cpp_source.html#l00426">verify()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00410">mlir::affine::hoistAffineIfOp()</a>.</p>

</div>
</div>
<a id="a44886de1f618c57e6589a875d1407830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44886de1f618c57e6589a875d1407830">&#9670;&nbsp;</a></span>applyPermutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;T&gt; mlir::applyPermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>permutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8h_source.html#l00201">201</a> of file <a class="el" href="IndexingUtils_8h_source.html">IndexingUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IndexingUtils_8h_source.html#l00215">applyPermutation()</a>, <a class="el" href="IndexingUtils_8h_source.html#l00226">applyPermutationToVector()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00386">mlir::detail::TileOffsetRangeImpl::getDynamicTileOffsets()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00378">mlir::detail::TileOffsetRangeImpl::getStaticTileOffsets()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01450">getTiledPackShape()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l01985">SwapTransposeWithBroadcast::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a920cb0f71558f739ea5605f05354ca01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920cb0f71558f739ea5605f05354ca01">&#9670;&nbsp;</a></span>applyPermutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;T&gt; mlir::applyPermutation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>permutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8h_source.html#l00215">215</a> of file <a class="el" href="IndexingUtils_8h_source.html">IndexingUtils.h</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00201">applyPermutation()</a>.</p>

</div>
</div>
<a id="a2b76f177cd65bd4fd394f9dc65d20be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b76f177cd65bd4fd394f9dc65d20be2">&#9670;&nbsp;</a></span>applyPermutationMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;T&gt; mlir::applyPermutationMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a permutation from <code>map</code> to <code>source</code> and return the result. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00675">675</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00402">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00618">mlir::AffineMap::isProjectedPermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l03973">mlir::vector::inferTransferOpMaskType()</a>.</p>

</div>
</div>
<a id="adbcff71555e8c1965e508f324f43a55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcff71555e8c1965e508f324f43a55a">&#9670;&nbsp;</a></span>applyPermutationToVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::applyPermutationToVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>inVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>permutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the permutation defined by <code>permutation</code> to <code>inVec</code>. </p>
<p>Element <code>i</code> in <code>inVec</code> is mapped to location <code>j = permutation[i]</code>. E.g.: for an input vector &lsquo;inVec = ['a&rsquo;, 'b', 'c']<code>and a permutation vector</code>permutation = [2, 0, 1]<code>, this function leaves</code>inVec = ['c', 'a', 'b']`. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8h_source.html#l00226">226</a> of file <a class="el" href="IndexingUtils_8h_source.html">IndexingUtils.h</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00201">applyPermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l03907">commonPermutationOfPackAndUnPackOp()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00102">computePackUnPackPerm()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00077">mlir::tensor::computeTransposedType()</a>, <a class="el" href="TensorOps_8cpp_source.html#l04077">getPackOpResultTypeShape()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00219">mlir::linalg::lowerPack()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00354">mlir::linalg::lowerUnPack()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00617">permuteShape()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00358">mlir::detail::TileOffsetRangeImpl::TileOffsetRangeImpl()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01534">vectorizeAsTensorPackOp()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01609">vectorizeAsTensorUnpackOp()</a>.</p>

</div>
</div>
<a id="ac680df79552c596c048cd9cb27638c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac680df79552c596c048cd9cb27638c5f">&#9670;&nbsp;</a></span>areValuesDefinedAbove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::areValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Range.html">Range</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if all values in the provided range are defined above the <code>limit</code> region. </p>
<p>That is, if they are defined in a region that is a proper ancestor of <code>limit</code>. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8h_source.html#l00024">24</a> of file <a class="el" href="RegionUtils_8h_source.html">RegionUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToGPU_8cpp_source.html#l00110">checkAffineLoopNestMappableImpl()</a>.</p>

</div>
</div>
<a id="a3d1168f4877a1008569deabfdab07fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1168f4877a1008569deabfdab07fbb">&#9670;&nbsp;</a></span>asMainReturnCode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mlir::asMainReturnCode </td>
          <td>(</td>
          <td class="paramtype">LogicalResult&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper wrapper to return the result of MlirOptMain directly from main. </p>
<p>Example: </p><pre class="fragment">int main(int argc, char **argv) {
  // ...
  return mlir::asMainReturnCode(mlir::MlirOptMain(
      argc, argv, /* ... *&amp;zwj;/);
}
</pre> 
<p class="definition">Definition at line <a class="el" href="MlirOptMain_8h_source.html#l00312">312</a> of file <a class="el" href="MlirOptMain_8h_source.html">MlirOptMain.h</a>.</p>

</div>
</div>
<a id="a0b57be921931a80cdd8e7b0f96fc6e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b57be921931a80cdd8e7b0f96fc6e9f">&#9670;&nbsp;</a></span>barePtrFuncArgTypeConverter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::barePtrFuncArgTypeConverter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to convert function argument types. </p>
<p>It converts MemRef function arguments to bare pointers to the MemRef element type. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00759">759</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00605">mlir::LLVMTypeConverter::convertCallingConventionType()</a>.</p>

</div>
</div>
<a id="a3d147ba82716614172eb7e9b5209d3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d147ba82716614172eb7e9b5209d3eb">&#9670;&nbsp;</a></span>bindDims()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... AffineExprTy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bindDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy &amp;...&#160;</td>
          <td class="paramname"><em>exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a list of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> references to DimExpr at positions: [0 . </p>
<p>. sizeof...(exprs)] </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00348">348</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00720">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00050">buildLinearId()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00025">mlir::tensor::createPadHighOp()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00191">createSubViewIntersection()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00735">denormalizeInductionVariableForIndexType()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l03187">denormalizeIndVar()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00205">getBoundedTileSize()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01826">mlir::affine::getDivMod()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00173">mlir::nvgpu::getLaneIdAndValueIdToOperandCoord()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00245">getTileOffsetAndSizes()</a>, <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00034">invertSliceIndexing()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00219">mlir::linalg::lowerPack()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00099">mlir::memref::multiBuffer()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00822">mlir::linalg::offsetIndices()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00079">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00351">mlir::linalg::updateBoundsForCyclicDistribution()</a>, and <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00748">updateExpandedGenericOpRegion()</a>.</p>

</div>
</div>
<a id="a2c870d90073423151a32e2c0f2afa506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c870d90073423151a32e2c0f2afa506">&#9670;&nbsp;</a></span>bindDimsList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AffineExprTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bindDimsList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineExprTy &gt;&#160;</td>
          <td class="paramname"><em>exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00353">353</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00607">getAffineDimExpr()</a>.</p>

</div>
</div>
<a id="a8df39b3ef750e258dbe3dfe5b251cea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df39b3ef750e258dbe3dfe5b251cea5">&#9670;&nbsp;</a></span>bindSymbols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... AffineExprTy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bindSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy &amp;...&#160;</td>
          <td class="paramname"><em>exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a list of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> references to SymbolExpr at positions: [0 . </p>
<p>. sizeof...(exprs)] </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00362">362</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00050">buildLinearId()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00159">mlir::memref::computeSuffixProductIRBlockImpl()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00735">denormalizeInductionVariableForIndexType()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l03187">denormalizeIndVar()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00675">emitNormalizedLoopBoundsForIndexType()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00205">getBoundedTileSize()</a>, <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00043">getCompressedMaskOp()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00070">mlir::linalg::getConvolvedIndex()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01839">getIndexProduct()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00128">getIndicesForLoadOrStore()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00052">mlir::memref::getLinearizedMemRefOffsetAndSize()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00090">getOffsetForBitwidth()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00789">getProductOfIndexes()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00245">getTileOffsetAndSizes()</a>, <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00034">invertSliceIndexing()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00219">mlir::linalg::lowerPack()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01720">mlir::affine::mapLoopToProcessorIds()</a>, <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00017">mlir::affine::mergeOffsetsSizesAndStrides()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l03170">normalizeUpperBounds()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00119">peelForLoop()</a>, <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00081">mlir::affine::resolveIndicesIntoOpWithOffsetsAndStrides()</a>, and <a class="el" href="NVGPUTransformOps_8cpp_source.html#l01037">CopyBuilder::rewrite()</a>.</p>

</div>
</div>
<a id="af523defc0429b26ab3f85b7023748822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af523defc0429b26ab3f85b7023748822">&#9670;&nbsp;</a></span>bindSymbolsList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AffineExprTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bindSymbolsList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineExprTy &gt;&#160;</td>
          <td class="paramname"><em>exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00367">367</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00617">getAffineSymbolExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00995">HopperBuilder::buildBarrierArriveTx()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00973">HopperBuilder::buildTmaAsyncLoad()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00304">computeLinearIndex()</a>, and <a class="el" href="MemRefUtils_8cpp_source.html#l00052">mlir::memref::getLinearizedMemRefOffsetAndSize()</a>.</p>

</div>
</div>
<a id="a80dcfbd64b4c5038926d874e46edeea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80dcfbd64b4c5038926d874e46edeea2">&#9670;&nbsp;</a></span>canonicalizeStridedLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MemRefType mlir::canonicalizeStridedLayout </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a version of <code>t</code> with identity layout if it can be determined statically that the layout is the canonical contiguous strided layout. </p>
<p>Otherwise pass <code>t</code>'s layout into <code>simplifyAffineMap</code> and return a copy of <code>t</code> with simplified layout.</p>
<p>Otherwise pass <code>t</code>'s layout into <code>simplifyAffineMap</code> and return a copy of <code>t</code> with simplified layout. If <code>t</code> has multiple layout maps or a multi-result layout, just return <code>t</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00894">894</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00276">dropUnitDims()</a>, and <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00288">rankReducingSubviewDroppingUnitDims()</a>.</p>

</div>
</div>
<a id="ab07dda6e0df087e91b18fdb2b8bfe5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07dda6e0df087e91b18fdb2b8bfe5aa">&#9670;&nbsp;</a></span>clone() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * mlir::clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>newResultTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newOperands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00197">197</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01364">clonePrivatizer()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01619">cloneToCollapsedOp&lt; LinalgOp &gt;()</a>, <a class="el" href="Fusion_8cpp_source.html#l00113">fuse()</a>, <a class="el" href="MeshOps_8cpp_source.html#l00637">mlir::mesh::MeshSharding::get()</a>, <a class="el" href="CAPI_2Dialect_2TransformInterpreter_8cpp_source.html#l00076">mlirMergeSymbolsIntoFromClone()</a>, <a class="el" href="Padding_8cpp_source.html#l00153">mlir::linalg::rewriteAsPaddedOp()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00519">mlir::vector::splitFullAndPartialTransfer()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l01079">mlir::scf::tileAndFuseProducerOfSlice()</a>.</p>

</div>
</div>
<a id="aa75b562b2c25a3d66295d10efde0b996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75b562b2c25a3d66295d10efde0b996">&#9670;&nbsp;</a></span>clone() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpT mlir::clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OpT&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>newResultTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newOperands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00145">145</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

</div>
</div>
<a id="a49429f945b2bca0efdd4c315bb68505b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49429f945b2bca0efdd4c315bb68505b">&#9670;&nbsp;</a></span>cloneWithoutRegions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * mlir::cloneWithoutRegions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>newResultTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newOperands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00209">209</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

</div>
</div>
<a id="ad6d3795f1b83fc9e56398102edb81bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d3795f1b83fc9e56398102edb81bd4">&#9670;&nbsp;</a></span>coalesceLoops() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::coalesceLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a perfect nest of "for" loops with a single linearized loop. </p>
<p>Assumes <code>loops</code> contains a list of perfectly nested loops with bounds and steps independent of any loop induction variable involved in the nest. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00974">974</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a id="abfbbec94f6bbf0a536fa87c73dd4c61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfbbec94f6bbf0a536fa87c73dd4c61b">&#9670;&nbsp;</a></span>coalesceLoops() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::coalesceLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00896">896</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00841">delinearizeInductionVariable()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00760">denormalizeInductionVariable()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00689">emitNormalizedLoopBounds()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00161">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00373">mlir::Operation::getOperands()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00804">getProductOfIntsOrIndexes()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00103">getValueOrCreateConstantIntOp()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00291">mlir::RewriterBase::inlineBlockBefore()</a>, <a class="el" href="PatternMatch_8h_source.html#l00630">mlir::RewriterBase::modifyOpInPlace()</a>, <a class="el" href="PatternMatch_8h_source.html#l00702">mlir::RewriterBase::replaceAllUsesExcept()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00133">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="Builders_8h_source.html#l00406">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="Builders_8h_source.html#l00439">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="a39a046fcc3a4da7eb0d54f9f6a65c3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a046fcc3a4da7eb0d54f9f6a65c3c5">&#9670;&nbsp;</a></span>coalescePerfectlyNestedSCFForLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::coalescePerfectlyNestedSCFForLoops </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk an affine.for to find a band to coalesce. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00982">982</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a id="a56042c88e158beeafccbff36bdc1cb42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56042c88e158beeafccbff36bdc1cb42">&#9670;&nbsp;</a></span>collapseParallelLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::collapseParallelLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ParallelOp&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::vector&lt; unsigned &gt;&gt;&#160;</td>
          <td class="paramname"><em>combinedDimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take the ParallelLoop and for each set of dimension indices, combine them into a single dimension. </p>
<p>combinedDimensions must contain each index into loops exactly once. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01057">1057</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00760">denormalizeInductionVariable()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00689">emitNormalizedLoopBounds()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00539">mlir::Operation::erase()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00103">getValueOrCreateConstantIntOp()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00032">replaceAllUsesInRegionWith()</a>, <a class="el" href="Builders_8h_source.html#l00406">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="Builders_8h_source.html#l00439">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="aab965622bbf0ccdfcb51384517fd3117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab965622bbf0ccdfcb51384517fd3117">&#9670;&nbsp;</a></span>composeReassociationIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; &gt; mlir::composeReassociationIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>producerReassociations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>consumerReassociations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose reassociation maps that are used in pair of reshape ops where one is a producer and other is the consumer. </p>
<p>Only valid to use this method when both the producer and consumer are collapsing dimensions or both are expanding dimensions.</p>
<p>For example, producerReassociation = [[0, 1], [2], [3, 4]] consumerReassociation = [[0, 1], [2]]</p>
<p>is folded into</p>
<p>result = [[0, 1, 2], [3, 4]]. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00097">97</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ReshapeOpsUtils_8h_source.html#l00191">mlir::ComposeReassociativeReshapeOps&lt; ReshapeOpTy, opKind &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ab05caafff59182b2191e4645cdceb5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05caafff59182b2191e4645cdceb5d5">&#9670;&nbsp;</a></span>compressDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::compressDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>unusedDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the dims that are listed in <code>unusedDims</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00717">717</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00904">projectDims()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00722">compressUnusedDims()</a>.</p>

</div>
</div>
<a id="a6de5b9ec7c351db7ed870d0df7248342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de5b9ec7c351db7ed870d0df7248342">&#9670;&nbsp;</a></span>compressSymbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::compressSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>unusedSymbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the symbols that are listed in <code>unusedSymbols</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00731">731</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00911">projectSymbols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00736">compressUnusedSymbols()</a>.</p>

</div>
</div>
<a id="a99f84d2ce14eec6c85a20251582e5cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f84d2ce14eec6c85a20251582e5cc1">&#9670;&nbsp;</a></span>compressUnusedDims() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::compressUnusedDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the dims that are not used. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00722">722</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00717">compressDims()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00928">getUnusedDimsBitVector()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l03973">mlir::vector::inferTransferOpMaskType()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00487">reindexIndexingMap()</a>.</p>

</div>
</div>
<a id="ae2a3cbce4381f83b710fe6cfc9a867c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a3cbce4381f83b710fe6cfc9a867c9">&#9670;&nbsp;</a></span>compressUnusedDims() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; mlir::compressUnusedDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>maps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the dims that are not used by any of the individual maps in <code>maps</code>. </p>
<p>Asserts that all maps in <code>maps</code> are normalized to the same number of dims and symbols. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00726">726</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00687">compressUnusedListImpl()</a>.</p>

</div>
</div>
<a id="ae4c401a074fdcc1cb0efb7e5369b2ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c401a074fdcc1cb0efb7e5369b2ef3">&#9670;&nbsp;</a></span>compressUnusedSymbols() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::compressUnusedSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the symbols that are not used. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00736">736</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00731">compressSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00940">getUnusedSymbolsBitVector()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00918">getProjectedMap()</a>.</p>

</div>
</div>
<a id="a4a26d1a643586acb4362f535168be129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a26d1a643586acb4362f535168be129">&#9670;&nbsp;</a></span>compressUnusedSymbols() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; mlir::compressUnusedSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>maps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the symbols that are not used by any of the individual maps in <code>maps</code>. </p>
<p>Asserts that all maps in <code>maps</code> are normalized to the same number of dims and symbols. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00740">740</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00687">compressUnusedListImpl()</a>.</p>

</div>
</div>
<a id="ad0f77472da918076c9d2a222a501823f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f77472da918076c9d2a222a501823f">&#9670;&nbsp;</a></span>computeElementwiseMul() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; mlir::computeElementwiseMul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector containing llvm::zip_equal(v1, v2) multiplied elementwise. </p>
<p>It is the caller's responsibility to pass proper <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> kind that result in valid <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> (i.e. cannot multiply 2 <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> or divide by an <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a>).</p>
<p>Return an empty vector if <code>v1</code> and <code>v2</code> are empty. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00154">154</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00033">computeElementwiseMulImpl()</a>.</p>

</div>
</div>
<a id="a1c7ccdb269314ad17ee4550b4bcb608a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7ccdb269314ad17ee4550b4bcb608a">&#9670;&nbsp;</a></span>computeElementwiseMul() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; mlir::computeElementwiseMul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector containing llvm::zip_equal(v1, v2) multiplied elementwise. </p>
<p>Return an empty vector if <code>v1</code> and <code>v2</code> are empty. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00078">78</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00033">computeElementwiseMulImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IndexingUtils_8cpp_source.html#l00386">mlir::detail::TileOffsetRangeImpl::getDynamicTileOffsets()</a>, and <a class="el" href="IndexingUtils_8cpp_source.html#l00378">mlir::detail::TileOffsetRangeImpl::getStaticTileOffsets()</a>.</p>

</div>
</div>
<a id="a19e07ab53e78b29f77777f2ade29c9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e07ab53e78b29f77777f2ade29c9e8">&#9670;&nbsp;</a></span>computeLinearIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt; mlir::computeLinearIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>sourceOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00335">335</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00304">computeLinearIndex()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00094">getAsIndexOpFoldResult()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00069">getAsOpFoldResult()</a>, and <a class="el" href="OpDefinition_8h_source.html#l00274">mlir::OpFoldResult::getContext()</a>.</p>

</div>
</div>
<a id="a3eafff30d6e835bda8247cf34463df2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eafff30d6e835bda8247cf34463df2c">&#9670;&nbsp;</a></span>computeLinearIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt; mlir::computeLinearIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>sourceOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute linear index from provided strides and indices, assuming strided layout. </p>
<p>Returns <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> and list of values to apply to it, e.g.:</p>
<p>auto &amp;&amp;[expr, values] = computeLinearIndex(...); offset = affine::makeComposedFoldedAffineApply(builder, loc, expr, values); </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00304">304</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00367">bindSymbolsList()</a>, and <a class="el" href="IndexingUtils_8cpp_source.html#l00295">getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IndexingUtils_8cpp_source.html#l00335">computeLinearIndex()</a>, <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00508">getCollapsedIndices()</a>, <a class="el" href="DecomposeMemRefs_8cpp_source.html#l00045">getFlatOffsetAndStrides()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01877">mlir::affine::linearizeIndex()</a>.</p>

</div>
</div>
<a id="a9c157bd2c9cf4949b45235593f6ef994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c157bd2c9cf4949b45235593f6ef994">&#9670;&nbsp;</a></span>computeMaxLinearIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::computeMaxLinearIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>basis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of elements of basis (i.e. </p>
<p>the max linear index). Return <code>0</code> if <code>basis</code> is empty.</p>
<p><code>basis</code> elements are asserted to be non-negative.</p>
<p>Return <code>0</code> if <code>basis</code> is empty. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8h_source.html#l00069">69</a> of file <a class="el" href="IndexingUtils_8h_source.html">IndexingUtils.h</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00091">computeProduct()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PolynomialApproximation_8cpp_source.html#l00103">handleMultidimensionalVectors()</a>, and <a class="el" href="IndexingUtils_8cpp_source.html#l00358">mlir::detail::TileOffsetRangeImpl::TileOffsetRangeImpl()</a>.</p>

</div>
</div>
<a id="ac2248838afeb293df08c1731f2d12fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2248838afeb293df08c1731f2d12fc2">&#9670;&nbsp;</a></span>computeMaxLinearIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::computeMaxLinearIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of elements of basis (i.e. </p>
<p>the max linear index). Return <code>0</code> if <code>basis</code> is empty.</p>
<p>It is the caller's responsibility to pass proper <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> kind that result in valid <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> (i.e. cannot multiply 2 <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> or divide by an <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a>).</p>
<p><code>basis</code> elements are expected to bind to non-negative values.</p>
<p>Return the <code>0</code> <a class="el" href="classmlir_1_1AffineConstantExpr.html" title="An integer constant appearing in affine expression.">AffineConstantExpr</a> if <code>basis</code> is empty. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8h_source.html#l00159">159</a> of file <a class="el" href="IndexingUtils_8h_source.html">IndexingUtils.h</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00091">computeProduct()</a>.</p>

</div>
</div>
<a id="a6eab61c26bfef3d7aaf3db051d58230b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eab61c26bfef3d7aaf3db051d58230b">&#9670;&nbsp;</a></span>computePermutationVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; mlir::computePermutationVector </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>permSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>desiredPositions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a permutation vector of size permSize that would result in moving positions into desiredPositions. </p>
<p>For example, permSize == 5, positions = {2, 4}, desiredPositions = {1, 0} would result in a {4, 2, 0, 1, 3} permutation vector. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00235">235</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00102">computePackUnPackPerm()</a>, and <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00766">mlir::linalg::packMatmulGreedily()</a>.</p>

</div>
</div>
<a id="a68e66c407bcfb1b4bbba4693496dbdc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e66c407bcfb1b4bbba4693496dbdc6">&#9670;&nbsp;</a></span>computeProduct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::computeProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>basis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Self-explicit. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00091">91</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00973">HopperBuilder::buildTmaAsyncLoad()</a>, <a class="el" href="GPUTransformOps_8cpp_source.html#l00734">checkMappingSpec()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00078">commonLinearIdBuilderFn()</a>, <a class="el" href="IndexingUtils_8h_source.html#l00069">computeMaxLinearIndex()</a>, and <a class="el" href="NVGPUTransformOps_8cpp_source.html#l01037">CopyBuilder::rewrite()</a>.</p>

</div>
</div>
<a id="ada8d7a2a03264db5a6ac02a351f1e059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8d7a2a03264db5a6ac02a351f1e059">&#9670;&nbsp;</a></span>computeProduct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::computeProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Self-explicit. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00167">167</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00631">getAffineConstantExpr()</a>.</p>

</div>
</div>
<a id="ac7e47350637dfbf8ad64f9e3bba17bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e47350637dfbf8ad64f9e3bba17bdd">&#9670;&nbsp;</a></span>computeRankReductionMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; llvm::SmallDenseSet&lt; unsigned &gt; &gt; mlir::computeRankReductionMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>originalShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>reducedShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>matchDynamic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an <code>originalShape</code> and a <code>reducedShape</code> assumed to be a subset of <code>originalShape</code> with some <code>1</code> entries erased, return the set of indices that specifies which of the entries of <code>originalShape</code> are dropped to obtain <code>reducedShape</code>. </p>
<p>The returned mask can be applied as a projection to <code>originalShape</code> to obtain the <code>reducedShape</code>. This mask is useful to track which dimensions must be kept when e.g. compute MemRef strides under rank-reducing operations. Return std::nullopt if reducedShape cannot be obtained by dropping only <code>1</code> entries in <code>originalShape</code>. If <code>matchDynamic</code> is true, then dynamic dims in <code>originalShape</code> and <code>reducedShape</code> will be considered matching with non-dynamic dims, unless the non-dynamic dim is from <code>originalShape</code> and equal to 1. For example, in ([1, 3, ?], [?, 5]), the mask would be {1, 0, 0}, since 3 and 5 will match with the corresponding dynamic dims. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00428">428</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00462">isRankReducedType()</a>.</p>

</div>
</div>
<a id="ad1c2ae63c247a9ba4509c8d1181127b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c2ae63c247a9ba4509c8d1181127b0">&#9670;&nbsp;</a></span>computeShapeRatio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; &gt; mlir::computeShapeRatio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>subShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the multi-dimensional integral ratio of <code>subShape</code> to the trailing dimensions of <code>shape</code>. </p>
<p>This represents how many times <code>subShape</code> fits within <code>shape</code>. If integral division is not possible, return std::nullopt. The trailing <code>subShape.size()</code> entries of both shapes are assumed (and enforced) to only contain non-negative values.</p>
<p>Examples:</p><ul>
<li>shapeRatio({3, 5, 8}, {2, 5, 2}) returns {3, 2, 1}.</li>
<li>shapeRatio({3, 8}, {2, 5, 2}) returns std::nullopt (subshape has higher rank).</li>
<li>shapeRatio({42, 2, 10, 32}, {2, 5, 2}) returns {42, 1, 2, 16} which is derived as {42(leading shape dim), 2/2, 10/5, 32/2}.</li>
<li>shapeRatio({42, 2, 11, 32}, {2, 5, 2}) returns std::nullopt which is derived as {42(leading shape dim), 2/2, 11/5(not divisible), 32/2}. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00116">116</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00071">copy()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IndexingUtils_8cpp_source.html#l00358">mlir::detail::TileOffsetRangeImpl::TileOffsetRangeImpl()</a>.</p>

</div>
</div>
<a id="a53b9af9c7621d308e75814d488a9f6d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b9af9c7621d308e75814d488a9f6d7">&#9670;&nbsp;</a></span>computeStrides() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&gt; mlir::computeStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8h_source.html#l00129">129</a> of file <a class="el" href="IndexingUtils_8h_source.html">IndexingUtils.h</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00071">computeSuffixProduct()</a>.</p>

</div>
</div>
<a id="a41f80386c0deb6ec32cbf4c8f3b929c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f80386c0deb6ec32cbf4c8f3b929c3">&#9670;&nbsp;</a></span>computeStrides() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t&gt; mlir::computeStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8h_source.html#l00047">47</a> of file <a class="el" href="IndexingUtils_8h_source.html">IndexingUtils.h</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00071">computeSuffixProduct()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00078">commonLinearIdBuilderFn()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00652">foreachIndividualVectorElement()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00103">handleMultidimensionalVectors()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01877">mlir::affine::linearizeIndex()</a>, and <a class="el" href="IndexingUtils_8cpp_source.html#l00358">mlir::detail::TileOffsetRangeImpl::TileOffsetRangeImpl()</a>.</p>

</div>
</div>
<a id="a530d6a928389d2f4c0234b059442a03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530d6a928389d2f4c0234b059442a03a">&#9670;&nbsp;</a></span>computeSuffixProduct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; mlir::computeSuffixProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of sizes, return the suffix product. </p>
<p>When applied to slicing, this is the calculation needed to derive the strides (i.e. the number of linear indices to skip along the (k-1) most minor dimensions to get the next k-slice).</p>
<p>This is the basis to linearize an n-D offset confined to <code>[0 ... sizes]</code>.</p>
<p>Assuming <code>sizes</code> is <code>[s0, .. sn]</code>, return the vector&lt;AffineExpr&gt; <code>[s1 * ... * sn, s2 * ... * sn, ..., sn, 1]</code>.</p>
<p>It is the caller's responsibility to pass proper <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> kind that result in valid <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> (i.e. cannot multiply 2 <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> or divide by an <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a>).</p>
<p><code>sizes</code> elements are expected to bind to non-negative values.</p>
<p>Return an empty vector if <code>sizes</code> is empty. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00147">147</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00022">computeSuffixProductImpl()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00631">getAffineConstantExpr()</a>.</p>

</div>
</div>
<a id="a93db6f545964ed23f06b57618f09b33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93db6f545964ed23f06b57618f09b33a">&#9670;&nbsp;</a></span>computeSuffixProduct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; mlir::computeSuffixProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of sizes, return the suffix product. </p>
<p>When applied to slicing, this is the calculation needed to derive the strides (i.e. the number of linear indices to skip along the (k-1) most minor dimensions to get the next k-slice).</p>
<p>This is the basis to linearize an n-D offset confined to <code>[0 ... sizes]</code>.</p>
<p>Assuming <code>sizes</code> is <code>[s0, .. sn]</code>, return the vector&lt;int64_t&gt; <code>[s1 * ... * sn, s2 * ... * sn, ..., sn, 1]</code>.</p>
<p><code>sizes</code> elements are asserted to be non-negative.</p>
<p>Return an empty vector if <code>sizes</code> is empty. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00071">71</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00022">computeSuffixProductImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IndexingUtils_8h_source.html#l00047">computeStrides()</a>, <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00508">getCollapsedIndices()</a>, and <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00166">resolveSourceIndicesCollapseShape()</a>.</p>

</div>
</div>
<a id="aea26c0821fa35a09260cd1aeb694d0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea26c0821fa35a09260cd1aeb694d0df">&#9670;&nbsp;</a></span>computeSum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::computeSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>basis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Self-explicit. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00083">83</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00995">HopperBuilder::buildBarrierArriveTx()</a>.</p>

</div>
</div>
<a id="a4cb1a444a06409db3eedd783e7f9ab0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb1a444a06409db3eedd783e7f9ab0b">&#9670;&nbsp;</a></span>computeSum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::computeSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Self-explicit. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00159">159</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00631">getAffineConstantExpr()</a>.</p>

</div>
</div>
<a id="a28129a93d39ade2d40077f25a09eb389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28129a93d39ade2d40077f25a09eb389">&#9670;&nbsp;</a></span>computeTopologicalSorting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::computeTopologicalSorting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>isOperandReady</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a topological ordering of the given ops. </p>
<p>This sort is not stable.</p>
<p>Note: If the specified ops contain incomplete/interrupted SSA use-def chains, the result may not actually be a topological sorting with respect to the entire program. </p>

<p class="definition">Definition at line <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00112">112</a> of file <a class="el" href="TopologicalSortUtils_8cpp_source.html">TopologicalSortUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8cpp_source.html#l00084">makeRegionIsolatedFromAbove()</a>.</p>

</div>
</div>
<a id="a6d24d64d6db077b8d5c88316b0d6c717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d24d64d6db077b8d5c88316b0d6c717">&#9670;&nbsp;</a></span>concatAffineMaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::concatAffineMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>maps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates a list of <code>maps</code> into a single <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a>, stepping over potentially empty maps. </p>
<p>Assumes each of the underlying map has 0 symbols. The resulting map has a number of dims equal to the max of <code>maps</code>' dims and the concatenated results as its results. Returns an empty map if all input <code>maps</code> are empty.</p>
<p>Example: When applied to the following list of 3 affine maps,</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  (i, j, k) -&gt; (i, k),</div>
<div class="line">  (i, j, k) -&gt; (k, j),</div>
<div class="line">  (i, j, k) -&gt; (i, j)</div>
<div class="line">}</div>
</div><!-- fragment --><p>Returns the map:</p>
<div class="fragment"><div class="line">(i, j, k) -&gt; (i, k, k, j, i, j)</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00836">836</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00036">mlir::linalg::detail::canOpOperandsBeDroppedImpl()</a>, and <a class="el" href="DropUnitDims_8cpp_source.html#l00390">mlir::linalg::dropUnitDims()</a>.</p>

</div>
</div>
<a id="acc3c1de7f45b21ef1f9deddb22b03655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3c1de7f45b21ef1f9deddb22b03655">&#9670;&nbsp;</a></span>configureAMXLegalizeForExportTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::configureAMXLegalizeForExportTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the target to support lowering AMX ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00211">211</a> of file <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00868">mlir::ConversionTarget::addIllegalOp()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00829">mlir::ConversionTarget::addLegalOp()</a>.</p>

</div>
</div>
<a id="ac5fc9cf7db1e6fcc78850ac4ab89742c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fc9cf7db1e6fcc78850ac4ab89742c">&#9670;&nbsp;</a></span>configureArmSMEToLLVMConversionLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::configureArmSMEToLLVMConversionLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure target to convert from the ArmSME dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8cpp_source.html#l00938">938</a> of file <a class="el" href="ArmSMEToLLVM_8cpp_source.html">ArmSMEToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00946">mlir::ConversionTarget::addIllegalDialect()</a>, <a class="el" href="DialectConversion_8h_source.html#l00911">mlir::ConversionTarget::addLegalDialect()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00829">mlir::ConversionTarget::addLegalOp()</a>.</p>

</div>
</div>
<a id="a026c18765c0bc2d44d9ab120174d36ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026c18765c0bc2d44d9ab120174d36ae">&#9670;&nbsp;</a></span>configureArmSVELegalizeForExportTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::configureArmSVELegalizeForExportTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the target to support lowering ArmSVE ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="ArmSVE_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00235">235</a> of file <a class="el" href="ArmSVE_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00868">mlir::ConversionTarget::addIllegalOp()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00829">mlir::ConversionTarget::addLegalOp()</a>.</p>

</div>
</div>
<a id="a7fa896c9229c786edc4a7970b960b208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa896c9229c786edc4a7970b960b208">&#9670;&nbsp;</a></span>configureGpuToNVVMConversionLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::configureGpuToNVVMConversionLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure target to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00320">320</a> of file <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html">LowerGpuOpsToNVVMOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00946">mlir::ConversionTarget::addIllegalDialect()</a>, <a class="el" href="DialectConversion_8h_source.html#l00868">mlir::ConversionTarget::addIllegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00911">mlir::ConversionTarget::addLegalDialect()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00829">mlir::ConversionTarget::addLegalOp()</a>.</p>

</div>
</div>
<a id="a65c490624b02da7c5cb78aa071e0aa2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c490624b02da7c5cb78aa071e0aa2a">&#9670;&nbsp;</a></span>configureGpuToROCDLConversionLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::configureGpuToROCDLConversionLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure target to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a>. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00329">329</a> of file <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html">LowerGpuOpsToROCDLOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00844">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00946">mlir::ConversionTarget::addIllegalDialect()</a>, <a class="el" href="DialectConversion_8h_source.html#l00868">mlir::ConversionTarget::addIllegalOp()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00911">mlir::ConversionTarget::addLegalDialect()</a>.</p>

</div>
</div>
<a id="ab3aae89781697b10e37f29e112251443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3aae89781697b10e37f29e112251443">&#9670;&nbsp;</a></span>configureOpenMPToLLVMConversionLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::configureOpenMPToLLVMConversionLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure dynamic conversion legality of regionless operations from OpenMP to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00223">223</a> of file <a class="el" href="OpenMPToLLVM_8cpp_source.html">OpenMPToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00844">mlir::ConversionTarget::addDynamicallyLegalOp()</a>.</p>

</div>
</div>
<a id="af01d59b73ef695a82338e96055101c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01d59b73ef695a82338e96055101c16">&#9670;&nbsp;</a></span>configureParallelLoopToGPULegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::configureParallelLoopToGPULegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the rewrite target such that only <code>scf.parallel</code> operations that are not rewritten by the provided patterns are legal. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPU_8cpp_source.html#l00680">680</a> of file <a class="el" href="SCFToGPU_8cpp_source.html">SCFToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00844">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00911">mlir::ConversionTarget::addLegalDialect()</a>, <a class="el" href="ParallelLoopMapper_8cpp_source.html#l00031">mlir::gpu::getMappingAttrName()</a>, and <a class="el" href="SCFToGPU_8cpp_source.html#l00058">kVisitedAttrName</a>.</p>

</div>
</div>
<a id="afa8013cee2241cd53aa923b23e4e3575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8013cee2241cd53aa923b23e4e3575">&#9670;&nbsp;</a></span>configureX86VectorLegalizeForExportTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::configureX86VectorLegalizeForExportTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the target to support lowering X86Vector ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="X86Vector_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00168">168</a> of file <a class="el" href="X86Vector_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00868">mlir::ConversionTarget::addIllegalOp()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00829">mlir::ConversionTarget::addLegalOp()</a>.</p>

</div>
</div>
<a id="a694b6ad2c919c4bcef792aca11deda42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a694b6ad2c919c4bcef792aca11deda42">&#9670;&nbsp;</a></span>constantTripCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; int64_t &gt; mlir::constantTripCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of iterations for a loop with a lower bound <code>lb</code>, upper bound <code>ub</code> and step <code>step</code>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00236">236</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00105">getConstantIntValue()</a>.</p>

</div>
</div>
<a id="ae0b6240841ff6c3a830c2e638547d1c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b6240841ff6c3a830c2e638547d1c2">&#9670;&nbsp;</a></span>constFoldBinaryOp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class PoisonAttr  = ub::PoisonAttr, class CalculationT  = function_ref&lt;ElementValueT(ElementValueT, ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldBinaryOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CalculationT &amp;&amp;&#160;</td>
          <td class="paramname"><em>calculate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00179">179</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

</div>
</div>
<a id="ad3fdc959472e22be684140b76ece47d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3fdc959472e22be684140b76ece47d5">&#9670;&nbsp;</a></span>constFoldBinaryOp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class PoisonAttr  = void, class CalculationT  = function_ref&lt;ElementValueT(ElementValueT, ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldBinaryOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>resultType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CalculationT &amp;&amp;&#160;</td>
          <td class="paramname"><em>calculate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00165">165</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

</div>
</div>
<a id="a9e1febec8a9cbec424911c290ed1b574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1febec8a9cbec424911c290ed1b574">&#9670;&nbsp;</a></span>constFoldBinaryOpConditional() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class PoisonAttr  = ub::PoisonAttr, class CalculationT  = function_ref&lt;              std::optional&lt;ElementValueT&gt;(ElementValueT, ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldBinaryOpConditional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CalculationT &amp;&amp;&#160;</td>
          <td class="paramname"><em>calculate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs constant folding <code>calculate</code> with element-wise behavior on the two attributes in <code>operands</code> and returns the result if possible. </p>
<p>Uses the operand element type for the element type of the returned attribute. Optional PoisonAttr template argument allows to specify 'poison' attribute which will be directly propagated to result. </p>

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00127">127</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

<p class="reference">References <a class="el" href="CommonFolders_8h_source.html#l00038">constFoldBinaryOpConditional()</a>.</p>

</div>
</div>
<a id="a790a3bb4de1793749c35325783ab5107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790a3bb4de1793749c35325783ab5107">&#9670;&nbsp;</a></span>constFoldBinaryOpConditional() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class PoisonAttr  = ub::PoisonAttr, class CalculationT  = function_ref&lt;              std::optional&lt;ElementValueT&gt;(ElementValueT, ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldBinaryOpConditional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>resultType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CalculationT &amp;&amp;&#160;</td>
          <td class="paramname"><em>calculate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs constant folding <code>calculate</code> with element-wise behavior on the two attributes in <code>operands</code> and returns the result if possible. </p>
<p>Uses <code>resultType</code> for the type of the returned attribute. Optional PoisonAttr template argument allows to specify 'poison' attribute which will be directly propagated to result. </p>

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00038">38</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">get()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00901">mlir::DenseElementsAttr::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CommonFolders_8h_source.html#l00127">constFoldBinaryOpConditional()</a>.</p>

</div>
</div>
<a id="a2927f15718a47f9dfaa0090c2235e954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2927f15718a47f9dfaa0090c2235e954">&#9670;&nbsp;</a></span>constFoldCastOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT , class TargetAttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class TargetElementValueT  = typename TargetAttrElementT::ValueType, class PoisonAttr  = ub::PoisonAttr, class CalculationT  = function_ref&lt;TargetElementValueT(ElementValueT, bool)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldCastOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>resType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CalculationT &amp;&amp;&#160;</td>
          <td class="paramname"><em>calculate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00269">269</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

</div>
</div>
<a id="a321429a6eb4c4480414e9a365d11caf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321429a6eb4c4480414e9a365d11caf6">&#9670;&nbsp;</a></span>constFoldUnaryOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class PoisonAttr  = ub::PoisonAttr, class CalculationT  = function_ref&lt;ElementValueT(ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldUnaryOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CalculationT &amp;&amp;&#160;</td>
          <td class="paramname"><em>calculate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00255">255</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

</div>
</div>
<a id="a5a44de2c24a2631be3084ffc5fd95431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a44de2c24a2631be3084ffc5fd95431">&#9670;&nbsp;</a></span>constFoldUnaryOpConditional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class PoisonAttr  = ub::PoisonAttr, class CalculationT  = function_ref&lt;std::optional&lt;ElementValueT&gt;(ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldUnaryOpConditional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CalculationT &amp;&amp;&#160;</td>
          <td class="paramname"><em>calculate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs constant folding <code>calculate</code> with element-wise behavior on the one attributes in <code>operands</code> and returns the result if possible. </p>
<p>Optional PoisonAttr template argument allows to specify 'poison' attribute which will be directly propagated to result. </p>

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00197">197</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

</div>
</div>
<a id="ac6e826b7dff0a2629197a20d859cd4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e826b7dff0a2629197a20d859cd4c7">&#9670;&nbsp;</a></span>controlFlowSink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mlir::controlFlowSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a>&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>domInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>shouldMoveIntoRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>moveIntoRegion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of regions, perform control flow sinking on them. </p>
<p>For each region, control-flow sinking moves operations that dominate the region but whose only users are in the region into the regions so that they aren't executed on paths where their results are not needed.</p>
<p>TODO: For the moment, this is a <em>simple</em> control-flow sink, i.e., no duplicating of ops. It should be made to accept a cost model to determine whether duplicating a particular op is profitable.</p>
<p>Example:</p>
<div class="fragment"><div class="line">%0 = arith.addi %arg0, %arg1</div>
<div class="line">scf.if %cond {</div>
<div class="line">  scf.yield %0</div>
<div class="line">} else {</div>
<div class="line">  scf.yield %arg2</div>
<div class="line">}</div>
</div><!-- fragment --><p>After control-flow sink:</p>
<div class="fragment"><div class="line">scf.if %cond {</div>
<div class="line">  %0 = arith.addi %arg0, %arg1</div>
<div class="line">  scf.yield %0</div>
<div class="line">} else {</div>
<div class="line">  scf.yield %arg2</div>
<div class="line">}</div>
</div><!-- fragment --><p>Users must supply a callback <code>shouldMoveIntoRegion</code> that determines whether the given operation that only has users in the given operation should be moved into that region. If this returns true, <code>moveIntoRegion</code> is called on the same operation and region.</p>
<p><code>moveIntoRegion</code> must move the operation into the region such that dominance of the operation is preserved; for example, by moving the operation to the start of the entry block. This ensures the preservation of SSA dominance of the operation's results.</p>
<p>Returns the number of operations sunk. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowSinkUtils_8cpp_source.html#l00127">127</a> of file <a class="el" href="ControlFlowSinkUtils_8cpp_source.html">ControlFlowSinkUtils.cpp</a>.</p>

</div>
</div>
<a id="a4e36f1b7aaec9319e5ba11077079aa4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e36f1b7aaec9319e5ba11077079aa4e">&#9670;&nbsp;</a></span>convertAffineLoopNestToGPULaunch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertAffineLoopNestToGPULaunch </td>
          <td>(</td>
          <td class="paramtype">affine::AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numBlockDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numThreadDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a perfect affine loop nest with the outermost loop identified by <code>forOp</code> into a gpu::Launch operation. </p>
<p>Map <code>numBlockDims</code> outer loops to GPU blocks and <code>numThreadDims</code> to GPU threads. The bounds of the loops that are mapped should be independent of the induction variables of the other mapped loops.</p>
<p>No check on the size of the block or grid, or on the validity of parallelization is performed, it is under the responsibility of the caller to strip-mine the loops and to perform the dependence analysis before calling the conversion. </p>

</div>
</div>
<a id="a8def5e235dec49017ed2ab6ca765e96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8def5e235dec49017ed2ab6ca765e96f">&#9670;&nbsp;</a></span>convertFromAttribute() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertFromAttribute </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the boolean from <code>attr</code> into <code>storage</code>. </p>
<p>If <code>attr</code> is not a <code><a class="el" href="classmlir_1_1BoolAttr.html" title="Special case of IntegerAttr to represent boolean integers, i.e., signless i1 integers.">BoolAttr</a></code>, return failure and emit an error into the diagnostic from <code>emitError</code>. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00067">67</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">emitError()</a>.</p>

</div>
</div>
<a id="abaaf50aca64f58a65c55414d3f3309d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaaf50aca64f58a65c55414d3f3309d5">&#9670;&nbsp;</a></span>convertFromAttribute() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertFromAttribute </td>
          <td>(</td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an IntegerAttr attribute to an int32_t, or return an error if the attribute isn't an IntegerAttr. </p>
<p>If the optional diagnostic is provided an error message is also emitted. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00037">37</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">emitError()</a>.</p>

</div>
</div>
<a id="abb62375c248ed1a8f282211f5d0cedd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb62375c248ed1a8f282211f5d0cedd8">&#9670;&nbsp;</a></span>convertFromAttribute() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertFromAttribute </td>
          <td>(</td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an IntegerAttr attribute to an int64_t, or return an error if the attribute isn't an IntegerAttr. </p>
<p>If the optional diagnostic is provided an error message is also emitted. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00022">22</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">emitError()</a>.</p>

</div>
</div>
<a id="a4bd22462e9e020181df531dfa5f8164e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd22462e9e020181df531dfa5f8164e">&#9670;&nbsp;</a></span>convertFromAttribute() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult mlir::convertFromAttribute </td>
          <td>(</td>
          <td class="paramtype">IntegerOverflowFlags &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMDialect_8cpp_source.html#l00066">66</a> of file <a class="el" href="LLVMDialect_8cpp_source.html">LLVMDialect.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">emitError()</a>.</p>

</div>
</div>
<a id="a44ed2f9952d1cb1a2eb02252768af95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ed2f9952d1cb1a2eb02252768af95b">&#9670;&nbsp;</a></span>convertFromAttribute() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertFromAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; int32_t &gt;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a DenseI32ArrayAttr to the provided storage. </p>
<p>It is expected that the storage has the same size as the array. An error is returned if the attribute isn't a DenseI32ArrayAttr or it does not have the same size. If the optional diagnostic is provided an error message is also emitted. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00105">105</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">emitError()</a>.</p>

</div>
</div>
<a id="a7950ff8da3b75555e08167ea5ea94eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7950ff8da3b75555e08167ea5ea94eed">&#9670;&nbsp;</a></span>convertFromAttribute() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertFromAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a DenseI64ArrayAttr to the provided storage. </p>
<p>It is expected that the storage has the same size as the array. An error is returned if the attribute isn't a DenseI64ArrayAttr or it does not have the same size. If the optional diagnostic is provided an error message is also emitted. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00099">99</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">emitError()</a>.</p>

</div>
</div>
<a id="a588ba679548595723d4e190dd6dc80b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588ba679548595723d4e190dd6dc80b9">&#9670;&nbsp;</a></span>convertFromAttribute() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertFromAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a DenseI32ArrayAttr to the provided storage, which will be cleared before writing. </p>
<p>It is expected that the storage has the same size as the array. An error is returned and emitted to the optional <code>emitError</code> function if the attribute isn't a DenseI32ArrayAttr. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00132">132</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">emitError()</a>.</p>

</div>
</div>
<a id="ae3dd8a9b554ad036fb40ec639db2b065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3dd8a9b554ad036fb40ec639db2b065">&#9670;&nbsp;</a></span>convertFromAttribute() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertFromAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a DenseI64ArrayAttr to the provided storage, which will be cleared before writing. </p>
<p>An error is returned and emitted to the optional <code>emitError</code> function if the attribute isn't a DenseI64ArrayAttr. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00126">126</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">emitError()</a>.</p>

</div>
</div>
<a id="a9846d2959aaf3565b6e538b320b19c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9846d2959aaf3565b6e538b320b19c4a">&#9670;&nbsp;</a></span>convertFromAttribute() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertFromAttribute </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the string from <code>attr</code> into <code>storage</code>. </p>
<p>If <code>attr</code> is not a <code>StringAttr</code>, return failure and emit an error into the diagnostic from <code>emitError</code>. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00052">52</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">emitError()</a>.</p>

</div>
</div>
<a id="ab178e3da97c296703d0ae8f56436f802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab178e3da97c296703d0ae8f56436f802">&#9670;&nbsp;</a></span>convertFuncOpToLLVMFuncOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; LLVM::LLVMFuncOp &gt; mlir::convertFuncOpToLLVMFuncOp </td>
          <td>(</td>
          <td class="paramtype">FunctionOpInterface&#160;</td>
          <td class="paramname"><em>funcOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionPatternRewriter.html">ConversionPatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert input FunctionOpInterface operation to LLVMFuncOp by using the provided <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a>. </p>
<p>Return failure if failed to so. </p>

<p class="definition">Definition at line <a class="el" href="FuncToLLVM_8cpp_source.html#l00303">303</a> of file <a class="el" href="FuncToLLVM_8cpp_source.html">FuncToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00349">mlir::LLVMTypeConverter::convertFunctionSignature()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01504">mlir::ConversionPatternRewriter::convertRegionTypes()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02683">mlir::LLVMTypeConverter::convertType()</a>, <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00075">filterFuncAttributes()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">get()</a>, <a class="el" href="Builders_8cpp_source.html#l00297">mlir::Builder::getArrayAttr()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="DialectConversion_8h_source.html#l00079">mlir::TypeConverter::SignatureConversion::getInputMapping()</a>, <a class="el" href="Builders_8cpp_source.html#l00134">mlir::Builder::getNamedAttr()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00372">mlir::RewriterBase::inlineRegionBefore()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00063">linkageAttrName</a>, <a class="el" href="PatternMatch_8h_source.html#l00718">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00273">restoreByValRefArgumentType()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00067">shouldUseBarePtrCallConv()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00062">varargsAttrName</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00178">wrapExternalFunction()</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00118">wrapForExternalCallers()</a>.</p>

</div>
</div>
<a id="a23560b6de94f046854c32398b275f8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23560b6de94f046854c32398b275f8b6">&#9670;&nbsp;</a></span>convertMMAToLLVMType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVM::LLVMStructType</a> mlir::convertMMAToLLVMType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1gpu_1_1MMAMatrixType.html">gpu::MMAMatrixType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the LLVMStructureType corresponding to the MMAMatrixType <code>type</code>. </p>

<p class="definition">Definition at line <a class="el" href="WmmaOpsToNvvm_8cpp_source.html#l00379">379</a> of file <a class="el" href="WmmaOpsToNvvm_8cpp_source.html">WmmaOpsToNvvm.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVOps_8cpp_source.html#l00215">getElementType()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00452">mlir::LLVM::LLVMStructType::getLiteral()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00142">mlir::gpu::MMAMatrixType::getOperand()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00136">mlir::gpu::MMAMatrixType::getShape()</a>, and <a class="el" href="namespacemlir_1_1NVVM.html#af89f820490ad44f10442793c0f8f2258">mlir::NVVM::inferMMAType()</a>.</p>

</div>
</div>
<a id="a823e1a3f23ee77e276bee93e6313abb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823e1a3f23ee77e276bee93e6313abb1">&#9670;&nbsp;</a></span>convertOpResultTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::convertOpResultTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionPatternRewriter.html">ConversionPatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic utility to convert op result types according to type converter without knowing exact op type. </p>
<p>Clones existing op with new result types and returns it. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l02915">2915</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

</div>
</div>
<a id="a9b2799e8f52860dadc460b88a8f2df32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b2799e8f52860dadc460b88a8f2df32">&#9670;&nbsp;</a></span>convertReassociationIndicesToExprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2 &gt;, 2 &gt; mlir::convertReassociationIndicesToExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociationIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert reassociation indices to affine expressions. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00133">133</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00607">getAffineDimExpr()</a>.</p>

</div>
</div>
<a id="a59a9251459ba0d0ff0b94d3084e429c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a9251459ba0d0ff0b94d3084e429c4">&#9670;&nbsp;</a></span>convertReassociationMapsToIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a>, 2 &gt; mlir::convertReassociationMapsToIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ae5cf0e24a954fa30fb469105d4ca5dd8">ReassociationExprs</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociationExprs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert Array&lt;Array&lt;AffineExpr&gt;&gt; to Array&lt;Array&lt;int64_t&gt;&gt;. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00170">170</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

</div>
</div>
<a id="a10d383da63b1370b9cf5c13c252b391d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d383da63b1370b9cf5c13c252b391d">&#9670;&nbsp;</a></span>convertScalarToDtype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::convertScalarToDtype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>toType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isUnsignedCast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a scalar value <code>operand</code> to type <code>toType</code>. </p>
<p>If the value doesn't convert, a warning will be issued and the operand is returned as is (which will presumably yield a verification issue downstream). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00239">239</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00187">convertScalarToComplexDtype()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00167">convertScalarToFpDtype()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00141">convertScalarToIntDtype()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00334">emitWarning()</a>, and <a class="el" href="Value_8h_source.html#l00129">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00040">mlir::linalg::createMul()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00151">mlir::sparse_tensor::genCast()</a>.</p>

</div>
</div>
<a id="abd5c480f463f3ed7b6369caae8c8d366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5c480f463f3ed7b6369caae8c8d366">&#9670;&nbsp;</a></span>convertToAttribute() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::convertToAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the provided <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;int64_t&gt;</a> to a DenseI64ArrayAttr attribute. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00138">138</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00863">mlir::detail::DenseArrayAttrImpl&lt; T &gt;::get()</a>.</p>

</div>
</div>
<a id="a2aad04a9375046387a3f9a4bea0293ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aad04a9375046387a3f9a4bea0293ec">&#9670;&nbsp;</a></span>convertToAttribute() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::convertToAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given string into a BooleanAttr. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00076">76</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01153">mlir::BoolAttr::get()</a>.</p>

</div>
</div>
<a id="a68dfe2bb2693d4a826a40b0c0a7cc362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dfe2bb2693d4a826a40b0c0a7cc362">&#9670;&nbsp;</a></span>convertToAttribute() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::convertToAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given string into a StringAttr. </p>
<p>Note that this takes a reference to the storage of a string property, which is an std::string. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00061">61</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">get()</a>.</p>

</div>
</div>
<a id="adc7fea0a3f8193ef3ab5dd53c78968f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7fea0a3f8193ef3ab5dd53c78968f6">&#9670;&nbsp;</a></span>convertToAttribute() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::convertToAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the provided int32_t to an IntegerAttr attribute. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00047">47</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">get()</a>.</p>

</div>
</div>
<a id="ab81e61402439e0b78cd25dc4ad7eb591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81e61402439e0b78cd25dc4ad7eb591">&#9670;&nbsp;</a></span>convertToAttribute() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::convertToAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the provided int64_t to an IntegerAttr attribute. </p>

<p class="definition">Definition at line <a class="el" href="ODSSupport_8cpp_source.html#l00032">32</a> of file <a class="el" href="ODSSupport_8cpp_source.html">ODSSupport.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">get()</a>.</p>

</div>
</div>
<a id="a173b0b96100cbcbab8373ad93e33c86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173b0b96100cbcbab8373ad93e33c86d">&#9670;&nbsp;</a></span>convertToAttribute() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::convertToAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerOverflowFlags&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMDialect_8cpp_source.html#l00060">60</a> of file <a class="el" href="LLVMDialect_8cpp_source.html">LLVMDialect.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">get()</a>.</p>

</div>
</div>
<a id="af7d71d5f26ac7f264365e6fb7a6aadff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d71d5f26ac7f264365e6fb7a6aadff">&#9670;&nbsp;</a></span>convertVectorToMMAOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertVectorToMMAOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>rootOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert vector ops to MMA matrix operations nested under <code>rootOp</code>. </p>
<p>This will convert slice of operations that can be legally converted to MMA operations. The rest of the vector operations are left untouched. </p>

<p class="definition">Definition at line <a class="el" href="VectorToGPU_8cpp_source.html#l01240">1240</a> of file <a class="el" href="VectorToGPU_8cpp_source.html">VectorToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorToGPU_8cpp_source.html#l00343">getOpToConvert()</a>.</p>

</div>
</div>
<a id="a8d66f364335bd7ca0a98bb53f82f0a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d66f364335bd7ca0a98bb53f82f0a77">&#9670;&nbsp;</a></span>convertVectorToNVVMCompatibleMMASync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::convertVectorToNVVMCompatibleMMASync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>rootOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert vector ops ops nested under <code>rootOp</code> to vector and GPU operaitons compatible with the <code>nvvm.mma.sync</code> lowering path. </p>
<p>This will convert a slice of operations that can be legally lowered on this path while the rest of the vector operations are left untouched. </p>

<p class="definition">Definition at line <a class="el" href="VectorToGPU_8cpp_source.html#l01273">1273</a> of file <a class="el" href="VectorToGPU_8cpp_source.html">VectorToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorToGPU_8cpp_source.html#l00343">getOpToConvert()</a>.</p>

</div>
</div>
<a id="aec305cc3472323a62580de136ce81cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec305cc3472323a62580de136ce81cc3">&#9670;&nbsp;</a></span>createAffineForToGPUPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a>&lt; FunctionOpInterface &gt; &gt; mlir::createAffineForToGPUPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCFToGPUPass_8cpp_source.html#l00076">76</a> of file <a class="el" href="SCFToGPUPass_8cpp_source.html">SCFToGPUPass.cpp</a>.</p>

</div>
</div>
<a id="a0ec40c7aecb333928b9b4e9e409f0670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec40c7aecb333928b9b4e9e409f0670">&#9670;&nbsp;</a></span>createAffineForToGPUPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a>&lt; FunctionOpInterface &gt; &gt; mlir::createAffineForToGPUPass </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numBlockDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numThreadDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that converts loop nests into GPU kernels. </p>
<p>It considers top-level affine.for operations as roots of loop nests and converts them to the gpu.launch operations if possible.</p>
<p>No check on the size of the block or grid, or on the validity of parallelization is performed, it is under the responsibility of the caller to strip-mine the loops and to perform the dependence analysis before calling the conversion. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPUPass_8cpp_source.html#l00072">72</a> of file <a class="el" href="SCFToGPUPass_8cpp_source.html">SCFToGPUPass.cpp</a>.</p>

</div>
</div>
<a id="aef286aa7b84037b9a4b9b638c57d20c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef286aa7b84037b9a4b9b638c57d20c1">&#9670;&nbsp;</a></span>createAsyncFuncToAsyncRuntimePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createAsyncFuncToAsyncRuntimePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00906">906</a> of file <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html">AsyncToAsyncRuntime.cpp</a>.</p>

</div>
</div>
<a id="a4239fe8f68fb32a8788127f7a6850950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4239fe8f68fb32a8788127f7a6850950">&#9670;&nbsp;</a></span>createAsyncParallelForPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createAsyncParallelForPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncParallelFor_8cpp_source.html#l00943">943</a> of file <a class="el" href="AsyncParallelFor_8cpp_source.html">AsyncParallelFor.cpp</a>.</p>

</div>
</div>
<a id="a755ae56707350858331f8a2d72036f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755ae56707350858331f8a2d72036f86">&#9670;&nbsp;</a></span>createAsyncParallelForPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createAsyncParallelForPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>asyncDispatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>numWorkerThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>minTaskSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncParallelFor_8cpp_source.html#l00947">947</a> of file <a class="el" href="AsyncParallelFor_8cpp_source.html">AsyncParallelFor.cpp</a>.</p>

</div>
</div>
<a id="a89c5cda96fda85b96d4c5786f58680bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c5cda96fda85b96d4c5786f58680bd">&#9670;&nbsp;</a></span>createAsyncRuntimePolicyBasedRefCountingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createAsyncRuntimePolicyBasedRefCountingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html#l00563">563</a> of file <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html">AsyncRuntimeRefCounting.cpp</a>.</p>

</div>
</div>
<a id="ac29ec7fe477dccf07bddf61bec9c3ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29ec7fe477dccf07bddf61bec9c3ac7">&#9670;&nbsp;</a></span>createAsyncRuntimeRefCountingOptPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createAsyncRuntimeRefCountingOptPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncRuntimeRefCountingOpt_8cpp_source.html#l00234">234</a> of file <a class="el" href="AsyncRuntimeRefCountingOpt_8cpp_source.html">AsyncRuntimeRefCountingOpt.cpp</a>.</p>

</div>
</div>
<a id="ac74b480a928c4e1972270a410dd3e214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74b480a928c4e1972270a410dd3e214">&#9670;&nbsp;</a></span>createAsyncRuntimeRefCountingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createAsyncRuntimeRefCountingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html#l00559">559</a> of file <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html">AsyncRuntimeRefCounting.cpp</a>.</p>

</div>
</div>
<a id="acda37b3719dc71d8caddd1d39ca215db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda37b3719dc71d8caddd1d39ca215db">&#9670;&nbsp;</a></span>createAsyncToAsyncRuntimePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createAsyncToAsyncRuntimePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00901">901</a> of file <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html">AsyncToAsyncRuntime.cpp</a>.</p>

</div>
</div>
<a id="ae01b05ed73bc512e7ae40bc6d37ae1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01b05ed73bc512e7ae40bc6d37ae1a0">&#9670;&nbsp;</a></span>createBufferizationToMemRefPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createBufferizationToMemRefPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BufferizationToMemRef_8cpp_source.html#l00171">171</a> of file <a class="el" href="BufferizationToMemRef_8cpp_source.html">BufferizationToMemRef.cpp</a>.</p>

</div>
</div>
<a id="aab0069355214b578476e81bc909f7f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0069355214b578476e81bc909f7f13">&#9670;&nbsp;</a></span>createCanonicalizerPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createCanonicalizerPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the Canonicalizer pass, configured with default settings (which can be overridden by pass options on the command line). </p>
<p>Create a Canonicalizer pass. </p>

<p class="definition">Definition at line <a class="el" href="Canonicalizer_8cpp_source.html#l00074">74</a> of file <a class="el" href="Canonicalizer_8cpp_source.html">Canonicalizer.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TosaToLinalgPass_8cpp_source.html#l00081">mlir::tosa::addTosaToLinalgPasses()</a>, <a class="el" href="BufferizationPipelines_8cpp_source.html#l00021">mlir::bufferization::buildBufferDeallocationPipeline()</a>, <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00032">mlir::sparse_tensor::buildSparsifier()</a>, and <a class="el" href="InlinerPass_8cpp_source.html#l00032">defaultInlinerOptPipeline()</a>.</p>

</div>
</div>
<a id="a93c145cb37ca2bf4e90ceaff2231652f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c145cb37ca2bf4e90ceaff2231652f">&#9670;&nbsp;</a></span>createCanonicalizerPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createCanonicalizerPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>disabledPatterns</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>enabledPatterns</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the Canonicalizer pass with the specified config. </p>
<p><code>disabledPatterns</code> is a set of labels used to filter out input patterns with a debug label or debug name in this set. <code>enabledPatterns</code> is a set of labels used to filter out input patterns that do not have one of the labels in this set. Debug labels must be set explicitly on patterns or when adding them with <code><a class="el" href="classmlir_1_1RewritePatternSet.html#acfa4cea1d588753d077a407ef5681391" title="An overload of the above add method that allows for attaching a set of debug labels to the attached p...">RewritePatternSet::addWithLabel</a></code>. Debug names may be empty, but patterns created with <code><a class="el" href="classmlir_1_1RewritePattern.html#a2df499b22dc244d6c265e372a16db01b" title="This method provides a convenient interface for creating and initializing derived rewrite patterns of...">RewritePattern::create</a></code> have their default debug name set to their type name. </p>

<p class="definition">Definition at line <a class="el" href="Canonicalizer_8cpp_source.html#l00080">80</a> of file <a class="el" href="Canonicalizer_8cpp_source.html">Canonicalizer.cpp</a>.</p>

</div>
</div>
<a id="a60273f83d83a8fb7e5a1ceebb7a8d4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60273f83d83a8fb7e5a1ceebb7a8d4a6">&#9670;&nbsp;</a></span>createCompositeFixedPointPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createCompositeFixedPointPass </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>populateFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxIterations</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create composite pass, which runs provided set of passes until fixed point or maximum number of iterations reached. </p>

<p class="definition">Definition at line <a class="el" href="CompositePass_8cpp_source.html#l00099">99</a> of file <a class="el" href="CompositePass_8cpp_source.html">CompositePass.cpp</a>.</p>

</div>
</div>
<a id="ac1f1d125e949d2172433639f2f31d3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f1d125e949d2172433639f2f31d3e6">&#9670;&nbsp;</a></span>createControlFlowSinkPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createControlFlowSinkPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to perform control-flow sinking. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowSink_8cpp_source.html#l00056">56</a> of file <a class="el" href="ControlFlowSink_8cpp_source.html">ControlFlowSink.cpp</a>.</p>

</div>
</div>
<a id="a4e1b32f0e812af513c57185c972dc0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1b32f0e812af513c57185c972dc0ae">&#9670;&nbsp;</a></span>createConvertAMDGPUToROCDLPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertAMDGPUToROCDLPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l01079">1079</a> of file <a class="el" href="AMDGPUToROCDL_8cpp_source.html">AMDGPUToROCDL.cpp</a>.</p>

</div>
</div>
<a id="a4655b459042808cdaf22b54faf67aaf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4655b459042808cdaf22b54faf67aaf6">&#9670;&nbsp;</a></span>createConvertArmNeon2dToIntrPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertArmNeon2dToIntrPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to lower Arm NEON 2D ops to intrinsics, i.e. </p>
<p>equivalent ops operating on flattened 1D vectors and mapping more directly to the corresponding Arm NEON instruction. </p>

<p class="definition">Definition at line <a class="el" href="ArmNeon2dToIntr_8cpp_source.html#l00074">74</a> of file <a class="el" href="ArmNeon2dToIntr_8cpp_source.html">ArmNeon2dToIntr.cpp</a>.</p>

</div>
</div>
<a id="a0d03e883b6465225cf16db9093a723a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d03e883b6465225cf16db9093a723a4">&#9670;&nbsp;</a></span>createConvertArmSMEToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertArmSMEToLLVMPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dumpTileLiveRanges</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert from the ArmSME dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8cpp_source.html#l01021">1021</a> of file <a class="el" href="ArmSMEToLLVM_8cpp_source.html">ArmSMEToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a09aec6549507dfd07b98e4afb14e7c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09aec6549507dfd07b98e4afb14e7c5e">&#9670;&nbsp;</a></span>createConvertArmSMEToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertArmSMEToSCFPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert a subset of ArmSME ops to SCF. </p>

<p class="definition">Definition at line <a class="el" href="ArmSMEToSCF_8cpp_source.html#l00416">416</a> of file <a class="el" href="ArmSMEToSCF_8cpp_source.html">ArmSMEToSCF.cpp</a>.</p>

</div>
</div>
<a id="a1c3204f9ba36eb541a03f8bf0ed4a9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3204f9ba36eb541a03f8bf0ed4a9a7">&#9670;&nbsp;</a></span>createConvertComplexToLibmPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertComplexToLibmPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Complex operations to libm calls. </p>

<p class="definition">Definition at line <a class="el" href="ComplexToLibm_8cpp_source.html#l00148">148</a> of file <a class="el" href="ComplexToLibm_8cpp_source.html">ComplexToLibm.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00032">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="ad891730d98fe42a400b188049ff923f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad891730d98fe42a400b188049ff923f2">&#9670;&nbsp;</a></span>createConvertComplexToStandardPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertComplexToStandardPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Complex operations to the Standard dialect. </p>

<p class="definition">Definition at line <a class="el" href="ComplexToStandard_8cpp_source.html#l01362">1362</a> of file <a class="el" href="ComplexToStandard_8cpp_source.html">ComplexToStandard.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00032">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="a3d0b6795b3be074dc19b6445f2cc687a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0b6795b3be074dc19b6445f2cc687a">&#9670;&nbsp;</a></span>createConvertControlFlowToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt; mlir::createConvertControlFlowToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert ControlFlow ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowToSPIRVPass_8cpp_source.html#l00056">56</a> of file <a class="el" href="ControlFlowToSPIRVPass_8cpp_source.html">ControlFlowToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a1face754eadd25641ccf594efd52ba7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1face754eadd25641ccf594efd52ba7b">&#9670;&nbsp;</a></span>createConvertFuncToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt; mlir::createConvertFuncToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert Func ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="FuncToSPIRVPass_8cpp_source.html#l00054">54</a> of file <a class="el" href="FuncToSPIRVPass_8cpp_source.html">FuncToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="ad39c9d3321b2f5f4aee088b02b535f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39c9d3321b2f5f4aee088b02b535f9b">&#9670;&nbsp;</a></span>createConvertGpuLaunchFuncToVulkanLaunchFuncPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::ModuleOp &gt; &gt; mlir::createConvertGpuLaunchFuncToVulkanLaunchFuncPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertGPULaunchFuncToVulkanLaunchFunc_8cpp_source.html#l00209">209</a> of file <a class="el" href="ConvertGPULaunchFuncToVulkanLaunchFunc_8cpp_source.html">ConvertGPULaunchFuncToVulkanLaunchFunc.cpp</a>.</p>

</div>
</div>
<a id="a112698688acfebc3284b59e6ffa4d155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112698688acfebc3284b59e6ffa4d155">&#9670;&nbsp;</a></span>createConvertGPUToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertGPUToSPIRVPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mapMemorySpace</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert GPU kernel ops to corresponding SPIR-V ops. </p>
<p>For a gpu.func to be converted, it should have a spirv.entry_point_abi attribute. If <code>mapMemorySpace</code> is true, performs MemRef memory space to SPIR-V mapping according to default Vulkan rules first. </p>

<p class="definition">Definition at line <a class="el" href="GPUToSPIRVPass_8cpp_source.html#l00165">165</a> of file <a class="el" href="GPUToSPIRVPass_8cpp_source.html">GPUToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="aefb33f39a4ad0d4d52396f132bee84cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb33f39a4ad0d4d52396f132bee84cf">&#9670;&nbsp;</a></span>createConvertLinalgToStandardPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertLinalgToStandardPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations to the Standard dialect. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToStandard_8cpp_source.html#l00155">155</a> of file <a class="el" href="LinalgToStandard_8cpp_source.html">LinalgToStandard.cpp</a>.</p>

</div>
</div>
<a id="aa0be8ab8e597910498a4a64215faa2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0be8ab8e597910498a4a64215faa2fb">&#9670;&nbsp;</a></span>createConvertMathToLibmPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertMathToLibmPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Math operations to libm calls. </p>

<p class="definition">Definition at line <a class="el" href="MathToLibm_8cpp_source.html#l00221">221</a> of file <a class="el" href="MathToLibm_8cpp_source.html">MathToLibm.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00032">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="a10c8995bd3756d7b1e15813d96b2b2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c8995bd3756d7b1e15813d96b2b2ad">&#9670;&nbsp;</a></span>createConvertMathToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt; mlir::createConvertMathToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert Math ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="MathToSPIRVPass_8cpp_source.html#l00056">56</a> of file <a class="el" href="MathToSPIRVPass_8cpp_source.html">MathToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a3bec430062ec4285c83eccbab6ebbe29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bec430062ec4285c83eccbab6ebbe29">&#9670;&nbsp;</a></span>createConvertMemRefToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt; mlir::createConvertMemRefToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert MemRef ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="MemRefToSPIRVPass_8cpp_source.html#l00058">58</a> of file <a class="el" href="MemRefToSPIRVPass_8cpp_source.html">MemRefToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a3c1dc4bc47a3830e063b709a36e0ab91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1dc4bc47a3830e063b709a36e0ab91">&#9670;&nbsp;</a></span>createConvertOpenACCToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertOpenACCToSCFPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert the OpenACC dialect into the LLVMIR dialect. </p>

<p class="definition">Definition at line <a class="el" href="OpenACCToSCF_8cpp_source.html#l00098">98</a> of file <a class="el" href="OpenACCToSCF_8cpp_source.html">OpenACCToSCF.cpp</a>.</p>

</div>
</div>
<a id="a877c34cdb063f52ff5ea4efd82807621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877c34cdb063f52ff5ea4efd82807621">&#9670;&nbsp;</a></span>createConvertSCFToCFPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertSCFToCFPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert SCF operations to CFG branch-based operation in the ControlFlow dialect. </p>

<p class="definition">Definition at line <a class="el" href="SCFToControlFlow_8cpp_source.html#l00730">730</a> of file <a class="el" href="SCFToControlFlow_8cpp_source.html">SCFToControlFlow.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00032">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="a74c87a4d7e914dda62d03a97cf7e8963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c87a4d7e914dda62d03a97cf7e8963">&#9670;&nbsp;</a></span>createConvertSCFToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt; mlir::createConvertSCFToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert SCF ops into SPIR-V ops. </p>

</div>
</div>
<a id="ac85b8b89468b7fc2b347d361b512e8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85b8b89468b7fc2b347d361b512e8d3">&#9670;&nbsp;</a></span>createConvertShapeConstraintsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertShapeConstraintsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertShapeConstraints_8cpp_source.html#l00071">71</a> of file <a class="el" href="ConvertShapeConstraints_8cpp_source.html">ConvertShapeConstraints.cpp</a>.</p>

</div>
</div>
<a id="abc9ecc9afba558cb026032d0453a7c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9ecc9afba558cb026032d0453a7c95">&#9670;&nbsp;</a></span>createConvertShapeToStandardPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertShapeToStandardPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ShapeToStandard_8cpp_source.html#l00732">732</a> of file <a class="el" href="ShapeToStandard_8cpp_source.html">ShapeToStandard.cpp</a>.</p>

</div>
</div>
<a id="a2ff30b5a742e19dd8d8fea41d953fbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff30b5a742e19dd8d8fea41d953fbe4">&#9670;&nbsp;</a></span>createConvertTensorToLinalgPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertTensorToLinalgPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert Tensor ops to Linalg ops. </p>

<p class="definition">Definition at line <a class="el" href="TensorToLinalgPass_8cpp_source.html#l00050">50</a> of file <a class="el" href="TensorToLinalgPass_8cpp_source.html">TensorToLinalgPass.cpp</a>.</p>

</div>
</div>
<a id="a81d3655f76a6db563fa528a741573691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d3655f76a6db563fa528a741573691">&#9670;&nbsp;</a></span>createConvertTensorToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt; mlir::createConvertTensorToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert Tensor ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="TensorToSPIRVPass_8cpp_source.html#l00057">57</a> of file <a class="el" href="TensorToSPIRVPass_8cpp_source.html">TensorToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a586ff454b60cac278bed38d19b5cbdb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586ff454b60cac278bed38d19b5cbdb2">&#9670;&nbsp;</a></span>createConvertToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that performs dialect conversion to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> for all dialects implementing <code><a class="el" href="classmlir_1_1ConvertToLLVMPatternInterface.html" title="Base class for dialect interfaces providing translation to LLVM IR.">ConvertToLLVMPatternInterface</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToLLVMPass_8cpp_source.html#l00134">134</a> of file <a class="el" href="ConvertToLLVMPass_8cpp_source.html">ConvertToLLVMPass.cpp</a>.</p>

</div>
</div>
<a id="a1e6248f4bc8957bd0e7339b5de636be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6248f4bc8957bd0e7339b5de636be1">&#9670;&nbsp;</a></span>createConvertVectorToArmSMEPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertVectorToArmSMEPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to lower operations from the vector dialect to Arm SME. </p>

<p class="definition">Definition at line <a class="el" href="VectorToArmSMEPass_8cpp_source.html#l00039">39</a> of file <a class="el" href="VectorToArmSMEPass_8cpp_source.html">VectorToArmSMEPass.cpp</a>.</p>

</div>
</div>
<a id="ad3e64d4460362ea3cdb2edc8b746396c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e64d4460362ea3cdb2edc8b746396c">&#9670;&nbsp;</a></span>createConvertVectorToGPUPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertVectorToGPUPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useNvGpu</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert from vector to GPU ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorToGPU_8cpp_source.html#l01344">1344</a> of file <a class="el" href="VectorToGPU_8cpp_source.html">VectorToGPU.cpp</a>.</p>

</div>
</div>
<a id="ac5c71e471d7d8cdda288a27d1ae75642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c71e471d7d8cdda288a27d1ae75642">&#9670;&nbsp;</a></span>createConvertVectorToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertVectorToSCFPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert a subset of vector ops to SCF. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSCF_8cpp_source.html#l01745">1745</a> of file <a class="el" href="VectorToSCF_8cpp_source.html">VectorToSCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00032">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="a8113c1109f8cc9f8d47492fce5d7723f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8113c1109f8cc9f8d47492fce5d7723f">&#9670;&nbsp;</a></span>createConvertVectorToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt; mlir::createConvertVectorToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert <a class="el" href="structVector.html">Vector</a> Ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSPIRVPass_8cpp_source.html#l00056">56</a> of file <a class="el" href="VectorToSPIRVPass_8cpp_source.html">VectorToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="acbd10dfc8f20e1f212be133738228aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd10dfc8f20e1f212be133738228aaf">&#9670;&nbsp;</a></span>createConvertVectorToXeGPUPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertVectorToXeGPUPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert ops from vector to XeGPU. </p>

<p class="definition">Definition at line <a class="el" href="VectorToXeGPU_8cpp_source.html#l00329">329</a> of file <a class="el" href="VectorToXeGPU_8cpp_source.html">VectorToXeGPU.cpp</a>.</p>

</div>
</div>
<a id="a14895da9723acd9c7f910c2694ff9f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14895da9723acd9c7f910c2694ff9f65">&#9670;&nbsp;</a></span>createCSEPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createCSEPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to perform common sub expression elimination. </p>

<p class="definition">Definition at line <a class="el" href="CSE_8cpp_source.html#l00416">416</a> of file <a class="el" href="CSE_8cpp_source.html">CSE.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizationPipelines_8cpp_source.html#l00021">mlir::bufferization::buildBufferDeallocationPipeline()</a>.</p>

</div>
</div>
<a id="a7c4ce1ebc47dbd367b9b8b19ceeafcb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4ce1ebc47dbd367b9b8b19ceeafcb3">&#9670;&nbsp;</a></span>createElementwiseOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::createElementwiseOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionPatternRewriter.html">ConversionPatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpu::SubgroupMmaElementwiseOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>coopType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a SPIR-V op to replace the given GPU subgroup mma elementwise op when the elementwise op directly supports with cooperative matrix type. </p>
<p>Returns false if cannot.</p>
<p>See SPV_KHR_cooperative_matrix for supported elementwise ops. </p>

<p class="definition">Definition at line <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html#l00043">43</a> of file <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html">WmmaOpsToSPIRV.cpp</a>.</p>

</div>
</div>
<a id="a20e00e282baf336b34a2bb6252d163b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e00e282baf336b34a2bb6252d163b3">&#9670;&nbsp;</a></span>createForallToForLoopPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createForallToForLoopPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that converts SCF forall loops to SCF for loops. </p>

<p class="definition">Definition at line <a class="el" href="ForallToFor_8cpp_source.html#l00072">72</a> of file <a class="el" href="ForallToFor_8cpp_source.html">ForallToFor.cpp</a>.</p>

</div>
</div>
<a id="a0fe217f8821de800b3899f931875c1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe217f8821de800b3899f931875c1c4">&#9670;&nbsp;</a></span>createForallToParallelLoopPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createForallToParallelLoopPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that converts SCF forall loops to SCF parallel loops. </p>

<p class="definition">Definition at line <a class="el" href="ForallToParallel_8cpp_source.html#l00081">81</a> of file <a class="el" href="ForallToParallel_8cpp_source.html">ForallToParallel.cpp</a>.</p>

</div>
</div>
<a id="a7acfeadb8fff74a53be77ccf540be99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acfeadb8fff74a53be77ccf540be99b">&#9670;&nbsp;</a></span>createForLoopPeelingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createForLoopPeelingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that peels for loops at their upper bounds for better vectorization. </p>

<p class="definition">Definition at line <a class="el" href="LoopSpecialization_8cpp_source.html#l00354">354</a> of file <a class="el" href="LoopSpecialization_8cpp_source.html">LoopSpecialization.cpp</a>.</p>

</div>
</div>
<a id="a2a6597022fdb6de5a99b895b2bfc9e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6597022fdb6de5a99b895b2bfc9e0a">&#9670;&nbsp;</a></span>createForLoopRangeFoldingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createForLoopRangeFoldingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which folds arith ops on induction variable into loop range. </p>

<p class="definition">Definition at line <a class="el" href="LoopRangeFolding_8cpp_source.html#l00089">89</a> of file <a class="el" href="LoopRangeFolding_8cpp_source.html">LoopRangeFolding.cpp</a>.</p>

</div>
</div>
<a id="a1d49e4ae28aeaaa552466850cc5e04ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d49e4ae28aeaaa552466850cc5e04ec">&#9670;&nbsp;</a></span>createForLoopSpecializationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createForLoopSpecializationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that specializes for loop for unrolling and vectorization. </p>

<p class="definition">Definition at line <a class="el" href="LoopSpecialization_8cpp_source.html#l00350">350</a> of file <a class="el" href="LoopSpecialization_8cpp_source.html">LoopSpecialization.cpp</a>.</p>

</div>
</div>
<a id="a76018eef454fd668d103ea3cc6afc52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76018eef454fd668d103ea3cc6afc52a">&#9670;&nbsp;</a></span>createForToWhileLoopPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createForToWhileLoopPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ForToWhile_8cpp_source.html#l00120">120</a> of file <a class="el" href="ForToWhile_8cpp_source.html">ForToWhile.cpp</a>.</p>

</div>
</div>
<a id="a6fdd2528f381177f9ded6de5eba9900b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fdd2528f381177f9ded6de5eba9900b">&#9670;&nbsp;</a></span>createGenerateRuntimeVerificationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createGenerateRuntimeVerificationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that generates IR to verify ops at runtime. </p>

<p class="definition">Definition at line <a class="el" href="GenerateRuntimeVerification_8cpp_source.html#l00038">38</a> of file <a class="el" href="GenerateRuntimeVerification_8cpp_source.html">GenerateRuntimeVerification.cpp</a>.</p>

</div>
</div>
<a id="a8bd2637570ab4c74519de8ed73747b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd2637570ab4c74519de8ed73747b5f">&#9670;&nbsp;</a></span>createGpuAsyncRegionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createGpuAsyncRegionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrites a function region so that GPU ops execute asynchronously. </p>

<p class="definition">Definition at line <a class="el" href="AsyncRegionRewriter_8cpp_source.html#l00351">351</a> of file <a class="el" href="AsyncRegionRewriter_8cpp_source.html">AsyncRegionRewriter.cpp</a>.</p>

</div>
</div>
<a id="a94f5fa04ae55102b2acaeb79274545da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f5fa04ae55102b2acaeb79274545da">&#9670;&nbsp;</a></span>createGpuDecomposeMemrefsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createGpuDecomposeMemrefsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> decomposes memref ops inside <code>gpu.launch</code> body. </p>

<p class="definition">Definition at line <a class="el" href="DecomposeMemRefs_8cpp_source.html#l00232">232</a> of file <a class="el" href="DecomposeMemRefs_8cpp_source.html">DecomposeMemRefs.cpp</a>.</p>

</div>
</div>
<a id="ae628f55b8a69b490ef848ceb63d234b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae628f55b8a69b490ef848ceb63d234b9">&#9670;&nbsp;</a></span>createGpuKernelOutliningPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createGpuKernelOutliningPass </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>dataLayoutStr</em> = <code>StringRef()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces <code>gpu.launch</code> with <code>gpu.launch_func</code> by moving the region into a separate kernel function. </p>

<p class="definition">Definition at line <a class="el" href="KernelOutlining_8cpp_source.html#l00453">453</a> of file <a class="el" href="KernelOutlining_8cpp_source.html">KernelOutlining.cpp</a>.</p>

</div>
</div>
<a id="a66200178a198c2f8aae15e94882f0788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66200178a198c2f8aae15e94882f0788">&#9670;&nbsp;</a></span>createGpuLauchSinkIndexComputationsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createGpuLauchSinkIndexComputationsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> that moves ops which are likely an index computation into gpu.launch body. </p>

<p class="definition">Definition at line <a class="el" href="KernelOutlining_8cpp_source.html#l00448">448</a> of file <a class="el" href="KernelOutlining_8cpp_source.html">KernelOutlining.cpp</a>.</p>

</div>
</div>
<a id="acc65540e2fcc88965c99cf18236192b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc65540e2fcc88965c99cf18236192b4">&#9670;&nbsp;</a></span>createGpuMapParallelLoopsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::func::FuncOp &gt; &gt; mlir::createGpuMapParallelLoopsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps the parallel loops found in the given function to workgroups. </p>
<p>The first loop encountered will be mapped to the global workgroup and the second loop encountered to the local workgroup. Within each mapping, the first three dimensions are mapped to x/y/z hardware ids and all following dimensions are mapped to sequential loops. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopMapper_8cpp_source.html#l00151">151</a> of file <a class="el" href="ParallelLoopMapper_8cpp_source.html">ParallelLoopMapper.cpp</a>.</p>

</div>
</div>
<a id="a6c6ad0644a283c257d1fbc15be6adc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6ad0644a283c257d1fbc15be6adc18">&#9670;&nbsp;</a></span>createInlinerPass() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createInlinerPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which inlines calls and callable operations as defined by the <a class="el" href="classmlir_1_1CallGraph.html">CallGraph</a>. </p>

<p class="definition">Definition at line <a class="el" href="InlinerPass_8cpp_source.html#l00186">186</a> of file <a class="el" href="InlinerPass_8cpp_source.html">InlinerPass.cpp</a>.</p>

</div>
</div>
<a id="a1372ce1294d9b98b652930aa6baf1386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1372ce1294d9b98b652930aa6baf1386">&#9670;&nbsp;</a></span>createInlinerPass() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createInlinerPass </td>
          <td>(</td>
          <td class="paramtype">llvm::StringMap&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt;&#160;</td>
          <td class="paramname"><em>opPipelines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the inliner pass, and use the provided pass managers when optimizing callable operations with names matching the key type. </p>
<p>Callable operations with a name not within the provided map will use the default inliner pipeline during optimization. </p>

<p class="definition">Definition at line <a class="el" href="InlinerPass_8cpp_source.html#l00190">190</a> of file <a class="el" href="InlinerPass_8cpp_source.html">InlinerPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="InlinerPass_8cpp_source.html#l00032">defaultInlinerOptPipeline()</a>.</p>

</div>
</div>
<a id="a282d4666d1a10f4c41e6b114bf5e6a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282d4666d1a10f4c41e6b114bf5e6a7f">&#9670;&nbsp;</a></span>createInlinerPass() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createInlinerPass </td>
          <td>(</td>
          <td class="paramtype">llvm::StringMap&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt;&#160;</td>
          <td class="paramname"><em>opPipelines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>defaultPipelineBuilder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the inliner pass, and use the provided pass managers when optimizing callable operations with names matching the key type. </p>
<p>Callable operations with a name not within the provided map will use the provided default pipeline builder. </p>

<p class="definition">Definition at line <a class="el" href="InlinerPass_8cpp_source.html#l00194">194</a> of file <a class="el" href="InlinerPass_8cpp_source.html">InlinerPass.cpp</a>.</p>

</div>
</div>
<a id="abb0bdadbeb0d7f5b8cef57668447640b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0bdadbeb0d7f5b8cef57668447640b">&#9670;&nbsp;</a></span>createLocationSnapshotPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLocationSnapshotPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload utilizing pass options for initialization. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00157">157</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

</div>
</div>
<a id="a415fbf6253902c584461fa6a43a59ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415fbf6253902c584461fa6a43a59ad5">&#9670;&nbsp;</a></span>createLocationSnapshotPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLocationSnapshotPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>fileName</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>tag</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to generate new locations by snapshotting the IR to the given file, and using the printed locations within that file. </p>
<p>If <code>filename</code> is empty, a temporary file is generated instead. If a 'tag' is non-empty, the generated locations are represented as a NameLoc with the given tag as the name, and then fused with the existing locations. Otherwise, the existing locations are replaced. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00152">152</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

</div>
</div>
<a id="a319fde65e573dbc3a947d58196cb2b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319fde65e573dbc3a947d58196cb2b3a">&#9670;&nbsp;</a></span>createLoopInvariantCodeMotionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLoopInvariantCodeMotionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop invariant code motion pass that hoists loop invariant instructions out of the loop. </p>

<p class="definition">Definition at line <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html#l00060">60</a> of file <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html">LoopInvariantCodeMotion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="acf61282117a610660819cb15624637d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf61282117a610660819cb15624637d6">&#9670;&nbsp;</a></span>createLoopInvariantSubsetHoistingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLoopInvariantSubsetHoistingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that hoists loop-invariant subset ops. </p>

<p class="definition">Definition at line <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html#l00064">64</a> of file <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html">LoopInvariantCodeMotion.cpp</a>.</p>

</div>
</div>
<a id="ae09ce34232ab009ce688d7cdc63695a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09ce34232ab009ce688d7cdc63695a8">&#9670;&nbsp;</a></span>createLowerAffinePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLowerAffinePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lowers affine control flow operations (ForStmt, IfStmt and AffineApplyOp) to equivalent lower-level constructs (flow of basic blocks and arithmetic primitives). </p>
<p>Lowers If and For operations within a function into their lower level CFG equivalent blocks. </p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00575">575</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00032">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="aaa0dbcff2285d9b5fc43c67189e783d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0dbcff2285d9b5fc43c67189e783d6">&#9670;&nbsp;</a></span>createLowerForeachToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLowerForeachToSCFPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00462">462</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a6cb6ab100d4d15861d7ed00e702ff0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb6ab100d4d15861d7ed00e702ff0ed">&#9670;&nbsp;</a></span>createLowerGpuOpsToROCDLOpsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; gpu::GPUModuleOp &gt; &gt; mlir::createLowerGpuOpsToROCDLOpsPass </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>chipset</em> = <code>&quot;gfx900&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>indexBitwidth</em> = <code><a class="el" href="namespacemlir.html#a2887883f00b094c5ca61c631d7b093a0">kDeriveIndexBitwidthFromDataLayout</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useBarePtrCallConv</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1gpu_1_1amd.html#a8637afbd01b984be30dbd1cdb78ae45f">gpu::amd::Runtime</a>&#160;</td>
          <td class="paramname"><em>runtime</em> = <code>gpu::amd::Runtime::Unknown</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that lowers GPU dialect operations to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> counterparts. </p>
<p>The index bitwidth used for the lowering of the device side index computations is configurable. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00401">401</a> of file <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html">LowerGpuOpsToROCDLOps.cpp</a>.</p>

</div>
</div>
<a id="ab956888e7892e8d37b40f660d2ab3222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab956888e7892e8d37b40f660d2ab3222">&#9670;&nbsp;</a></span>createLowerSparseIterationToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLowerSparseIterationToSCFPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00466">466</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a0c927ead951ebddddb979353f1ddda9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c927ead951ebddddb979353f1ddda9e">&#9670;&nbsp;</a></span>createLowerSparseOpsToForeachPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLowerSparseOpsToForeachPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00453">453</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a93efca2366cbf131cf7359f94cc5f2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93efca2366cbf131cf7359f94cc5f2a5">&#9670;&nbsp;</a></span>createLowerSparseOpsToForeachPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLowerSparseOpsToForeachPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableRT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableConvert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00458">458</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

</div>
</div>
<a id="a0c5b68602e237b1c1c3209ae71184cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5b68602e237b1c1c3209ae71184cd2">&#9670;&nbsp;</a></span>createMapMemRefStorageClassPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt; mlir::createMapMemRefStorageClassPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to map numeric MemRef memory spaces to symbolic SPIR-V storage classes. </p>
<p>The mapping is read from the command-line option. </p>

<p class="definition">Definition at line <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00326">326</a> of file <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html">MapMemRefStorageClassPass.cpp</a>.</p>

</div>
</div>
<a id="a87060fc8d3ef747e189053c6bd556a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87060fc8d3ef747e189053c6bd556a5a">&#9670;&nbsp;</a></span>createOptReductionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createOptReductionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OptReductionPass_8cpp_source.html#l00090">90</a> of file <a class="el" href="OptReductionPass_8cpp_source.html">OptReductionPass.cpp</a>.</p>

</div>
</div>
<a id="a4bb4bec758f757740b983d352319eccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb4bec758f757740b983d352319eccb">&#9670;&nbsp;</a></span>createOutlineShapeComputationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createOutlineShapeComputationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outline the shape computation part by adding shape.func and populate conrresponding mapping infomation into ShapeMappingAnalysis. </p>

<p class="definition">Definition at line <a class="el" href="OutlineShapeComputation_8cpp_source.html#l00329">329</a> of file <a class="el" href="OutlineShapeComputation_8cpp_source.html">OutlineShapeComputation.cpp</a>.</p>

</div>
</div>
<a id="ad00701d01638289dd08ec9e255076f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00701d01638289dd08ec9e255076f50">&#9670;&nbsp;</a></span>createParallelLoopFusionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createParallelLoopFusionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop fusion pass which fuses parallel loops. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00285">285</a> of file <a class="el" href="ParallelLoopFusion_8cpp_source.html">ParallelLoopFusion.cpp</a>.</p>

</div>
</div>
<a id="a16b9f8678ec66eed9c66536834540184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b9f8678ec66eed9c66536834540184">&#9670;&nbsp;</a></span>createParallelLoopSpecializationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createParallelLoopSpecializationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that specializes parallel loop for unrolling and vectorization. </p>

<p class="definition">Definition at line <a class="el" href="LoopSpecialization_8cpp_source.html#l00346">346</a> of file <a class="el" href="LoopSpecialization_8cpp_source.html">LoopSpecialization.cpp</a>.</p>

</div>
</div>
<a id="a1e453b62efd8209d12c5c0f43c409952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e453b62efd8209d12c5c0f43c409952">&#9670;&nbsp;</a></span>createParallelLoopTilingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">Pass</a>&gt; mlir::createParallelLoopTilingPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>tileSize</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noMinMaxBounds</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which tiles innermost parallel loops. </p>
<p>If noMinMaxBounds, the upper bound of the inner loop will be a same value among different outter loop iterations, and an additional inbound check will be emitted inside the internal loops. </p>

</div>
</div>
<a id="aa2f36107d7ffc6c1f873c746385d9de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f36107d7ffc6c1f873c746385d9de0">&#9670;&nbsp;</a></span>createParallelLoopToGpuPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createParallelLoopToGpuPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that converts scf.parallel operations into a gpu.launch operation. </p>
<p>The mapping of loop dimensions to launch dimensions is derived from mapping attributes. See ParallelToGpuLaunchLowering::matchAndRewrite for a description of the used attributes. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPUPass_8cpp_source.html#l00080">80</a> of file <a class="el" href="SCFToGPUPass_8cpp_source.html">SCFToGPUPass.cpp</a>.</p>

</div>
</div>
<a id="af882e712b4e426905d73c1c74bd0f353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af882e712b4e426905d73c1c74bd0f353">&#9670;&nbsp;</a></span>createPDLToPDLInterpPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createPDLToPDLInterpPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a pass to convert PDL ops to PDL interpreter ops. </p>

<p class="definition">Definition at line <a class="el" href="PDLToPDLInterp_8cpp_source.html#l01016">1016</a> of file <a class="el" href="PDLToPDLInterp_8cpp_source.html">PDLToPDLInterp.cpp</a>.</p>

</div>
</div>
<a id="ae7b51cc369e6be47cad63fe35c030ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b51cc369e6be47cad63fe35c030ca3">&#9670;&nbsp;</a></span>createPDLToPDLInterpPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createPDLToPDLInterpPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, PDLPatternConfigSet * &gt; &amp;&#160;</td>
          <td class="paramname"><em>configMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a pass to convert PDL ops to PDL interpreter ops. </p>
<p><code>configMap</code> holds a map of the configurations for each pattern being compiled. </p>

<p class="definition">Definition at line <a class="el" href="PDLToPDLInterp_8cpp_source.html#l01019">1019</a> of file <a class="el" href="PDLToPDLInterp_8cpp_source.html">PDLToPDLInterp.cpp</a>.</p>

</div>
</div>
<a id="aa6abc74515648dc477ae4f5af8cbf310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6abc74515648dc477ae4f5af8cbf310">&#9670;&nbsp;</a></span>createPreSparsificationRewritePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createPreSparsificationRewritePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00436">436</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a0a84c3fae02e7540b0db48350b738be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a84c3fae02e7540b0db48350b738be1">&#9670;&nbsp;</a></span>createPrintIRPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createPrintIRPass </td>
          <td>(</td>
          <td class="paramtype">const PrintIRPassOptions &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to print IR on the debug stream. </p>

<p class="definition">Definition at line <a class="el" href="PrintIR_8cpp_source.html#l00034">34</a> of file <a class="el" href="PrintIR_8cpp_source.html">PrintIR.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a045e1f32a8d90260d292aad61149c0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045e1f32a8d90260d292aad61149c0ef">&#9670;&nbsp;</a></span>createPrintOpGraphPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createPrintOpGraphPass </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>llvm::errs()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to print op graphs. </p>

<p class="definition">Definition at line <a class="el" href="ViewOpGraph_8cpp_source.html#l00364">364</a> of file <a class="el" href="ViewOpGraph_8cpp_source.html">ViewOpGraph.cpp</a>.</p>

</div>
</div>
<a id="a738190b0f29ddc52ba6847cb310eb60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a738190b0f29ddc52ba6847cb310eb60d">&#9670;&nbsp;</a></span>createPrintOpStatsPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createPrintOpStatsPass </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>printAsJSON</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which prints the list of ops and the number of occurrences in the module with the output format option. </p>

<p class="definition">Definition at line <a class="el" href="OpStats_8cpp_source.html#l00120">120</a> of file <a class="el" href="OpStats_8cpp_source.html">OpStats.cpp</a>.</p>

</div>
</div>
<a id="ab56d49b89c1f203d6fa20f126bf4d900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56d49b89c1f203d6fa20f126bf4d900">&#9670;&nbsp;</a></span>createPrintOpStatsPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createPrintOpStatsPass </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>llvm::errs()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which prints the list of ops and the number of occurrences in the module. </p>

<p class="definition">Definition at line <a class="el" href="OpStats_8cpp_source.html#l00116">116</a> of file <a class="el" href="OpStats_8cpp_source.html">OpStats.cpp</a>.</p>

</div>
</div>
<a id="aab06609d5a7ea6d475070dcc8d271725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab06609d5a7ea6d475070dcc8d271725">&#9670;&nbsp;</a></span>createReconcileUnrealizedCastsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createReconcileUnrealizedCastsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that eliminates noop <code>unrealized_conversion_cast</code> operation sequences. </p>

<p class="definition">Definition at line <a class="el" href="ReconcileUnrealizedCasts_8cpp_source.html#l00052">52</a> of file <a class="el" href="ReconcileUnrealizedCasts_8cpp_source.html">ReconcileUnrealizedCasts.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00032">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="a4ed5140e30c6e204e8bdc35d08d0eb08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed5140e30c6e204e8bdc35d08d0eb08">&#9670;&nbsp;</a></span>createReductionTreePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createReductionTreePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ReductionTreePass_8cpp_source.html#l00259">259</a> of file <a class="el" href="ReductionTreePass_8cpp_source.html">ReductionTreePass.cpp</a>.</p>

</div>
</div>
<a id="ab17b2f115a7d8025fb9d5eacf14368b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17b2f115a7d8025fb9d5eacf14368b3">&#9670;&nbsp;</a></span>createRemoveDeadValuesPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createRemoveDeadValuesPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an optimization pass to remove dead values. </p>

<p class="definition">Definition at line <a class="el" href="RemoveDeadValues_8cpp_source.html#l00611">611</a> of file <a class="el" href="RemoveDeadValues_8cpp_source.html">RemoveDeadValues.cpp</a>.</p>

</div>
</div>
<a id="ad79c79f5d3c3fd8668be6d76e33bad9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79c79f5d3c3fd8668be6d76e33bad9a">&#9670;&nbsp;</a></span>createRemoveShapeConstraintsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createRemoveShapeConstraintsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RemoveShapeConstraints_8cpp_source.html#l00070">70</a> of file <a class="el" href="RemoveShapeConstraints_8cpp_source.html">RemoveShapeConstraints.cpp</a>.</p>

</div>
</div>
<a id="acd7b8f0656a50e3147f888f41325b8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7b8f0656a50e3147f888f41325b8bb">&#9670;&nbsp;</a></span>createScalarOrSplatConstant() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::createScalarOrSplatConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const APFloat &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00296">296</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00528">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00901">mlir::DenseElementsAttr::get()</a>, and <a class="el" href="Builders_8cpp_source.html#l00285">mlir::Builder::getFloatAttr()</a>.</p>

</div>
</div>
<a id="a147eacb98e107c587492012f9981cd62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147eacb98e107c587492012f9981cd62">&#9670;&nbsp;</a></span>createScalarOrSplatConstant() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::createScalarOrSplatConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const APInt &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a constant of type <code>type</code> at location <code>loc</code> whose value is <code>value</code> (an APInt or APFloat whose type must match the element type of <code>type</code>). </p>
<p>If <code>type</code> is a shaped type, create a splat constant of the given value. Constants are folded if possible. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00271">271</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00901">mlir::DenseElementsAttr::get()</a>, and <a class="el" href="Builders_8cpp_source.html#l00262">mlir::Builder::getIntegerAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithToAMDGPU_8cpp_source.html#l00164">clampInput()</a>, <a class="el" href="Arith_2Transforms_2EmulateWideInt_8cpp_source.html#l00153">constructResultVector()</a>, and <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00284">createScalarOrSplatConstant()</a>.</p>

</div>
</div>
<a id="a083c2c253d760b0fb021e6ce396105ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a083c2c253d760b0fb021e6ce396105ed">&#9670;&nbsp;</a></span>createScalarOrSplatConstant() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::createScalarOrSplatConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00284">284</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00271">createScalarOrSplatConstant()</a>.</p>

</div>
</div>
<a id="a6119493f8c83de427f34658e5e39cbfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6119493f8c83de427f34658e5e39cbfe">&#9670;&nbsp;</a></span>createSCCPPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSCCPPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which performs sparse conditional constant propagation over nested operations. </p>

<p class="definition">Definition at line <a class="el" href="SCCP_8cpp_source.html#l00133">133</a> of file <a class="el" href="SCCP_8cpp_source.html">SCCP.cpp</a>.</p>

</div>
</div>
<a id="a8c2a7464fefab1d85cec445e487f0d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2a7464fefab1d85cec445e487f0d0c">&#9670;&nbsp;</a></span>createSCFBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSCFBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that bufferizes the SCF dialect. </p>

<p class="definition">Definition at line <a class="el" href="SCF_2Transforms_2Bufferize_8cpp_source.html#l00045">45</a> of file <a class="el" href="SCF_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

</div>
</div>
<a id="ac7f8ebf7a2133d1c68cea6e20fba0ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f8ebf7a2133d1c68cea6e20fba0ea8">&#9670;&nbsp;</a></span>createSCFForLoopCanonicalizationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSCFForLoopCanonicalizationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that canonicalizes affine.min and affine.max operations inside of scf.for loops with known lower and upper bounds. </p>

<p class="definition">Definition at line <a class="el" href="LoopCanonicalization_8cpp_source.html#l00187">187</a> of file <a class="el" href="LoopCanonicalization_8cpp_source.html">LoopCanonicalization.cpp</a>.</p>

</div>
</div>
<a id="a050e7653e9cef5f155370ca0425994e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050e7653e9cef5f155370ca0425994e9">&#9670;&nbsp;</a></span>createShapeToShapeLowering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createShapeToShapeLowering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the ShapeToShapeLowering pass that legalizes Shape dialect to be convertible to Arith. </p>
<p>For example, <code>shape.num_elements</code> get transformed to <code>shape.reduce</code>, which can be lowered to SCF and Arith. </p>

<p class="definition">Definition at line <a class="el" href="ShapeToShapeLowering_8cpp_source.html#l00085">85</a> of file <a class="el" href="ShapeToShapeLowering_8cpp_source.html">ShapeToShapeLowering.cpp</a>.</p>

</div>
</div>
<a id="a07377f22cc6146bebe3a32a4a13c00bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07377f22cc6146bebe3a32a4a13c00bb">&#9670;&nbsp;</a></span>createSparseAssembler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseAssembler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00421">421</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

</div>
</div>
<a id="a48caf279aad98e01f3db2a93a2f51b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48caf279aad98e01f3db2a93a2f51b48">&#9670;&nbsp;</a></span>createSparseAssembler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">Pass</a>&gt; mlir::createSparseAssembler </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52922b4f9a9b71d07318a65565e1d95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52922b4f9a9b71d07318a65565e1d95d">&#9670;&nbsp;</a></span>createSparseBufferRewritePass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseBufferRewritePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00485">485</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="aa9c5d254155d499befa419181f2539ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c5d254155d499befa419181f2539ea">&#9670;&nbsp;</a></span>createSparseBufferRewritePass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseBufferRewritePass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableBufferInitialization</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00490">490</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

</div>
</div>
<a id="a2fa7d8a0754783f37e6e38a77c7e8116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa7d8a0754783f37e6e38a77c7e8116">&#9670;&nbsp;</a></span>createSparseGPUCodegenPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseGPUCodegenPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00506">506</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00032">mlir::sparse_tensor::buildSparsifier()</a>, and <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="ab19ebeb6aa5cf97ebbb73f3b7cd8c6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19ebeb6aa5cf97ebbb73f3b7cd8c6c1">&#9670;&nbsp;</a></span>createSparseGPUCodegenPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseGPUCodegenPass </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableRT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00510">510</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

</div>
</div>
<a id="a3968e0a16a255017c133162badae2da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3968e0a16a255017c133162badae2da2">&#9670;&nbsp;</a></span>createSparseReinterpretMapPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseReinterpretMapPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00425">425</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="ac6f3748b0d302eac21bac48a9887146b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f3748b0d302eac21bac48a9887146b">&#9670;&nbsp;</a></span>createSparseReinterpretMapPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseReinterpretMapPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a855a7d93430958efaaf3a6f69e3dac1c">ReinterpretMapScope</a>&#160;</td>
          <td class="paramname"><em>scope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00430">430</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a3110b4f58e57c2f284923d882d45cff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3110b4f58e57c2f284923d882d45cff4">&#9670;&nbsp;</a></span>createSparseSpaceCollapsePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseSpaceCollapsePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseSpaceCollapse_8cpp_source.html#l00197">197</a> of file <a class="el" href="SparseSpaceCollapse_8cpp_source.html">SparseSpaceCollapse.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a1444af92cb6556316a97dbd17dc10ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1444af92cb6556316a97dbd17dc10ea4">&#9670;&nbsp;</a></span>createSparseTensorCodegenPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseTensorCodegenPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00474">474</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="ad11d8839f833db69a07242adf6894472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11d8839f833db69a07242adf6894472">&#9670;&nbsp;</a></span>createSparseTensorCodegenPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseTensorCodegenPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createSparseDeallocs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableBufferInitialization</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00479">479</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

</div>
</div>
<a id="a50fe6af993ee7df395f88312234f0dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50fe6af993ee7df395f88312234f0dc0">&#9670;&nbsp;</a></span>createSparseTensorConversionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseTensorConversionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00470">470</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a06a9ca41ccfad286cda8688e8d66f588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a9ca41ccfad286cda8688e8d66f588">&#9670;&nbsp;</a></span>createSparseVectorizationPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseVectorizationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00494">494</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a3399bec16625e6af75488bb739d48d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3399bec16625e6af75488bb739d48d4c">&#9670;&nbsp;</a></span>createSparseVectorizationPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseVectorizationPass </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>vectorLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableVLAVectorization</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableSIMDIndex32</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00499">499</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

</div>
</div>
<a id="a5328b60bddf5d222bef6d92658019b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5328b60bddf5d222bef6d92658019b9d">&#9670;&nbsp;</a></span>createSparsificationAndBufferizationPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">mlir::Pass</a> &gt; mlir::createSparsificationAndBufferizationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00239">239</a> of file <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html">SparsificationAndBufferizationPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00216">getBufferizationOptionsForSparsification()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00032">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="af312c1b22096f10a3123c5136824b691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af312c1b22096f10a3123c5136824b691">&#9670;&nbsp;</a></span>createSparsificationAndBufferizationPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">mlir::Pass</a> &gt; mlir::createSparsificationAndBufferizationPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">bufferization::OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>bufferizationOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsificationOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createSparseDeallocs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableRuntimeLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableBufferInitialization</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>vectorLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableVLAVectorization</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableSIMDIndex32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableGPULibgen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a90f3feaa61d2ade78f26489cc92061c9">SparseEmitStrategy</a>&#160;</td>
          <td class="paramname"><em>emitStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832">SparseParallelizationStrategy</a>&#160;</td>
          <td class="paramname"><em>parallelizationStrategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00250">250</a> of file <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html">SparsificationAndBufferizationPass.cpp</a>.</p>

</div>
</div>
<a id="ae0be4f778219bfb3917a2c7d3e7e1bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0be4f778219bfb3917a2c7d3e7e1bd0">&#9670;&nbsp;</a></span>createSparsificationPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparsificationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00440">440</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="a11b0dcc4a707e4e560a7a2f69a95a7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b0dcc4a707e4e560a7a2f69a95a7c9">&#9670;&nbsp;</a></span>createSparsificationPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparsificationPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00445">445</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="adfa7974cf8032ae0d38f7fcc16387d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa7974cf8032ae0d38f7fcc16387d3a">&#9670;&nbsp;</a></span>createStageSparseOperationsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createStageSparseOperationsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00449">449</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00125">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="aa52fe837d33ee51beba517a1d44dbea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52fe837d33ee51beba517a1d44dbea3">&#9670;&nbsp;</a></span>createStorageSpecifierToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createStorageSpecifierToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00515">515</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00032">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="a3b152134b4d44a148dac8bfc24070dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b152134b4d44a148dac8bfc24070dcd">&#9670;&nbsp;</a></span>createStripDebugInfoPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createStripDebugInfoPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to strip debug information from a function. </p>

<p class="definition">Definition at line <a class="el" href="StripDebugInfo_8cpp_source.html#l00046">46</a> of file <a class="el" href="StripDebugInfo_8cpp_source.html">StripDebugInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00032">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="a69605e45210627de9b7fde4644fa50c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69605e45210627de9b7fde4644fa50c1">&#9670;&nbsp;</a></span>createSymbolDCEPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSymbolDCEPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which delete symbol operations that are unreachable. </p>
<p>This pass may <em>only</em> be scheduled on an operation that defines a <a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a>. </p>

<p class="definition">Definition at line <a class="el" href="SymbolDCE_8cpp_source.html#l00149">149</a> of file <a class="el" href="SymbolDCE_8cpp_source.html">SymbolDCE.cpp</a>.</p>

</div>
</div>
<a id="ae0b0f8a089ed821a240c7dd4e5573573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b0f8a089ed821a240c7dd4e5573573">&#9670;&nbsp;</a></span>createSymbolPrivatizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSymbolPrivatizePass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>excludeSymbols</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which marks top-level symbol operations as <code>private</code> unless listed in <code>excludeSymbols</code>. </p>

<p class="definition">Definition at line <a class="el" href="SymbolPrivatize_8cpp_source.html#l00061">61</a> of file <a class="el" href="SymbolPrivatize_8cpp_source.html">SymbolPrivatize.cpp</a>.</p>

</div>
</div>
<a id="ab03de4687b73fcc63bfde7e0dda6b741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03de4687b73fcc63bfde7e0dda6b741">&#9670;&nbsp;</a></span>createTestSCFParallelLoopCollapsingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createTestSCFParallelLoopCollapsingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that transforms a single ParallelLoop over N induction variables into another ParallelLoop over less than N induction variables. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopCollapsing_8cpp_source.html#l00109">109</a> of file <a class="el" href="ParallelLoopCollapsing_8cpp_source.html">ParallelLoopCollapsing.cpp</a>.</p>

</div>
</div>
<a id="a4480ae6dd145482f88ec81d28df3bca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4480ae6dd145482f88ec81d28df3bca8">&#9670;&nbsp;</a></span>createTopologicalSortPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createTopologicalSortPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that recursively sorts nested regions without SSA dominance topologically such that, as much as possible, users of values appear after their producers. </p>

<p class="definition">Definition at line <a class="el" href="TopologicalSort_8cpp_source.html#l00038">38</a> of file <a class="el" href="TopologicalSort_8cpp_source.html">TopologicalSort.cpp</a>.</p>

</div>
</div>
<a id="a54881321f630a119cdee5af076de868d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54881321f630a119cdee5af076de868d">&#9670;&nbsp;</a></span>debugString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string mlir::debugString </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DebugStringHelper_8h_source.html#l00028">28</a> of file <a class="el" href="DebugStringHelper_8h_source.html">DebugStringHelper.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transport_8cpp_source.html#l00118">mlir::lsp::MessageHandler::onReply()</a>, and <a class="el" href="Transport_8h_source.html#l00192">mlir::lsp::MessageHandler::outgoingRequest()</a>.</p>

</div>
</div>
<a id="a9c4a8218eabc2fa6756612f896572dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c4a8218eabc2fa6756612f896572dff">&#9670;&nbsp;</a></span>decomposeMixedValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt; mlir::decomposeMixedValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mixedValues</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompose a vector of mixed static or dynamic values into the corresponding pair of arrays. </p>
<p>This is the inverse function of <code>getMixedValues</code>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00184">184</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

</div>
</div>
<a id="a1041856e784cdbf7811cd10bc5a5ffd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1041856e784cdbf7811cd10bc5a5ffd6">&#9670;&nbsp;</a></span>delinearize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; mlir::delinearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>linearIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>strides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the strides together with a linear index in the dimension space, return the vector-space offsets in each dimension for a de-linearized index. </p>
<p>Let <code>li = linearIndex</code>, assuming <code>strides</code> are <code>[s0, .. sn]</code>, return the vector of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> <code>[li % s0, (li / s0) % s1, ..., (li / s0 / .. / sn-1) % sn]</code></p>
<p>It is the caller's responsibility to pass proper <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> kind that result in valid <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> (i.e. cannot multiply 2 <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> or divide by an <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a>).</p>
<p><code>strides</code> elements are expected to bind to non-negative values. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00187">187</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00055">delinearizeImpl()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00907">mlir::AffineExpr::floorDiv()</a>.</p>

</div>
</div>
<a id="a2830e5f60c269c339ef24c33d8f7fbf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2830e5f60c269c339ef24c33d8f7fbf0">&#9670;&nbsp;</a></span>delinearize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; mlir::delinearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>linearIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>strides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00194">194</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00107">delinearize()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00641">getAffineConstantExprs()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00033">mlir::AffineExpr::getContext()</a>.</p>

</div>
</div>
<a id="a448d2cc69bc47c1304f4f1608937c3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448d2cc69bc47c1304f4f1608937c3c4">&#9670;&nbsp;</a></span>delinearize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; mlir::delinearize </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>linearIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>strides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the strides together with a linear index in the dimension space, return the vector-space offsets in each dimension for a de-linearized index. </p>
<p><code>strides</code> elements are asserted to be non-negative.</p>
<p>Let <code>li = linearIndex</code>, assuming <code>strides</code> are <code>[s0, .. sn]</code>, return the vector of int64_t <code>[li % s0, (li / s0) % s1, ..., (li / s0 / .. / sn-1) % sn]</code> </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00107">107</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00055">delinearizeImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00078">commonLinearIdBuilderFn()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00194">delinearize()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00652">foreachIndividualVectorElement()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00386">mlir::detail::TileOffsetRangeImpl::getDynamicTileOffsets()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00378">mlir::detail::TileOffsetRangeImpl::getStaticTileOffsets()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00103">handleMultidimensionalVectors()</a>, and <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00166">resolveSourceIndicesCollapseShape()</a>.</p>

</div>
</div>
<a id="acad9612c1d4f11375369c3d1b2029b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad9612c1d4f11375369c3d1b2029b5c">&#9670;&nbsp;</a></span>denormalizeInductionVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::denormalizeInductionVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>normalizedIv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>origLb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>origStep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get back the original induction variable values after loop normalization. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00760">760</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00735">denormalizeInductionVariableForIndexType()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00305">getType()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00103">getValueOrCreateConstantIntOp()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00135">isConstantIntValue()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00702">mlir::RewriterBase::replaceAllUsesExcept()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00896">coalesceLoops()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01057">collapseParallelLoops()</a>.</p>

</div>
</div>
<a id="abf9a8d86f0213b02a553c01aea31e6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9a8d86f0213b02a553c01aea31e6e4">&#9670;&nbsp;</a></span>dispatchIndexOpFoldResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::dispatchIndexOpFoldResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dynamicVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>staticVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to dispatch an <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> into <code>staticVec</code> if: a) it is an IntegerAttr In other cases, the <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> is dispached to the <code>dynamicVec</code>. </p>
<p>In such dynamic cases, ShapedType::kDynamic is also pushed to <code>staticVec</code>. This is useful to extract mixed static and dynamic entries that come from an AttrSizedOperandSegments trait.</p>
<p>In such dynamic cases, a copy of the <code>sentinel</code> value is also pushed to <code>staticVec</code>. This is useful to extract mixed static and dynamic entries that come from an AttrSizedOperandSegments trait. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00047">47</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="StaticValueUtils_8cpp_source.html#l00060">dispatchIndexOpFoldResults()</a>.</p>

</div>
</div>
<a id="a923d05c8f39df57cf19f1ec709bbe5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923d05c8f39df57cf19f1ec709bbe5a5">&#9670;&nbsp;</a></span>dispatchIndexOpFoldResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::dispatchIndexOpFoldResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>ofrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dynamicVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>staticVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to dispatch multiple OpFoldResults according to the behavior of <code>dispatchIndexOpFoldResult(<a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> ofr</code> for a single <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00060">60</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00047">dispatchIndexOpFoldResult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00720">mlir::tensor::bubbleUpPadSlice()</a>.</p>

</div>
</div>
<a id="aeaf688b845e36e8284034d28fe9899bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf688b845e36e8284034d28fe9899bc">&#9670;&nbsp;</a></span>dropDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; mlir::dropDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>inputPerm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>dropPositions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a permutation vector that drop the input dims in dropPositions from inputPerm. </p>
<p>For example, inputPerm = {2, 4, 0, 1, 3} and dropPositions= {1, 2} would result in a {2, 0, 1} permutation vector. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00255">255</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l01985">SwapTransposeWithBroadcast::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ab05e50dddc61ab840dee2a99add961d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05e50dddc61ab840dee2a99add961d8">&#9670;&nbsp;</a></span>eliminateCommonSubExpressions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::eliminateCommonSubExpressions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>domInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>changed</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eliminate common subexpressions within the given operation. </p>
<p>This transform looks for and deduplicates equivalent operations.</p>
<p><code>changed</code> indicates whether the IR was modified or not. </p>

<p class="definition">Definition at line <a class="el" href="CSE_8cpp_source.html#l00382">382</a> of file <a class="el" href="CSE_8cpp_source.html">CSE.cpp</a>.</p>

</div>
</div>
<a id="a7739fe988f31077f0005b73f457eb373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7739fe988f31077f0005b73f457eb373">&#9670;&nbsp;</a></span>emitDefiniteFailure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DiagnosedDefiniteFailure.html">DiagnosedDefiniteFailure</a> mlir::emitDefiniteFailure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emits a definite failure with the given message. </p>
<p>The returned object allows for last-minute modification to the error message, such as attaching notes and completing the message. It will be reported when the object is destructed or converted. </p>

<p class="definition">Definition at line <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00243">243</a> of file <a class="el" href="DiagnosedSilenceableFailure_8h_source.html">DiagnosedSilenceableFailure.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUTransformOps_8cpp_source.html#l00282">definiteFailureHelper()</a>.</p>

</div>
</div>
<a id="a1f82005038ea404596c74643db0d564f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f82005038ea404596c74643db0d564f">&#9670;&nbsp;</a></span>emitDefiniteFailure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DiagnosedDefiniteFailure.html">DiagnosedDefiniteFailure</a> mlir::emitDefiniteFailure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00247">247</a> of file <a class="el" href="DiagnosedSilenceableFailure_8h_source.html">DiagnosedSilenceableFailure.h</a>.</p>

</div>
</div>
<a id="a4e96b0c437652eb5a4890734bb6bcee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e96b0c437652eb5a4890734bb6bcee7">&#9670;&nbsp;</a></span>emitError() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to emit an error message using this location. </p>
<p>Emit an error message using this location. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">328</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassManagerOptions_8cpp_source.html#l00145">applyPassManagerCLOptions()</a>, <a class="el" href="LLVM_2ROCDL_2Target_8cpp_source.html#l00282">mlir::ROCDL::SerializeGPUModuleBase::assembleIsa()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00303">buildSequentialConstant()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01447">mlir::transform::detail::checkApplyToOne()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01425">mlir::transform::detail::checkNestedConsumption()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00323">checkTensorElementType()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00615">mlir::LLVM::ModuleImport::convertDataLayout()</a>, <a class="el" href="ODSSupport_8cpp_source.html#l00082">convertDenseArrayFromAttr()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00455">convertDenseResourceElementsAttr()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00066">convertFromAttribute()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00597">mlir::LLVM::ModuleImport::convertGlobals()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01222">mlir::LLVM::ModuleImport::convertValue()</a>, <a class="el" href="ControlFlowToSCF_8cpp_source.html#l00134">mlir::ControlFlowToSCFTransformation::createUnreachableTerminator()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00040">deserializeModule()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00454">mlir::spirv::Deserializer::processOp&lt; spirv::CopyMemoryOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00330">mlir::spirv::Deserializer::processOp&lt; spirv::EntryPointOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00379">mlir::spirv::Deserializer::processOp&lt; spirv::ExecutionModeOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00412">mlir::spirv::Deserializer::processOp&lt; spirv::FunctionCallOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00526">mlir::spirv::Deserializer::processOp&lt; spirv::GenericCastToPtrExplicitOp &gt;()</a>, <a class="el" href="ImplicitLocOpBuilder_8h_source.html#l00094">mlir::ImplicitLocOpBuilder::emitError()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00268">mlir::Operation::emitError()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l00201">mlir::detail::Parser::emitError()</a>, <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00496">emitOptionalError()</a>, <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00041">mlir::transform::detail::expandPathsToMLIRFiles()</a>, <a class="el" href="FakeQuantSupport_8cpp_source.html#l00108">mlir::quant::fakeQuantAttrsToType()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00238">mlir::detail::PassCrashReproducerGenerator::finalize()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00232">mlir::detail::OpPassManagerImpl::finalizePassList()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l01289">forwardPassthroughAttributes()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00127">mlir::DynamicType::get()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00127">mlir::gpu::MMAMatrixType::getChecked()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00252">mlir::DynamicAttr::getChecked()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00137">mlir::DynamicType::getChecked()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01103">mlir::spirv::MatrixType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00422">mlir::quant::CalibratedQuantizedType::getChecked()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00737">mlir::spirv::SampledImageType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00350">mlir::quant::UniformQuantizedPerAxisType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00292">mlir::quant::UniformQuantizedType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00254">mlir::quant::AnyQuantizedType::getChecked()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01287">mlir::detail::getDefaultDiagnosticEmitFn()</a>, <a class="el" href="MemoryOps_8cpp_source.html#l00263">mlir::spirv::getElementPtrType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00266">getElementType()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00429">mlir::LLVM::LLVMStructType::getIdentifiedChecked()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01842">getInsertExtractValueElementType()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00458">mlir::LLVM::LLVMStructType::getLiteralChecked()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00547">mlir::LLVM::detail::getLLVMConstant()</a>, <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00185">mlir::bufferization::DeallocationState::getMemrefsAndConditionsToDeallocate()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00469">mlir::LLVM::LLVMStructType::getOpaqueChecked()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00748">getScalarConstantAsAttr()</a>, <a class="el" href="CLOptionsSetup_8cpp_source.html#l00080">mlir::tracing::InstallDebugHandler::Impl::Impl()</a>, <a class="el" href="LLVMImportInterface_8h_source.html#l00108">mlir::LLVMImportInterface::initializeImport()</a>, <a class="el" href="IRDLLoading_8cpp_source.html#l00034">irdlAttrOrTypeVerifier()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00251">loadIRDLDialects()</a>, <a class="el" href="CAPI_2IR_2Diagnostics_8cpp_source.html#l00078">mlirEmitError()</a>, <a class="el" href="LLVM_8cpp_source.html#l00091">mlirLLVMStructTypeLiteralGetChecked()</a>, <a class="el" href="MlirReduceMain_8cpp_source.html#l00048">mlirReduceMain()</a>, <a class="el" href="OpDefinition_8h_source.html#l02001">mlir::Op&lt; ConcreteType, Traits &gt;::parseProperties()</a>, <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00090">mlir::transform::detail::parseTransformModuleFromFile()</a>, <a class="el" href="BytecodeReader_8cpp_source.html#l02571">readBytecodeFileImpl()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00027">registerFromLLVMIRTranslation()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00227">reshapeLikeShapesAreCompatible()</a>, <a class="el" href="OperationSupport_8h_source.html#l00439">mlir::OperationName::setOpPropertiesFromAttribute()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00219">mlir::MlirOptMainConfig::setPassPipelineParser()</a>, <a class="el" href="ExtensibleDialect_8h_source.html#l00489">mlir::DynamicOpDefinition::setPropertiesFromAttr()</a>, <a class="el" href="OperationSupport_8h_source.html#l00637">mlir::RegisteredOperationName::Model&lt; ConcreteOp &gt;::setPropertiesFromAttr()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00180">translateDataLayout()</a>, <a class="el" href="ExtensibleDialect_8h_source.html#l00086">mlir::DynamicAttrDefinition::verify()</a>, <a class="el" href="ExtensibleDialect_8h_source.html#l00242">mlir::DynamicTypeDefinition::verify()</a>, <a class="el" href="IRDLVerifiers_8cpp_source.html#l00058">mlir::irdl::IsConstraint::verify()</a>, <a class="el" href="IRDLVerifiers_8cpp_source.html#l00071">mlir::irdl::BaseAttrConstraint::verify()</a>, <a class="el" href="IRDLVerifiers_8cpp_source.html#l00084">mlir::irdl::BaseTypeConstraint::verify()</a>, <a class="el" href="IRDLVerifiers_8cpp_source.html#l00103">mlir::irdl::DynParametricAttrConstraint::verify()</a>, <a class="el" href="IRDLVerifiers_8cpp_source.html#l00139">mlir::irdl::DynParametricTypeConstraint::verify()</a>, <a class="el" href="IRDLVerifiers_8cpp_source.html#l00183">mlir::irdl::AnyOfConstraint::verify()</a>, <a class="el" href="IRDLVerifiers_8cpp_source.html#l00199">mlir::irdl::AllOfConstraint::verify()</a>, <a class="el" href="IRDLVerifiers_8cpp_source.html#l00034">mlir::irdl::ConstraintVerifier::verify()</a>, <a class="el" href="IRDLVerifiers_8cpp_source.html#l00217">mlir::irdl::RegionConstraint::verify()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00698">mlir::detail::verifyDataLayoutSpec()</a>, <a class="el" href="MeshOps_8cpp_source.html#l00820">verifyDimensionCompatibility()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00622">mlir::LLVM::LLVMStructType::verifyEntries()</a>, <a class="el" href="DLTI_8cpp_source.html#l00115">verifyEntries()</a>, <a class="el" href="MeshOps_8cpp_source.html#l00837">verifyGatherOperandAndResultShape()</a>, <a class="el" href="MeshOps_8cpp_source.html#l00782">verifyInGroupDevice()</a>, <a class="el" href="OperationSupport_8h_source.html#l00409">mlir::OperationName::verifyInherentAttrs()</a>, <a class="el" href="OperationSupport_8h_source.html#l00598">mlir::RegisteredOperationName::Model&lt; ConcreteOp &gt;::verifyInherentAttrs()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00151">mlir::gpu::MMAMatrixType::verifyInvariants()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00501">mlir::LLVM::LLVMStructType::verifyInvariants()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00165">mlir::spirv::InterfaceVarABIAttr::verifyInvariants()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00260">mlir::spirv::VerCapExtAttr::verifyInvariants()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01110">mlir::spirv::MatrixType::verifyInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00429">mlir::quant::CalibratedQuantizedType::verifyInvariants()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00745">mlir::spirv::SampledImageType::verifyInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00360">mlir::quant::UniformQuantizedPerAxisType::verifyInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00301">mlir::quant::UniformQuantizedType::verifyInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00048">mlir::quant::QuantizedType::verifyInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00264">mlir::quant::AnyQuantizedType::verifyInvariants()</a>, <a class="el" href="MeshOps_8cpp_source.html#l00156">verifyMeshAxes()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00908">verifyRegionAttribute()</a>, <a class="el" href="MeshOps_8cpp_source.html#l00909">verifyScatterOrSliceOperandAndResultShape()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00788">mlir::detail::verifyTargetSystemSpec()</a>, and <a class="el" href="LLVMTypes_8cpp_source.html#l00661">verifyVectorConstructionInvariants()</a>.</p>

</div>
</div>
<a id="a2dc4e9418ff63ebea20c7f709ebcb0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc4e9418ff63ebea20c7f709ebcb0f8">&#9670;&nbsp;</a></span>emitError() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00329">329</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00306">emitDiag()</a>, and <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd">Error</a>.</p>

</div>
</div>
<a id="aecf5a29768872240e0bbd49d969f084b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf5a29768872240e0bbd49d969f084b">&#9670;&nbsp;</a></span>emitNormalizedLoopBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1Range.html">Range</a> mlir::emitNormalizedLoopBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Materialize bounds and step of a zero-based and unit-step loop derived by normalizing the specified bounds and step. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00689">689</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00528">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00675">emitNormalizedLoopBoundsForIndexType()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00105">getConstantIntValue()</a>, <a class="el" href="Builders_8cpp_source.html#l00373">mlir::Builder::getOneAttr()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00305">getType()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00103">getValueOrCreateConstantIntOp()</a>, and <a class="el" href="Builders_8cpp_source.html#l00355">mlir::Builder::getZeroAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00896">coalesceLoops()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01057">collapseParallelLoops()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01462">normalizeForallOp()</a>.</p>

</div>
</div>
<a id="a45deee4eed2b998fbde1d3573325bc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45deee4eed2b998fbde1d3573325bc6e">&#9670;&nbsp;</a></span>emitOptionalError()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::emitOptionalError </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads of the above emission functions that take an optionally null location. </p>
<p>If the location is null, no diagnostic is emitted and a failure is returned. Given that the provided location may be null, these methods take the diagnostic arguments directly instead of relying on the returned <a class="el" href="classmlir_1_1InFlightDiagnostic.html" title="This class represents a diagnostic that is inflight and set to be reported.">InFlightDiagnostic</a>. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00496">496</a> of file <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00339">mlir::InFlightDiagnostic::append()</a>, and <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">emitError()</a>.</p>

</div>
</div>
<a id="a3f5cd384eee5c5c8a7125233ade78eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5cd384eee5c5c8a7125233ade78eea">&#9670;&nbsp;</a></span>emitOptionalRemark()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::emitOptionalRemark </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00508">508</a> of file <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00339">mlir::InFlightDiagnostic::append()</a>, and <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00342">emitRemark()</a>.</p>

</div>
</div>
<a id="ac03c4337fa32d3045568e4dc6eef60ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03c4337fa32d3045568e4dc6eef60ca">&#9670;&nbsp;</a></span>emitOptionalWarning()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::emitOptionalWarning </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00502">502</a> of file <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00339">mlir::InFlightDiagnostic::append()</a>, and <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00334">emitWarning()</a>.</p>

</div>
</div>
<a id="a8a9ca6fe9d5aab498bf090db3e878c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9ca6fe9d5aab498bf090db3e878c87">&#9670;&nbsp;</a></span>emitRemark() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitRemark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to emit a remark message using this location. </p>
<p>Emit a remark message using this location. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00342">342</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00508">emitOptionalRemark()</a>, <a class="el" href="ImplicitLocOpBuilder_8h_source.html#l00102">mlir::ImplicitLocOpBuilder::emitRemark()</a>, and <a class="el" href="IR_2Operation_8cpp_source.html#l00289">mlir::Operation::emitRemark()</a>.</p>

</div>
</div>
<a id="a391c4b4ea9dc95fbcfbfdab8a49547a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391c4b4ea9dc95fbcfbfdab8a49547a3">&#9670;&nbsp;</a></span>emitRemark() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitRemark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00345">345</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00306">emitDiag()</a>, and <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a91921ada405fd6ba65dff028df047cb6">Remark</a>.</p>

</div>
</div>
<a id="a428b91d18eabd5b259a3ed6e0f27f60c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428b91d18eabd5b259a3ed6e0f27f60c">&#9670;&nbsp;</a></span>emitSilenceableFailure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a> mlir::emitSilenceableFailure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emits a silenceable failure with the given message. </p>
<p>A silenceable failure must be either suppressed or converted into a definite failure and reported to the user. </p>

<p class="definition">Definition at line <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00256">256</a> of file <a class="el" href="DiagnosedSilenceableFailure_8h_source.html">DiagnosedSilenceableFailure.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgMatchOps_8cpp_source.html#l00326">containsAll()</a>, <a class="el" href="MatchInterfaces_8cpp_source.html#l00103">mlir::transform::expandTargetSpecification()</a>, <a class="el" href="SCFTransformOps_8cpp_source.html#l00465">isOpSibling()</a>, and <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00355">pipelineForSharedCopies()</a>.</p>

</div>
</div>
<a id="a078c07e9f16a6122a56bae420ce94308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078c07e9f16a6122a56bae420ce94308">&#9670;&nbsp;</a></span>emitSilenceableFailure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a> mlir::emitSilenceableFailure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00262">262</a> of file <a class="el" href="DiagnosedSilenceableFailure_8h_source.html">DiagnosedSilenceableFailure.h</a>.</p>

</div>
</div>
<a id="a0768c8a572dc71b0b00d57414b56b60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0768c8a572dc71b0b00d57414b56b60d">&#9670;&nbsp;</a></span>emitWarning() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitWarning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to emit a warning message using this location. </p>
<p>Emit a warning message using this location. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00334">334</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleImport_8cpp_source.html#l00615">mlir::LLVM::ModuleImport::convertDataLayout()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00239">convertScalarToDtype()</a>, <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00502">emitOptionalWarning()</a>, <a class="el" href="ImplicitLocOpBuilder_8h_source.html#l00098">mlir::ImplicitLocOpBuilder::emitWarning()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00280">mlir::Operation::emitWarning()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00023">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01963">mlir::LLVM::ModuleImport::processFunction()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01762">processPassthroughAttrs()</a>, and <a class="el" href="LoopAnnotationImporter_8cpp_source.html#l00487">mlir::LLVM::detail::LoopAnnotationImporter::translateAccessGroup()</a>.</p>

</div>
</div>
<a id="a5e96e5ea091fb5bea539cef6ea7c5624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e96e5ea091fb5bea539cef6ea7c5624">&#9670;&nbsp;</a></span>emitWarning() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitWarning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00337">337</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00306">emitDiag()</a>, and <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a0eaadb4fcb48a0a0ed7bc9868be9fbaa">Warning</a>.</p>

</div>
</div>
<a id="ab8075944125730fed529e3b93dcfed5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8075944125730fed529e3b93dcfed5b">&#9670;&nbsp;</a></span>encodeBindAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::encodeBindAttribute </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes global variable's descriptor set and binding into its name if they both exist. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01674">1674</a> of file <a class="el" href="SPIRVToLLVM_8cpp_source.html">SPIRVToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a6ab9585c8607c12142232e0f58ebcc8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab9585c8607c12142232e0f58ebcc8b">&#9670;&nbsp;</a></span>eraseUnreachableBlocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::eraseUnreachableBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase the unreachable blocks within the provided regions. </p>
<p>Returns success if any blocks were erased, failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00183">183</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00055">mlir::Region::begin()</a>, <a class="el" href="IR_2Region_8h_source.html#l00060">mlir::Region::empty()</a>, and <a class="el" href="IR_2Region_8h_source.html#l00056">mlir::Region::end()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8cpp_source.html#l01043">simplifyRegions()</a>.</p>

</div>
</div>
<a id="a0bbb3252a45b5feab49c0bac2a68779c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbb3252a45b5feab49c0bac2a68779c">&#9670;&nbsp;</a></span>expandDimsToRank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::expandDimsToRank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>projectedDimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand <code>map</code> to operate on <code>rank</code> dims while projecting out the dims in <code>projectedDimensions</code>. </p>
<p>This amounts to composing <code>map</code> with <code>id(rank).dropResults(projectedDimensions)</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00953">953</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00556">mlir::AffineMap::compose()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00299">mlir::AffineMap::dropResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00343">mlir::AffineMap::getContext()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00334">mlir::AffineMap::getMultiDimIdentityMap()</a>.</p>

</div>
</div>
<a id="aecdaa20d0acb7aec0f05cb700b1e09df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdaa20d0acb7aec0f05cb700b1e09df">&#9670;&nbsp;</a></span>extractFixedOuterLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a3f0d45d0562d47acc2c42934ccbfea19">TileLoops</a> mlir::extractFixedOuterLoops </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>rootFOrOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01318">1318</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00271">ceilDivPositive()</a>, <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01215">getPerfectlyNestedLoopsImpl()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01278">tile()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01193">tryIsolateBands()</a>.</p>

</div>
</div>
<a id="a6511366965a313e6b0eb85c620b941d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6511366965a313e6b0eb85c620b941d0">&#9670;&nbsp;</a></span>extractFromIntegerArrayAttr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;IntTy&gt; mlir::extractFromIntegerArrayAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract integer values from the assumed ArrayAttr of IntegerAttr. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8h_source.html#l00065">65</a> of file <a class="el" href="StaticValueUtils_8h_source.html">StaticValueUtils.h</a>.</p>

</div>
</div>
<a id="a3083728e72d361c987c5e5a0e8d2f39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3083728e72d361c987c5e5a0e8d2f39a">&#9670;&nbsp;</a></span>failableParallelForEach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT , typename FuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::failableParallelForEach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements between [begin, end) asynchronously. </p>
<p>If the given function returns a failure when processing any of the elements, execution is stopped and a failure is returned from this function. This means that in the case of failure, not all elements of the range will be processed. Diagnostics emitted during processing are ordered relative to the element's position within [begin, end). If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00036">36</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l01035">mlir::ParallelDiagnosticHandler::eraseOrderIDForThread()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00602">mlir::MLIRContext::isMultithreadingEnabled()</a>, and <a class="el" href="IR_2Diagnostics_8cpp_source.html#l01029">mlir::ParallelDiagnosticHandler::setOrderIDForThread()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Threading_8h_source.html#l00090">failableParallelForEach()</a>, <a class="el" href="Threading_8h_source.html#l00105">failableParallelForEachN()</a>, and <a class="el" href="Threading_8h_source.html#l00117">parallelForEach()</a>.</p>

</div>
</div>
<a id="a98aa0f01173a481075d9d5a2ca50d8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98aa0f01173a481075d9d5a2ca50d8ab">&#9670;&nbsp;</a></span>failableParallelForEach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT , typename FuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::failableParallelForEach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeT &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements in the provided range asynchronously. </p>
<p>If the given function returns a failure when processing any of the elements, execution is stopped and a failure is returned from this function. This means that in the case of failure, not all elements of the range will be processed. Diagnostics emitted during processing are ordered relative to the element's position within the range. If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00090">90</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="Threading_8h_source.html#l00036">failableParallelForEach()</a>.</p>

</div>
</div>
<a id="af5aa5179ec6f13db4eaa8fa255bde665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5aa5179ec6f13db4eaa8fa255bde665">&#9670;&nbsp;</a></span>failableParallelForEachN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::failableParallelForEachN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements between [begin, end) asynchronously. </p>
<p>If the given function returns a failure when processing any of the elements, execution is stopped and a failure is returned from this function. This means that in the case of failure, not all elements of the range will be processed. Diagnostics emitted during processing are ordered relative to the element's position within [begin, end). If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00105">105</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="Threading_8h_source.html#l00036">failableParallelForEach()</a>.</p>

</div>
</div>
<a id="a6ceb7a2611f873431057e03992432701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ceb7a2611f873431057e03992432701">&#9670;&nbsp;</a></span>filterTypesOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> mlir::filterTypesOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BitVector &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters out any elements referenced by <code>indices</code>. </p>
<p>If any types are removed, <code>storage</code> is used to hold the new type list. Returns the new type list. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00195">195</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

</div>
</div>
<a id="a04b8cb2bfcf870fb9909b4805c0aad13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b8cb2bfcf870fb9909b4805c0aad13">&#9670;&nbsp;</a></span>finalizeParallelLoopToGPUConversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::finalizeParallelLoopToGPUConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up after applyPartialConversion/applyFullConversion call. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPU_8cpp_source.html#l00688">688</a> of file <a class="el" href="SCFToGPU_8cpp_source.html">SCFToGPU.cpp</a>.</p>

</div>
</div>
<a id="adb672e2258ecd8657ec36b0fd391208a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb672e2258ecd8657ec36b0fd391208a">&#9670;&nbsp;</a></span>findPositionsOfType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::findPositionsOfType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt;&#160;</td>
          <td class="paramname"><em>iteratorTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utils::IteratorType&#160;</td>
          <td class="paramname"><em>iteratorTypeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return positions in <code>iteratorTypes</code> that match <code>iteratorTypeName</code>. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00077">77</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>.</p>

</div>
</div>
<a id="ae92bdb36e3e6eeecc32f23923e58d973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92bdb36e3e6eeecc32f23923e58d973">&#9670;&nbsp;</a></span>foldAttributesIntoMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::foldAttributesIntoMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>remainingValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fold all attributes among the given operands into the affine map. </p>
<p>Return the folded affine map. Return all remaining values via <code>remainingValues</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00745">745</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00403">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00395">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00399">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00500">mlir::AffineMap::replaceDimsAndSymbols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00777">mlir::ValueBoundsConstraintSet::areOverlappingSlices()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01142">mlir::affine::makeComposedAffineApply()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01250">makeComposedMinMax()</a>.</p>

</div>
</div>
<a id="afccef918a87cccab273bba3cb00beed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afccef918a87cccab273bba3cb00beed7">&#9670;&nbsp;</a></span>foldDynamicIndexList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::foldDynamicIndexList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ofrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyNonNegative</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyNonZero</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns "success" when any of the elements in <code>ofrs</code> is a constant value. </p>
<p>In that case the value is replaced by an attribute. Returns "failure" when no folding happened. If <code>onlyNonNegative</code> and <code>onlyNonZero</code> are set, only non-negative and non-zero constant values are folded respectively. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00266">266</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00105">getConstantIntValue()</a>, <a class="el" href="Matchers_8h_source.html#l00369">m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00485">matchPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StaticValueUtils_8cpp_source.html#l00287">foldDynamicOffsetSizeList()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00292">foldDynamicStrideList()</a>.</p>

</div>
</div>
<a id="af04a9037c5785dac1e037c025297c4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04a9037c5785dac1e037c025297c4da">&#9670;&nbsp;</a></span>foldDynamicOffsetSizeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::foldDynamicOffsetSizeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsetsOrSizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns "success" when any of the elements in <code>offsetsOrSizes</code> is a constant value. </p>
<p>In that case the value is replaced by an attribute. Returns "failure" when no folding happened. Invalid values are not folded to avoid canonicalization crashes. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00287">287</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00266">foldDynamicIndexList()</a>.</p>

</div>
</div>
<a id="a26f1eae6696c52c728b7109da9e8ceb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f1eae6696c52c728b7109da9e8ceb8">&#9670;&nbsp;</a></span>foldDynamicStrideList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::foldDynamicStrideList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>strides</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns "success" when any of the elements in <code>strides</code> is a constant value. </p>
<p>In that case the value is replaced by an attribute. Returns "failure" when no folding happened. Invalid values are not folded to avoid canonicalization crashes. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00292">292</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00266">foldDynamicIndexList()</a>.</p>

</div>
</div>
<a id="a2b0271e4a2b1e694242618a6e91a9c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0271e4a2b1e694242618a6e91a9c37">&#9670;&nbsp;</a></span>foldReshapeOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReshapeOpTy , typename InverseReshapeOpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::foldReshapeOp </td>
          <td>(</td>
          <td class="paramtype">ReshapeOpTy&#160;</td>
          <td class="paramname"><em>reshapeOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00086">86</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

</div>
</div>
<a id="acdfbb5ad3709577536fd8002ed734921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdfbb5ad3709577536fd8002ed734921">&#9670;&nbsp;</a></span>fuseIndependentSiblingForallLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scf::ForallOp mlir::fuseIndependentSiblingForallLoops </td>
          <td>(</td>
          <td class="paramtype">scf::ForallOp&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForallOp&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two scf.forall loops, <code>target</code> and <code>source</code>, fuses <code>target</code> into <code>source</code>. </p>
<p>Assumes that the given loops are siblings and are independent of each other.</p>
<p>This function does not perform any legality checks and simply fuses the loops. The caller is responsible for ensuring that the loops are legal to fuse. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01360">1360</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>, <a class="el" href="Builders_8h_source.html#l00420">mlir::OpBuilder::setInsertionPointAfter()</a>, and <a class="el" href="Builders_8h_source.html#l00439">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="ad7634eaf008502f8ebca317ec4a1ad84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7634eaf008502f8ebca317ec4a1ad84">&#9670;&nbsp;</a></span>fuseIndependentSiblingForLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scf::ForOp mlir::fuseIndependentSiblingForLoops </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two scf.for loops, <code>target</code> and <code>source</code>, fuses <code>target</code> into <code>source</code>. </p>
<p>Assumes that the given loops are siblings and are independent of each other.</p>
<p>This function does not perform any legality checks and simply fuses the loops. The caller is responsible for ensuring that the loops are legal to fuse. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01412">1412</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>, <a class="el" href="Builders_8h_source.html#l00420">mlir::OpBuilder::setInsertionPointAfter()</a>, and <a class="el" href="Builders_8h_source.html#l00439">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="a2d3bd1afbf84ef9cca6c336a104d7280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3bd1afbf84ef9cca6c336a104d7280">&#9670;&nbsp;</a></span>generateLocationsFromIR() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::generateLocationsFromIR </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates new locations from the given IR by snapshotting the IR to the given stream, and using the printed locations within that stream. </p>
<p>The generated locations replace the current operation locations. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00101">101</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

</div>
</div>
<a id="a94e9bde94caabba0feba96a044a09afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e9bde94caabba0feba96a044a09afc">&#9670;&nbsp;</a></span>generateLocationsFromIR() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::generateLocationsFromIR </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates new locations from the given IR by snapshotting the IR to the given stream, and using the printed locations within that stream. </p>
<p>The generated locations are represented as a NameLoc with the given tag as the name, and then fused with the existing locations. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00117">117</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

</div>
</div>
<a id="af16c6823f94d6ce99fa7da7547658345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16c6823f94d6ce99fa7da7547658345">&#9670;&nbsp;</a></span>generateLocationsFromIR() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::generateLocationsFromIR </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates new locations from the given IR by snapshotting the IR to the given file, and using the printed locations within that file. </p>
<p>If <code>filename</code> is empty, a temporary file is generated instead. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00108">108</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

</div>
</div>
<a id="ab170389f5f17475f89037e332018b4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab170389f5f17475f89037e332018b4f8">&#9670;&nbsp;</a></span>generateLocationsFromIR() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::generateLocationsFromIR </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates new locations from the given IR by snapshotting the IR to the given file, and using the printed locations within that file. </p>
<p>If <code>filename</code> is empty, a temporary file is generated instead. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00125">125</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

</div>
</div>
<a id="ab4871db68c59a176135e0e35a3625e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4871db68c59a176135e0e35a3625e73">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method that injects context only if needed, this helps unify some of the attribute construction methods. </p>

<p class="definition">Definition at line <a class="el" href="BytecodeImplementation_8h_source.html#l00509">509</a> of file <a class="el" href="BytecodeImplementation_8h_source.html">BytecodeImplementation.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToOpenMP_8cpp_source.html#l00218">addAtomicRMW()</a>, <a class="el" href="OperationSupport_8h_source.html#l01035">mlir::OperationState::addAttribute()</a>, <a class="el" href="LLVM_2ROCDL_2Target_8cpp_source.html#l00230">mlir::ROCDL::SerializeGPUModuleBase::addControlVariables()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l01483">addOpaquePointerConversion()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l00247">addResumeFunction()</a>, <a class="el" href="DIScopeForLLVMFuncOp_8cpp_source.html#l00040">addScopeToFunction()</a>, <a class="el" href="Promotion_8cpp_source.html#l00435">allocateSubviewGPUMemoryInAddressSpace()</a>, <a class="el" href="Promotion_8cpp_source.html#l00048">allocBuffer()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00392">mlir::sparse_tensor::allocDenseTensor()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00066">mlir::NamedAttrList::append()</a>, <a class="el" href="Arith_2Transforms_2EmulateWideInt_8cpp_source.html#l00114">appendX1Dim()</a>, <a class="el" href="TosaToLinalgNamed_8cpp_source.html#l00037">applyPad()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00145">applyPassManagerCLOptions()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00042">applyToIntegerAttrs()</a>, <a class="el" href="LLVMMemorySlot_8cpp_source.html#l00924">areAllIndicesI32()</a>, <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00152">mlir::transform::detail::assembleTransformLibraryFromPaths()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00982">bitAndAddrspaceCast()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00151">broadcast()</a>, <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00720">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00053">mlir::bufferization::BufferizeTypeConverter::BufferizeTypeConverter()</a>, <a class="el" href="BasicPtxBuilderInterface_8cpp_source.html#l00110">mlir::NVVM::PtxBuilder::build()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01540">mlir::affine::AffineDmaStartOp::build()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01723">mlir::affine::AffineDmaWaitOp::build()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00931">HopperBuilder::buildAndInitBarrierInSharedMemory()</a>, <a class="el" href="LowerDeallocations_8cpp_source.html#l00427">mlir::bufferization::buildDeallocationLibraryFunction()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00945">HopperBuilder::buildGlobalMemRefDescriptor()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l02518">buildLLVMFunctionType()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00677">buildPackingLoopNestImpl()</a>, <a class="el" href="QuantUtils_8cpp_source.html#l00339">mlir::tosa::buildQTypeAttrFromMinMax()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00303">buildSequentialConstant()</a>, <a class="el" href="BytecodeReader_8cpp_source.html#l02530">mlir::BytecodeReader::BytecodeReader()</a>, <a class="el" href="MemRefToSPIRV_8cpp_source.html#l00457">calculateMemoryRequirements()</a>, <a class="el" href="AllocLikeConversion_8cpp_source.html#l00049">castAllocFuncResult()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00182">mlir::quant::QuantizedType::castFromExpressedType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00131">mlir::quant::QuantizedType::castFromStorageType()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00172">castToCompatibleMemRefType()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00413">castToElemPtrPtr()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00210">mlir::quant::QuantizedType::castToExpressedType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00155">mlir::quant::QuantizedType::castToStorageType()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00296">mlir::TensorType::cloneWith()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00385">mlir::BaseMemRefType::cloneWith()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00284">collapseValue()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00658">collectSymbolScopes()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00040">collectValidReferencesFor()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02416">computeCollapsedLayoutMap()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02221">computeExpandedLayoutMap()</a>, <a class="el" href="InlinerInterfaceImpl_8cpp_source.html#l00213">concatArrayAttr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00434">mlir::AffineMap::constantFold()</a>, <a class="el" href="CommonFolders_8h_source.html#l00038">constFoldBinaryOpConditional()</a>, <a class="el" href="AttrTypeSubElements_8h_source.html#l00539">mlir::detail::constructSubElementReplacement()</a>, <a class="el" href="UniformSupport_8cpp_source.html#l00035">mlir::quant::ExpressedToQuantizedConverter::convert()</a>, <a class="el" href="ArithCommon_2AttrToLLVMConverter_8cpp_source.html#l00032">mlir::arith::convertArithFastMathAttrToLLVM()</a>, <a class="el" href="ArithCommon_2AttrToLLVMConverter_8cpp_source.html#l00069">mlir::arith::convertArithRoundingModeAttrToLLVM()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00258">convertArrayType()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00303">convertFuncOpToLLVMFuncOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02859">convertFuncOpTypes()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00373">mlir::LLVMTypeConverter::convertFunctionTypeCWrapper()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00597">mlir::LLVM::ModuleImport::convertGlobals()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l01271">convertIntegerArrayToMDNode()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l01254">convertIntegerToMDNode()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l01247">convertIntegerToMetadata()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01276">mlir::LLVM::ModuleImport::convertIntrinsicArguments()</a>, <a class="el" href="NVGPUToNVVM_8cpp_source.html#l00100">convertIntrinsicResult()</a>, <a class="el" href="SparseIterationToScf_8cpp_source.html#l00040">convertIteratorType()</a>, <a class="el" href="SparseIterationToScf_8cpp_source.html#l00027">convertIterSpaceType()</a>, <a class="el" href="SparseIterationToScf_8cpp_source.html#l00015">convertLevelType()</a>, <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00198">convertLinkerOptionsOp()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00333">convertOmpCritical()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00269">convertOmpMasked()</a>, <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00217">convertOperationImpl()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00273">convertPointerType()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00284">convertRuntimeArrayType()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00060">convertToAttribute()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01222">mlir::LLVM::ModuleImport::convertValue()</a>, <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html#l00258">convertVecTypeHint()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l01260">convertVecTypeHintToMDNode()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00245">mlir::ConvertToLLVMPattern::copyUnrankedDescriptors()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01785">mlir::DistinctAttr::create()</a>, <a class="el" href="AsyncParallelFor_8cpp_source.html#l00465">createAsyncDispatchFunction()</a>, <a class="el" href="MathToFuncs_8cpp_source.html#l00651">createCtlzFunc()</a>, <a class="el" href="IRCore_8cpp_source.html#l00193">createCustomDialectWrapper()</a>, <a class="el" href="MathToFuncs_8cpp_source.html#l00412">createElementFPowIFunc()</a>, <a class="el" href="MathToFuncs_8cpp_source.html#l00185">createElementIPowIFunc()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00303">createFullPartialVectorTransferRead()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00422">createFullPartialVectorTransferWrite()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l03662">mlir::LLVM::createGlobalString()</a>, <a class="el" href="GPUToSPIRV_8cpp_source.html#l00466">createGroupReduceOpImpl()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00221">createI32ConstantOf()</a>, <a class="el" href="LoopAnnotationImporter_8cpp_source.html#l00275">createIfNonNull()</a>, <a class="el" href="InlinerInterfaceImpl_8cpp_source.html#l00266">createNewAliasScopesFromNoAliasParameter()</a>, <a class="el" href="PrintCallHelper_8cpp_source.html#l00030">mlir::LLVM::createPrintStrCall()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00245">createPrivateMemRef()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00918">createQuickSort()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00329">mlir::vector::createReadOrMaskedRead()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00998">createSortStableFunc()</a>, <a class="el" href="VCIXToLLVMIRTranslation_8cpp_source.html#l00039">createVL()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01461">createWriteOrMaskedWrite()</a>, <a class="el" href="InlinerInterfaceImpl_8cpp_source.html#l00154">deepCloneAliasScopes()</a>, <a class="el" href="Promotion_8cpp_source.html#l00093">defaultAllocBufferCallBack()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00040">deserializeModule()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00330">mlir::spirv::Deserializer::processOp&lt; spirv::EntryPointOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00379">mlir::spirv::Deserializer::processOp&lt; spirv::ExecutionModeOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00412">mlir::spirv::Deserializer::processOp&lt; spirv::FunctionCallOp &gt;()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00431">mlir::detail::divideCeil()</a>, <a class="el" href="Arith_2Transforms_2EmulateWideInt_8cpp_source.html#l00097">dropTrailingX1Dim()</a>, <a class="el" href="LoopEmitter_8cpp_source.html#l00048">dumpIndexMemRef()</a>, <a class="el" href="IRCore_8cpp_source.html#l00265">PyAttrBuilderMap::dundeGetItemNamed()</a>, <a class="el" href="IRCore_8cpp_source.html#l00262">PyAttrBuilderMap::dunderContains()</a>, <a class="el" href="IRCore_8cpp_source.html#l00271">PyAttrBuilderMap::dundeSetItemNamed()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00124">encodeKernelName()</a>, <a class="el" href="ConversionUtils_8cpp_source.html#l00109">mlir::tosa::EqualizeRanks()</a>, <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00041">mlir::transform::detail::expandPathsToMLIRFiles()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00605">expandRank()</a>, <a class="el" href="LowerVectorTransfer_8cpp_source.html#l00038">extendVectorRank()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00232">mlir::detail::OpPassManagerImpl::finalizePassList()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00868">finalizeWhileOp()</a>, <a class="el" href="InterpreterPass_8cpp_source.html#l00027">findPayloadRoot()</a>, <a class="el" href="EmulateAtomics_8cpp_source.html#l00093">flattenVecToBits()</a>, <a class="el" href="IndexOps_8cpp_source.html#l00095">foldBinaryOpChecked()</a>, <a class="el" href="IndexOps_8cpp_source.html#l00069">foldBinaryOpUnchecked()</a>, <a class="el" href="IndexOps_8cpp_source.html#l00448">foldCastOp()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00179">foldDynamicToStaticDimSizes()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00352">foldMemRefCasts()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00149">mlir::sparse_tensor::foreachFieldAndTypeInSparseTensor()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00360">mlir::sparse_tensor::genAlloca()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00375">mlir::sparse_tensor::genAllocaScalar()</a>, <a class="el" href="CodegenUtils_8h_source.html#l00085">mlir::sparse_tensor::FuncCallOrInlineGenerator&lt; SubClass &gt;::genCallOrInline()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01929">generateCopy()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00868">generateNewRefAttr()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00582">mlir::sparse_tensor::genReader()</a>, <a class="el" href="SparseTensorCodegen_8cpp_source.html#l00418">genSliceToSize()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00550">mlir::sparse_tensor::genToMemref()</a>, <a class="el" href="CodegenUtils_8h_source.html#l00403">mlir::sparse_tensor::genValFromAttr()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00121">mlir::gpu::MMAMatrixType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00961">mlir::spirv::StructType::get()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00136">mlir::spirv::InterfaceVarABIAttr::get()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00212">mlir::spirv::VerCapExtAttr::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00863">mlir::detail::DenseArrayAttrImpl&lt; T &gt;::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01010">mlir::DenseElementsAttr::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01609">mlir::detail::DenseResourceElementsAttrBase&lt; T &gt;::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00339">mlir::spirv::ImageType::get()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00875">mlir::FlatSymbolRefAttr::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01099">mlir::spirv::MatrixType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00463">mlir::spirv::RuntimeArrayType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00222">mlir::spirv::CooperativeMatrixType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00052">mlir::spirv::ArrayType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00417">mlir::quant::CalibratedQuantizedType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00732">mlir::spirv::SampledImageType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00406">mlir::spirv::PointerType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00340">mlir::quant::UniformQuantizedPerAxisType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00283">mlir::quant::UniformQuantizedType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00245">mlir::quant::AnyQuantizedType::get()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00289">mlir::spirv::TargetEnvAttr::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00349">mlir::Builder::getAffineMapArrayAttr()</a>, <a class="el" href="AffineOps_8h_source.html#l00218">mlir::affine::AffineDmaStartOp::getAffineMapAttrForMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00340">mlir::affine::AffineDmaWaitOp::getAffineMapAttrForMemRef()</a>, <a class="el" href="Builders_8cpp_source.html#l00297">mlir::Builder::getArrayAttr()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00094">getAsIndexOpFoldResult()</a>, <a class="el" href="Builders_8h_source.html#l00106">mlir::Builder::getAttr()</a>, <a class="el" href="lib_2Conversion_2PDLToPDLInterp_2Predicate_8h_source.html#l00628">mlir::pdl_to_pdl_interp::PredicateBuilder::getAttribute()</a>, <a class="el" href="MemRefMemorySlot_8cpp_source.html#l00198">getAttributeIndexFromIndexOperands()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00472">mlir::FloatType::getBF16()</a>, <a class="el" href="Builders_8cpp_source.html#l00156">mlir::Builder::getBoolVectorAttr()</a>, <a class="el" href="Traits_8cpp_source.html#l00133">mlir::OpTrait::util::getBroadcastedType()</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00062">mlir::bufferization::func_ext::getBufferizedFunctionArgType()</a>, <a class="el" href="LLVMMemorySlot_8cpp_source.html#l00804">getByteArrayType()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01007">getCallOpVarCalleeType()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l03066">getCanonicalSubViewResultType()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00206">VectorizationState::getCanonicalVecType()</a>, <a class="el" href="IRCore_8cpp_source.html#l00292">mlir::python::PyBlock::getCapsule()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00141">getCastCompatibleMemRefType()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00100">getCharPtr()</a>, <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00043">getCompressedMaskOp()</a>, <a class="el" href="TosaToLinalgNamed_8cpp_source.html#l00158">getConvOrPoolOutputDim()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l01011">mlir::sparse_tensor::SparseTensorType::getCOOType()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00140">mlir::detail::getDefaultABIAlignment()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01287">mlir::detail::getDefaultDiagnosticEmitFn()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00194">mlir::detail::getDefaultPreferredAlignment()</a>, <a class="el" href="TargetAndABI_8cpp_source.html#l00156">mlir::spirv::getDefaultResourceLimits()</a>, <a class="el" href="FakeQuantSupport_8cpp_source.html#l00015">getDefaultStorageParams()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00052">mlir::detail::getDefaultTypeSizeInBits()</a>, <a class="el" href="SparseTensorType_8h_source.html#l00265">mlir::sparse_tensor::SparseTensorType::getDemappedType()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00811">getDenseResource()</a>, <a class="el" href="IRCore_8cpp_source.html#l01013">mlir::python::PyDialects::getDialectForKey()</a>, <a class="el" href="Builders_8cpp_source.html#l00144">mlir::Builder::getDictionaryAttr()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00496">mlir::Operation::getDiscardableAttrDictionary()</a>, <a class="el" href="DebugTranslation_8cpp_source.html#l00134">getDistinctOrUnique()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00107">mlir::ConvertToLLVMPattern::getElementPtrType()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00984">mlir::spirv::StructType::getEmpty()</a>, <a class="el" href="AsmParser_2Lexer_8cpp_source.html#l00050">mlir::Lexer::getEncodedSourceLocation()</a>, <a class="el" href="TargetAndABI_8cpp_source.html#l00123">mlir::spirv::getEntryPointABIAttr()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00709">getExpandedType()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00041">mlir::shape::getExtentTensorType()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00496">mlir::FloatType::getF128()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00476">mlir::FloatType::getF16()</a>, <a class="el" href="Builders_8cpp_source.html#l00281">mlir::Builder::getF16FloatAttr()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00484">mlir::FloatType::getF32()</a>, <a class="el" href="Builders_8cpp_source.html#l00277">mlir::Builder::getF32FloatAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00180">mlir::Builder::getF32VectorAttr()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00488">mlir::FloatType::getF64()</a>, <a class="el" href="Builders_8cpp_source.html#l00273">mlir::Builder::getF64FloatAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00185">mlir::Builder::getF64VectorAttr()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00492">mlir::FloatType::getF80()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00953">mlir::LLVM::getFixedVectorType()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00428">mlir::FloatType::getFloat4E2M1FN()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00432">mlir::FloatType::getFloat6E2M3FN()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00436">mlir::FloatType::getFloat6E3M2FN()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00464">mlir::FloatType::getFloat8E3M4()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00444">mlir::FloatType::getFloat8E4M3()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00460">mlir::FloatType::getFloat8E4M3B11FNUZ()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00448">mlir::FloatType::getFloat8E4M3FN()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00456">mlir::FloatType::getFloat8E4M3FNUZ()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00440">mlir::FloatType::getFloat8E5M2()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00452">mlir::FloatType::getFloat8E5M2FNUZ()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00468">mlir::FloatType::getFloat8E8M0FNU()</a>, <a class="el" href="Builders_8cpp_source.html#l00285">mlir::Builder::getFloatAttr()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00323">mlir::sparse_tensor::getFunc()</a>, <a class="el" href="Builders_8cpp_source.html#l00120">mlir::Builder::getFunctionType()</a>, <a class="el" href="Builders_8cpp_source.html#l00029">mlir::Builder::getFusedLoc()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00239">getGetValueTypeOpValueType()</a>, <a class="el" href="Builders_8cpp_source.html#l00254">mlir::Builder::getI16IntegerAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00105">mlir::Builder::getI16Type()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00170">getI1SameShape()</a>, <a class="el" href="Builders_8cpp_source.html#l00097">mlir::Builder::getI1Type()</a>, <a class="el" href="Builders_8cpp_source.html#l00099">mlir::Builder::getI2Type()</a>, <a class="el" href="Builders_8cpp_source.html#l00240">mlir::Builder::getI32IntegerAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00219">mlir::Builder::getI32TensorAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00107">mlir::Builder::getI32Type()</a>, <a class="el" href="Builders_8cpp_source.html#l00162">mlir::Builder::getI32VectorAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00101">mlir::Builder::getI4Type()</a>, <a class="el" href="Builders_8cpp_source.html#l00152">mlir::Builder::getI64IntegerAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00226">mlir::Builder::getI64TensorAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00109">mlir::Builder::getI64Type()</a>, <a class="el" href="Builders_8cpp_source.html#l00168">mlir::Builder::getI64VectorAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00258">mlir::Builder::getI8IntegerAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getI8Type()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00974">mlir::spirv::StructType::getIdentified()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00424">mlir::LLVM::LLVMStructType::getIdentified()</a>, <a class="el" href="Builders_8cpp_source.html#l00318">mlir::Builder::getIndexArrayAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00148">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00233">mlir::Builder::getIndexTensorAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00095">mlir::Builder::getIndexType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00233">mlir::LLVMTypeConverter::getIndexType()</a>, <a class="el" href="Builders_8cpp_source.html#l00174">mlir::Builder::getIndexVectorAttr()</a>, <a class="el" href="EmitC_8cpp_source.html#l01056">getInitializerTypeForGlobal()</a>, <a class="el" href="SparseTensorDescriptor_8cpp_source.html#l00077">mlir::sparse_tensor::SparseTensorSpecifier::getInitValue()</a>, <a class="el" href="Builders_8cpp_source.html#l00262">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00111">mlir::Builder::getIntegerType()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00082">getInterfaceVariables()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00040">mlir::ConvertToLLVMPattern::getIntPtrType()</a>, <a class="el" href="Target_2LLVM_2ROCDL_2Utils_8cpp_source.html#l00071">mlir::ROCDL::getKernelMetadata()</a>, <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00069">getLaneId()</a>, <a class="el" href="DataFlowFramework_8h_source.html#l00276">mlir::DataFlowSolver::getLatticeAnchor()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00452">mlir::LLVM::LLVMStructType::getLiteral()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00547">mlir::LLVM::detail::getLLVMConstant()</a>, <a class="el" href="ArithCommon_2AttrToLLVMConverter_8cpp_source.html#l00078">mlir::arith::getLLVMDefaultFPExceptionBehavior()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01012">getLLVMFuncType()</a>, <a class="el" href="DeadCodeAnalysis_8cpp_source.html#l00102">mlir::dataflow::CFGEdge::getLoc()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00078">getMangledSortHelperFunc()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00114">mlir::ConvertToLLVMPattern::getMemRefDescriptorSizes()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00764">mlir::bufferization::getMemRefType()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00790">mlir::bufferization::getMemRefTypeWithFullyDynamicLayout()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00814">mlir::bufferization::getMemRefTypeWithStaticIdentityLayout()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00100">mlir::nvgpu::getMmaSyncRegisterType()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00626">getMmaSyncVectorOperandType()</a>, <a class="el" href="Builders_8cpp_source.html#l00128">mlir::Builder::getNoneType()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l01206">getNormalizedEncodingForSpecifier()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00464">mlir::LLVM::LLVMStructType::getOpaque()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00352">mlir::sparse_tensor::getOpaquePointerType()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l01664">mlir::LLVM::ModuleTranslation::getOrCreateAliasScope()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l01698">mlir::LLVM::ModuleTranslation::getOrCreateAliasScopes()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00345">getOrCreateFormatStringConstant()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00540">mlir::MLIRContext::getOrLoadDynamicDialect()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01029">getPackOpSourceOrPaddedSource()</a>, <a class="el" href="PtrTypes_8cpp_source.html#l00032">getPointerSpec()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00964">mlir::LLVM::getScalableVectorType()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00748">getScalarConstantAsAttr()</a>, <a class="el" href="ArithToSPIRV_8cpp_source.html#l00115">getScalarOrVectorConstInt()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00924">getSharedAddressSpaceAttribute()</a>, <a class="el" href="Builders_8cpp_source.html#l00244">mlir::Builder::getSI32IntegerAttr()</a>, <a class="el" href="TypeConversions_8cpp_source.html#l00055">mlir::emitc::getSignedTypeFor()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00169">mlir::ConvertToLLVMPattern::getSizeInBytes()</a>, <a class="el" href="Dialect_2ArmSME_2IR_2Utils_8cpp_source.html#l00114">mlir::arm_sme::getSMETileTypeForElement()</a>, <a class="el" href="Builders_8cpp_source.html#l00293">mlir::Builder::getStringAttr()</a>, <a class="el" href="LLVMMemorySlot_8cpp_source.html#l01404">mlir::LLVM::LLVMStructType::getSubelementIndexMap()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00059">mlir::memref::getTensorTypeFromMemRefType()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00480">mlir::FloatType::getTF32()</a>, <a class="el" href="Builders_8cpp_source.html#l00124">mlir::Builder::getTupleType()</a>, <a class="el" href="ShapeUtils_8h_source.html#l00069">mlir::tosa::ValueKnowledge::getType()</a>, <a class="el" href="Builders_8h_source.html#l00099">mlir::Builder::getType()</a>, <a class="el" href="Builders_8cpp_source.html#l00343">mlir::Builder::getTypeArrayAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00249">mlir::Builder::getUI32IntegerAttr()</a>, <a class="el" href="SPIRVOpDefinition_8cpp_source.html#l00041">mlir::spirv::getUnaryOpResultType()</a>, <a class="el" href="Builders_8cpp_source.html#l00138">mlir::Builder::getUnitAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00027">mlir::Builder::getUnknownLoc()</a>, <a class="el" href="TypeConversions_8cpp_source.html#l00042">mlir::emitc::getUnsignedTypeFor()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l03049">getValAndBoolStructType()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00926">mlir::LLVM::getVectorType()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00936">getVectorType()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00049">mlir::ConvertToLLVMPattern::getVoidPtrType()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00045">mlir::ConvertToLLVMPattern::getVoidType()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00186">mlir::transform::gpu::GpuBlockIdBuilder::GpuBlockIdBuilder()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00222">mlir::transform::gpu::GpuThreadIdBuilder::GpuThreadIdBuilder()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00195">mlir::transform::gpu::GpuWarpgroupIdBuilder::GpuWarpgroupIdBuilder()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00209">mlir::transform::gpu::GpuWarpIdBuilder::GpuWarpIdBuilder()</a>, <a class="el" href="InlinerInterfaceImpl_8cpp_source.html#l00052">handleInlinedAllocas()</a>, <a class="el" href="InlinerInterfaceImpl_8cpp_source.html#l00482">handleLoopAnnotations()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00103">handleMultidimensionalVectors()</a>, <a class="el" href="CLOptionsSetup_8cpp_source.html#l00080">mlir::tracing::InstallDebugHandler::Impl::Impl()</a>, <a class="el" href="NVGPUToNVVM_8cpp_source.html#l00061">inferIntrinsicResultType()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00219">mlir::detail::inferReturnTensorTypes()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l01602">inferSparseBufferType()</a>, <a class="el" href="VectorOps_8cpp_source.html#l03399">inferStridedSliceOpResultType()</a>, <a class="el" href="VectorOps_8cpp_source.html#l03973">mlir::vector::inferTransferOpMaskType()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l03340">inferTransposeResultType()</a>, <a class="el" href="LLVMImportInterface_8h_source.html#l00108">mlir::LLVMImportInterface::initializeImport()</a>, <a class="el" href="LoopEmitter_8cpp_source.html#l00231">mlir::sparse_tensor::LoopEmitter::initializeLoopEmit()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00124">invertPredicate()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00172">isBatchMatvec()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00123">isBatchVecmat()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00148">isMatvec()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00099">isVecmat()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00385">joinShapes()</a>, <a class="el" href="GPUHeuristics_8cpp_source.html#l00027">linearId0()</a>, <a class="el" href="GPUHeuristics_8cpp_source.html#l00030">linearId1()</a>, <a class="el" href="GPUHeuristics_8cpp_source.html#l00033">linearId2()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l01186">mlir::spirv::linearizeIndex()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00048">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00251">loadIRDLDialects()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00143">mlir::SymbolTable::lookup()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00048">mlir::LLVM::lookupOrCreateFn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00148">mlir::LLVM::lookupOrCreateFreeFn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00168">mlir::LLVM::lookupOrCreateGenericFreeFn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00175">mlir::LLVM::lookupOrCreateMemRefCopyFn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00082">mlir::LLVM::lookupOrCreatePrintBF16Fn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00121">mlir::LLVM::lookupOrCreatePrintCloseFn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00126">mlir::LLVM::lookupOrCreatePrintCommaFn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00076">mlir::LLVM::lookupOrCreatePrintF16Fn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00088">mlir::LLVM::lookupOrCreatePrintF32Fn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00094">mlir::LLVM::lookupOrCreatePrintF64Fn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00064">mlir::LLVM::lookupOrCreatePrintI64Fn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00131">mlir::LLVM::lookupOrCreatePrintNewlineFn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00116">mlir::LLVM::lookupOrCreatePrintOpenFn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00109">mlir::LLVM::lookupOrCreatePrintStringFn()</a>, <a class="el" href="FunctionCallUtils_8cpp_source.html#l00070">mlir::LLVM::lookupOrCreatePrintU64Fn()</a>, <a class="el" href="GPUToLLVMSPV_8cpp_source.html#l00048">lookupOrCreateSPIRVFn()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00385">mlir::SymbolTable::lookupSymbolIn()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00118">lowerEntryPointABIAttr()</a>, <a class="el" href="LoweringOptions_8cpp_source.html#l00018">mlir::LowerToLLVMOptions::LowerToLLVMOptions()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00046">makeArrayAttr()</a>, <a class="el" href="VectorOps_8cpp_source.html#l03062">makeI64ArrayAttr()</a>, <a class="el" href="LinalgToStandard_8cpp_source.html#l00028">makeStridedLayoutDynamic()</a>, <a class="el" href="NamedOpConversions_8cpp_source.html#l00036">matchAndReplaceDepthwiseConv()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00023">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00386">mlir::GPUPrintfOpToHIPLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00484">mlir::GPUPrintfOpToLLVMCallLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00530">mlir::GPUPrintfOpToVPrintfLowering::matchAndRewrite()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01985">SwapTransposeWithBroadcast::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00434">ConvertLoad::matchAndRewrite()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01146">mlir::linalg::GeneralizeOuterUnitDimsPackOpPattern::matchAndRewrite()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01227">mlir::linalg::GeneralizeOuterUnitDimsUnPackOpPattern::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00082">ConsolidateTransposeOptimization::matchAndRewrite()</a>, <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00167">mlir::spirv::MemorySpaceToStorageClassConverter::MemorySpaceToStorageClassConverter()</a>, <a class="el" href="Dialect_2Transform_2IR_2Utils_8cpp_source.html#l00031">mergeInto()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00068">mergeOverflowFlags()</a>, <a class="el" href="SCFToOpenMP_8cpp_source.html#l00156">minMaxValueForFloat()</a>, <a class="el" href="SCFToOpenMP_8cpp_source.html#l00165">minMaxValueForSignedInt()</a>, <a class="el" href="SCFToOpenMP_8cpp_source.html#l00175">minMaxValueForUnsignedInt()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00040">mlirAffineMapAttrGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00060">mlirArrayAttrGet()</a>, <a class="el" href="IR_8cpp_source.html#l01085">mlirAttributeGetType()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00288">mlirComplexTypeGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00086">mlirDictionaryAttrGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00107">mlirDictionaryAttrGetElementByName()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00124">mlirFloatAttrDoubleGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00587">mlirFunctionTypeGet()</a>, <a class="el" href="GPU_8cpp_source.html#l00038">mlirGPUObjectAttrGet()</a>, <a class="el" href="GPU_8cpp_source.html#l00051">mlirGPUObjectAttrGetWithKernels()</a>, <a class="el" href="IR_8cpp_source.html#l01121">mlirIdentifierGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00072">mlirIndexTypeGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00148">mlirIntegerAttrGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00196">mlirIntegerSetAttrGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00034">mlirIntegerTypeGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00038">mlirIntegerTypeSignedGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00042">mlirIntegerTypeUnsignedGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00042">mlirLLVMArrayTypeGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00220">mlirLLVMCConvAttrGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00224">mlirLLVMComdatAttrGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00153">mlirLLVMDIBasicTypeAttrGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00239">mlirLLVMDICompileUnitAttrGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00167">mlirLLVMDICompositeTypeAttrGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00190">mlirLLVMDIDerivedTypeAttrGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00137">mlirLLVMDIExpressionAttrGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00129">mlirLLVMDIExpressionElemAttrGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00232">mlirLLVMDIFileAttrGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00251">mlirLLVMDIFlagsAttrGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00365">mlirLLVMDIImportedEntityAttrGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00255">mlirLLVMDILexicalBlockAttrGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00265">mlirLLVMDILexicalBlockFileAttrGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00274">mlirLLVMDILocalVariableAttrGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00347">mlirLLVMDIModuleAttrGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00149">mlirLLVMDINullTypeAttrGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00203">mlirLLVMDIStringTypeAttrGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00301">mlirLLVMDISubprogramAttrGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00284">mlirLLVMDISubroutineTypeAttrGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00046">mlirLLVMFunctionTypeGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00228">mlirLLVMLinkageAttrGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00026">mlirLLVMPointerTypeGet()</a>, <a class="el" href="LLVM_8cpp_source.html#l00038">mlirLLVMVoidTypeGet()</a>, <a class="el" href="IR_8cpp_source.html#l00266">mlirLocationCallSiteGet()</a>, <a class="el" href="IR_8cpp_source.html#l00259">mlirLocationFileLineColGet()</a>, <a class="el" href="IR_8cpp_source.html#l00270">mlirLocationFusedGet()</a>, <a class="el" href="IR_8cpp_source.html#l00278">mlirLocationNameGet()</a>, <a class="el" href="IR_8cpp_source.html#l00287">mlirLocationUnknownGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00483">mlirMemRefTypeContiguousGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00459">mlirMemRefTypeGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00274">mlirNoneTypeGet()</a>, <a class="el" href="NVGPU_8cpp_source.html#l00023">mlirNVGPUTensorMapDescriptorTypeGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00212">mlirOpaqueAttrGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00627">mlirOpaqueTypeGet()</a>, <a class="el" href="IR_8cpp_source.html#l01021">mlirOpOperandGetValue()</a>, <a class="el" href="CAPI_2Dialect_2PDL_8cpp_source.html#l00035">mlirPDLAttributeTypeGet()</a>, <a class="el" href="CAPI_2Dialect_2PDL_8cpp_source.html#l00047">mlirPDLOperationTypeGet()</a>, <a class="el" href="CAPI_2Dialect_2PDL_8cpp_source.html#l00059">mlirPDLRangeTypeGet()</a>, <a class="el" href="CAPI_2Dialect_2PDL_8cpp_source.html#l00075">mlirPDLTypeTypeGet()</a>, <a class="el" href="CAPI_2Dialect_2PDL_8cpp_source.html#l00087">mlirPDLValueTypeGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00416">mlirRankedTensorTypeGet()</a>, <a class="el" href="MlirReduceMain_8cpp_source.html#l00048">mlirReduceMain()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00945">mlirSparseElementsAttribute()</a>, <a class="el" href="SparseTensor_8cpp_source.html#l00049">mlirSparseTensorEncodingAttrGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00974">mlirStridedLayoutAttrGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00241">mlirStringAttrGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00245">mlirStringAttrTypedGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00265">mlirSymbolRefAttrGet()</a>, <a class="el" href="IR_8cpp_source.html#l01174">mlirSymbolTableReplaceAllSymbolUses()</a>, <a class="el" href="Transform_8cpp_source.html#l00032">mlirTransformAnyOpTypeGet()</a>, <a class="el" href="Transform_8cpp_source.html#l00048">mlirTransformAnyParamTypeGet()</a>, <a class="el" href="Transform_8cpp_source.html#l00064">mlirTransformAnyValueTypeGet()</a>, <a class="el" href="Transform_8cpp_source.html#l00080">mlirTransformOperationTypeGet()</a>, <a class="el" href="Transform_8cpp_source.html#l00102">mlirTransformParamTypeGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00559">mlirTupleTypeGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00329">mlirTypeAttrGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00347">mlirUnitAttrGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00790">mlirUnmanagedDenseResourceElementsAttrGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00532">mlirUnrankedMemRefTypeGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00436">mlirUnrankedTensorTypeGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00354">mlirVectorTypeGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00367">mlirVectorTypeGetScalable()</a>, <a class="el" href="AVXTranspose_8cpp_source.html#l00032">mlir::x86vector::avx2::inline_asm::mm256BlendPsAsm()</a>, <a class="el" href="Spmdization_8cpp_source.html#l00389">mlir::mesh::moveLastSplitAxisInResharding()</a>, <a class="el" href="Arith_2Transforms_2EmulateNarrowType_8cpp_source.html#l00030">mlir::arith::NarrowTypeEmulationConverter::NarrowTypeEmulationConverter()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01747">mlir::affine::normalizeMemRefType()</a>, <a class="el" href="IntegerRangeAnalysis_8cpp_source.html#l00039">mlir::dataflow::IntegerValueRangeLattice::onUpdate()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00787">mlir::OperationName::OperationName()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00244">mlir::MemRefType::Builder::operator MemRefType()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00301">mlir::RankedTensorType::Builder::operator RankedTensorType()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00357">mlir::VectorType::Builder::operator VectorType()</a>, <a class="el" href="LLVMDialect_8h_source.html#l00164">mlir::LLVM::GEPIndicesAdaptor&lt; DynamicRange &gt;::iterator::operator*()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00613">mlir::DenseElementsAttr::AttributeElementIterator::operator*()</a>, <a class="el" href="SparseTensorDescriptor_8cpp_source.html#l00026">optionalLevelAttr()</a>, <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00296">outlineExecuteOp()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00178">outlineKernelFuncImpl()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00119">outlineSingleBlockRegion()</a>, <a class="el" href="ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00144">packFunctionArguments()</a>, <a class="el" href="Padding_8cpp_source.html#l00102">padOperandToSmallestStaticBoundingBox()</a>, <a class="el" href="AsmParser_2Parser_8cpp_source.html#l02816">parseAsmSourceFile()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00052">mlir::detail::Parser::parseAttribute()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01918">parseBound()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00034">mlir::detail::Parser::parseCallSiteLocation()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l01481">parseCaptureType()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00161">parseClauseAttr()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00512">parseClauseWithRegionArgs()</a>, <a class="el" href="OpenACC_8cpp_source.html#l01313">parseCombinedConstructsLoop()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00135">mlir::detail::Parser::parseComplexType()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l01024">parseCopyprivate()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00410">mlir::detail::Parser::parseDecOrHexAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00938">mlir::detail::Parser::parseDenseArrayAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l01008">mlir::detail::Parser::parseDenseResourceElementsAttr()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l01128">parseDependVarList()</a>, <a class="el" href="OpenACC_8cpp_source.html#l02597">parseDeviceTypeArrayAttr()</a>, <a class="el" href="OpenACC_8cpp_source.html#l01231">parseDeviceTypeOperandsWithKeywordOnly()</a>, <a class="el" href="OpenACC_8cpp_source.html#l01001">parseDeviceTypeOperandsWithSegment()</a>, <a class="el" href="EmitC_8cpp_source.html#l01063">parseEmitCGlobalOpTypeAndInitialValue()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00252">mlir::detail::Parser::parseExtendedAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00344">mlir::detail::Parser::parseFloatAttr()</a>, <a class="el" href="TransformOps_8cpp_source.html#l01170">parseForeachMatchSymbols()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00164">mlir::function_interface_impl::parseFunctionOp()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00066">mlir::detail::Parser::parseFusedLocation()</a>, <a class="el" href="OpenACC_8cpp_source.html#l01614">parseGangClause()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01565">parseGlobalMemrefOpTypeAndInitialValue()</a>, <a class="el" href="SPIRVOpDefinition_8cpp_source.html#l00049">mlir::spirv::parseImageOperands()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l01265">parseLaunchDimType()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l02112">parseLevelRange()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00156">mlir::detail::Parser::parseLocationInstance()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l01394">parseMembersIndex()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00100">mlir::detail::Parser::parseNameOrFileLineColLocation()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00276">mlir::detail::Parser::parseNonFunctionType()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00934">parseNumGangs()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00248">mlir::detail::Parser::parseOptionalAttribute()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00509">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalSymbolName()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00438">parseOrderClause()</a>, <a class="el" href="OpDefinition_8h_source.html#l02001">mlir::Op&lt; ConcreteType, Traits &gt;::parseProperties()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00409">parseRangeType()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00453">parseResultsValueType()</a>, <a class="el" href="OpenACC_8cpp_source.html#l02506">parseRoutineGangClause()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00357">parseScheduleClause()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l01068">mlir::detail::Parser::parseSparseElementsAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l01144">mlir::detail::Parser::parseStridedLayoutAttr()</a>, <a class="el" href="ControlFlow_2IR_2ControlFlowOps_8cpp_source.html#l00507">parseSwitchOpCases()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00641">parseSymOperandList()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l01192">parseSynchronizationHint()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00392">mlir::detail::Parser::parseTensorType()</a>, <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00090">mlir::transform::detail::parseTransformModuleFromFile()</a>, <a class="el" href="AsmParser_2TypeParser_8cpp_source.html#l00450">mlir::detail::Parser::parseTupleType()</a>, <a class="el" href="IR_2Dialect_8cpp_source.html#l00072">mlir::Dialect::parseType()</a>, <a class="el" href="MLProgramOps_8cpp_source.html#l00084">parseTypedInitialValue()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00166">mlir::tosa::parseTypeOrAttr()</a>, <a class="el" href="Dialect_2IRDL_2IR_2IRDL_8cpp_source.html#l00205">parseValuesWithVariadicity()</a>, <a class="el" href="Dialect_2IRDL_2IR_2IRDL_8cpp_source.html#l00177">parseValueWithVariadicity()</a>, <a class="el" href="OpenACC_8cpp_source.html#l01064">parseWaitClause()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l01149">populateAsyncStructuralTypeConversionsAndLegality()</a>, <a class="el" href="TypeConversions_8cpp_source.html#l00032">populateEmitCSizeTTypeConversions()</a>, <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00350">populateGpuToNVVMConversionPatterns()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00618">mlir::memref::populateMemRefNarrowTypeEmulationConversions()</a>, <a class="el" href="MemRefToEmitC_8cpp_source.html#l00166">populateMemRefToEmitCTypeConversion()</a>, <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html#l00307">populateMMAToSPIRVCoopMatrixTypeConversion()</a>, <a class="el" href="VectorLinearize_8cpp_source.html#l00464">mlir::vector::populateVectorLinearizeTypeConversionsAndLegality()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00799">printClauseWithRegionArgs()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03994">printMinMaxBound()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01819">mlir::LLVM::ModuleImport::processFunctionAttributes()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01714">processMemoryEffects()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01762">processPassthroughAttrs()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00363">mlir::ValueBoundsConstraintSet::processWorklist()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00673">mlir::LLVMTypeConverter::promoteOneMemRefDescriptor()</a>, <a class="el" href="Promotion_8cpp_source.html#l00288">promoteSubViews()</a>, <a class="el" href="BytecodeReader_8cpp_source.html#l02571">readBytecodeFileImpl()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00038">reducedVectorTypeBack()</a>, <a class="el" href="Arith_2Transforms_2EmulateWideInt_8cpp_source.html#l00052">reduceInnermostDim()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00425">mlir::ExtensibleDialect::registerDynamicAttr()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00389">mlir::ExtensibleDialect::registerDynamicType()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00027">registerFromLLVMIRTranslation()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00031">remapInlinedLocations()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00608">mlir::Operation::removeAttr()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00474">mlir::Operation::removeDiscardableAttr()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00248">mlir::SymbolTable::rename()</a>, <a class="el" href="ModuleCombiner_8cpp_source.html#l00033">renameSymbol()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00259">mlir::SymbolTable::renameToUnique()</a>, <a class="el" href="DIExpressionLegalization_8cpp_source.html#l00035">mlir::LLVM::MergeFragments::replace()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00880">replaceAllSymbolUsesImpl()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00068">mlir::IntegerSet::replaceDimsAndSymbols()</a>, <a class="el" href="Padding_8cpp_source.html#l00153">mlir::linalg::rewriteAsPaddedOp()</a>, <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00854">rewriteI4ToI8SignedExt()</a>, <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00883">rewriteI4ToI8UnsignedExt()</a>, <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00915">rewriteI8ToI4Trunc()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00079">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="Vectorization_8cpp_source.html#l02635">PadOpVectorizationWithInsertSlicePattern::rewriteUser()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00133">mlir::NamedAttrList::set()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00588">mlir::Operation::setAttr()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00305">mlir::Operation::setAttrs()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00460">mlir::Operation::setDiscardableAttr()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00522">mlir::Operation::setDiscardableAttrs()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00219">mlir::MlirOptMainConfig::setPassPipelineParser()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00496">mlir::UnrankedMemRefDescriptor::setSize()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00529">mlir::UnrankedMemRefDescriptor::setStride()</a>, <a class="el" href="SymbolTable_8h_source.html#l00130">mlir::SymbolTable::setSymbolName()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00317">mlir::SymbolTable::setSymbolVisibility()</a>, <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00171">setupCoroMachinery()</a>, <a class="el" href="DIExpressionRewriter_8cpp_source.html#l00028">mlir::LLVM::DIExpressionRewriter::simplify()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00484">mlir::UnrankedMemRefDescriptor::size()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00132">mlir::MemRefDescriptor::size()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00473">mlir::UnrankedMemRefDescriptor::sizeBasePtr()</a>, <a class="el" href="Detensorize_8cpp_source.html#l00031">sourceMaterializationCallback()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00519">mlir::vector::splitFullAndPartialTransfer()</a>, <a class="el" href="CodegenEnv_8cpp_source.html#l00062">mlir::sparse_tensor::CodegenEnv::startEmit()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00517">mlir::UnrankedMemRefDescriptor::stride()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00508">mlir::UnrankedMemRefDescriptor::strideBasePtr()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00118">mlir::SymbolTable::SymbolTable()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00180">translateDataLayout()</a>, <a class="el" href="DebugImporter_8cpp_source.html#l00035">mlir::LLVM::detail::DebugImporter::translateFuncLocation()</a>, <a class="el" href="DebugImporter_8cpp_source.html#l00444">mlir::LLVM::detail::DebugImporter::translateGlobalVariableExpression()</a>, <a class="el" href="DebugTranslation_8cpp_source.html#l00463">mlir::LLVM::detail::DebugTranslation::translateGlobalVariableExpression()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l02202">translateLLVMIRToModule()</a>, <a class="el" href="DebugImporter_8cpp_source.html#l00406">mlir::LLVM::detail::DebugImporter::translateLoc()</a>, <a class="el" href="AVXTranspose_8cpp_source.html#l00115">mlir::x86vector::avx2::transpose4x8xf32()</a>, <a class="el" href="AVXTranspose_8cpp_source.html#l00140">mlir::x86vector::avx2::transpose8x8xf32()</a>, <a class="el" href="VectorDropLeadUnitDim_8cpp_source.html#l00027">trimLeadingOneDims()</a>, <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00313">trimNonScalableUnitDims()</a>, <a class="el" href="Vectorization_8cpp_source.html#l02299">GenericPadOpVectorizationPattern::tryVectorizeCopy()</a>, <a class="el" href="Spmdization_8cpp_source.html#l00258">mlir::mesh::unsplitLastAxisInResharding()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00051">updateFuncOp()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01534">vectorizeAsTensorPackOp()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01609">vectorizeAsTensorUnpackOp()</a>, <a class="el" href="Vectorization_8cpp_source.html#l02228">mlir::linalg::vectorizeCopy()</a>, <a class="el" href="IRDLVerifiers_8cpp_source.html#l00217">mlir::irdl::RegionConstraint::verify()</a>, <a class="el" href="MemRefMemorySlot_8cpp_source.html#l00050">walkIndicesAsAttr()</a>, <a class="el" href="Arith_2Transforms_2EmulateWideInt_8cpp_source.html#l01064">mlir::arith::WideIntEmulationConverter::WideIntEmulationConverter()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00396">wmmaPushInputOperand()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00178">wrapExternalFunction()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00510">mlir::detail::wrapIntegerMemorySpace()</a>, and <a class="el" href="GPUOpsLowering_8cpp_source.html#l00631">wrapNumericMemorySpace()</a>.</p>

</div>
</div>
<a id="a6e8a0f44c623301035b6151ca51cca4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8a0f44c623301035b6151ca51cca4d">&#9670;&nbsp;</a></span>getAffineBinaryOpExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineBinaryOpExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">AffineExprKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00070">70</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01586">createDimSizeExprForTiledLayout()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l01059">mlir::sparse_tensor::inverseBlockSparsity()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00120">mlirAffineAddExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00173">mlirAffineCeilDivExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00159">mlirAffineFloorDivExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00146">mlirAffineModExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00133">mlirAffineMulExprGet()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00157">mlir::AffineExpr::replace()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00089">mlir::AffineExpr::replaceDimsAndSymbols()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00649">simplifyAdd()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00785">simplifyExprAndOperands()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00551">simplifySemiAffine()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00464">mlir::affine::substWithMin()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00418">symbolicDivide()</a>.</p>

</div>
</div>
<a id="ab26cdced424aa629fde4150cc8674d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26cdced424aa629fde4150cc8674d50">&#9670;&nbsp;</a></span>getAffineConstantExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineConstantExpr </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>constant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00631">631</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="StorageUniquer_8h_source.html#l00195">mlir::StorageUniquer::get()</a>, and <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::MLIRContext::getAffineUniquer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01357">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00954">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00580">mlir::AffineMap::compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01070">composeAffineMapAndOperands()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00167">computeProduct()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00147">computeSuffixProduct()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00159">computeSum()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00418">detectAsFloorDiv()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00390">mlir::linalg::dropUnitDims()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00907">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="Builders_8cpp_source.html#l00403">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00641">getAffineConstantExprs()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01038">getAffineExprFromFlatForm()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00831">mlir::FlatLinearConstraints::getAsIntegerSet()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00128">mlir::AffineMap::getConstantMap()</a>, <a class="el" href="mlir_2IR_2IntegerSet_8h_source.html#l00056">mlir::IntegerSet::getEmptySet()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01081">getSemiAffineExprFromFlatForm()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00537">mlir::FlatLinearConstraints::getSliceBounds()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00153">mlir::vector::getTransferMinorIdentityMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00815">inverseAndBroadcastProjectedPermutation()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00513">isModOfModSubtraction()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00175">linearize()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00932">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00126">makePermutationMap()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01797">makeStridedLinearLayoutMap()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00104">mlirAffineConstantExprGet()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01012">mlir::AffineExpr::operator%()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00838">mlir::AffineExpr::operator*()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00773">mlir::AffineExpr::operator+()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00851">mlir::AffineExpr::operator-()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00627">mlir::AffineExpr::operator==()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00453">mlir::AffineMap::partialConstantFold()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00858">projectCommonImpl()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00649">simplifyAdd()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00920">simplifyCeilDiv()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00785">simplifyExprAndOperands()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00861">simplifyFloorDiv()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00888">simplifyMinOrMaxExprWithOperands()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00967">simplifyMod()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00786">simplifyMul()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00551">simplifySemiAffine()</a>, <a class="el" href="VectorUnroll_8cpp_source.html#l00032">sliceTransferIndices()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00418">symbolicDivide()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00145">transferReadSupportsMMAMatrixType()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01315">mlir::SimpleAffineExprFlattener::visitModExpr()</a>.</p>

</div>
</div>
<a id="ace395202c24e4dc75013296cf46ed692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace395202c24e4dc75013296cf46ed692">&#9670;&nbsp;</a></span>getAffineConstantExprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; mlir::getAffineConstantExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00641">641</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00631">getAffineConstantExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IndexingUtils_8cpp_source.html#l00194">delinearize()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00386">mlir::detail::TileOffsetRangeImpl::getDynamicTileOffsets()</a>, and <a class="el" href="IndexingUtils_8cpp_source.html#l00181">linearize()</a>.</p>

</div>
</div>
<a id="addfd4323ef72147332661606b030d04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfd4323ef72147332661606b030d04d">&#9670;&nbsp;</a></span>getAffineDimExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineDimExpr </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These free functions allow clients of the API to not use classes in detail. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00607">607</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133ab49b848e4bb608f4d5650e4b2817c641">DimId</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00596">getAffineDimOrSymbol()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerVectorContract_8cpp_source.html#l00067">adjustMap()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00329">mlir::detail::bindDims()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00353">bindDimsList()</a>, <a class="el" href="VectorDistribute_8cpp_source.html#l00037">calculateImplicitMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01357">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01314">canonicalizePromotedSymbols()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00135">common3DIdBuilderFn()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00078">commonLinearIdBuilderFn()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00556">mlir::AffineMap::compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01070">composeAffineMapAndOperands()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l02745">computeIteratorTypesAndIndexingMaps()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00802">mlir::FlatLinearConstraints::computeLocalVars()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00689">mlir::linalg::computeTileSizes()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00133">convertReassociationIndicesToExprs()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00390">mlir::linalg::dropUnitDims()</a>, <a class="el" href="SparseReinterpretMap_8cpp_source.html#l00152">genReplaceDimToLvlMap()</a>, <a class="el" href="Builders_8cpp_source.html#l00395">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01038">getAffineExprFromFlatForm()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01464">getCollapsedOpIndexingMap()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01087">getDimMap()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00238">mlir::nvgpu::getLaneIdToLdMatrixMatrixCoord()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00334">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00280">mlir::AffineMap::getMultiDimMapWithTargets()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01081">getSemiAffineExprFromFlatForm()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00537">mlir::FlatLinearConstraints::getSliceBounds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00815">inverseAndBroadcastProjectedPermutation()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l01059">mlir::sparse_tensor::inverseBlockSparsity()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00791">inversePermutation()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00316">mlir::AffineExpr::isFunctionOfDim()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01567">isNormalizedMemRefDynamicDim()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l02267">mlir::linalg::makeAffineDimExprs()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00964">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00126">makePermutationMap()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01797">makeStridedLinearLayoutMap()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00072">mlirAffineDimExprGet()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00858">projectCommonImpl()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01022">replaceDimOrSym()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00133">mlir::AffineExpr::shiftDims()</a>, <a class="el" href="VectorUnroll_8cpp_source.html#l00032">sliceTransferIndices()</a>, and <a class="el" href="VectorToGPU_8cpp_source.html#l00145">transferReadSupportsMMAMatrixType()</a>.</p>

</div>
</div>
<a id="a8ad71c14bebce843758768ff160e2283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad71c14bebce843758768ff160e2283">&#9670;&nbsp;</a></span>getAffineExprFromFlatForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineExprFromFlatForm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>flatExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>localExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an affine expression from a flat ArrayRef. </p>
<p>If there are local identifiers (neither dimensional nor symbolic) that appear in the sum of products expression, 'localExprs' is expected to have the <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> for it, and is substituted into. The ArrayRef 'eq' is expected to be in the format [dims, symbols, locals, constant term].</p>
<p>If there are local identifiers (neither dimensional nor symbolic) that appear in the sum of products expression, <code>localExprs</code> is expected to have the <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> for it, and is substituted into. The ArrayRef <code>flatExprs</code> is expected to be in the format [dims, symbols, locals, constant term]. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01038">1038</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00631">getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00607">getAffineDimExpr()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00617">getAffineSymbolExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00831">mlir::FlatLinearConstraints::getAsIntegerSet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00312">mlir::affine::FlatAffineValueConstraints::getIneqAsAffineValueMap()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00448">mlir::FlatLinearConstraints::getLowerAndUpperBound()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01556">simplifyAffineExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01315">mlir::SimpleAffineExprFlattener::visitModExpr()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01264">mlir::SimpleAffineExprFlattener::visitMulExpr()</a>.</p>

</div>
</div>
<a id="aefb7ba5a55b4f16631528884d3617a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb7ba5a55b4f16631528884d3617a47">&#9670;&nbsp;</a></span>getAffineSymbolExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineSymbolExpr </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00617">617</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00596">getAffineDimOrSymbol()</a>, and <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133aea00d3c6059a4ff11d351696747fc7ff">SymbolId</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00338">mlir::detail::bindSymbols()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00367">bindSymbolsList()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01357">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01314">canonicalizePromotedSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00556">mlir::AffineMap::compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01070">composeAffineMapAndOperands()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00802">mlir::FlatLinearConstraints::computeLocalVars()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01038">getAffineExprFromFlatForm()</a>, <a class="el" href="Builders_8cpp_source.html#l00399">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01081">getSemiAffineExprFromFlatForm()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00537">mlir::FlatLinearConstraints::getSliceBounds()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00327">mlir::AffineExpr::isFunctionOfSymbol()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01877">mlir::affine::linearizeIndex()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00932">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01797">makeStridedLinearLayoutMap()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00088">mlirAffineSymbolExprGet()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00858">projectCommonImpl()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01022">replaceDimOrSym()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00145">mlir::AffineExpr::shiftSymbols()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00351">mlir::linalg::updateBoundsForCyclicDistribution()</a>.</p>

</div>
</div>
<a id="a3b4f49fb88f428ae223bf75ce8e9f849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4f49fb88f428ae223bf75ce8e9f849">&#9670;&nbsp;</a></span>getAsIndexOpFoldResult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; mlir::getAsIndexOpFoldResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00098">98</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00094">getAsIndexOpFoldResult()</a>.</p>

</div>
</div>
<a id="a0c18958fe34840cfafad41a1226f7a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c18958fe34840cfafad41a1226f7a68">&#9670;&nbsp;</a></span>getAsIndexOpFoldResult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::getAsIndexOpFoldResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert int64_t to integer attributes of index type and return them as <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00094">94</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00886">HopperBuilder::buildPredicateLoadsOnThread0()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00078">commonLinearIdBuilderFn()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00335">computeLinearIndex()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00098">getAsIndexOpFoldResult()</a>.</p>

</div>
</div>
<a id="a622f03f8cb8e4cfde7e34c30e9aa02b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622f03f8cb8e4cfde7e34c30e9aa02b6">&#9670;&nbsp;</a></span>getAsOpFoldResult() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::getAsOpFoldResult </td>
          <td>(</td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>arrayAttr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert <code>arrayAttr</code> to a vector of <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00086">86</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

</div>
</div>
<a id="ac19b7af1333485b34ebfe4bf6300c362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19b7af1333485b34ebfe4bf6300c362">&#9670;&nbsp;</a></span>getAsOpFoldResult() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::getAsOpFoldResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a value, try to extract a constant <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>. </p>
<p>If this fails, return the original value. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00069">69</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00369">m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00485">matchPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BlockPackMatmul_8cpp_source.html#l00139">mlir::linalg::blockPackMatmul()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00335">computeLinearIndex()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00080">getAsOpFoldResult()</a>, <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00043">getCompressedMaskOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00052">getDimValue()</a>, <a class="el" href="DecomposeMemRefs_8cpp_source.html#l00096">getFlatMemref()</a>, <a class="el" href="DecomposeMemRefs_8cpp_source.html#l00045">getFlatOffsetAndStrides()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00804">getProductOfIntsOrIndexes()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00245">getTileOffsetAndSizes()</a>, <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00181">InsertSliceOfInsertSliceFolder&lt; OpTy &gt;::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01398">replaceConstantUsesOf()</a>, and <a class="el" href="ViewLikeInterfaceUtils_8h_source.html#l00082">mlir::affine::resolveIndicesIntoOpWithOffsetsAndStrides()</a>.</p>

</div>
</div>
<a id="a0f4688956ac5cd539b0b3e134af30248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4688956ac5cd539b0b3e134af30248">&#9670;&nbsp;</a></span>getAsOpFoldResult() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::getAsOpFoldResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an array of values, try to extract a constant <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> from each value. </p>
<p>If this fails, return the original value. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00080">80</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00069">getAsOpFoldResult()</a>.</p>

</div>
</div>
<a id="a4984b71591e73aa40a13f020a3547233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4984b71591e73aa40a13f020a3547233">&#9670;&nbsp;</a></span>getBackwardSlice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getBackwardSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *&#160;</td>
          <td class="paramname"><em>backwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1BackwardSliceOptions.html">BackwardSliceOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills <code>backwardSlice</code> with the computed backward slice (i.e. </p>
<p>all the transitive defs of op), <b>without</b> including that operation.</p>
<p>This additionally takes a TransitiveFilter which acts as a frontier: when looking at defs transitively, an operation that does not pass the filter is never propagated through. This allows in particular to carve out the scope within a ForOp or the scope within an IfOp.</p>
<p>The implementation traverses the def chains in postorder traversal for efficiency reasons: if an operation is already in <code>backwardSlice</code>, no need to traverse its definitions again. Since useuse-def chains form a DAG, this terminates.</p>
<p>Upon return to the root call, <code>backwardSlice</code> is filled with a postorder list of defs. This happens to be a topological order, from the point of view of the use-def chains.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Example starting from node 8</h1>
<p>1 2 3 4 |_______| |______| | | | | 5 6 |___|_____________| | | 7 8 |_______________| | 9</p>
<p>Assuming all local orders match the numbering order: {1, 2, 5, 3, 4, 6} </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00121">121</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SliceAnalysis_8cpp_source.html#l00133">getBackwardSlice()</a>.</p>

</div>
</div>
<a id="a7584eb4e9bf1c3d0b146ff37bca2da90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7584eb4e9bf1c3d0b146ff37bca2da90">&#9670;&nbsp;</a></span>getBackwardSlice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getBackwardSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *&#160;</td>
          <td class="paramname"><em>backwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1BackwardSliceOptions.html">BackwardSliceOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value-rooted version of <code>getBackwardSlice</code>. </p>
<p>Return the union of all backward slices for the op defining or owning the value <code>root</code>. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00133">133</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00121">getBackwardSlice()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a1ee8e54b17fecc4eaad55779facd0068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee8e54b17fecc4eaad55779facd0068">&#9670;&nbsp;</a></span>getBlocksSortedByDominance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt; mlir::getBlocksSortedByDominance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a list of blocks that is sorted according to dominance. </p>
<p>This sort is stable. </p>

<p class="definition">Definition at line <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00155">155</a> of file <a class="el" href="TopologicalSortUtils_8cpp_source.html">TopologicalSortUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00045">mlir::Region::getBlocks()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00140">convertOmpOpRegions()</a>, and <a class="el" href="Mem2Reg_8cpp_source.html#l00526">getOrCreateBlockIndices()</a>.</p>

</div>
</div>
<a id="a23af303f7dd3f645fbb9d05338774b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23af303f7dd3f645fbb9d05338774b7c">&#9670;&nbsp;</a></span>getBoundForAffineExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; int64_t &gt; mlir::getBoundForAffineExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::optional&lt; int64_t &gt;&gt;&#160;</td>
          <td class="paramname"><em>constLowerBounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::optional&lt; int64_t &gt;&gt;&#160;</td>
          <td class="paramname"><em>constUpperBounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isUpper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a lower or upper (depending on <code>isUpper</code>) bound for <code>expr</code> while using the constant lower and upper bounds for its inputs provided in <code>constLowerBounds</code> and <code>constUpperBounds</code>. </p>
<p>Return std::nullopt if such a bound can't be computed. This method only handles simple sum of product expressions (w.r.t constant coefficients) so as to not depend on anything heavyweight in <code>Analysis</code>. Expressions of the form: c0*d0 + c1*d1 + c2*s0 + ... + c_n are handled. Expressions involving floordiv, ceildiv, mod or semi-affine ones will lead a none being returned. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01585">1585</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a30c212eb3184a5ed41f01a25c8124e8a">CeilDiv</a>, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133abaa422535e7ce48b442cc07089e64e7a">FloorDiv</a>, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a7aeb0277500c86e4aa6bd23f9a737942">Mod</a>, <a class="el" href="AffineExprVisitor_8h_source.html#l00368">mlir::SimpleAffineExprFlattener::numLocals</a>, <a class="el" href="AffineExprVisitor_8h_source.html#l00362">mlir::SimpleAffineExprFlattener::operandExprStack</a>, and <a class="el" href="AffineExprVisitor_8h_source.html#l00150">mlir::AffineExprVisitor&lt; SubClass, RetTy &gt;::walkPostOrder()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00761">getLowerBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00738">getUpperBound()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00888">simplifyMinOrMaxExprWithOperands()</a>.</p>

</div>
</div>
<a id="a3775f03f9a65464fefb370229adcac95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3775f03f9a65464fefb370229adcac95">&#9670;&nbsp;</a></span>getBufferizationOptionsForSparsification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">mlir::bufferization::OneShotBufferizationOptions</a> mlir::getBufferizationOptionsForSparsification </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>analysisOnly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00216">216</a> of file <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html">SparsificationAndBufferizationPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00814">mlir::bufferization::getMemRefTypeWithStaticIdentityLayout()</a>, <a class="el" href="Value_8h_source.html#l00129">mlir::Value::getType()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00032">mlir::sparse_tensor::buildSparsifier()</a>, and <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00239">createSparsificationAndBufferizationPass()</a>.</p>

</div>
</div>
<a id="a22bfcc5fa9deffb32e7c39183f732c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bfcc5fa9deffb32e7c39183f732c90">&#9670;&nbsp;</a></span>getConstantIntValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; int64_t &gt; mlir::getConstantIntValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If ofr is a constant integer or an IntegerAttr, return the integer. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00105">105</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00522">m_ConstantInt()</a>, and <a class="el" href="Matchers_8h_source.html#l00485">matchPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00038">mlir::affine::FlatAffineValueConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00079">mlir::scf::addLoopRangeConstraints()</a>, <a class="el" href="Promotion_8cpp_source.html#l00048">allocBuffer()</a>, <a class="el" href="TensorOps_8cpp_source.html#l04062">asShapeWithAnyValueAsDynamic()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02660">buildAffineLoopFromValues()</a>, <a class="el" href="Tiling_8cpp_source.html#l00338">canOmitTileOffsetInBoundsCheck()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00236">constantTripCount()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00115">constifyIndexValues()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00043">createInBoundsCond()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00320">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00689">emitNormalizedLoopBounds()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00266">foldDynamicIndexList()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00179">foldDynamicToStaticDimSizes()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00680">mlir::affine::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00205">getBoundedTileSize()</a>, <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00508">getCollapsedIndices()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00121">getConstantIntValues()</a>, <a class="el" href="BlockPackMatmul_8cpp_source.html#l00030">getConstantRange()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00303">getConstantTripCount()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00354">mlir::vector::getConstantVscaleMultiplier()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00200">mlir::ValueBoundsConstraintSet::getExpr()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01029">getPackOpSourceOrPaddedSource()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00804">getProductOfIntsOrIndexes()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00269">getSlicedDimensions()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00135">isConstantIntValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00346">isDimOpValidSymbol()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00219">mlir::vector::isDisjointTransferIndices()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00144">isEqualConstantIntOrValue()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l03131">isTrivialSubViewOp()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00017">isZeroIndex()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00376">loopUnrollByFactor()</a>, <a class="el" href="Tiling_8cpp_source.html#l00049">mlir::linalg::makeTiledLoopRanges()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01146">mlir::linalg::GeneralizeOuterUnitDimsPackOpPattern::matchAndRewrite()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00477">mlir::linalg::pack()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00119">peelForLoop()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00190">tileDividesIterationDomain()</a>, <a class="el" href="Vectorization_8cpp_source.html#l02299">GenericPadOpVectorizationPattern::tryVectorizeCopy()</a>, <a class="el" href="LoopEmitter_8cpp_source.html#l00086">unFoldOpIntResult()</a>, <a class="el" href="BlockPackMatmul_8cpp_source.html#l00044">validateFullTilesOnDims()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00085">mlir::ValueBoundsConstraintSet::Variable::Variable()</a>.</p>

</div>
</div>
<a id="addda9c80b032fe1ec781a4317d45725f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addda9c80b032fe1ec781a4317d45725f">&#9670;&nbsp;</a></span>getConstantIntValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; &gt; mlir::getConstantIntValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>ofrs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If all ofrs are constant integers or IntegerAttrs, return the integers. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00121">121</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00105">getConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUTransformOps_8cpp_source.html#l00760">getThreadIdBuilder()</a>, <a class="el" href="GPUTransformOps_8cpp_source.html#l00414">rewriteOneForallCommonImpl()</a>, and <a class="el" href="GPUTransformOps_8cpp_source.html#l00356">verifyGpuMapping()</a>.</p>

</div>
</div>
<a id="a20b466301e036ddc2e72c55838139324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b466301e036ddc2e72c55838139324">&#9670;&nbsp;</a></span>getControlFlowPredecessors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt; mlir::getControlFlowPredecessors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a vector of all control predecessors of <code>value</code>. </p>
<p>Relies on RegionBranchOpInterface, BranchOpInterface, and SelectLikeOpInterface to determine predecessors. Returns nullopt if <code>value</code> has no predecessors or when the relevant operations are missing the interface implementations. </p>

<p class="definition">Definition at line <a class="el" href="SliceWalk_8cpp_source.html#l00106">106</a> of file <a class="el" href="SliceWalk_8cpp_source.html">SliceWalk.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceWalk_8cpp_source.html#l00084">getBlockPredecessorOperands()</a>, <a class="el" href="Block_8cpp_source.html#l00030">mlir::Block::getParentOp()</a>, <a class="el" href="SliceWalk_8cpp_source.html#l00038">getRegionPredecessorOperands()</a>, and <a class="el" href="Block_8cpp_source.html#l00035">mlir::Block::isEntryBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InlinerInterfaceImpl_8cpp_source.html#l00229">getUnderlyingObjectSet()</a>.</p>

</div>
</div>
<a id="abd4e8ec066bf4a2025b81d2a8c0c9ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4e8ec066bf4a2025b81d2a8c0c9ebe">&#9670;&nbsp;</a></span>getEffectsRecursively()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">llvm::SmallVector</a>&lt; <a class="el" href="namespacemlir_1_1MemoryEffects.html#ac845c307c34161d9e9c0c1a0287c9664">MemoryEffects::EffectInstance</a> &gt; &gt; mlir::getEffectsRecursively </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>rootOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the side effects of an operation. </p>
<p>If the operation has RecursiveMemoryEffects, include all side effects of child operations.</p>
<p>std::nullopt indicates that an option did not have a memory effect interface and so no result could be obtained. An empty vector indicates that there were no memory effects found (but every operation implemented the memory effect interface or has RecursiveMemoryEffects). If the vector contains multiple effects, these effects may be duplicates. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00335">335</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

</div>
</div>
<a id="a252aee27751e05d584d0b1a8e793ecf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252aee27751e05d584d0b1a8e793ecf0">&#9670;&nbsp;</a></span>getElementTypeOrSelf() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::getElementTypeOrSelf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the element type or return the type itself. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00033">33</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeUtilities_8cpp_source.html#l00023">getElementTypeOrSelf()</a>.</p>

</div>
</div>
<a id="a82686ceb29eb0f78b59e29021f1b2cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82686ceb29eb0f78b59e29021f1b2cdd">&#9670;&nbsp;</a></span>getElementTypeOrSelf() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::getElementTypeOrSelf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the element type or return the type itself. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00023">23</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l00949">buildGenericRegion()</a>, <a class="el" href="ArithToAMDGPU_8cpp_source.html#l00164">clampInput()</a>, <a class="el" href="Arith_2Transforms_2ExpandOps_8cpp_source.html#l00027">createConst()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00026">createFloatConst()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00048">createIntConst()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00268">exp2I32()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00120">fillStructuredOpRegion()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00227">frexp()</a>, <a class="el" href="Traits_8cpp_source.html#l00133">mlir::OpTrait::util::getBroadcastedType()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00029">getElementTypeOrSelf()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00129">getScalarOrElementWidth()</a>, <a class="el" href="ArithOps_8cpp_source.html#l01227">getUnderlyingType()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02390">mlir::vector::isBroadcastableTo()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00219">mlir::linalg::lowerPack()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00477">mlir::linalg::pack()</a>, <a class="el" href="Padding_8cpp_source.html#l00102">padOperandToSmallestStaticBoundingBox()</a>, <a class="el" href="Padding_8cpp_source.html#l00153">mlir::linalg::rewriteAsPaddedOp()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l02228">mlir::linalg::vectorizeCopy()</a>.</p>

</div>
</div>
<a id="ae81d443c449b61825fb2c2ec6aa90d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81d443c449b61825fb2c2ec6aa90d35">&#9670;&nbsp;</a></span>getElementTypeOrSelf() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::getElementTypeOrSelf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00029">29</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeUtilities_8cpp_source.html#l00023">getElementTypeOrSelf()</a>, and <a class="el" href="Value_8h_source.html#l00129">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a59222c6d1f54e57a5f71291f205911da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59222c6d1f54e57a5f71291f205911da">&#9670;&nbsp;</a></span>getEnclosingRepetitiveRegion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Region.html">Region</a> * mlir::getEnclosingRepetitiveRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first enclosing region of the given op that may be executed repetitively as per RegionBranchOpInterface or <code>nullptr</code> if no such region exists. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00343">343</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

</div>
</div>
<a id="abea4281da1b0006e0c9622cff14858a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea4281da1b0006e0c9622cff14858a7">&#9670;&nbsp;</a></span>getEnclosingRepetitiveRegion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Region.html">Region</a> * mlir::getEnclosingRepetitiveRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first enclosing region of the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> that may be executed repetitively as per RegionBranchOpInterface or <code>nullptr</code> if no such region exists. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00353">353</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00041">mlir::Value::getParentRegion()</a>.</p>

</div>
</div>
<a id="ac0e1219853f339da1b9caa57a9503c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e1219853f339da1b9caa57a9503c5c">&#9670;&nbsp;</a></span>getFlattenedAffineExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::getFlattenedAffineExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>flattenedExpr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a> *&#160;</td>
          <td class="paramname"><em>cst</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addConservativeSemiAffineBounds</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens 'expr' into 'flattenedExpr', which contains the coefficients of the dimensions, symbols, and additional variables that represent floor divisions of dimensions, symbols, and in turn other floor divisions. </p>
<p>Returns failure if 'expr' could not be flattened (i.e., an unhandled semi-affine was found). 'cst' contains constraints that connect newly introduced local variables to existing dimensional and symbolic variables. See documentation for AffineExprFlattener on how mod's and div's are flattened. </p>

<p class="definition">Definition at line <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00178">178</a> of file <a class="el" href="FlatLinearValueConstraints_8cpp_source.html">FlatLinearValueConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00192">getFlattenedAffineExprs()</a>.</p>

</div>
</div>
<a id="ac9cccd81f500fe900e2a7d3e68c7c84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9cccd81f500fe900e2a7d3e68c7c84f">&#9670;&nbsp;</a></span>getFlattenedAffineExprs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::getFlattenedAffineExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>flattenedExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a> *&#160;</td>
          <td class="paramname"><em>localVarCst</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addConservativeSemiAffineBounds</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens the result expressions of the map to their corresponding flattened forms and set in 'flattenedExprs'. </p>
<p>Flattens the expressions in map.</p>
<p>Returns failure if any expression in the map could not be flattened (i.e., an unhandled semi-affine was found). 'cst' contains constraints that connect newly introduced local variables to existing dimensional and / symbolic variables. See documentation for AffineExprFlattener on how mod's and div's are flattened. For all affine expressions that share the same operands (like those of an affine map), this method should be used instead of repeatedly calling getFlattenedAffineExpr since local variables added to deal with div's and mod's will be reused across expressions.</p>
<p>Returns failure if 'expr' was unable to be flattened (i.e., an unhandled semi-affine was found). </p>

<p class="definition">Definition at line <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00192">192</a> of file <a class="el" href="FlatLinearValueConstraints_8cpp_source.html">FlatLinearValueConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00136">getFlattenedAffineExprs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00402">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00889">mlir::FlatLinearValueConstraints::FlatLinearValueConstraints()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00711">mlir::FlatLinearConstraints::flattenAlignedMapAndMergeLocals()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00178">getFlattenedAffineExpr()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01306">getMultiAffineFunctionFromMap()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00492">mlir::affine::getRelationFromMap()</a>.</p>

</div>
</div>
<a id="a99d3ec2b375b73649766ce133c49aa1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d3ec2b375b73649766ce133c49aa1e">&#9670;&nbsp;</a></span>getFlattenedAffineExprs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::getFlattenedAffineExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>flattenedExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a> *&#160;</td>
          <td class="paramname"><em>cst</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00206">206</a> of file <a class="el" href="FlatLinearValueConstraints_8cpp_source.html">FlatLinearValueConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00041">mlir::IntegerSet::getConstraints()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00136">getFlattenedAffineExprs()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00021">mlir::IntegerSet::getNumConstraints()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00015">mlir::IntegerSet::getNumDims()</a>, and <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00016">mlir::IntegerSet::getNumSymbols()</a>.</p>

</div>
</div>
<a id="a46bbb7497276c5ea7e8ed4ad1315bf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46bbb7497276c5ea7e8ed4ad1315bf40">&#9670;&nbsp;</a></span>getFlattenedTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, 10 &gt; mlir::getFlattenedTypes </td>
          <td>(</td>
          <td class="paramtype">TupleType&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the types within a nested Tuple. </p>
<p>A helper for the class method that handles storage concerns, which is tricky to do in tablegen. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00039">39</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

</div>
</div>
<a id="afffe695e75923a7c364bceee778826a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afffe695e75923a7c364bceee778826a9">&#9670;&nbsp;</a></span>getForwardSlice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getForwardSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *&#160;</td>
          <td class="paramname"><em>forwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a5bbb33912ce41da593598188d8bcc13a">ForwardSliceOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills <code>forwardSlice</code> with the computed forward slice (i.e. </p>
<p>all the transitive uses of op), <b>without</b> including that operation.</p>
<p>This additionally takes a TransitiveFilter which acts as a frontier: when looking at uses transitively, an operation that does not pass the filter is never propagated through. This allows in particular to carve out the scope within a ForOp or the scope within an IfOp.</p>
<p>The implementation traverses the use chains in postorder traversal for efficiency reasons: if an operation is already in <code>forwardSlice</code>, no need to traverse its uses again. Since use-def chains form a DAG, this terminates.</p>
<p>Upon return to the root call, <code>forwardSlice</code> is filled with a postorder list of uses (i.e. a reverse topological order). To get a proper topological order, we just reverse the order in <code>forwardSlice</code> before returning.</p>
<h1><a class="anchor" id="autotoc_md0"></a>
Example starting from node 0</h1>
<pre class="fragment">          0
</pre><p> ___________|___________ 1 2 3 4 |_______| |______| | | | | 5 6 |___|_____________| | | 7 8 |_______________| | 9</p>
<p>Assuming all local orders match the numbering order:</p><ol type="1">
<li>after getting back to the root getForwardSlice, <code>forwardSlice</code> may contain: {9, 7, 8, 5, 1, 2, 6, 3, 4}</li>
<li>reversing the result of 1. gives: {4, 3, 6, 2, 1, 5, 8, 7, 9} </li>
</ol>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00054">54</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l00047">computeDestructuringInfo()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00202">mlir::linalg::hoistRedundantVectorTransfers()</a>, and <a class="el" href="LoopFusionUtils_8cpp_source.html#l00358">promoteSingleIterReductionLoop()</a>.</p>

</div>
</div>
<a id="a54d503b65f87b6cab0452ff97122cbff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d503b65f87b6cab0452ff97122cbff">&#9670;&nbsp;</a></span>getForwardSlice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getForwardSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *&#160;</td>
          <td class="paramname"><em>forwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a5bbb33912ce41da593598188d8bcc13a">ForwardSliceOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value-rooted version of <code>getForwardSlice</code>. </p>
<p>Return the union of all forward slices for the uses of the value <code>root</code>. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00070">70</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00029">getForwardSliceImpl()</a>, <a class="el" href="Value_8h_source.html#l00228">mlir::Value::getUsers()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a84637d8636fade36ebdd466b38527c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84637d8636fade36ebdd466b38527c23">&#9670;&nbsp;</a></span>getI64SubArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; mlir::getI64SubArray </td>
          <td>(</td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>arrayAttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dropFront</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dropBack</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to return a subset of <code>arrayAttr</code> as a vector of int64_t. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00281">281</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="CRunnerUtils_8h_source.html#l00118">dropFront()</a>.</p>

</div>
</div>
<a id="a820f3296c3cd59eaed418f42f874a217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820f3296c3cd59eaed418f42f874a217">&#9670;&nbsp;</a></span>getInnermostParallelLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::getInnermostParallelLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>rootOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; scf::ParallelOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of innermost parallel loops contained in <code>rootOp</code>. </p>
<p>Innermost parallel loops are those that do not contain further parallel loops themselves. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00246">246</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00672">mlir::Operation::getRegions()</a>.</p>

</div>
</div>
<a id="ace39a548030ae8416f5ae52af1eb24e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace39a548030ae8416f5ae52af1eb24e1">&#9670;&nbsp;</a></span>getLinearizedDimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallBitVector mlir::getLinearizedDimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociationIndices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine which dimensions are linearized by a <code>tensor.collapse_shape</code> op by inspecting its reassociation indices. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00286">286</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>.</p>

</div>
</div>
<a id="a74485bec820f2186ce852a09f45ebd47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74485bec820f2186ce852a09f45ebd47">&#9670;&nbsp;</a></span>getMaxDimAndSymbol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AffineExprContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mlir::getMaxDimAndSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineExprContainer &gt;&#160;</td>
          <td class="paramname"><em>exprsList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>maxDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>maxSym</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates maximum dimension and symbol positions from the expressions in <code>exprsLists</code> and stores them in <code>maxDim</code> and <code>maxSym</code> respectively. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00697">697</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="PolynomialApproximation_8cpp_source.html#l00213">max()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00297">inferFromExprList()</a>, and <a class="el" href="MLIRContext_8cpp_source.html#l01223">willBeValidAffineMap()</a>.</p>

</div>
</div>
<a id="abad6a59a2a6b463b300c786547c64563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad6a59a2a6b463b300c786547c64563">&#9670;&nbsp;</a></span>getMixedValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; mlir::getMixedValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>staticValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>dynamicValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector of OpFoldResults with the same size a staticValues, but all elements for which ShapedType::isDynamic is true, will be replaced by dynamicValues. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00166">166</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00152">mlir::Builder::getI64IntegerAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00024">inferExpandShapeOutputShape()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00325">mlir::ComposeExpandOfCollapseOp&lt; ExpandOpTy, CollapseOpTy &gt;::matchAndRewrite()</a>, and <a class="el" href="ReshapeOpsUtils_8h_source.html#l00191">mlir::ComposeReassociativeReshapeOps&lt; ReshapeOpTy, opKind &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="aeb248e9fd529c9528e4e235a52941e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb248e9fd529c9528e4e235a52941e67">&#9670;&nbsp;</a></span>getMultiAffineFunctionFromMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::getMultiAffineFunctionFromMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1presburger_1_1MultiAffineFunction.html">presburger::MultiAffineFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>multiAff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01306">1306</a> of file <a class="el" href="FlatLinearValueConstraints_8cpp_source.html">FlatLinearValueConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00192">getFlattenedAffineExprs()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01023">mlir::presburger::IntegerRelation::getLocalReprs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumDims()</a>, <a class="el" href="Analysis_2Presburger_2Utils_8h_source.html#l00125">mlir::presburger::DivisionRepr::getNumDivs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00402">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="Analysis_2Presburger_2Utils_8h_source.html#l00133">mlir::presburger::DivisionRepr::hasAllReprs()</a>.</p>

</div>
</div>
<a id="a0d96a98d184d13853b53c410d814775c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d96a98d184d13853b53c410d814775c">&#9670;&nbsp;</a></span>getOffsetsSizesAndStrides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt; mlir::getOffsetsSizesAndStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>ranges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an array of <a class="el" href="structmlir_1_1Range.html" title="Represents a range (offset, size, and stride) where each element of the triple may be dynamic or stat...">Range</a> values, return a tuple of (offset vector, sizes vector, and strides vector) formed by separating out the individual elements of each range. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00028">28</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

</div>
</div>
<a id="a45e134959101de052e7dbfd12610b5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e134959101de052e7dbfd12610b5d6">&#9670;&nbsp;</a></span>getOrCreateRanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a>, 8 &gt; mlir::getOrCreateRanges </td>
          <td>(</td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the list of <a class="el" href="structmlir_1_1Range.html" title="Represents a range (offset, size, and stride) where each element of the triple may be dynamic or stat...">Range</a> (i.e. </p>
<p>offset, size, stride). Each <a class="el" href="structmlir_1_1Range.html" title="Represents a range (offset, size, and stride) where each element of the triple may be dynamic or stat...">Range</a> entry contains either the dynamic value or a ConstantIndexOp constructed with <code>b</code> at location <code>loc</code>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l03033">3033</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

</div>
</div>
<a id="a002c6258ba17b3a08e25cde241861c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002c6258ba17b3a08e25cde241861c3f">&#9670;&nbsp;</a></span>getPerfectlyNestedLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getPerfectlyNestedLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; scf::ForOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>nestedLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get perfectly nested sequence of loops starting at root of loop nest (the first op being another AffineFor, and the second op - a terminator). </p>
<p>A loop is perfectly nested iff: the first op in the loop's body is another AffineForOp, and the second op is a terminator). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01313">1313</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01215">getPerfectlyNestedLoopsImpl()</a>.</p>

</div>
</div>
<a id="ac1bdf7e87740dbe0f603efdbc83c0a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1bdf7e87740dbe0f603efdbc83c0a68">&#9670;&nbsp;</a></span>getPositionsOfShapeOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallBitVector mlir::getPositionsOfShapeOne </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00091">91</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a id="ab45e3ce76869b05848f96a5f8b97fc90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45e3ce76869b05848f96a5f8b97fc90">&#9670;&nbsp;</a></span>getProjectedMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::getProjectedMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>projectedDimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressDimsFlag</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressSymbolsFlag</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <code>projectDims(map, projectedDimensions, compressDimsFlag)</code>. </p>
<p>If <code>compressSymbolsFlag</code> is true, additionally call <code>compressUnusedSymbols</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00918">918</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00736">compressUnusedSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00904">projectDims()</a>.</p>

</div>
</div>
<a id="aeba376b9b63ed400e64bb041e459a62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba376b9b63ed400e64bb041e459a62e">&#9670;&nbsp;</a></span>getPrunedAttributeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &gt; mlir::getPrunedAttributeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt;&#160;</td>
          <td class="paramname"><em>elidedAttrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00220">220</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00720">mlir::tensor::bubbleUpPadSlice()</a>.</p>

</div>
</div>
<a id="a12acf2020ef95ce0a5d7c3f2bbb6af14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12acf2020ef95ce0a5d7c3f2bbb6af14">&#9670;&nbsp;</a></span>getReassociationAttrName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getReassociationAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> name for the ArrayAttr which encodes reassociation indices. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00031">31</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

</div>
</div>
<a id="a8ecbdeef85cdbc2ce3b49a088fa5946a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ecbdeef85cdbc2ce3b49a088fa5946a">&#9670;&nbsp;</a></span>getReassociationIndicesAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrayAttr mlir::getReassociationIndicesAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a list of reassociations in an ArrayAttr. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00160">160</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00297">mlir::Builder::getArrayAttr()</a>, and <a class="el" href="Builders_8cpp_source.html#l00312">mlir::Builder::getI64ArrayAttr()</a>.</p>

</div>
</div>
<a id="a76b303e750705222900d23e44f2a22ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b303e750705222900d23e44f2a22ce">&#9670;&nbsp;</a></span>getReassociationIndicesForCollapse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; &gt; mlir::getReassociationIndicesForCollapse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sourceShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>targetShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the reassociation maps to collapse <code>sourceShape</code> to <code>targetShape</code> if possible. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00032">32</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00020">getReassociationIndicesForReshape()</a>.</p>

</div>
</div>
<a id="a6783c78835273b8062a5b5e2a710d863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6783c78835273b8062a5b5e2a710d863">&#9670;&nbsp;</a></span>getReassociationIndicesForReshape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; &gt; mlir::getReassociationIndicesForReshape </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>sourceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>targetType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the reassociations maps to use to reshape given the source type and the target type when possible. </p>
<p>Return std::nullopt when this computation failed. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00020">20</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00032">getReassociationIndicesForCollapse()</a>.</p>

</div>
</div>
<a id="ab22ed238130b85dadcd9f75892b540b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22ed238130b85dadcd9f75892b540b1">&#9670;&nbsp;</a></span>getSCFMinMaxExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::pair&lt;<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&gt; &gt; mlir::getSCFMinMaxExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>loopFilter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the min/max expressions for <code>value</code> if it is an induction variable from scf.for or scf.parallel loop. </p>
<p>if <code>loopFilter</code> is passed, the filter determines which loop to consider. Other induction variables are ignored. </p>

</div>
</div>
<a id="a03521cb5a2e00b91574ef1df705310bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03521cb5a2e00b91574ef1df705310bd">&#9670;&nbsp;</a></span>getSinglyExecutedRegionsToSink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getSinglyExecutedRegionsToSink </td>
          <td>(</td>
          <td class="paramtype">RegionBranchOpInterface&#160;</td>
          <td class="paramname"><em>branch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>regions</code> with regions of the provided region branch op that are executed at most once at that are reachable given the current operands of the op. </p>
<p>These regions can be passed to <code>controlFlowSink</code> to perform sinking on the regions of the operation. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowSinkUtils_8cpp_source.html#l00135">135</a> of file <a class="el" href="ControlFlowSinkUtils_8cpp_source.html">ControlFlowSinkUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00271">mlir::InvocationBounds::getUpperBound()</a>, <a class="el" href="Matchers_8h_source.html#l00369">m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00485">matchPattern()</a>.</p>

</div>
</div>
<a id="acd9f91ff576a4cb961289ea2f9e3dd0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9f91ff576a4cb961289ea2f9e3dd0f">&#9670;&nbsp;</a></span>getSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::getSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1BackwardSliceOptions.html">BackwardSliceOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>backwardSliceOptions</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a5bbb33912ce41da593598188d8bcc13a">ForwardSliceOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>forwardSliceOptions</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iteratively computes backward slices and forward slices until a fixed point is reached. </p>
<p>Returns an <code>SetVector&lt;<a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> *&gt;</code> which <b>includes</b> the original operation.</p>
<p>This allows building a slice (i.e. multi-root DAG where everything that is reachable from an <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> in forward and backward direction is contained in the slice). This is the abstraction we need to materialize all the operations for supervectorization without worrying about orderings and <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> replacements.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Example starting from any node</h1>
<p>1 2 3 4 |_______| |______| | | | | | 5 6___| |___|_____________| | | | | 7 8 | |_______________| | | | 9 10</p>
<p>Return the whole DAG in some topological order.</p>
<p>The implementation works by just filling up a worklist with iterative alternate calls to <code>getBackwardSlice</code> and <code>getForwardSlice</code>.</p>
<p>The following section describes some additional implementation considerations for a potentially more efficient implementation but they are just an intuition without proof, we still use a worklist for now.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Additional implementation considerations</h1>
<p>Consider the defs-op-uses hourglass. </p><hr  />
<p> \ / defs (in some topological order) \/ op /\ / \ uses (in some topological order) /____\</p>
<p>We want to iteratively apply <code>getSlice</code> to construct the whole list of <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> that are reachable by (use|def)+ from op. We want the resulting slice in topological order. Ideally we would like the ordering to be maintained in-place to avoid copying <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> at each step. Keeping this ordering by construction seems very unclear, so we list invariants in the hope of seeing whether useful properties pop up.</p>
<p>In the following: we use |= for set inclusion; we use &lt;&lt; for set topological ordering (i.e. each pair is ordered).</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Assumption:</h1>
<p>We wish to maintain the following property by a recursive argument: """ defs &lt;&lt; {op} &lt;&lt;uses are in topological order. """ The property clearly holds for 0 and 1-sized uses and defs;</p>
<p>Invariants:</p><ol type="1">
<li>defs and uses are in topological order internally, by construction;</li>
<li>for any {x} |= defs, defs(x) |= defs; because all go through op</li>
<li>for any {x} |= uses, defs |= defs(x); because all go through op</li>
<li>for any {x} |= defs, uses |= uses(x); because all go through op</li>
<li>for any {x} |= uses, uses(x) |= uses; because all go through op</li>
</ol>
<p>Intuitively, we should be able to recurse like: preorder(defs) - op - postorder(uses) and keep things ordered but this is still hand-wavy and not worth the trouble for now: punt to a simple worklist-based solution. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00144">144</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

</div>
</div>
<a id="a10337918edd90e6a270db09d71d66dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10337918edd90e6a270db09d71d66dc5">&#9670;&nbsp;</a></span>getSlicedDimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallBitVector mlir::getSlicedDimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sliceInputShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>sliceParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The input parameters <code>offsets</code>, <code>sizes</code>, <code>strides</code> specify a rectangular non rank-reducing slice of the collapse_shape output. </p>
<p>Try to find which dimensions have been sliced and which dimensions are not sliced (offset = 0, size = dim, size = 1). Note that this conservative as it cannot detect if a dynamic size corresponds to the full tensor dimension or not. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00269">269</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00105">getConstantIntValue()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00144">isEqualConstantIntOrValue()</a>.</p>

</div>
</div>
<a id="a91209454b6a2bc993c1d3ebc2ac3aab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91209454b6a2bc993c1d3ebc2ac3aab1">&#9670;&nbsp;</a></span>getStridesAndOffset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;, int64_t &gt; mlir::getStridesAndOffset </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around getStridesAndOffset(MemRefType, SmallVectorImpl&lt;int64_t&gt;, int64_t) that will assert if the logical result is not succeeded. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00853">853</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00823">getStridesAndOffset()</a>.</p>

</div>
</div>
<a id="a506c478f802ab2f874c0b34a18bc091b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506c478f802ab2f874c0b34a18bc091b">&#9670;&nbsp;</a></span>getStridesAndOffset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::getStridesAndOffset </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the strides of the MemRef if the layout map is in strided form. </p>
<p>MemRefs with a layout map in strided form include:</p><ol type="1">
<li>empty or identity layout map, in which case the stride information is the canonical form computed from sizes;</li>
<li>a StridedLayoutAttr layout;</li>
<li>any other layout that be converted into a single affine map layout of the form <code>K + k0 * d0 + ... kn * dn</code>, where K and ki's are constants or symbols.</li>
</ol>
<p>A stride specification is a list of integer values that are either static or dynamic (encoded with ShapedType::kDynamic). Strides encode the distance in the number of elements between successive entries along a particular dimension. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00823">823</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefBuilder_8cpp_source.html#l00191">mlir::MemRefDescriptor::bufferPtr()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00536">mlir::LLVMTypeConverter::canConvertToBarePtr()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00026">mlir::bufferization::castOrReallocMemRefValue()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02416">computeCollapsedLayoutMap()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02221">computeExpandedLayoutMap()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00938">computeMemRefRankReductionMask()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00049">mlir::MemRefDescriptor::fromStaticShape()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00141">getCastCompatibleMemRefType()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00163">getConstantOffset()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00176">getConstantStrides()</a>, <a class="el" href="DecomposeMemRefs_8cpp_source.html#l00045">getFlatOffsetAndStrides()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l01242">mlir::spirv::getOpenCLElementPtr()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00126">getStaticallyKnownRowStride()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00853">getStridesAndOffset()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l01211">mlir::spirv::getVulkanElementPtr()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00027">hasFullyDynamicLayoutMap()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02911">haveCompatibleOffsets()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02922">haveCompatibleStrides()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l03340">inferTransposeResultType()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00980">isLastMemrefDimUnitStride()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00024">mlir::memref::isStaticShapeAndContiguousRowMajor()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00973">isStrided()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00512">mlirMemRefTypeGetStridesAndOffset()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00618">mlir::memref::populateMemRefNarrowTypeEmulationConversions()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00987">trailingNDimsContiguous()</a>.</p>

</div>
</div>
<a id="a561d5231fcefc471a4c9069fce2eaf87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561d5231fcefc471a4c9069fce2eaf87">&#9670;&nbsp;</a></span>getSymbolLessAffineMaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, 4 &gt; mlir::getSymbolLessAffineMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ae5cf0e24a954fa30fb469105d4ca5dd8">ReassociationExprs</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs affine maps out of Array&lt;Array&lt;AffineExpr&gt;&gt;. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00184">184</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01240">mlir::AffineMap::get()</a>, and <a class="el" href="IndexingUtils_8cpp_source.html#l00295">getContext()</a>.</p>

</div>
</div>
<a id="a348ed9fcbefe1f5094cc571c346c7080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348ed9fcbefe1f5094cc571c346c7080">&#9670;&nbsp;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::getType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the int type of the integer in ofr. </p>
<p>Other attribute types are not supported. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00305">305</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenUtils_8cpp_source.html#l00380">mlir::sparse_tensor::allocaBuffer()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00053">mlir::bufferization::BufferizeTypeConverter::BufferizeTypeConverter()</a>, <a class="el" href="PredicateTree_8cpp_source.html#l00422">buildCostGraph()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00689">collectReductionInfo()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00422">createFullPartialVectorTransferWrite()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00846">mlir::LLVM::detail::createIntrinsicCall()</a>, <a class="el" href="CFGToSCF_8cpp_source.html#l00555">createSingleExitingLatch()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00760">denormalizeInductionVariable()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00412">mlir::spirv::Deserializer::processOp&lt; spirv::FunctionCallOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00526">mlir::spirv::Deserializer::processOp&lt; spirv::GenericCastToPtrExplicitOp &gt;()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00390">mlir::linalg::dropUnitDims()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00689">emitNormalizedLoopBounds()</a>, <a class="el" href="Fusion_8cpp_source.html#l00113">fuse()</a>, <a class="el" href="AffineOps_8h_source.html#l00159">mlir::affine::AffineDmaStartOp::getDstMemorySpace()</a>, <a class="el" href="AffineOps_8h_source.html#l00154">mlir::affine::AffineDmaStartOp::getDstMemRefRank()</a>, <a class="el" href="AffineOps_8h_source.html#l00149">mlir::affine::AffineDmaStartOp::getDstMemRefType()</a>, <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00168">mlir::sparse_tensor::getMemRefType()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00804">getProductOfIntsOrIndexes()</a>, <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00160">mlir::sparse_tensor::getRankedTensorType()</a>, <a class="el" href="AffineOps_8h_source.html#l00135">mlir::affine::AffineDmaStartOp::getSrcMemorySpace()</a>, <a class="el" href="AffineOps_8h_source.html#l00113">mlir::affine::AffineDmaStartOp::getSrcMemRefType()</a>, <a class="el" href="AffineOps_8h_source.html#l00192">mlir::affine::AffineDmaStartOp::getTagMemRefRank()</a>, <a class="el" href="AffineOps_8h_source.html#l00334">mlir::affine::AffineDmaWaitOp::getTagMemRefRank()</a>, <a class="el" href="AffineOps_8h_source.html#l00187">mlir::affine::AffineDmaStartOp::getTagMemRefType()</a>, <a class="el" href="AffineOps_8h_source.html#l00316">mlir::affine::AffineDmaWaitOp::getTagMemRefType()</a>, <a class="el" href="Nodes_8h_source.html#l00600">mlir::pdll::ast::RangeExpr::getType()</a>, <a class="el" href="Nodes_8h_source.html#l00633">mlir::pdll::ast::TupleExpr::getType()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00103">handleMultidimensionalVectors()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00045">materializeToTensor()</a>, <a class="el" href="LLVM_8cpp_source.html#l00343">mlirLLVMDISubprogramAttrGetType()</a>, <a class="el" href="Transform_8cpp_source.html#l00106">mlirTransformParamTypeGetType()</a>, <a class="el" href="CAPI_2IR_2BuiltinTypes_8cpp_source.html#l00570">mlirTupleTypeGetType()</a>, <a class="el" href="IR_8cpp_source.html#l00974">mlirValueGetType()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00079">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01660">mlir::affine::AffineDmaStartOp::verifyInvariantsImpl()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01777">mlir::affine::AffineDmaWaitOp::verifyInvariantsImpl()</a>.</p>

</div>
</div>
<a id="ac61c6bb6068af953a0711cf404a99645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61c6bb6068af953a0711cf404a99645">&#9670;&nbsp;</a></span>getUnusedDimsBitVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallBitVector mlir::getUnusedDimsBitVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>maps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00928">928</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00722">compressUnusedDims()</a>.</p>

</div>
</div>
<a id="a2798707e1d2321021e16802305d3c152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2798707e1d2321021e16802305d3c152">&#9670;&nbsp;</a></span>getUnusedSymbolsBitVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallBitVector mlir::getUnusedSymbolsBitVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>maps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00940">940</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00736">compressUnusedSymbols()</a>.</p>

</div>
</div>
<a id="a2c45b388f069e9396c50660f41a7eacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c45b388f069e9396c50660f41a7eacf">&#9670;&nbsp;</a></span>getUsedValuesDefinedAbove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill <code>values</code> with a list of values used within any of the regions provided but defined in one of the ancestors. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00074">74</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00067">getUsedValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="a98f08e970a346cd42559db87f97f0b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f08e970a346cd42559db87f97f0b91">&#9670;&nbsp;</a></span>getUsedValuesDefinedAbove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill <code>values</code> with a list of values defined at the ancestors of the <code>limit</code> region and used within <code>region</code> or its descendants. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00067">67</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00040">visitUsedValuesDefinedAbove()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassDetail_8cpp_source.html#l00020">mlir::async::cloneConstantsIntoTheRegion()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00074">getUsedValuesDefinedAbove()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00084">makeRegionIsolatedFromAbove()</a>, <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00296">outlineExecuteOp()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00178">outlineKernelFuncImpl()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00119">outlineSingleBlockRegion()</a>, and <a class="el" href="KernelOutlining_8cpp_source.html#l00123">sinkOperationsIntoLaunchOp()</a>.</p>

</div>
</div>
<a id="a7d8bbfc3d0c15e92f5cba28e5ef447b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8bbfc3d0c15e92f5cba28e5ef447b5">&#9670;&nbsp;</a></span>getValueOrCreateCastToIndexLike()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::getValueOrCreateCastToIndexLike </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>targetType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a cast from an index-like value (index or integer) to another index-like value. </p>
<p>If the value type and the target type are the same, it returns the original value. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00120">120</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="Value_8h_source.html#l00129">mlir::Value::getType()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00064">mlir::Type::isIndex()</a>.</p>

</div>
</div>
<a id="ab09c62516a7b31fc96892014feeae832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09c62516a7b31fc96892014feeae832">&#9670;&nbsp;</a></span>getValueOrCreateConstantIndexOp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::getValueOrCreateConstantIndexOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>valueOrAttrVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the other overload, but converts multiple OpFoldResults into Values. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00263">263</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00112">getValueOrCreateConstantIndexOp()</a>.</p>

</div>
</div>
<a id="aa058eb9c12d3b97deb073543c1372195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa058eb9c12d3b97deb073543c1372195">&#9670;&nbsp;</a></span>getValueOrCreateConstantIndexOp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::getValueOrCreateConstantIndexOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>
<p>Returns the fold result if it casts to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> or creates a ConstantIndexOp if it casts to an Integer <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>. Other attribute types are not supported. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00112">112</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00720">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00931">HopperBuilder::buildAndInitBarrierInSharedMemory()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00995">HopperBuilder::buildBarrierArriveTx()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00945">HopperBuilder::buildGlobalMemRefDescriptor()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00050">buildLinearId()</a>, <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00376">calculateExpandedAccessIndices()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00043">createInBoundsCond()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01852">mlir::affine::delinearizeIndex()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00735">denormalizeInductionVariableForIndexType()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l03187">denormalizeIndVar()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00393">generateLoopNestUsingForOp()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00205">getBoundedTileSize()</a>, <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00043">getCompressedMaskOp()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00128">getIndicesForLoadOrStore()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00090">getOffsetForBitwidth()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00804">getProductOfIntsOrIndexes()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00263">getValueOrCreateConstantIndexOp()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00099">mlir::memref::multiBuffer()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00822">mlir::linalg::offsetIndices()</a>, <a class="el" href="Promotion_8cpp_source.html#l00238">mlir::linalg::promoteSubviewAsNewBuffer()</a>, <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00081">mlir::affine::resolveIndicesIntoOpWithOffsetsAndStrides()</a>, <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00166">resolveSourceIndicesCollapseShape()</a>, <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00063">resolveSourceIndicesExpandShape()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00129">unpackRanges()</a>.</p>

</div>
</div>
<a id="a4654f8a83dcd16f99ce83a6a991fa348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4654f8a83dcd16f99ce83a6a991fa348">&#9670;&nbsp;</a></span>getValueOrCreateConstantIntOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::getValueOrCreateConstantIntOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>
<p>Returns the fold result if it casts to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> or creates a ConstantOp if it casts to an Integer <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>. Other attribute types are not supported. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00103">103</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, and <a class="el" href="Builders_8cpp_source.html#l00262">mlir::Builder::getIntegerAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00896">coalesceLoops()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01057">collapseParallelLoops()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00760">denormalizeInductionVariable()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00689">emitNormalizedLoopBounds()</a>.</p>

</div>
</div>
<a id="ac4a106cc8c510602a1ee219489b64c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a106cc8c510602a1ee219489b64c5c">&#9670;&nbsp;</a></span>getValuesSortedByKey() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t&gt; mlir::getValuesSortedByKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt;&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00229">229</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Fraction_8h_source.html#l00068">mlir::presburger::compare()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00201">getValuesSortedByKeyImpl()</a>.</p>

</div>
</div>
<a id="af3ec25d896f63f835649e57fa1156deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ec25d896f63f835649e57fa1156deb">&#9670;&nbsp;</a></span>getValuesSortedByKey() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::getValuesSortedByKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt;&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00223">223</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Fraction_8h_source.html#l00068">mlir::presburger::compare()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00201">getValuesSortedByKeyImpl()</a>.</p>

</div>
</div>
<a id="ae8b5c05e14ade6108624f49c4c8bf104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b5c05e14ade6108624f49c4c8bf104">&#9670;&nbsp;</a></span>getValuesSortedByKey() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::getValuesSortedByKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt;&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to sort <code>values</code> according to matching <code>keys</code>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00217">217</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Fraction_8h_source.html#l00068">mlir::presburger::compare()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00201">getValuesSortedByKeyImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUTransformOps_8cpp_source.html#l00414">rewriteOneForallCommonImpl()</a>.</p>

</div>
</div>
<a id="aaf9994bf5e77db2932598481cf8e46fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9994bf5e77db2932598481cf8e46fb">&#9670;&nbsp;</a></span>getValuesSortedByKeyImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;V&gt; mlir::getValuesSortedByKeyImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; K &gt;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; V &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(K, K)&gt;&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to sort <code>values</code> according to matching <code>keys</code>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00201">201</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="StaticValueUtils_8cpp_source.html#l00217">getValuesSortedByKey()</a>.</p>

</div>
</div>
<a id="ac155ca106ea75d1bf8f9b995d7e2d99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac155ca106ea75d1bf8f9b995d7e2d99d">&#9670;&nbsp;</a></span>hasEffect() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... EffectTys&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::hasEffect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>op</code> has an effect of type <code>EffectTy</code>. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00211">211</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

</div>
</div>
<a id="ae27d7e4ff6226389cfa4a4a5129caea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27d7e4ff6226389cfa4a4a5129caea0">&#9670;&nbsp;</a></span>hasEffect() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... EffectTys&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::hasEffect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>op</code> has an effect of type <code>EffectTy</code> on <code>value</code>. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00229">229</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

</div>
</div>
<a id="a4bc8a79e07b7e048723a9fbfe9bc914e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc8a79e07b7e048723a9fbfe9bc914e">&#9670;&nbsp;</a></span>hasEffect() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueTy , typename... EffectTys&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::hasEffect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueTy&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>op</code> has an effect of type <code>EffectTy</code> on <code>value</code> of type <code>ValueTy</code>. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00251">251</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

</div>
</div>
<a id="ad9141d8b586a68549d2ecaccbce99a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9141d8b586a68549d2ecaccbce99a69">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> hashable. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00260">260</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="OperationSupport_8h_source.html#l01291">mlir::OperationEquivalence::directHashValue()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00402">llvm::DenseMapInfo&lt; mlir::AffineExpr &gt;::getHashValue()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00726">llvm::DenseMapInfo&lt; mlir::AffineMap &gt;::getHashValue()</a>, <a class="el" href="Attributes_8h_source.html#l00355">llvm::DenseMapInfo&lt; mlir::Attribute &gt;::getHashValue()</a>, <a class="el" href="mlir_2IR_2IntegerSet_8h_source.html#l00142">llvm::DenseMapInfo&lt; mlir::IntegerSet &gt;::getHashValue()</a>, <a class="el" href="Location_8h_source.html#l00214">llvm::DenseMapInfo&lt; mlir::Location &gt;::getHashValue()</a>, <a class="el" href="Attributes_8h_source.html#l00400">llvm::DenseMapInfo&lt; mlir::NamedAttribute &gt;::getHashValue()</a>, <a class="el" href="IR_2Types_8h_source.html#l00370">llvm::DenseMapInfo&lt; mlir::Type &gt;::getHashValue()</a>, <a class="el" href="TypeID_8h_source.html#l00347">llvm::DenseMapInfo&lt; mlir::TypeID &gt;::getHashValue()</a>, and <a class="el" href="Value_8h_source.html#l00514">llvm::DenseMapInfo&lt; mlir::Value &gt;::getHashValue()</a>.</p>

</div>
</div>
<a id="a032c893ca9a2fff3b16e5a7cb6d413cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032c893ca9a2fff3b16e5a7cb6d413cd">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00425">425</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

</div>
</div>
<a id="a68bae84b1d7cdba11b048d9af3478a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bae84b1d7cdba11b048d9af3478a07">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Attributes_8h_source.html#l00198">198</a> of file <a class="el" href="Attributes_8h_source.html">Attributes.h</a>.</p>

</div>
</div>
<a id="aac18c17aca8d8a8549fef55a52af5393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac18c17aca8d8a8549fef55a52af5393">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AsmDialectResourceHandle.html">AsmDialectResourceHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="OpImplementation_8h_source.html#l00043">mlir::AsmDialectResourceHandle::getResource()</a>.</p>

</div>
</div>
<a id="aa4b795f2f972c070efff53082563f976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b795f2f972c070efff53082563f976">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Attributes_8h_source.html#l00256">256</a> of file <a class="el" href="Attributes_8h_source.html">Attributes.h</a>.</p>

</div>
</div>
<a id="a655bb0e17a21ea2c35194f7c822c9ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655bb0e17a21ea2c35194f7c822c9ca5">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2IntegerSet_8h_source.html#l00124">124</a> of file <a class="el" href="mlir_2IR_2IntegerSet_8h_source.html">IntegerSet.h</a>.</p>

</div>
</div>
<a id="aa6261878bc5197cfcc003e5b3fa735ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6261878bc5197cfcc003e5b3fa735ea">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Location_8h_source.html#l00129">129</a> of file <a class="el" href="Location_8h_source.html">Location.h</a>.</p>

</div>
</div>
<a id="ad93109842c1b05424c5052d9bd9a4394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93109842c1b05424c5052d9bd9a4394">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00515">515</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00485">mlir::OperationName::getAsOpaquePointer()</a>.</p>

</div>
</div>
<a id="a31eede9183d3fdae566e18d94a5ef51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31eede9183d3fdae566e18d94a5ef51b">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00326">326</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="aafb3bcc9d23b2cfd1367b84f5b00b7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb3bcc9d23b2cfd1367b84f5b00b7c1">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable hashing <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a>. </p>

<p class="definition">Definition at line <a class="el" href="TypeID_8h_source.html#l00149">149</a> of file <a class="el" href="TypeID_8h_source.html">TypeID.h</a>.</p>

</div>
</div>
<a id="abb322b17530b4289c3e3ec1f4ad2ecce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb322b17530b4289c3e3ec1f4ad2ecce">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make <a class="el" href="classmlir_1_1TypeRange.html" title="This class provides an abstraction over the various different ranges of value types.">TypeRange</a> hashable. </p>

<p class="definition">Definition at line <a class="el" href="TypeRange_8h_source.html#l00072">72</a> of file <a class="el" href="TypeRange_8h_source.html">TypeRange.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeRange_8h_source.html#l00200">llvm::DenseMapInfo&lt; mlir::TypeRange &gt;::getHashValue()</a>.</p>

</div>
</div>
<a id="ab710b1f6f21f3f35197575b609aae4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab710b1f6f21f3f35197575b609aae4b4">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> hashable. </p>

<p class="definition">Definition at line <a class="el" href="Value_8h_source.html#l00490">490</a> of file <a class="el" href="Value_8h_source.html">Value.h</a>.</p>

</div>
</div>
<a id="a1858ec5ab152ee2a09d4ceaf95cf2811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1858ec5ab152ee2a09d4ceaf95cf2811">&#9670;&nbsp;</a></span>hasNonIdentityLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::hasNonIdentityLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the type is a MemRefType and has a non-identity layout. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00262">262</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ReshapeOpsUtils_8h_source.html#l00259">mlir::ComposeCollapseOfExpandOp&lt; CollapseOpTy, ExpandOpTy, CastOpTy, DimOpTy, TensorTy &gt;::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00325">mlir::ComposeExpandOfCollapseOp&lt; ExpandOpTy, CollapseOpTy &gt;::matchAndRewrite()</a>, and <a class="el" href="ReshapeOpsUtils_8h_source.html#l00191">mlir::ComposeReassociativeReshapeOps&lt; ReshapeOpTy, opKind &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a54bdf3d5eaaef529cc7cf1ea0fa1808b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bdf3d5eaaef529cc7cf1ea0fa1808b">&#9670;&nbsp;</a></span>hasSingleEffect() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EffectTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::hasSingleEffect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>op</code> has only an effect of type <code>EffectTy</code>. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00107">107</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

</div>
</div>
<a id="a4e5c028078f8fdc86950f374b834cb07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5c028078f8fdc86950f374b834cb07">&#9670;&nbsp;</a></span>hasSingleEffect() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EffectTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::hasSingleEffect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>op</code> has only an effect of type <code>EffectTy</code> (and of no other type) on <code>value</code>. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00129">129</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

</div>
</div>
<a id="a1879b99cadf0d3c0c5de98b33412b650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1879b99cadf0d3c0c5de98b33412b650">&#9670;&nbsp;</a></span>hasSingleEffect() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueTy , typename EffectTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::hasSingleEffect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueTy&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>op</code> has only an effect of type <code>EffectTy</code> (and of no other type) on <code>value</code> of type <code>ValueTy</code>. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00158">158</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

</div>
</div>
<a id="a653bf589569eab36eb696bc4db3371c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653bf589569eab36eb696bc4db3371c6">&#9670;&nbsp;</a></span>hasValidSizesOffsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::hasValidSizesOffsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizesOrOffsets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to check whether the passed in <code>sizes</code> or <code>offsets</code> are valid. </p>
<p>This can be used to re-check whether dimensions are still valid after constant folding the dynamic dimensions. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00254">254</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

</div>
</div>
<a id="a88795bccdeef2b7388f2bbd6d1c15ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88795bccdeef2b7388f2bbd6d1c15ae7">&#9670;&nbsp;</a></span>hasValidStrides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::hasValidStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>strides</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to check whether the passed in <code>strides</code> are valid. </p>
<p>This can be used to re-check whether dimensions are still valid after constant folding the dynamic dimensions. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00260">260</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

</div>
</div>
<a id="a249488f6fe37fa1e0175eed93494136d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249488f6fe37fa1e0175eed93494136d">&#9670;&nbsp;</a></span>hoistLoopInvariantSubsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LoopLikeOpInterface mlir::hoistLoopInvariantSubsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoopLikeOpInterface&#160;</td>
          <td class="paramname"><em>loopLike</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoist loop-invariant tensor subsets (subset extraction and subset insertion ops) from loop-like ops. </p>
<p>Extraction ops are moved before the loop. Insertion ops are moved after the loop. The loop body operates on newly added region iter_args (one per extraction-insertion pair).</p>
<p>A subset extraction op (<code>SubsetExtractionOpInterface</code>) extracts from a tensor value at a subset. The result of the op may have an arbitrary type, i.e., not necessarily a tensor type. Example: "tensor.extract_slice".</p>
<p>A subset insertion op (<code>SubsetInsertionOpInterface</code>) inserts into a tensor value ("destination") at a subset. Example: "tensor.insert_slice".</p>
<p>Matching extraction-insertion subset ops can be hoisted from a loop if there are no other ops within the loop that operate on the same or on an overlapping subset. In particular, non-subset ops can prevent hoisting because the analysis does not know what subset they operate on.</p>
<p>Example: </p><div class="fragment"><div class="line">%r = scf.for ... iter_args(%t = %a) -&gt; (tensor&lt;?xf32&gt;) {</div>
<div class="line">  %0 = tensor.extract_slice %t[0][5][1] : tensor&lt;?xf32&gt; to tensor&lt;5xf32&gt;</div>
<div class="line">  %1 = <span class="stringliteral">&quot;test.foo&quot;</span>(%0) : (tensor&lt;5xf32&gt;) -&gt; (tensor&lt;5xf32&gt;)</div>
<div class="line">  %2 = tensor.insert_slice %1 into %t[0][5][1]</div>
<div class="line">      : tensor&lt;5xf32&gt; into tensor&lt;?xf32&gt;</div>
<div class="line">  scf.yield %2 : tensor&lt;?xf32&gt;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Is rewritten to: </p><div class="fragment"><div class="line">%0 = tensor.extract_slice %a[0][5][1] : tensor&lt;?xf32&gt; to tensor&lt;5xf32&gt;</div>
<div class="line">%new_loop:2 = scf.for ... iter_args(%t = %a, %h = %0) -&gt; (tensor&lt;?xf32&gt;) {</div>
<div class="line">  %1 = <span class="stringliteral">&quot;test.foo&quot;</span>(%h) : (tensor&lt;5xf32&gt;) -&gt; (tensor&lt;5xf32&gt;)</div>
<div class="line">  scf.yield %t, %2 : tensor&lt;?xf32&gt;, tensor&lt;5xf32&gt;</div>
<div class="line">}</div>
<div class="line">%r = tensor.insert_slice %new_loop#1 into %new_loop#0</div>
<div class="line">    : tensor&lt;5xf32&gt; into tensor&lt;?xf32&gt;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00392">392</a> of file <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html">LoopInvariantCodeMotionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00321">hoistSubsetAtIterArg()</a>.</p>

</div>
</div>
<a id="aa23862ef78a8ff63b4f6a3c344448e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23862ef78a8ff63b4f6a3c344448e16">&#9670;&nbsp;</a></span>inferExpandShapeOutputShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt; mlir::inferExpandShapeOutputShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>expandedType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>inputShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the output shape for a {memref|tensor}.expand_shape when it is possible to do so. </p>
<p>Note: This should <em>only</em> be used to implement <code>ExpandShapeOp::inferOutputShape</code> in both the memref and tensor namespaces. If you need to infer the output shape you should use the static method of <code>ExpandShapeOp</code> instead of calling this.</p>
<p><code>inputShape</code> is the shape of the tensor or memref being expanded as a sequence of SSA values or constants. <code>expandedType</code> is the output shape of the expand_shape operation. <code>reassociation</code> is the reassociation denoting the output dims each input dim is mapped to.</p>
<p>Returns the output shape in <code>outputShape</code> and <code>staticOutputShape</code>, following the conventions for the output_shape and static_output_shape inputs to the expand_shape ops. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00024">24</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8h_source.html#l00528">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00166">getMixedValues()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00063">resolveSourceIndicesExpandShape()</a>.</p>

</div>
</div>
<a id="afa82b2f82348c0eacc76f1c4a862a796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa82b2f82348c0eacc76f1c4a862a796">&#9670;&nbsp;</a></span>inlineCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::inlineCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallOpInterface&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallableOpInterface&#160;</td>
          <td class="paramname"><em>callable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCloneInlinedRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inlines a given region, 'src', of a callable operation, 'callable', into the location defined by the given call operation. </p>
<p>This function returns failure if inlining is not possible, success otherwise. On failure, no changes are made to the module. 'shouldCloneInlinedRegion' corresponds to whether the source region should be cloned into the 'call' or spliced directly. </p>

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00443">443</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00060">mlir::Region::empty()</a>, and <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>.</p>

</div>
</div>
<a id="ad1236e68e2c467729ae0f0c6189e3d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1236e68e2c467729ae0f0c6189e3d55">&#9670;&nbsp;</a></span>inlineRegion() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::inlineRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>inlineBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>inlinePoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>resultsToReplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>regionResultTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>inlineLoc</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCloneInlinedRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00381">381</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="InliningUtils_8cpp_source.html#l00236">inlineRegionImpl()</a>.</p>

</div>
</div>
<a id="ad1be5dbac3676f88a7f87669ec0f2484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1be5dbac3676f88a7f87669ec0f2484">&#9670;&nbsp;</a></span>inlineRegion() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::inlineRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>inlineBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>inlinePoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>inlinedOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>resultsToReplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>inlineLoc</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCloneInlinedRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00403">403</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="InliningUtils_8cpp_source.html#l00236">inlineRegionImpl()</a>.</p>

</div>
</div>
<a id="a754f32a9d62efdcb48e4e0a2f3da1576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754f32a9d62efdcb48e4e0a2f3da1576">&#9670;&nbsp;</a></span>inlineRegion() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::inlineRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>inlinePoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>resultsToReplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>regionResultTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>inlineLoc</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCloneInlinedRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inlines a region, 'src', into another. </p>
<p>This function returns failure if it is not possible to inline this function. If the function returned failure, then no changes to the module have been made.</p>
<p>The provided 'inlinePoint' must be within a region, and corresponds to the location where the 'src' region should be inlined. 'mapping' contains any remapped operands that are used within the region, and <em>must</em> include remappings for the entry arguments to the region. 'resultsToReplace' corresponds to any results that should be replaced by terminators within the inlined region. 'regionResultTypes' specifies the expected return types of the terminators in the region. 'inlineLoc' is an optional <a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> that, if provided, will be used to update the inlined operations' location information. 'shouldCloneInlinedRegion' corresponds to whether the source region should be cloned into the 'inlinePoint' or spliced directly. </p>

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00371">371</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InliningUtils_8cpp_source.html#l00393">inlineRegion()</a>.</p>

</div>
</div>
<a id="a16442f718030c48c28c7ae986fa39acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16442f718030c48c28c7ae986fa39acf">&#9670;&nbsp;</a></span>inlineRegion() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::inlineRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>inlinePoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>inlinedOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>resultsToReplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>inlineLoc</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCloneInlinedRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is an overload of the above 'inlineRegion' that allows for providing the set of operands ('inlinedOperands') that should be used in-favor of the region arguments when inlining. </p>

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00393">393</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, and <a class="el" href="InliningUtils_8cpp_source.html#l00371">inlineRegion()</a>.</p>

</div>
</div>
<a id="ae873ed9c30ada4ee5e87cf53a550c610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae873ed9c30ada4ee5e87cf53a550c610">&#9670;&nbsp;</a></span>insertTypesInto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> mlir::insertTypesInto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>oldTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>newTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a set of <code>newTypes</code> into <code>oldTypes</code> at the given <code>indices</code>. </p>
<p>If any types are inserted, <code>storage</code> is used to hold the new type list. The new type list is returned. <code>indices</code> must be sorted by increasing index. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00176">176</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

</div>
</div>
<a id="a426b7e62d7400b01d368a3db835df9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426b7e62d7400b01d368a3db835df9d3">&#9670;&nbsp;</a></span>insideMutuallyExclusiveRegions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::insideMutuallyExclusiveRegions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>a</code> and <code>b</code> are in mutually exclusive regions as per RegionBranchOpInterface. </p>
<p>Return <code>true</code> if <code>a</code> and <code>b</code> are in mutually exclusive regions.</p>
<ol type="1">
<li>Find the first common of <code>a</code> and <code>b</code> (ancestor) that implements RegionBranchOpInterface.</li>
<li>Determine the regions <code>regionA</code> and <code>regionB</code> in which <code>a</code> and <code>b</code> are contained.</li>
<li>Check if <code>regionA</code> and <code>regionB</code> are mutually exclusive. They are mutually exclusive if they are not reachable from each other as per RegionBranchOpInterface::getSuccessorRegions. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00284">284</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00238">mlir::Operation::getParentOfType()</a>.</p>

</div>
</div>
<a id="a39612be2ef116102866d3bb9c6a8ca88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39612be2ef116102866d3bb9c6a8ca88">&#9670;&nbsp;</a></span>inverseAndBroadcastProjectedPermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::inverseAndBroadcastProjectedPermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the reverse map of a projected permutation where the projected dimensions are transformed into 0s. </p>
<p>Prerequisites: <code>map</code> must be a projected permutation.</p>
<p>Example 1:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1, d2, d3) -&gt; (d2, d0)&gt;</div>
</div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1) -&gt; (d1, 0, d0, 0)&gt;</div>
</div><!-- fragment --><p>Example 2:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1, d2, d3) -&gt; (d0, d3)&gt;</div>
</div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1) -&gt; (d0, 0, 0, d1)&gt;</div>
</div><!-- fragment --><p>Example 3:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1, d2, d3) -&gt; (d2)&gt;</div>
</div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0) -&gt; (0, 0, d0, 0)&gt;</div>
</div><!-- fragment --><p> Example 4:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1, d2) -&gt; (d0, 0)&gt;</div>
</div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1) -&gt; (d0, 0, 0)&gt;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00815">815</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01240">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00631">getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00607">getAffineDimExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00343">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00415">mlir::AffineMap::getDimPosition()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00402">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00411">mlir::AffineMap::getResult()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00618">mlir::AffineMap::isProjectedPermutation()</a>.</p>

</div>
</div>
<a id="a52b322818d83a2256d4e4391acbf78a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b322818d83a2256d4e4391acbf78a2">&#9670;&nbsp;</a></span>inversePermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::inversePermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map of codomain to domain dimensions such that the first codomain dimension for a particular domain dimension is selected. </p>
<p>Returns an empty map if the input map is empty. Returns null map (not empty map) if <code>map</code> is not invertible (i.e. <code>map</code> does not contain a subset that is a permutation of full domain rank).</p>
<p>Prerequisites:</p><ol type="1">
<li><code>map</code> has no symbols.</li>
</ol>
<p>Example 1:</p>
<div class="fragment"><div class="line">(d0, d1, d2) -&gt; (d1, d1, d0, d2, d1, d2, d1, d0)</div>
<div class="line">                  0       2   3</div>
</div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">(d0, d1, d2, d3, d4, d5, d6, d7) -&gt; (d2, d0, d3)</div>
</div><!-- fragment --><p>Example 2:</p>
<div class="fragment"><div class="line">(d0, d1, d2) -&gt; (d1, d0 + d1, d0, d2, d1, d2, d1, d0)</div>
<div class="line">                  0            2   3</div>
</div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">(d0, d1, d2, d3, d4, d5, d6, d7) -&gt; (d2, d0, d3)</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00791">791</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01240">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00607">getAffineDimExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00343">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00402">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00369">mlir::AffineMap::isEmpty()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00036">mlir::linalg::detail::canOpOperandsBeDroppedImpl()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00390">mlir::linalg::dropUnitDims()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00331">mlir::linalg::fuseElementwiseOps()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00045">getIndexingMapOfProducerOperandsInCoordinatesOfFusedOp()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l01044">mlir::sparse_tensor::inferLvlToDim()</a>, <a class="el" href="VectorOps_8cpp_source.html#l03973">mlir::vector::inferTransferOpMaskType()</a>, <a class="el" href="Interchange_8cpp_source.html#l00050">mlir::linalg::interchangeGenericOp()</a>, <a class="el" href="Interchange_8cpp_source.html#l00036">interchangeGenericOpPrecondition()</a>, and <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00214">mlir::linalg::rewriteInIm2Col()</a>.</p>

</div>
</div>
<a id="afc254f56cba37671e1e5b2b933c6a090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc254f56cba37671e1e5b2b933c6a090">&#9670;&nbsp;</a></span>invertPermutationVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; mlir::invertPermutationVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>permutation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to apply to inverse a permutation. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00205">205</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01093">getPackUnpackNormalizedPerm()</a>, <a class="el" href="TensorOps_8cpp_source.html#l04268">inferStaticShape()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00219">mlir::linalg::lowerPack()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01985">SwapTransposeWithBroadcast::matchAndRewrite()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01227">mlir::linalg::GeneralizeOuterUnitDimsUnPackOpPattern::matchAndRewrite()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01534">vectorizeAsTensorPackOp()</a>.</p>

</div>
</div>
<a id="a2823559fb2fadd8959a578eecc499342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2823559fb2fadd8959a578eecc499342">&#9670;&nbsp;</a></span>isBatchMatvec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isBatchMatvec </td>
          <td>(</td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>indexingMaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the given maps describe a batch matrix vector multiplication. </p>
<p>The test is permutation-invariant. Note that this only checks the affine maps from an operation, so does not perform any checks on the math being performed within the reduction. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00172">172</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01240">mlir::AffineMap::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00033">mlir::AffineExpr::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00402">mlir::AffineMap::getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00411">mlir::AffineMap::getResult()</a>.</p>

</div>
</div>
<a id="a9c3a18535f4146298157c782e5254e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3a18535f4146298157c782e5254e94">&#9670;&nbsp;</a></span>isBatchVecmat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isBatchVecmat </td>
          <td>(</td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>indexingMaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the given maps describe a batch vector matrix multiplication. </p>
<p>The test is permutation-invariant. Note that this only checks the affine maps from an operation, so does not perform any checks on the math being performed within the reduction. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00123">123</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01240">mlir::AffineMap::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00033">mlir::AffineExpr::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00402">mlir::AffineMap::getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00411">mlir::AffineMap::getResult()</a>.</p>

</div>
</div>
<a id="a336eaa1f1417cbe1468e56b34ce866a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336eaa1f1417cbe1468e56b34ce866a1">&#9670;&nbsp;</a></span>isBytecode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isBytecode </td>
          <td>(</td>
          <td class="paramtype">llvm::MemoryBufferRef&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given buffer starts with the magic bytes that signal MLIR bytecode. </p>

<p class="definition">Definition at line <a class="el" href="BytecodeReader_8cpp_source.html#l02563">2563</a> of file <a class="el" href="BytecodeReader_8cpp_source.html">BytecodeReader.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="BytecodeReader_8cpp_source.html#l02571">readBytecodeFileImpl()</a>.</p>

</div>
</div>
<a id="a0dfea8ee2dd0eba944b0cd299591ccf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dfea8ee2dd0eba944b0cd299591ccf9">&#9670;&nbsp;</a></span>isColumnMajorMatmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isColumnMajorMatmul </td>
          <td>(</td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>indexingMaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the given maps describe a column major matmul. </p>
<p>The test is permutation-invariant. Note that this only checks the affine maps from an operation, so does not perform any checks on the math being performed within the reduction. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00046">46</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00402">mlir::AffineMap::getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00411">mlir::AffineMap::getResult()</a>.</p>

</div>
</div>
<a id="a043789541ff1881513700b717bf5491d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043789541ff1881513700b717bf5491d">&#9670;&nbsp;</a></span>isConstantIntValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isConstantIntValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if <code>ofr</code> is constant integer equal to <code>value</code>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00135">135</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00105">getConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00720">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="Tiling_8cpp_source.html#l00367">calculateTileOffsetsAndSizes()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00760">denormalizeInductionVariable()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00735">denormalizeInductionVariableForIndexType()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00474">generateLoopNestUsingForallOp()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00336">getLoopBounds()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00245">getTileOffsetAndSizes()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l03214">normalizeForallLoopOp()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01462">normalizeForallOp()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l01743">mlir::scf::tileAndFuseConsumerOfSlice()</a>.</p>

</div>
</div>
<a id="a2ee77c6f0feb82212b1b817785f95f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee77c6f0feb82212b1b817785f95f48">&#9670;&nbsp;</a></span>isEqualConstantIntOrValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isEqualConstantIntOrValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if ofr1 and ofr2 are the same integer constant attribute values or the same SSA value. </p>
<p>Ignore integer bitwitdh and type mismatch that come from the fact there is no IndexAttr and that IndexType have no bitwidth.</p>
<p>Ignore integer bitwidth and type mismatch that come from the fact there is no IndexAttr and that IndexType has no bitwidth. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00144">144</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00105">getConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00071">mlir::bufferization::Ownership::getCombined()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00269">getSlicedDimensions()</a>, <a class="el" href="Vectorization_8cpp_source.html#l02530">PadOpVectorizationWithTransferWritePattern::hasSameTensorSize()</a>, <a class="el" href="TensorOps_8cpp_source.html#l04241">haveSameTiles()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00153">isEqualConstantIntOrValueArray()</a>.</p>

</div>
</div>
<a id="ab03d63917414f04e985c804f24086b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03d63917414f04e985c804f24086b76">&#9670;&nbsp;</a></span>isEqualConstantIntOrValueArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isEqualConstantIntOrValueArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>ofrs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>ofrs2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00153">153</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00144">isEqualConstantIntOrValue()</a>.</p>

</div>
</div>
<a id="a6cf90202d2d87692ea1b8d22068bffa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf90202d2d87692ea1b8d22068bffa7">&#9670;&nbsp;</a></span>isIdentityPermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isIdentityPermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>permutation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>permutation</code> is an identity permutation. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00215">215</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l04227">hasSameInnerOuterAttribute()</a>.</p>

</div>
</div>
<a id="a3094da0d25a9eabb0cea9f0b859c0adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3094da0d25a9eabb0cea9f0b859c0adc">&#9670;&nbsp;</a></span>isLastMemrefDimUnitStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isLastMemrefDimUnitStride </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return "true" if the last dimension of the given type has a static unit stride. </p>
<p>Also return "true" for types with no strides. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00980">980</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00823">getStridesAndOffset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00092">isMemRefTypeSupported()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00987">trailingNDimsContiguous()</a>.</p>

</div>
</div>
<a id="af57575f33d64fcef5f5027164a59d87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57575f33d64fcef5f5027164a59d87d">&#9670;&nbsp;</a></span>isLegalForBranchOpInterfaceTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isLegalForBranchOpInterfaceTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if op is a BranchOpInterface op whose operands are all legal according to converter. </p>

<p class="definition">Definition at line <a class="el" href="FuncConversions_8cpp_source.html#l00124">124</a> of file <a class="el" href="FuncConversions_8cpp_source.html">FuncConversions.cpp</a>.</p>

</div>
</div>
<a id="a0a4d325aad6186114a919156b25b29bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4d325aad6186114a919156b25b29bc">&#9670;&nbsp;</a></span>isLegalForReturnOpTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isLegalForReturnOpTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>returnOpAlwaysLegal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For ReturnLike ops (except <code>return</code>), return True. </p>
<p>If op is a <code>return</code> &amp;&amp; returnOpAlwaysLegal is false, legalize op according to converter. Otherwise, return false. </p>

<p class="definition">Definition at line <a class="el" href="FuncConversions_8cpp_source.html#l00145">145</a> of file <a class="el" href="FuncConversions_8cpp_source.html">FuncConversions.cpp</a>.</p>

</div>
</div>
<a id="a50aeecdfac818acb74f464b9f19a030e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50aeecdfac818acb74f464b9f19a030e">&#9670;&nbsp;</a></span>isMatvec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isMatvec </td>
          <td>(</td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>indexingMaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the given maps describe a matrix vector multiplication. </p>
<p>The test is permutation-invariant. Note that this only checks the affine maps from an operation, so does not perform any checks on the math being performed within the reduction. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00148">148</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01240">mlir::AffineMap::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00033">mlir::AffineExpr::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00402">mlir::AffineMap::getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00411">mlir::AffineMap::getResult()</a>.</p>

</div>
</div>
<a id="a5799849a369b839d27241c96a9572de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5799849a369b839d27241c96a9572de7">&#9670;&nbsp;</a></span>isMemoryEffectFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isMemoryEffectFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given operation is free of memory effects. </p>
<p>An operation is free of memory effects if its implementation of <code>MemoryEffectOpInterface</code> indicates that it has no memory effects. For example, it may implement <code>NoMemoryEffect</code> in ODS. Alternatively, if the operation has the <code>HasRecursiveMemoryEffects</code> trait, then it is free of memory effects if all of its nested operations are free of memory effects.</p>
<p>If the operation has both, then it is free of memory effects if both conditions are satisfied. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00309">309</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="CFGToSCF_8cpp_source.html#l01229">checkTransformationPreconditions()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00224">matchReduction()</a>, and <a class="el" href="Hoisting_8cpp_source.html#l00172">noAliasingUseInLoop()</a>.</p>

</div>
</div>
<a id="a625259a35e521a9f6d7b7fe115423e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625259a35e521a9f6d7b7fe115423e87">&#9670;&nbsp;</a></span>isNotBranchOpInterfaceOrReturnLikeOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isNotBranchOpInterfaceOrReturnLikeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if op is neither BranchOpInterface nor ReturnLike. </p>
<p>TODO Try to get rid of this function and invert the meaning of <code>isLegalForBranchOpInterfaceTypeConversionPattern</code> and <code>isLegalForReturnOpTypeConversionPattern</code>. </p>

<p class="definition">Definition at line <a class="el" href="FuncConversions_8cpp_source.html#l00158">158</a> of file <a class="el" href="FuncConversions_8cpp_source.html">FuncConversions.cpp</a>.</p>

</div>
</div>
<a id="a4bd6b581b08699ce79d3e9f820c1ade9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd6b581b08699ce79d3e9f820c1ade9">&#9670;&nbsp;</a></span>isOpaqueTypeWithName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isOpaqueTypeWithName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>dialect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>typeData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified type is an opaque type with the specified dialect and typeData. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00047">47</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

</div>
</div>
<a id="a8583719d6a8f0699c36ac4c4b53057f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8583719d6a8f0699c36ac4c4b53057f2">&#9670;&nbsp;</a></span>isOpTriviallyDead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isOpTriviallyDead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the given operation is unused, and has no side effects on memory that prevent erasing. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00035">35</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

</div>
</div>
<a id="aeb49fb26d8c1e3dc571db7ff9e34cb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb49fb26d8c1e3dc571db7ff9e34cb7f">&#9670;&nbsp;</a></span>isPermutationVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isPermutationVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>interchange</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to check if an interchange vector is a permutation. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00222">222</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l03907">commonPermutationOfPackAndUnPackOp()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00077">mlir::tensor::computeTransposedType()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00766">mlir::linalg::packMatmulGreedily()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00675">mlir::linalg::packTranspose()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00358">mlir::detail::TileOffsetRangeImpl::TileOffsetRangeImpl()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00078">verifyTileSizeOptions()</a>.</p>

</div>
</div>
<a id="a550cdaef652bf5d59dfe33a15dc81af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550cdaef652bf5d59dfe33a15dc81af5">&#9670;&nbsp;</a></span>isPure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isPure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given operation is pure, i.e., is speculatable that does not touch memory. </p>
<p>The implementation of this function replicates the <code>def Pure : TraitList</code> in <code>SideEffectInterfaces.td</code> and has to be kept in sync manually.</p>
<p>This function is the C++ equivalent of the <code>Pure</code> trait. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00392">392</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2ArmSME_2IR_2Utils_8cpp_source.html#l00139">mlir::arm_sme::isTriviallyCloneableTileOp()</a>.</p>

</div>
</div>
<a id="ae209f096d9240a818927afbab10f43b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae209f096d9240a818927afbab10f43b8">&#9670;&nbsp;</a></span>isRankReducedType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">SliceVerificationResult</a> mlir::isRankReducedType </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>originalType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>candidateReducedType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if <code>originalType</code> can be rank reduced to <code>candidateReducedType</code> type by dropping some dimensions with static size <code>1</code>. </p>
<p>Return <code><a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a505a83f220c02df2f85c3810cd9ceb38">SliceVerificationResult::Success</a></code> on success or an appropriate error code. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00462">462</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00428">computeRankReductionMask()</a>, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a6341e1bfc09d56fa49bb1b9400459d8e">ElemTypeMismatch</a>, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a780dd32ee9af184442cea3f2a2a75271">RankTooLarge</a>, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a87c69361ccd090c9c844e19d08432a26">SizeMismatch</a>, and <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a505a83f220c02df2f85c3810cd9ceb38">Success</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00219">mlir::linalg::lowerPack()</a>, and <a class="el" href="TensorOps_8cpp_source.html#l02551">verifyInsertSliceOp()</a>.</p>

</div>
</div>
<a id="a9e3d6f94b6a941066c3e7e5535817a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3d6f94b6a941066c3e7e5535817a9b">&#9670;&nbsp;</a></span>isReassociationValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isReassociationValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>invalidIndex</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the reassociation specification is valid, false otherwise. </p>
<p>When false, the <code>invalidIndex</code> integer pointer is optionally filled with the index of the offending reassociation map. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00197">197</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>.</p>

</div>
</div>
<a id="aa28d7afae3a8e6d54489b5857b938d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28d7afae3a8e6d54489b5857b938d07">&#9670;&nbsp;</a></span>isRowMajorBatchMatmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isRowMajorBatchMatmul </td>
          <td>(</td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>indexingMaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the given maps describe a row major batch matmul. </p>
<p>The test is permutation-invariant. Note that this only checks the affine maps from an operation, so does not perform any checks on the math being performed within the reduction. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00072">72</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00402">mlir::AffineMap::getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00411">mlir::AffineMap::getResult()</a>.</p>

</div>
</div>
<a id="ae53f9bcf99efe125a11237ad6b64642c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53f9bcf99efe125a11237ad6b64642c">&#9670;&nbsp;</a></span>isRowMajorMatmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isRowMajorMatmul </td>
          <td>(</td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>indexingMaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the given maps describe a row major matmul. </p>
<p>The test is permutation-invariant. Note that this only checks the affine maps from an operation, so does not perform any checks on the math being performed within the reduction. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00020">20</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getNumInputs()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00402">mlir::AffineMap::getNumResults()</a>.</p>

</div>
</div>
<a id="a7a2c465ce654633415e61167b64b8a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2c465ce654633415e61167b64b8a91">&#9670;&nbsp;</a></span>isSpeculatable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isSpeculatable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given operation is speculatable, i.e. </p>
<p>has no undefined behavior or other side effects.</p>
<p>An operation can indicate that it is speculatable by implementing the getSpeculatability hook in the ConditionallySpeculatable op interface. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00366">366</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

</div>
</div>
<a id="ad0c26bcf64137533f38f2cda9abd75af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c26bcf64137533f38f2cda9abd75af">&#9670;&nbsp;</a></span>isStrided()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isStrided </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return "true" if the layout for <code>t</code> is compatible with strided semantics. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00973">973</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00823">getStridesAndOffset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01584">mlir::affine::AffineDmaStartOp::parse()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01562">mlir::affine::AffineDmaStartOp::print()</a>.</p>

</div>
</div>
<a id="ac5fb321c11f8758094dbc4ece855d206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fb321c11f8758094dbc4ece855d206">&#9670;&nbsp;</a></span>isVecmat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isVecmat </td>
          <td>(</td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>indexingMaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the given maps describe a vector matrix multiplication. </p>
<p>The test is permutation-invariant. Note that this only checks the affine maps from an operation, so does not perform any checks on the math being performed within the reduction. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00099">99</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01240">mlir::AffineMap::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00033">mlir::AffineExpr::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00402">mlir::AffineMap::getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00411">mlir::AffineMap::getResult()</a>.</p>

</div>
</div>
<a id="a04dd9fbdfc3426b88a910e2e7ded495c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04dd9fbdfc3426b88a910e2e7ded495c">&#9670;&nbsp;</a></span>isZeroIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isZeroIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if <code>v</code> is an IntegerAttr with value <code>0</code> of a ConstantIndexOp with attribute with value <code>0</code>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00017">17</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00105">getConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00675">mlir::linalg::computeTileOffsets()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00689">mlir::linalg::computeTileSizes()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00546">generateLoopNest()</a>, <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00508">getCollapsedIndices()</a>, and <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00424">mlir::linalg::rewriteInDestinationPassingStyle()</a>.</p>

</div>
</div>
<a id="a4bfe9337070eb0f67cb7a3098ee136ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfe9337070eb0f67cb7a3098ee136ee">&#9670;&nbsp;</a></span>JitRunnerMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mlir::JitRunnerMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1JitRunnerConfig.html">JitRunnerConfig</a>&#160;</td>
          <td class="paramname"><em>config</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for all CPU runners. </p>
<p>Expects the common argc/argv arguments for standard C++ main functions. The supplied dialect registry is expected to contain any registers that appear in the input IR, they will be loaded on-demand by the parser.</p>
<p>Expects the common argc/argv arguments for standard C++ main functions. </p>

<p class="definition">Definition at line <a class="el" href="JitRunner_8cpp_source.html#l00300">300</a> of file <a class="el" href="JitRunner_8cpp_source.html">JitRunner.cpp</a>.</p>

<p class="reference">References <a class="el" href="JitRunner_8cpp_source.html#l00163">getCommandLineOptLevel()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="ac84b6a6dfd9d9eb78ca02c17cabbebed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84b6a6dfd9d9eb78ca02c17cabbebed">&#9670;&nbsp;</a></span>linearize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::linearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the linearized index of 'offsets' w.r.t. </p>
<p>'basis'.</p>
<p><code>basis</code> elements are asserted to be non-negative. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00100">100</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00045">linearizeImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l01699">foldExtractFromShapeCast()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00181">linearize()</a>, and <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00063">resolveSourceIndicesExpandShape()</a>.</p>

</div>
</div>
<a id="a3e83fe20fc8231df5769e1eebe268bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e83fe20fc8231df5769e1eebe268bdd">&#9670;&nbsp;</a></span>linearize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::linearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the linearized index of 'offsets' w.r.t. </p>
<p>'basis'.</p>
<p>Assuming <code>offsets</code> is <code>[o0, .. on]</code> and <code>basis</code> is <code>[b0, .. bn]</code>, return the <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> <code>o0 * b0 + .. + on * bn</code>.</p>
<p>It is the caller's responsibility to pass proper <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> kind that result in valid <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> (i.e. cannot multiply 2 <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> or divide by an <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a>).</p>
<p><code>basis</code> elements are expected to bind to non-negative values. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00175">175</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00631">getAffineConstantExpr()</a>, and <a class="el" href="IndexingUtils_8cpp_source.html#l00045">linearizeImpl()</a>.</p>

</div>
</div>
<a id="a1c0b8417b72fde91ffbc7d792fc97121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0b8417b72fde91ffbc7d792fc97121">&#9670;&nbsp;</a></span>linearize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::linearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00181">181</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00641">getAffineConstantExprs()</a>, and <a class="el" href="IndexingUtils_8cpp_source.html#l00100">linearize()</a>.</p>

</div>
</div>
<a id="af912da94236cff04e9076f6e052676b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af912da94236cff04e9076f6e052676b1">&#9670;&nbsp;</a></span>LLVM_ENABLE_BITMASK_ENUMS_IN_NAMESPACE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::LLVM_ENABLE_BITMASK_ENUMS_IN_NAMESPACE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Bitmask enums for <a class="el" href="structmlir_1_1OperationEquivalence.html#a292ebf6a0885a07fd4c94f9750587dfe">OperationEquivalence::Flags</a>. </p>

</div>
</div>
<a id="a040c47f3f5d15eecb05a18c6343df489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040c47f3f5d15eecb05a18c6343df489">&#9670;&nbsp;</a></span>loopUnrollByFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::loopUnrollByFactor </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(unsigned, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt;&#160;</td>
          <td class="paramname"><em>annotateFn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls this for operation by the specified unroll factor. </p>
<p>Unrolls 'forOp' by 'unrollFactor', returns success if the loop is unrolled.</p>
<p>Returns failure if the loop cannot be unrolled either due to restrictions or due to invalid unroll factors. Requires positive loop bounds and step. If specified, annotates the Ops in each unrolled iteration by applying <code>annotateFn</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00376">376</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00271">ceilDivPositive()</a>, <a class="el" href="Builders_8cpp_source.html#l00579">mlir::OpBuilder::clone()</a>, <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00323">generateUnrolledLoop()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00105">getConstantIntValue()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00303">getConstantTripCount()</a>, <a class="el" href="Builders_8cpp_source.html#l00262">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="Value_8h_source.html#l00129">mlir::Value::getType()</a>, and <a class="el" href="Builders_8h_source.html#l00406">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="a7f0b0e4e1d0aa48d157009f2f9530492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f0b0e4e1d0aa48d157009f2f9530492">&#9670;&nbsp;</a></span>loopUnrollJamByFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::loopUnrollJamByFactor </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls and jams this <code>scf.for</code> operation by the specified unroll factor. </p>
<p>Unrolls and jams this loop by the specified factor.</p>
<p>Returns failure if the loop cannot be unrolled either due to restrictions or due to invalid unroll factors. In case of unroll factor of 1, the function bails out without doing anything (returns success). Currently, only constant trip count that are divided by the unroll factor is supported. Currently, for operations with results are not supported. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00511">511</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00498">areInnerBoundsInvariant()</a>, <a class="el" href="Builders_8cpp_source.html#l00579">mlir::OpBuilder::clone()</a>, <a class="el" href="Builders_8h_source.html#l00528">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00303">getConstantTripCount()</a>, <a class="el" href="Builders_8cpp_source.html#l00148">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00038">LDBG</a>, <a class="el" href="Builders_8h_source.html#l00406">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="LoopLikeInterface_8h_source.html#l00058">mlir::JamBlockGatherer&lt; OpTy &gt;::subBlocks</a>, <a class="el" href="Value_8h_source.html#l00218">mlir::Value::use_empty()</a>, and <a class="el" href="LoopLikeInterface_8h_source.html#l00061">mlir::JamBlockGatherer&lt; OpTy &gt;::walk()</a>.</p>

</div>
</div>
<a id="af4cd463c8738400fd147e2f040e89948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4cd463c8738400fd147e2f040e89948">&#9670;&nbsp;</a></span>lowerAffineLowerBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::lowerAffineLowerBound </td>
          <td>(</td>
          <td class="paramtype">affine::AffineForOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit code that computes the lower bound of the given affine loop using standard arithmetic operations. </p>

<p class="reference">Referenced by <a class="el" href="SCFToGPU_8cpp_source.html#l00094">getOrEmitLowerBound()</a>.</p>

</div>
</div>
<a id="a59b670d3c5d9075cd52ef9d183168708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b670d3c5d9075cd52ef9d183168708">&#9670;&nbsp;</a></span>lowerAffineUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::lowerAffineUpperBound </td>
          <td>(</td>
          <td class="paramtype">affine::AffineForOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit code that computes the upper bound of the given affine loop using standard arithmetic operations. </p>

<p class="reference">Referenced by <a class="el" href="SCFToGPU_8cpp_source.html#l00100">getOrEmitUpperBound()</a>.</p>

</div>
</div>
<a id="a8ea33aa665368d4f2108eb2d41c85111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea33aa665368d4f2108eb2d41c85111">&#9670;&nbsp;</a></span>m_AnyZeroFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_AnyZeroFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float (both positive and negative) zero. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00399">399</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="FoldAddIntoDest_8cpp_source.html#l00018">isDefinedAsZero()</a>, and <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00043">isZeroValue()</a>.</p>

</div>
</div>
<a id="a18d87ea3290be975b746704e58465017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d87ea3290be975b746704e58465017">&#9670;&nbsp;</a></span>m_Attr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1AttrOpMatcher.html">detail::AttrOpMatcher</a> mlir::m_Attr </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>attrName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a named attribute operation. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00374">374</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a3132b68de242f1e938904d71be736db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3132b68de242f1e938904d71be736db8">&#9670;&nbsp;</a></span>m_Attr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AttrT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1AttrOpBinder.html">detail::AttrOpBinder</a>&lt;AttrT&gt; mlir::m_Attr </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>attrName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AttrT *&#160;</td>
          <td class="paramname"><em>bindValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a named attribute operation and writes the value to bind_value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00392">392</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="ad402a86ee4c9000c6fa1fceaddab560b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad402a86ee4c9000c6fa1fceaddab560b">&#9670;&nbsp;</a></span>m_Constant() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__op__matcher.html">detail::constant_op_matcher</a> mlir::m_Constant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant foldable operation. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00369">369</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LocalAliasAnalysis_8cpp_source.html#l00259">mlir::LocalAliasAnalysis::aliasImpl()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01357">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="InlinerInterfaceImpl_8cpp_source.html#l00266">createNewAliasScopesFromNoAliasParameter()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00660">mlir::Operation::fold()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00266">foldDynamicIndexList()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02183">foldLoopBounds()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00069">getAsOpFoldResult()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00050">mlir::shape::getShapeVec()</a>, <a class="el" href="ControlFlowSinkUtils_8cpp_source.html#l00135">getSinglyExecutedRegionsToSink()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00192">mlir::ValueShapeRange::getValueAsShape()</a>, <a class="el" href="InlinerInterfaceImpl_8cpp_source.html#l00052">handleInlinedAllocas()</a>, <a class="el" href="AsyncParallelFor_8cpp_source.html#l00191">integerConstants()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00502">isDefinedOutsideOrConstant()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00175">isSplatWriteConsistentWithMaskedRead()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00419">mlir::affine::isValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01192">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01265">makeComposedFoldedMinMax()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00192">mlir::linalg::makeComposedPadHighOp()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00333">UModSimplification::matchAndRewrite()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01320">mlir::LLVM::ModuleImport::matchFloatAttr()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01310">mlir::LLVM::ModuleImport::matchIntegerAttr()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00050">materializeConstant()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00095">movePaddingToFillOrGenericOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00058">remainsLegalAfterInline()</a>, <a class="el" href="LoopEmitter_8cpp_source.html#l00093">tryFoldTensors()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01922">vectorizePackOpPrecondition()</a>.</p>

</div>
</div>
<a id="a10b6da5781fbe1b019fcb64dcd6921dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b6da5781fbe1b019fcb64dcd6921dd">&#9670;&nbsp;</a></span>m_Constant() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AttrT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__op__binder.html">detail::constant_op_binder</a>&lt;AttrT&gt; mlir::m_Constant </td>
          <td>(</td>
          <td class="paramtype">AttrT *&#160;</td>
          <td class="paramname"><em>bind_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a value from a constant foldable operation and writes the value to bind_value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00386">386</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="aefeea9b182f6e6e1a267b0bd157e7970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefeea9b182f6e6e1a267b0bd157e7970">&#9670;&nbsp;</a></span>m_ConstantFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__value__binder.html">detail::constant_float_value_binder</a> mlir::m_ConstantFloat </td>
          <td>(</td>
          <td class="paramtype">FloatAttr::ValueType *&#160;</td>
          <td class="paramname"><em>bind_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant holding a scalar/vector/tensor float (splat) and writes the float value to bind_value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00515">515</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a091c0686ba6d6f3ad4af9db1aea8063f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091c0686ba6d6f3ad4af9db1aea8063f">&#9670;&nbsp;</a></span>m_ConstantInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__value__binder.html">detail::constant_int_value_binder</a> mlir::m_ConstantInt </td>
          <td>(</td>
          <td class="paramtype">IntegerAttr::ValueType *&#160;</td>
          <td class="paramname"><em>bind_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant holding a scalar/vector/tensor integer (splat) and writes the integer value to bind_value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00522">522</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Promotion_8cpp_source.html#l00435">allocateSubviewGPUMemoryInAddressSpace()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00707">destructureIndices()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00105">getConstantIntValue()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00061">getConstantIntValue()</a>, <a class="el" href="AMDGPUDialect_8cpp_source.html#l00114">getConstantUint32()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00141">getIntOrSplatIntValue()</a>, and <a class="el" href="KernelOutlining_8cpp_source.html#l00158">maybeConstantDimsAttr()</a>.</p>

</div>
</div>
<a id="a4136ce33972b8eb3801f4c304f53acae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4136ce33972b8eb3801f4c304f53acae">&#9670;&nbsp;</a></span>m_IntRangeWithoutNegOneS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__range__predicate__matcher.html">detail::constant_int_range_predicate_matcher</a> mlir::m_IntRangeWithoutNegOneS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer or a signed integer range that does not contain minus one. </p>
<p>Note that this matcher interprets the target value as a signed integer. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00466">466</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithOps_8cpp_source.html#l00637">getDivSISpeculatability()</a>.</p>

</div>
</div>
<a id="ab744f07f6776a02e49c0851786db161a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab744f07f6776a02e49c0851786db161a">&#9670;&nbsp;</a></span>m_IntRangeWithoutZeroS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__range__predicate__matcher.html">detail::constant_int_range_predicate_matcher</a> mlir::m_IntRangeWithoutZeroS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer or a signed integer range that does not contain zero. </p>
<p>Note that this matcher interprets the target value as a signed integer. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00457">457</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithOps_8cpp_source.html#l00637">getDivSISpeculatability()</a>.</p>

</div>
</div>
<a id="afbe6d87f8ecb162173628bc66674ba72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe6d87f8ecb162173628bc66674ba72">&#9670;&nbsp;</a></span>m_IntRangeWithoutZeroU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__range__predicate__matcher.html">detail::constant_int_range_predicate_matcher</a> mlir::m_IntRangeWithoutZeroU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer or a unsigned integer range that does not contain zero. </p>
<p>Note that this matcher interprets the target value as an unsigned integer. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00450">450</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithOps_8cpp_source.html#l00599">getDivUISpeculatability()</a>.</p>

</div>
</div>
<a id="a9e89b015211525b010832d2d2c37650b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e89b015211525b010832d2d2c37650b">&#9670;&nbsp;</a></span>m_NegInfFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_NegInfFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float negative infinity. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00430">430</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="aa9eba8d1292854c0da6c062988ecac9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9eba8d1292854c0da6c062988ecac9b">&#9670;&nbsp;</a></span>m_NegZeroFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_NegZeroFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float negative zero. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00409">409</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a94bb42600b9be680591776fdc14a53cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bb42600b9be680591776fdc14a53cd">&#9670;&nbsp;</a></span>m_NonZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a> mlir::m_NonZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer that is any non-zero value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00443">443</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a907f415a4c803b15ef57db37cc732f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907f415a4c803b15ef57db37cc732f39">&#9670;&nbsp;</a></span>m_One()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a> mlir::m_One </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer one. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00473">473</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="af0495d84f34cf3238a7741fa6974a485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0495d84f34cf3238a7741fa6974a485">&#9670;&nbsp;</a></span>m_OneFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_OneFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float ones. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00414">414</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="ac2418532386147bec2ca5aadf5414406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2418532386147bec2ca5aadf5414406">&#9670;&nbsp;</a></span>m_Op() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpClass &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">detail::op_matcher</a>&lt;OpClass&gt; mlir::m_Op </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches the given OpClass. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00479">479</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a7ecde76b07cd295bae0d6ef10d1c45d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecde76b07cd295bae0d6ef10d1c45d8">&#9670;&nbsp;</a></span>m_Op() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpType , typename... Matchers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::m_Op </td>
          <td>(</td>
          <td class="paramtype">Matchers...&#160;</td>
          <td class="paramname"><em>matchers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00527">527</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a69b52f968271c9a4da1bc766ee083a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b52f968271c9a4da1bc766ee083a9c">&#9670;&nbsp;</a></span>m_Op() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1NameOpMatcher.html">detail::NameOpMatcher</a> mlir::m_Op </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>opName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a named operation. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00379">379</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="adc93dfeaa35bda23b16591c462c335f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc93dfeaa35bda23b16591c462c335f6">&#9670;&nbsp;</a></span>m_PosInfFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_PosInfFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float positive infinity. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00422">422</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a774a1ae971f4ef00eb57389293dfe617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774a1ae971f4ef00eb57389293dfe617">&#9670;&nbsp;</a></span>m_PosZeroFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_PosZeroFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float positive zero. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00404">404</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a7f5d8af15bd8994b1a7abeaaacfe1b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5d8af15bd8994b1a7abeaaacfe1b06">&#9670;&nbsp;</a></span>m_Zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a> mlir::m_Zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer zero. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00437">437</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="FoldAddIntoDest_8cpp_source.html#l00018">isDefinedAsZero()</a>, and <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00043">isZeroValue()</a>.</p>

</div>
</div>
<a id="ac603376cc0dac0b2bd27c2dcde3c2e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac603376cc0dac0b2bd27c2dcde3c2e14">&#9670;&nbsp;</a></span>makeCanonicalStridedLayoutExpr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::makeCanonicalStridedLayoutExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>exprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given MemRef <code>sizes</code> that are either static or dynamic, returns the canonical "contiguous" strides <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a>. </p>
<p>Strides are multiplicative and once a dynamic dimension is encountered, all canonical strides become dynamic and need to be encoded with a different symbol. For canonical strides expressions, the offset is always 0 and the fastest varying stride is always <code>1</code>.</p>
<p>Examples:</p><ul>
<li>memref&lt;3x4x5xf32&gt; has canonical stride expression <code>20*exprs[0] + 5*exprs[1] + exprs[2]</code>.</li>
<li>memref&lt;3x?x5xf32&gt; has canonical stride expression <code>s0*exprs[0] + 5*exprs[1] + exprs[2]</code>.</li>
<li>memref&lt;3x4x?xf32&gt; has canonical stride expression <code>s1*exprs[0] + s0*exprs[1] + exprs[2]</code>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00932">932</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00631">getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00617">getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00312">mlir::AffineMap::inferFromExprList()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01556">simplifyAffineExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00964">makeCanonicalStridedLayoutExpr()</a>.</p>

</div>
</div>
<a id="ad25cd8672ecb721d7a4f0ecd22bac6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25cd8672ecb721d7a4f0ecd22bac6e8">&#9670;&nbsp;</a></span>makeCanonicalStridedLayoutExpr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::makeCanonicalStridedLayoutExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the result of makeCanonicalStrudedLayoutExpr for the common case where <code>exprs</code> is {d0, d1, .., d_(sizes.size()-1)}. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00964">964</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00607">getAffineDimExpr()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00932">makeCanonicalStridedLayoutExpr()</a>.</p>

</div>
</div>
<a id="a643fb5da616fe37fef528fbcf735b8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643fb5da616fe37fef528fbcf735b8ec">&#9670;&nbsp;</a></span>makeOptimizingTransformer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;llvm::Error(llvm::Module *)&gt; mlir::makeOptimizingTransformer </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>optLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>sizeLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::TargetMachine *&#160;</td>
          <td class="paramname"><em>targetMachine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a module transformer function for MLIR <a class="el" href="classmlir_1_1ExecutionEngine.html" title="JIT-backed execution engine for MLIR.">ExecutionEngine</a> that runs <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR passes corresponding to the given speed and size optimization levels (e.g. </p>
<p>-O2 or -Os). If not null, <code>targetMachine</code> is used to initialize passes that provide target-specific information to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> optimizer. <code>targetMachine</code> must outlive the returned std::function. </p>

<p class="reference">Referenced by <a class="el" href="ModuleToObject_8cpp_source.html#l00140">mlir::LLVM::ModuleToObject::optimizeModule()</a>.</p>

</div>
</div>
<a id="a7d806144c2d33e56f341109c75c3d277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d806144c2d33e56f341109c75c3d277">&#9670;&nbsp;</a></span>makeRegionIsolatedFromAbove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::makeRegionIsolatedFromAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>cloneOperationIntoRegion</em> = <code>[](<a class="el" href="classmlir_1_1Operation.html">Operation</a>&#160;*)&#160;{&#160;return&#160;false;&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a region isolated from above. </p>
<ul>
<li>Capture the values that are defined above the region and used within it.</li>
<li>Append to the entry block arguments that represent the captured values (one per captured value).</li>
<li>Replace all uses within the region of the captured values with the newly added arguments.</li>
<li><code>cloneOperationIntoRegion</code> is a callback that allows caller to specify if the operation defining an <code><a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a></code> needs to be cloned into the region. Then the operands of this operation become part of the captured values set (unless the operations that define the operands themeselves are to be cloned). The cloned operations are added to the entry block of the region. Return the set of captured values for the operation. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00084">84</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00055">mlir::Region::begin()</a>, <a class="el" href="Builders_8cpp_source.html#l00579">mlir::OpBuilder::clone()</a>, <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00112">computeTopologicalSorting()</a>, <a class="el" href="Builders_8cpp_source.html#l00461">mlir::OpBuilder::createBlock()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="Block_8h_source.html#l00085">mlir::Block::getArguments()</a>, <a class="el" href="Block_8cpp_source.html#l00148">mlir::Block::getArgumentTypes()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Block_8h_source.html#l00126">mlir::Block::getNumArguments()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00373">mlir::Operation::getOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00410">mlir::Operation::getResults()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00067">getUsedValuesDefinedAbove()</a>, <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00339">mlir::RewriterBase::mergeBlocks()</a>, <a class="el" href="PatternMatch_8h_source.html#l00679">mlir::RewriterBase::replaceOpUsesWithIf()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00262">mlir::RewriterBase::replaceUsesWithIf()</a>, and <a class="el" href="Builders_8h_source.html#l00439">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="a4df3b51e6123c8ab9fb3809ba255e00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df3b51e6123c8ab9fb3809ba255e00b">&#9670;&nbsp;</a></span>makeReproducer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlir::makeReproducer </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>anchorName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1iterator__range.html">llvm::iterator_range</a>&lt; <a class="el" href="classmlir_1_1OpPassManager.html#a84658003e9efeda5080172631ef41305">OpPassManager::pass_iterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>passes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>outputFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disableThreads</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verifyPasses</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PassCrashRecovery_8cpp_source.html#l00448">448</a> of file <a class="el" href="PassCrashRecovery_8cpp_source.html">PassCrashRecovery.cpp</a>.</p>

</div>
</div>
<a id="a923fafcbdcfdcb3b735fab2ab293a1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923fafcbdcfdcb3b735fab2ab293a1ad">&#9670;&nbsp;</a></span>makeStridedLinearLayoutMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::makeStridedLinearLayoutMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of strides (in which ShapedType::kDynamic represents a dynamic value), return the single result <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> which represents the linearized strided layout map. </p>
<p>Dimensions correspond to the offset followed by the strides in order. Symbols are inserted for each dynamic dimension in order. A stride is always positive.</p>
<h1><a class="anchor" id="autotoc_md36"></a>
Examples:</h1>
<ol type="1">
<li>For offset: 0 strides: ?, ?, 1 return (i, j, k)[M, N]-&gt;(M * i + N * j + k)</li>
<li>For offset: 3 strides: 32, ?, 16 return (i, j, k)[M]-&gt;(3 + 32 * i + M * j + 16 * k)</li>
<li>For offset: ? strides: ?, ?, ? return (i, j, k)[off, M, N, P]-&gt;(off + M * i + N * j + P * k) </li>
</ol>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01797">1797</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01240">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00631">getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00607">getAffineDimExpr()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00617">getAffineSymbolExpr()</a>.</p>

</div>
</div>
<a id="ac7736bcb70dbd9f242cd5182dd443031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7736bcb70dbd9f242cd5182dd443031">&#9670;&nbsp;</a></span>matchConstantIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">detail::op_matcher</a>&lt; <a class="el" href="classmlir_1_1arith_1_1ConstantIndexOp.html">arith::ConstantIndexOp</a> &gt; mlir::matchConstantIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a ConstantIndexOp. </p>
<p>TODO: This should probably just be a general matcher that uses matchConstant and checks the operation for an index type. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00087">87</a> of file <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a id="a77883d2221f5bdf428d745d778f90d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77883d2221f5bdf428d745d778f90d49">&#9670;&nbsp;</a></span>matchPattern() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pattern &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::matchPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entry point for matching a pattern over an <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>. </p>
<p>Returns <code>false</code> when <code>attr</code> is null. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00503">503</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a1b97d57dcd6c08b495fbd3ef22aeda6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b97d57dcd6c08b495fbd3ef22aeda6f">&#9670;&nbsp;</a></span>matchPattern() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pattern &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::matchPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entry point for matching a pattern over an <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00495">495</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a0190228b09e7b51a4bc1e013c01d404c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0190228b09e7b51a4bc1e013c01d404c">&#9670;&nbsp;</a></span>matchPattern() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pattern &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::matchPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entry point for matching a pattern over a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00485">485</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LocalAliasAnalysis_8cpp_source.html#l00259">mlir::LocalAliasAnalysis::aliasImpl()</a>, <a class="el" href="Promotion_8cpp_source.html#l00435">allocateSubviewGPUMemoryInAddressSpace()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01357">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="InlinerInterfaceImpl_8cpp_source.html#l00266">createNewAliasScopesFromNoAliasParameter()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00707">destructureIndices()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00660">mlir::Operation::fold()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00266">foldDynamicIndexList()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02183">foldLoopBounds()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00069">getAsOpFoldResult()</a>, <a class="el" href="MemRefMemorySlot_8cpp_source.html#l00198">getAttributeIndexFromIndexOperands()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00105">getConstantIntValue()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00061">getConstantIntValue()</a>, <a class="el" href="AMDGPUDialect_8cpp_source.html#l00114">getConstantUint32()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00637">getDivSISpeculatability()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00599">getDivUISpeculatability()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00141">getIntOrSplatIntValue()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00050">mlir::shape::getShapeVec()</a>, <a class="el" href="ControlFlowSinkUtils_8cpp_source.html#l00135">getSinglyExecutedRegionsToSink()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00192">mlir::ValueShapeRange::getValueAsShape()</a>, <a class="el" href="InlinerInterfaceImpl_8cpp_source.html#l00052">handleInlinedAllocas()</a>, <a class="el" href="AsyncParallelFor_8cpp_source.html#l00191">integerConstants()</a>, <a class="el" href="FoldAddIntoDest_8cpp_source.html#l00018">isDefinedAsZero()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00502">isDefinedOutsideOrConstant()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00175">isSplatWriteConsistentWithMaskedRead()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00419">mlir::affine::isValidSymbol()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00043">isZeroValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01192">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01265">makeComposedFoldedMinMax()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00192">mlir::linalg::makeComposedPadHighOp()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00333">UModSimplification::matchAndRewrite()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01320">mlir::LLVM::ModuleImport::matchFloatAttr()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l01310">mlir::LLVM::ModuleImport::matchIntegerAttr()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00050">materializeConstant()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00158">maybeConstantDimsAttr()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00095">movePaddingToFillOrGenericOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00058">remainsLegalAfterInline()</a>, <a class="el" href="LoopEmitter_8cpp_source.html#l00093">tryFoldTensors()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01922">vectorizePackOpPrecondition()</a>.</p>

</div>
</div>
<a id="a6bc751bc8f30d71ad4cb771c0fcc788b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc751bc8f30d71ad4cb771c0fcc788b">&#9670;&nbsp;</a></span>matchReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::matchReduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt;&#160;</td>
          <td class="paramname"><em>iterCarriedArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>redPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>combinerOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility to match a generic reduction given a list of iteration-carried arguments, <code>iterCarriedArgs</code> and the position of the potential reduction argument within the list, <code>redPos</code>. </p>
<p>If a reduction is matched, returns the reduced value and the topologically-sorted list of combiner operations involved in the reduction. Otherwise, returns a null value.</p>
<p>The matching algorithm relies on the following invariants, which are subject to change:</p><ol type="1">
<li>The first combiner operation must be a binary operation with the iteration-carried value and the reduced value as operands.</li>
<li>The iteration-carried value and combiner operations must be side effect-free, have single result and a single use.</li>
<li>Combiner operations must be immediately nested in the region op performing the reduction.</li>
<li>Reduction def-use chain must end in a terminator op that yields the next iteration/output values in the same order as the iteration-carried values in <code>iterCarriedArgs</code>.</li>
<li><code>iterCarriedArgs</code> must contain all the iteration-carried/output values of the region op performing the reduction.</li>
</ol>
<p>This utility is generic enough to detect reductions involving multiple combiner operations (disabled for now) across multiple dialects, including Linalg, Affine and SCF. For the sake of genericity, it does not return specific enum values for the combiner operations since its goal is also matching reductions without pre-defined semantics in core MLIR. It's up to each client to make sense out of the list of combiner operations. It's also up to each client to check for additional invariants on the expected reductions not covered by this generic matching. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00224">224</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00170">dependsOnCarriedVals()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00341">mlir::Operation::getNumOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00399">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00345">mlir::Operation::getOperand()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00869">mlir::Operation::getUsers()</a>, <a class="el" href="Value_8h_source.html#l00228">mlir::Value::getUsers()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00845">mlir::Operation::hasOneUse()</a>, <a class="el" href="Value_8h_source.html#l00215">mlir::Value::hasOneUse()</a>, <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00309">isMemoryEffectFree()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00753">mlir::Operation::mightHaveTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00557">matchLinalgReduction()</a>, and <a class="el" href="SCFToOpenMP_8cpp_source.html#l00042">matchSimpleReduction()</a>.</p>

</div>
</div>
<a id="a5c318aa15564b0d662d9a699f74f8eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c318aa15564b0d662d9a699f74f8eea">&#9670;&nbsp;</a></span>mayBeGraphRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::mayBeGraphRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return "true" if the given region may be a graph region without SSA dominance. </p>
<p>This function returns "true" in case the owner op is an unregistered op. It returns "false" if it is a registered op that does not implement the RegionKindInterface. </p>

<p class="definition">Definition at line <a class="el" href="RegionKindInterface_8cpp_source.html#l00027">27</a> of file <a class="el" href="RegionKindInterface_8cpp_source.html">RegionKindInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00200">mlir::Region::getParentOp()</a>, <a class="el" href="IR_2Region_8cpp_source.html#l00062">mlir::Region::getRegionNumber()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00129">mlir::Operation::isRegistered()</a>.</p>

</div>
</div>
<a id="a5ed40bd15766a7dff96f3d30577d8f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed40bd15766a7dff96f3d30577d8f87">&#9670;&nbsp;</a></span>mayHaveSSADominance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::mayHaveSSADominance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return "true" if the given region may have SSA dominance. </p>
<p>This function also returns "true" in case the owner op is an unregistered op or an op that does not implement the RegionKindInterface. </p>

<p class="definition">Definition at line <a class="el" href="RegionKindInterface_8cpp_source.html#l00020">20</a> of file <a class="el" href="RegionKindInterface_8cpp_source.html">RegionKindInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00200">mlir::Region::getParentOp()</a>, and <a class="el" href="IR_2Region_8cpp_source.html#l00062">mlir::Region::getRegionNumber()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Iterators_8h_source.html#l00053">mlir::ForwardDominanceIterator&lt; NoGraphRegions &gt;::makeIterable()</a>, and <a class="el" href="Iterators_8h_source.html#l00095">mlir::ReverseDominanceIterator&lt; NoGraphRegions &gt;::makeIterable()</a>.</p>

</div>
</div>
<a id="af3ad163144fafb93cf9814b2235ccf59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ad163144fafb93cf9814b2235ccf59">&#9670;&nbsp;</a></span>MlirLspServerMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::MlirLspServerMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation for tools like <code>mlir-lsp-server</code>. </p>
<ul>
<li>registry should contain all the dialects that can be parsed in source IR passed to the server. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MlirLspServerMain_8cpp_source.html#l00021">21</a> of file <a class="el" href="MlirLspServerMain_8cpp_source.html">MlirLspServerMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581aa603905470e2a5b8c13e96b579ef0dba">mlir::lsp::Logger::Debug</a>, <a class="el" href="Transport_8h_source.html#l00043">mlir::lsp::Delimited</a>, <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581a902b0d55fddef6f8d651fe1035b7d4bd">mlir::lsp::Logger::Error</a>, <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581a4059b0251f66a18cb56f544728796875">mlir::lsp::Logger::Info</a>, <a class="el" href="lsp-server-support_2Protocol_8cpp_source.html#l00243">mlir::lsp::URIForFile::registerSupportedScheme()</a>, <a class="el" href="mlir-lsp-server_2LSPServer_8cpp_source.html#l00286">mlir::lsp::runMlirLSPServer()</a>, <a class="el" href="Logging_8cpp_source.html#l00017">mlir::lsp::Logger::setLogLevel()</a>, and <a class="el" href="Transport_8h_source.html#l00041">mlir::lsp::Standard</a>.</p>

</div>
</div>
<a id="af142b3ef60201e867dd545860bf1f71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af142b3ef60201e867dd545860bf1f71d">&#9670;&nbsp;</a></span>MlirOptMain() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::MlirOptMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>inputFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>outputFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation for tools like <code>mlir-opt</code>. </p>
<p>This function can be used with registrationAndParseCLIOptions so that CLI options can be accessed before running MlirOptMain.</p><ul>
<li>inputFilename is the name of the input mlir file.</li>
<li>outputFilename is the name of the output file.</li>
<li>registry should contain all the dialects that can be parsed in the source. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MlirOptMain_8cpp_source.html#l00568">568</a> of file <a class="el" href="MlirOptMain_8cpp_source.html">MlirOptMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="MlirOptMain_8cpp_source.html#l00214">mlir::MlirOptMainConfig::createFromCLOptions()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00534">MlirOptMain()</a>, <a class="el" href="namespacemlir.html#a0c2eb0b34f6d7e90435b0a6ce3d8ffaf">openInputFile()</a>, <a class="el" href="namespacemlir.html#a4c8c9750d9c8efdbcc7542f3b1564d8d">openOutputFile()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00522">printRegisteredDialects()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00529">printRegisteredPassesAndReturn()</a>, <a class="el" href="MlirOptMain_8h_source.html#l00127">mlir::MlirOptMainConfig::shouldListPasses()</a>, and <a class="el" href="MlirOptMain_8h_source.html#l00144">mlir::MlirOptMainConfig::shouldShowDialects()</a>.</p>

</div>
</div>
<a id="a1f6b96254b4e476bf34403287c27825a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6b96254b4e476bf34403287c27825a">&#9670;&nbsp;</a></span>MlirOptMain() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::MlirOptMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>toolName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation for tools like <code>mlir-opt</code>. </p>
<ul>
<li>toolName is used for the header displayed by <code>--help</code>.</li>
<li>registry should contain all the dialects that can be parsed in the source. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MlirOptMain_8cpp_source.html#l00612">612</a> of file <a class="el" href="MlirOptMain_8cpp_source.html">MlirOptMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="MlirOptMain_8cpp_source.html#l00534">MlirOptMain()</a>, and <a class="el" href="MlirOptMain_8cpp_source.html#l00493">registerAndParseCLIOptions()</a>.</p>

</div>
</div>
<a id="a440508357b9fe36f36010043c99e2f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440508357b9fe36f36010043c99e2f22">&#9670;&nbsp;</a></span>MlirOptMain() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::MlirOptMain </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>outputStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; llvm::MemoryBuffer &gt;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1MlirOptMainConfig.html">MlirOptMainConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the core processing behind <code>mlir-opt</code>. </p>
<ul>
<li>outputStream is the stream where the resulting IR is printed.</li>
<li>buffer is the in-memory file to parser and process.</li>
<li>registry should contain all the dialects that can be parsed in the source.</li>
<li>config contains the configuration options for the tool. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MlirOptMain_8cpp_source.html#l00534">534</a> of file <a class="el" href="MlirOptMain_8cpp_source.html">MlirOptMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="MlirOptMain_8cpp_source.html#l00522">printRegisteredDialects()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00529">printRegisteredPassesAndReturn()</a>, <a class="el" href="MlirOptMain_8h_source.html#l00127">mlir::MlirOptMainConfig::shouldListPasses()</a>, and <a class="el" href="MlirOptMain_8h_source.html#l00144">mlir::MlirOptMainConfig::shouldShowDialects()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00568">MlirOptMain()</a>.</p>

</div>
</div>
<a id="afcf1fa346908020b9dbc2009bb3630ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf1fa346908020b9dbc2009bb3630ce">&#9670;&nbsp;</a></span>MlirPdllLspServerMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::MlirPdllLspServerMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation for tools like <code>mlir-pdll-lsp-server</code>. </p>

<p class="definition">Definition at line <a class="el" href="MlirPdllLspServerMain_8cpp_source.html#l00020">20</a> of file <a class="el" href="MlirPdllLspServerMain_8cpp_source.html">MlirPdllLspServerMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581aa603905470e2a5b8c13e96b579ef0dba">mlir::lsp::Logger::Debug</a>, <a class="el" href="Transport_8h_source.html#l00043">mlir::lsp::Delimited</a>, <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581a902b0d55fddef6f8d651fe1035b7d4bd">mlir::lsp::Logger::Error</a>, <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581a4059b0251f66a18cb56f544728796875">mlir::lsp::Logger::Info</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="mlir-pdll-lsp-server_2LSPServer_8cpp_source.html#l00283">mlir::lsp::runPdllLSPServer()</a>, <a class="el" href="Logging_8cpp_source.html#l00017">mlir::lsp::Logger::setLogLevel()</a>, and <a class="el" href="Transport_8h_source.html#l00041">mlir::lsp::Standard</a>.</p>

</div>
</div>
<a id="a7810268d0608849708e435fcb9791bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7810268d0608849708e435fcb9791bb1">&#9670;&nbsp;</a></span>mlirQueryMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::LogicalResult mlir::mlirQueryMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1query_1_1matcher_1_1Registry.html">mlir::query::matcher::Registry</a> &amp;&#160;</td>
          <td class="paramname"><em>matcherRegistry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MlirQueryMain_8cpp_source.html#l00031">31</a> of file <a class="el" href="MlirQueryMain_8cpp_source.html">MlirQueryMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00594">mlir::MLIRContext::allowUnregisteredDialects()</a>, <a class="el" href="Query_8cpp_source.html#l00025">mlir::query::complete()</a>, <a class="el" href="OwningOpRef_8h_source.html#l00051">mlir::OwningOpRef&lt; OpTy &gt;::get()</a>, <a class="el" href="namespacemlir.html#a0c2eb0b34f6d7e90435b0a6ce3d8ffaf">openInputFile()</a>, <a class="el" href="Query_8cpp_source.html#l00020">mlir::query::parse()</a>, <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00020">parseSourceFile()</a>, and <a class="el" href="QuerySession_8h_source.html#l00031">mlir::query::QuerySession::terminate</a>.</p>

</div>
</div>
<a id="ab515fd3b6aebea7df681f094b42d9e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab515fd3b6aebea7df681f094b42d9e71">&#9670;&nbsp;</a></span>mlirReduceMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::mlirReduceMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MlirReduceMain_8cpp_source.html#l00048">48</a> of file <a class="el" href="MlirReduceMain_8cpp_source.html">MlirReduceMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassRegistry_8cpp_source.html#l00990">mlir::PassPipelineCLParser::addToPipeline()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">emitError()</a>, <a class="el" href="OwningOpRef_8h_source.html#l00051">mlir::OwningOpRef&lt; OpTy &gt;::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">get()</a>, <a class="el" href="MlirReduceMain_8cpp_source.html#l00032">loadModule()</a>, and <a class="el" href="namespacemlir.html#a4c8c9750d9c8efdbcc7542f3b1564d8d">openOutputFile()</a>.</p>

</div>
</div>
<a id="ad4175a8043cece857c2779663ef3ba91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4175a8043cece857c2779663ef3ba91">&#9670;&nbsp;</a></span>MlirTblgenMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mlir::MlirTblgenMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main Program for tools like 'mlir-tblgen' with custom backends. </p>
<p>To add a new backend, simply create a new '<a class="el" href="structmlir_1_1GenRegistration.html" title="GenRegistration provides a global initializer that registers a generator function.">mlir::GenRegistration</a>' global variable. See its documentation for more info.</p>
<p>The 'argc' and 'argv' arguments are simply forwarded from a main function. The return value is the exit code from llvm::TableGenMain. </p>

<p class="definition">Definition at line <a class="el" href="MlirTblgenMain_8cpp_source.html#l00140">140</a> of file <a class="el" href="MlirTblgenMain_8cpp_source.html">MlirTblgenMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="MlirTblgenMain_8cpp_source.html#l00030">actionOnDeprecatedValue</a>, <a class="el" href="MlirTblgenMain_8cpp_source.html#l00028">Error</a>, <a class="el" href="MlirTblgenMain_8cpp_source.html#l00125">generator</a>, <a class="el" href="MlirTblgenMain_8cpp_source.html#l00129">mlirTableGenMain()</a>, <a class="el" href="MlirTblgenMain_8cpp_source.html#l00028">None</a>, and <a class="el" href="MlirTblgenMain_8cpp_source.html#l00028">Warn</a>.</p>

</div>
</div>
<a id="ab673e648679ec83d87417b04baf281dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab673e648679ec83d87417b04baf281dd">&#9670;&nbsp;</a></span>mlirTranslateMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::mlirTranslateMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>toolName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate to/from an MLIR module from/to an external representation (e.g. </p>
<p><a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR, SPIRV binary, ...). This is the entry point for the implementation of tools like <code>mlir-translate</code>. The translation to perform is parsed from the command line. The <code>toolName</code> argument is used for the header displayed by <code>--help</code>. </p>

</div>
</div>
<a id="af79a420cd75e576fa80212258d3de025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79a420cd75e576fa80212258d3de025">&#9670;&nbsp;</a></span>moveLoopInvariantCode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mlir::moveLoopInvariantCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> * &gt;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>isDefinedOutsideRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>shouldMoveOutOfRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>moveOutOfRegion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of regions, perform loop-invariant code motion. </p>
<p>An operation is loop-invariant if it depends only of values defined outside of the loop. LICM moves these operations out of the loop body so that they are not computed more than once.</p>
<p>Example:</p>
<div class="fragment"><div class="line">affine.for %arg0 = 0 to 10 {</div>
<div class="line">  affine.for %arg1 = 0 to 10 {</div>
<div class="line">    %v0 = arith.addi %arg0, %arg0 : i32</div>
<div class="line">    %v1 = arith.addi %v0, %arg1 : i32</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>After LICM:</p>
<div class="fragment"><div class="line">affine.for %arg0 = 0 to 10 {</div>
<div class="line">  %v0 = arith.addi %arg0, %arg0 : i32</div>
<div class="line">  affine.for %arg1 = 0 to 10 {</div>
<div class="line">    %v1 = arith.addi %v0, %arg1 : i32</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Users must supply three callbacks.</p>
<ul>
<li><code>isDefinedOutsideRegion</code> returns true if the given value is invariant with respect to the given region. A common implementation might be: <code>value.getParentRegion()-&gt;isProperAncestor(region)</code>.</li>
<li><code>shouldMoveOutOfRegion</code> returns true if the provided operation can be moved of the given region, e.g. if it is side-effect free.</li>
<li><code>moveOutOfRegion</code> moves the operation out of the given region. A common implementation might be: <code>op-&gt;moveBefore(region-&gt;getParentOp())</code>.</li>
</ul>
<p>An operation is moved if all of its operands satisfy <code>isDefinedOutsideRegion</code> and it satisfies <code>shouldMoveOutOfRegion</code>.</p>
<p>Returns the number of operations moved. </p>

<p class="definition">Definition at line <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00059">59</a> of file <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html">LoopInvariantCodeMotionUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Hoisting_8cpp_source.html#l00097">mlir::linalg::hoistRedundantVectorBroadcasts()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00202">mlir::linalg::hoistRedundantVectorTransfers()</a>, and <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00106">moveLoopInvariantCode()</a>.</p>

</div>
</div>
<a id="a56b9f2d2e0330c53880b673633907ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b9f2d2e0330c53880b673633907ac6">&#9670;&nbsp;</a></span>moveLoopInvariantCode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mlir::moveLoopInvariantCode </td>
          <td>(</td>
          <td class="paramtype">LoopLikeOpInterface&#160;</td>
          <td class="paramname"><em>loopLike</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move side-effect free loop invariant code out of a loop-like op using methods provided by the interface. </p>

<p class="definition">Definition at line <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00106">106</a> of file <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html">LoopInvariantCodeMotionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00059">moveLoopInvariantCode()</a>.</p>

</div>
</div>
<a id="afff65ad1a751cdba6e58ef912d9ebaa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff65ad1a751cdba6e58ef912d9ebaa8">&#9670;&nbsp;</a></span>normalizeForallOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; scf::ForallOp &gt; mlir::normalizeForallOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForallOp&#160;</td>
          <td class="paramname"><em>forallOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize an <code>scf.forall</code> operation. </p>
<p>Returns <code>failure()</code>if normalization fails. newly created operation with all uses of the original operation replaced with results of the new operation. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01462">1462</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00689">emitNormalizedLoopBounds()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00372">mlir::RewriterBase::inlineRegionBefore()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00135">isConstantIntValue()</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00034">mlir::Range::offset</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00114">mlir::RewriterBase::replaceAllOpUsesWith()</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00035">mlir::Range::size</a>, and <a class="el" href="StaticValueUtils_8h_source.html#l00036">mlir::Range::stride</a>.</p>

</div>
</div>
<a id="a4ec63c3f9b9b50f77b7cc8b92f506204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec63c3f9b9b50f77b7cc8b92f506204">&#9670;&nbsp;</a></span>openInputFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; llvm::MemoryBuffer &gt; mlir::openInputFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>inputFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Align&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>errorMessage</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the file specified by its name for reading, with the given buffer alignment constraint. </p>
<p>Write the error message to <code>errorMessage</code> if errors occur and <code>errorMessage</code> is not nullptr. </p>

<p class="definition">Definition at line <a class="el" href="FileUtilities_8cpp_source.html#l00043">43</a> of file <a class="el" href="FileUtilities_8cpp_source.html">FileUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="FileUtilities_8cpp_source.html#l00023">openInputFileImpl()</a>.</p>

</div>
</div>
<a id="a0c2eb0b34f6d7e90435b0a6ce3d8ffaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2eb0b34f6d7e90435b0a6ce3d8ffaf">&#9670;&nbsp;</a></span>openInputFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::MemoryBuffer&gt; mlir::openInputFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>inputFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>errorMessage</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the file specified by its name for reading. </p>
<p>Write the error message to <code>errorMessage</code> if errors occur and <code>errorMessage</code> is not nullptr. </p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00251">loadIRDLDialects()</a>, <a class="el" href="MlirReduceMain_8cpp_source.html#l00032">loadModule()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00568">MlirOptMain()</a>, <a class="el" href="MlirQueryMain_8cpp_source.html#l00031">mlirQueryMain()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00134">parseMLIRInput()</a>, and <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00090">mlir::transform::detail::parseTransformModuleFromFile()</a>.</p>

</div>
</div>
<a id="a4c8c9750d9c8efdbcc7542f3b1564d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8c9750d9c8efdbcc7542f3b1564d8d">&#9670;&nbsp;</a></span>openOutputFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::ToolOutputFile&gt; mlir::openOutputFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>outputFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>errorMessage</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the file specified by its name for writing. </p>
<p>Write the error message to <code>errorMessage</code> if errors occur and <code>errorMessage</code> is not nullptr. </p>

<p class="reference">Referenced by <a class="el" href="ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00083">mlir::SimpleObjectCache::dumpToObjectFile()</a>, <a class="el" href="CLOptionsSetup_8cpp_source.html#l00080">mlir::tracing::InstallDebugHandler::Impl::Impl()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00429">makeReproducerStreamFactory()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00568">MlirOptMain()</a>, and <a class="el" href="MlirReduceMain_8cpp_source.html#l00048">mlirReduceMain()</a>.</p>

</div>
</div>
<a id="aee326f96469cd288efb48265e173295e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee326f96469cd288efb48265e173295e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00261">261</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00108">mlir::OpState::getOperation()</a>.</p>

</div>
</div>
<a id="a62534636110d65226b611986e9a316a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62534636110d65226b611986e9a316a1">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RegionBranchPoint.html">RegionBranchPoint</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RegionBranchPoint.html">RegionBranchPoint</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8h_source.html#l00251">251</a> of file <a class="el" href="ControlFlowInterfaces_8h_source.html">ControlFlowInterfaces.h</a>.</p>

</div>
</div>
<a id="a8db56ba5c170b04848e194937be59a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db56ba5c170b04848e194937be59a56">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01058">1058</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a6bb385e3105982b905c5ef4db9f9f21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb385e3105982b905c5ef4db9f9f21b">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01064">1064</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a48146d74baebce1c83140c378053f3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48146d74baebce1c83140c378053f3c2">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01070">1070</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a4bfbb1c5941d2cc005eb3f483e881202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfbb1c5941d2cc005eb3f483e881202">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01074">1074</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a4f5d450d84010aaf140c9cccddf00804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5d450d84010aaf140c9cccddf00804">&#9670;&nbsp;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> mlir::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataFlowFramework_8h_source.html#l00045">45</a> of file <a class="el" href="DataFlowFramework_8h_source.html">DataFlowFramework.h</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999da4bac8cdf0a968472b519b3b295d0d48b">NoChange</a>.</p>

</div>
</div>
<a id="a9137193b56dc5134c3092273b13e3f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9137193b56dc5134c3092273b13e3f47">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::operator* </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00265">265</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

</div>
</div>
<a id="a8f6f52bcd2d859c9d9a6f393ad5481c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6f52bcd2d859c9d9a6f393ad5481c1">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::operator+ </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00264">264</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

</div>
</div>
<a id="a72aa3fc8e169b33e5d4a63f593172d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72aa3fc8e169b33e5d4a63f593172d4e">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::operator- </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00266">266</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

</div>
</div>
<a id="ab1058014e7cd14312242383156c0d174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1058014e7cd14312242383156c0d174">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#acefb76d43733fcaa50b62e0962d9c463">DeviceIDTargetDeviceSpecPair</a>&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DLTI_8cpp_source.html#l00349">349</a> of file <a class="el" href="DLTI_8cpp_source.html">DLTI.cpp</a>.</p>

</div>
</div>
<a id="a6d315bdf3396a4c2cac6ead94cfc0e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d315bdf3396a4c2cac6ead94cfc0e26">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT , typename ElementT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::value, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; ElementT &gt;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="ab69273e2629a0b7e18af99582f687692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69273e2629a0b7e18af99582f687692">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::value, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a627aa7e5b958743b9a67a4ccbe1418c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627aa7e5b958743b9a67a4ccbe1418c9">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::value, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a424d21ac06bbb37dee5c29f22e9d261a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424d21ac06bbb37dee5c29f22e9d261a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::value, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const APFloat &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a462d4f34f404bcc705506899944185f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462d4f34f404bcc705506899944185f6">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT , typename T , std::enable_if_t&lt;!std::is_convertible&lt; T &amp;, Value &amp; &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Type &amp; &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Attribute &amp; &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, ValueRange &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, APFloat &amp; &gt;::value &amp;&amp;!llvm::is_one_of&lt; T, bool, float, double &gt;::value, T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::value, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a970e10cc4cef6e2f2dd48772041b4773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a970e10cc4cef6e2f2dd48772041b4773">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_same&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::value &amp;&amp; std::is_convertible&lt;T &amp;, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&gt;::value, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a4d69cef9b50344549afeaaa734f8172d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d69cef9b50344549afeaaa734f8172d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::value, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> &amp;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a26ecef972faf3b5c78d8415d69a86728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ecef972faf3b5c78d8415d69a86728">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT , typename ValueRangeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::value, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a>&lt; ValueRangeT &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="ad013c3d87cad19d6a7fa6ce16eb6bd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad013c3d87cad19d6a7fa6ce16eb6bd58">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[10/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::value, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="ac31efc2a6e3489b511bf1640b6e3b9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31efc2a6e3489b511bf1640b6e3b9eb">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[11/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::value, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a97986a4859106d3c96b089e726e26c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97986a4859106d3c96b089e726e26c7c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[12/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::value, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00096">96</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="ad554d3204bdbdc4a87d291ed94c1e575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad554d3204bdbdc4a87d291ed94c1e575">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[13/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00534">534</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1OpAsmPrinter.html#a922b7c99e121802c2e58a80f964b8561">mlir::OpAsmPrinter::printSuccessor()</a>.</p>

</div>
</div>
<a id="a58c02ebe7d299d1683ae658ea4e9352c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c02ebe7d299d1683ae658ea4e9352c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[14/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::enable_if_t&lt; std::is_convertible&lt; T &amp;, ValueRange &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Value &amp; &gt;::value, T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00529">529</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="OpImplementation_8h_source.html#l00445">mlir::OpAsmPrinter::printOperands()</a>.</p>

</div>
</div>
<a id="acabdc4e9d44aae13942c9ea9b41b9a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabdc4e9d44aae13942c9ea9b41b9a33">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[15/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00520">520</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1OpAsmPrinter.html#acddd5eb143c94fa8528920c75799e3ba">mlir::OpAsmPrinter::printOperand()</a>.</p>

</div>
</div>
<a id="a13e488dd4f0933d688cd10581b313afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e488dd4f0933d688cd10581b313afb">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[16/38]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l04011">4011</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l03977">mlir::Block::print()</a>.</p>

</div>
</div>
<a id="a7cbf6a6a0dd14f6d2f1e7d7772006077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cbf6a6a0dd14f6d2f1e7d7772006077">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[17/38]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ConstantIntRanges.html">ConstantIntRanges</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InferIntRangeInterface_8cpp_source.html#l00125">125</a> of file <a class="el" href="InferIntRangeInterface_8cpp_source.html">InferIntRangeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="InferIntRangeInterface_8cpp_source.html#l00028">mlir::ConstantIntRanges::smax()</a>, <a class="el" href="InferIntRangeInterface_8cpp_source.html#l00026">mlir::ConstantIntRanges::smin()</a>, <a class="el" href="InferIntRangeInterface_8cpp_source.html#l00024">mlir::ConstantIntRanges::umax()</a>, and <a class="el" href="InferIntRangeInterface_8cpp_source.html#l00022">mlir::ConstantIntRanges::umin()</a>.</p>

</div>
</div>
<a id="ab96f3b26c90ea659c4be029b0e410cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96f3b26c90ea659c4be029b0e410cd3">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[18/38]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IntegerValueRange.html">IntegerValueRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InferIntRangeInterface_8cpp_source.html#l00142">142</a> of file <a class="el" href="InferIntRangeInterface_8cpp_source.html">InferIntRangeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="InferIntRangeInterface_8h_source.html#l00149">mlir::IntegerValueRange::print()</a>.</p>

</div>
</div>
<a id="ae69078b1d3f3263a1769df2e0f1730df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69078b1d3f3263a1769df2e0f1730df">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[19/38]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01028">1028</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l03852">mlir::AffineExpr::print()</a>.</p>

</div>
</div>
<a id="a6f93a44db5e2d93372201d5a594e51cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f93a44db5e2d93372201d5a594e51cd">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[20/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00664">664</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l03866">mlir::AffineMap::print()</a>.</p>

</div>
</div>
<a id="a5e8f0e932c305de3ac1584560d1b03d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8f0e932c305de3ac1584560d1b03d0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[21/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Attributes_8h_source.html#l00168">168</a> of file <a class="el" href="Attributes_8h_source.html">Attributes.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l03772">mlir::Attribute::print()</a>.</p>

</div>
</div>
<a id="af8130946445de43cbbe975607457e51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8130946445de43cbbe975607457e51c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[22/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AliasResult.html">AliasResult</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AliasAnalysis_8h_source.html#l00078">78</a> of file <a class="el" href="AliasAnalysis_8h_source.html">AliasAnalysis.h</a>.</p>

<p class="reference">References <a class="el" href="AliasAnalysis_8cpp_source.html#l00034">mlir::AliasResult::print()</a>.</p>

</div>
</div>
<a id="aa90cebc5db982e1f7b1147c8c6595595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90cebc5db982e1f7b1147c8c6595595">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[23/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AnalysisState.html">AnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataFlowFramework_8h_source.html#l00527">527</a> of file <a class="el" href="DataFlowFramework_8h_source.html">DataFlowFramework.h</a>.</p>

</div>
</div>
<a id="a85b9a8e647d5e73b7e107b0669ec9e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b9a8e647d5e73b7e107b0669ec9e29">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[24/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a> &amp;&#160;</td>
          <td class="paramname"><em>diag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00301">301</a> of file <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="ModuleImport_8cpp_source.html#l00054">diag()</a>.</p>

</div>
</div>
<a id="ae72e36349258a6b2baeae78188a74550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72e36349258a6b2baeae78188a74550">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[25/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DiagnosticArgument.html">DiagnosticArgument</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00143">143</a> of file <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00058">mlir::DiagnosticArgument::print()</a>.</p>

</div>
</div>
<a id="a279adec3f964e12de632fa76060d2669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279adec3f964e12de632fa76060d2669">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[26/38]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IRUnit.html">IRUnit</a> &amp;&#160;</td>
          <td class="paramname"><em>unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab097ddf5971ea2a3956fc814005f459f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab097ddf5971ea2a3956fc814005f459f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[27/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Location.html">Location</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Location_8h_source.html#l00123">123</a> of file <a class="el" href="Location_8h_source.html">Location.h</a>.</p>

<p class="reference">References <a class="el" href="Location_8h_source.html#l00104">mlir::Location::print()</a>.</p>

</div>
</div>
<a id="a0e8ea3e011d372d1f5b3bc1fb34e1286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8ea3e011d372d1f5b3bc1fb34e1286">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[28/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ModRefResult.html">ModRefResult</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AliasAnalysis_8h_source.html#l00165">165</a> of file <a class="el" href="AliasAnalysis_8h_source.html">AliasAnalysis.h</a>.</p>

<p class="reference">References <a class="el" href="AliasAnalysis_8cpp_source.html#l00055">mlir::ModRefResult::print()</a>.</p>

</div>
</div>
<a id="ab0dd71f700f3e4336e89a94f69ff28de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0dd71f700f3e4336e89a94f69ff28de">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[29/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Operation_8h_source.html#l01096">1096</a> of file <a class="el" href="IR_2Operation_8h_source.html">Operation.h</a>.</p>

</div>
</div>
<a id="ac7e879c874e4fdc6aaf9d4742abdb876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e879c874e4fdc6aaf9d4742abdb876">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[30/38]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1Range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l03025">3025</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8h_source.html#l00034">mlir::Range::offset</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00035">mlir::Range::size</a>, and <a class="el" href="StaticValueUtils_8h_source.html#l00036">mlir::Range::stride</a>.</p>

</div>
</div>
<a id="a40e22b31f6f0d59955e0e73f0d387613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e22b31f6f0d59955e0e73f0d387613">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[31/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> &amp;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit a type range to the given output stream. </p>

<p class="definition">Definition at line <a class="el" href="TypeRange_8h_source.html#l00077">77</a> of file <a class="el" href="TypeRange_8h_source.html">TypeRange.h</a>.</p>

</div>
</div>
<a id="aa0b04ef5fe364cd0e2f086eb998894ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b04ef5fe364cd0e2f086eb998894ca">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[32/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LatticeAnchor.html">LatticeAnchor</a>&#160;</td>
          <td class="paramname"><em>anchor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataFlowFramework_8h_source.html#l00532">532</a> of file <a class="el" href="DataFlowFramework_8h_source.html">DataFlowFramework.h</a>.</p>

<p class="reference">References <a class="el" href="DataFlowFramework_8cpp_source.html#l00070">mlir::LatticeAnchor::print()</a>.</p>

</div>
</div>
<a id="a45dade5c2740697bc36ceb8d6554ee00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45dade5c2740697bc36ceb8d6554ee00">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[33/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a>&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00509">509</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l00061">mlir::OperationName::print()</a>.</p>

</div>
</div>
<a id="a8c357b30f2e56803678fe5f7b75e80a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c357b30f2e56803678fe5f7b75e80a1">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[34/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow printing to a stream. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00302">302</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="af07e7b01e09b3da975cc984b4e1c506d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07e7b01e09b3da975cc984b4e1c506d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[35/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow printing to a stream. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00310">310</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="a78425f2c879f5b708f5c58af03931e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78425f2c879f5b708f5c58af03931e9f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[36/38]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SymbolTable.html#a4f1a6f39b93a08abe4e80a5c15fe32b8">SymbolTable::Visibility</a>&#160;</td>
          <td class="paramname"><em>visibility</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SymbolTable_8cpp_source.html#l00466">466</a> of file <a class="el" href="SymbolTable_8cpp_source.html">SymbolTable.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1SymbolTable.html#a4f1a6f39b93a08abe4e80a5c15fe32b8a13c479c348969ab459513a4bfd559bb9">mlir::SymbolTable::Nested</a>, <a class="el" href="classmlir_1_1SymbolTable.html#a4f1a6f39b93a08abe4e80a5c15fe32b8a47f9082fc380ca62d531096aa1d110f1">mlir::SymbolTable::Private</a>, and <a class="el" href="classmlir_1_1SymbolTable.html#a4f1a6f39b93a08abe4e80a5c15fe32b8a3d067bedfe2f4677470dd6ccf64d05ed">mlir::SymbolTable::Public</a>.</p>

</div>
</div>
<a id="acd5bfd80339235fbb32a685ff75f4e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5bfd80339235fbb32a685ff75f4e16">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[37/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00261">261</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l03824">mlir::Type::print()</a>.</p>

</div>
</div>
<a id="a3df16c49c963cdc57cf6f9e7c3e9f822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df16c49c963cdc57cf6f9e7c3e9f822">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[38/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Value_8h_source.html#l00256">256</a> of file <a class="el" href="Value_8h_source.html">Value.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l03880">mlir::Value::print()</a>.</p>

</div>
</div>
<a id="a8fc3d1f66f267d9111234fac1effdfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc3d1f66f267d9111234fac1effdfce">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a>&lt; RangeT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeRange_8h_source.html#l00163">163</a> of file <a class="el" href="TypeRange_8h_source.html">TypeRange.h</a>.</p>

</div>
</div>
<a id="abc4f129dda2c412845b5ec66a77325a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4f129dda2c412845b5ec66a77325a3">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00258">258</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00108">mlir::OpState::getOperation()</a>.</p>

</div>
</div>
<a id="a543c4328a4fa5ed530aa88a9d7d158a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543c4328a4fa5ed530aa88a9d7d158a9">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define comparisons for StringAttr against nullptr and itself to avoid the StringRef overloads from being chosen when not desirable. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01057">1057</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00967">mlir::ValueBoundsConstraintSet::BoundBuilder::operator==()</a>.</p>

</div>
</div>
<a id="a40ce38cb70a016263f28574d4982475b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ce38cb70a016263f28574d4982475b">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01061">1061</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a075d7bf5dfe5d33c409763bc28330180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075d7bf5dfe5d33c409763bc28330180">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow direct comparison with StringRef. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01067">1067</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a50c46bfb0a0fbbe700ef6c07a611dbf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c46bfb0a0fbbe700ef6c07a611dbf8">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01071">1071</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a609ab9ceb7a2ad554864c86fc7ece4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609ab9ceb7a2ad554864c86fc7ece4fd">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> mlir::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataFlowFramework_8h_source.html#l00038">38</a> of file <a class="el" href="DataFlowFramework_8h_source.html">DataFlowFramework.h</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999daf4ec5f57bd4d31b803312d873be40da9">Change</a>.</p>

</div>
</div>
<a id="a001ec055bf293748f02c00aff842dc38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001ec055bf293748f02c00aff842dc38">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&amp; mlir::operator|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataFlowFramework_8h_source.html#l00041">41</a> of file <a class="el" href="DataFlowFramework_8h_source.html">DataFlowFramework.h</a>.</p>

</div>
</div>
<a id="a10aad3624e000c0585087c96357ea857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10aad3624e000c0585087c96357ea857">&#9670;&nbsp;</a></span>outlineIfOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::outlineIfOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::IfOp&#160;</td>
          <td class="paramname"><em>ifOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">func::FuncOp *&#160;</td>
          <td class="paramname"><em>thenFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>thenFnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">func::FuncOp *&#160;</td>
          <td class="paramname"><em>elseFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>elseFnName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outline the then and/or else regions of <code>ifOp</code> as follows: </p>
<ul>
<li>if <code>thenFn</code> is not null, <code>thenFnName</code> must be specified and the <code>then</code> region is inlined into a new FuncOp that is captured by the pointer.</li>
<li>if <code>elseFn</code> is not null, <code>elseFnName</code> must be specified and the <code>else</code> region is inlined into a new FuncOp that is captured by the pointer. Creates new FuncOps and thus cannot be used in a FuncOp pass. The client is responsible for providing a unique <code>thenFnName</code>/<code>elseFnName</code> that will not collide with another FuncOp name. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00223">223</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00119">outlineSingleBlockRegion()</a>.</p>

</div>
</div>
<a id="ae9152a09d079148a1a2f40d4946f7c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9152a09d079148a1a2f40d4946f7c17">&#9670;&nbsp;</a></span>outlineKernelFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gpu::GPUFuncOp mlir::outlineKernelFunc </td>
          <td>(</td>
          <td class="paramtype">gpu::LaunchOp&#160;</td>
          <td class="paramname"><em>launchOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>kernelFnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">llvm::SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a gpu.func created from outlining the region of a gpu.launch op with the given <code>kernelFnName</code>. </p>
<p>The region of the <code>launchOp</code> can use values from above. These need to be captured and passed as arguments to the generated gpu.func. The generated function has arguments</p><ul>
<li>corresponding to the values passed in as <code>operands</code>, in that order.</li>
<li>any additional values that might be used within the region of the <code>launchOp</code> and defined above it. These captured values are appended to the <code>operands</code> list. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="KernelOutlining_8cpp_source.html#l00265">265</a> of file <a class="el" href="KernelOutlining_8cpp_source.html">KernelOutlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="KernelOutlining_8cpp_source.html#l00178">outlineKernelFuncImpl()</a>.</p>

</div>
</div>
<a id="abdec8fa23b93085ee2e142defd7c5599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdec8fa23b93085ee2e142defd7c5599">&#9670;&nbsp;</a></span>outlineSingleBlockRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; func::FuncOp &gt; mlir::outlineSingleBlockRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>funcName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">func::CallOp *&#160;</td>
          <td class="paramname"><em>callOp</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outline a region with a single block into a new FuncOp. </p>
<p>Assumes the FuncOp result types is the type of the yielded operands of the single block. This constraint makes it easy to determine the result. This method also clones the <code><a class="el" href="classmlir_1_1arith_1_1ConstantIndexOp.html" title="Specialization of arith.constant op that returns an integer of index type.">arith::ConstantIndexOp</a></code> at the start of <code>outlinedFuncBody</code> to alloc simple canonicalizations. Creates a new FuncOp and thus cannot be used in a FuncOp pass. The client is responsible for providing a unique <code>funcName</code> that will not collide with another FuncOp name. If <code>callOp</code> is provided, it will be set to point to the operation that calls the outlined function.</p>
<p>Assumes the FuncOp result types is the type of the yielded operands of the single block. This constraint makes it easy to determine the result. This method also clones the <code><a class="el" href="classmlir_1_1arith_1_1ConstantIndexOp.html" title="Specialization of arith.constant op that returns an integer of index type.">arith::ConstantIndexOp</a></code> at the start of <code>outlinedFuncBody</code> to alloc simple canonicalizations. If <code>callOp</code> is provided, it will be set to point to the operation that calls the outlined function. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00119">119</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00055">mlir::Region::begin()</a>, <a class="el" href="Builders_8cpp_source.html#l00579">mlir::OpBuilder::clone()</a>, <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8cpp_source.html#l00461">mlir::OpBuilder::createBlock()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00161">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">get()</a>, <a class="el" href="Block_8h_source.html#l00085">mlir::Block::getArguments()</a>, <a class="el" href="IR_2Region_8h_source.html#l00081">mlir::Region::getArguments()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Block_8h_source.html#l00126">mlir::Block::getNumArguments()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00373">mlir::Operation::getOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00392">mlir::Operation::getOperandTypes()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="IR_2Region_8h_source.html#l00205">mlir::Region::getParentOfType()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00402">mlir::Operation::getResult()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00423">mlir::Operation::getResultTypes()</a>, <a class="el" href="Block_8cpp_source.html#l00243">mlir::Block::getTerminator()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00067">getUsedValuesDefinedAbove()</a>, <a class="el" href="IR_2Region_8h_source.html#l00068">mlir::Region::hasOneBlock()</a>, <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00339">mlir::RewriterBase::mergeBlocks()</a>, <a class="el" href="Value_8cpp_source.html#l00081">mlir::Value::replaceUsesWithIf()</a>, <a class="el" href="Builders_8h_source.html#l00406">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00444">mlir::OpBuilder::setInsertionPointToEnd()</a>, and <a class="el" href="Builders_8h_source.html#l00439">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00223">outlineIfOp()</a>.</p>

</div>
</div>
<a id="ad02ff92115796118c612bc82db603b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02ff92115796118c612bc82db603b7e">&#9670;&nbsp;</a></span>parallelFor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::parallelFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements between [begin, end) asynchronously. </p>
<p>Diagnostics emitted during processing are ordered relative to the element's position within [begin, end). If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00141">141</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="Threading_8h_source.html#l00117">parallelForEach()</a>.</p>

</div>
</div>
<a id="a7acf0c58d63da562112dd8f6a81b49e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acf0c58d63da562112dd8f6a81b49e3">&#9670;&nbsp;</a></span>parallelForEach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT , typename FuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::parallelForEach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements between [begin, end) asynchronously. </p>
<p>Diagnostics emitted during processing are ordered relative to the element's position within [begin, end). If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00117">117</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="Threading_8h_source.html#l00036">failableParallelForEach()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Threading_8h_source.html#l00141">parallelFor()</a>, and <a class="el" href="Threading_8h_source.html#l00130">parallelForEach()</a>.</p>

</div>
</div>
<a id="af1232c5821e793866aa3cf2234e1ba93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1232c5821e793866aa3cf2234e1ba93">&#9670;&nbsp;</a></span>parallelForEach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT , typename FuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::parallelForEach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeT &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements in the provided range asynchronously. </p>
<p>Diagnostics emitted during processing are ordered relative to the element's position within the range. If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00130">130</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="Threading_8h_source.html#l00117">parallelForEach()</a>.</p>

</div>
</div>
<a id="a351183b9c1036310349dea952c1f2d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351183b9c1036310349dea952c1f2d5a">&#9670;&nbsp;</a></span>parseAffineMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::parseAffineMap </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses a single IntegerSet/AffineMap to an MLIR context if it was valid. </p>
<p>If not, an error message is emitted through a new <a class="el" href="classmlir_1_1SourceMgrDiagnosticHandler.html" title="This class is a utility diagnostic handler for use with llvm::SourceMgr.">SourceMgrDiagnosticHandler</a> constructed from a new SourceMgr with a single MemoryBuffer wrapping <code>str</code>. If the passed <code>str</code> has additional tokens that were not part of the IntegerSet/AffineMap, a failure is returned. </p>

</div>
</div>
<a id="a2ce4d766139754b57d04b314aefacea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce4d766139754b57d04b314aefacea5">&#9670;&nbsp;</a></span>parseAsmSourceFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::parseAsmSourceFile </td>
          <td>(</td>
          <td class="paramtype">const llvm::SourceMgr &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParserState.html">AsmParserState</a> *&#160;</td>
          <td class="paramname"><em>asmState</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParserCodeCompleteContext.html">AsmParserCodeCompleteContext</a> *&#160;</td>
          <td class="paramname"><em>codeCompleteContext</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated SourceMgr and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. If <code>sourceFileLoc</code> is non-null, it is populated with a file location representing the start of the source file that is being parsed. If <code>asmState</code> is non-null, it is populated with detailed information about the parsed IR (including exact locations for SSA uses and definitions). <code>asmState</code> should only be provided if this detailed information is desired. If <code>codeCompleteContext</code> is non-null, it is used to signal tracking of a code completion event (generally only ever useful for LSP or other high level language tooling). </p>

<p class="definition">Definition at line <a class="el" href="AsmParser_2Parser_8cpp_source.html#l02816">2816</a> of file <a class="el" href="AsmParser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">get()</a>, and <a class="el" href="AsmState_8h_source.html#l00474">mlir::ParserConfig::getContext()</a>.</p>

</div>
</div>
<a id="a6658f887276425945e0ebe6fcc194c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6658f887276425945e0ebe6fcc194c23">&#9670;&nbsp;</a></span>parseAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::parseAttribute </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>attrStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>numRead</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isKnownNullTerminated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses a single MLIR attribute to an MLIR context if it was valid. </p>
<p>If not, an error diagnostic is emitted to the context and a null value is returned. If <code>numRead</code> is provided, it is set to the number of consumed characters on succesful parse. Otherwise, parsing fails if the entire string is not consumed. Some internal copying can be skipped if the source string is known to be null terminated. </p>

<p class="reference">Referenced by <a class="el" href="IR_8cpp_source.html#l01077">mlirAttributeParseGet()</a>.</p>

</div>
</div>
<a id="a12d828f0860b1c0863b1badf0fe06e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d828f0860b1c0863b1badf0fe06e30">&#9670;&nbsp;</a></span>parseDimensionList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::parseDimensionList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a> &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l04030">4030</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00863">mlir::detail::DenseArrayAttrImpl&lt; T &gt;::get()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00073">mlir::AsmParser::getContext()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a7850fe0a2961f835384adb372758d58b">mlir::AsmParser::getCurrentLocation()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a55d178f0d42011618d0c479b1d48cc0a">mlir::AsmParser::parseDimensionList()</a>, <a class="el" href="classmlir_1_1AsmParser.html#aed41da9f5ed12ea4b41136ef1b6239dd">mlir::AsmParser::parseOptionalLSquare()</a>, and <a class="el" href="classmlir_1_1AsmParser.html#a3a1446df423154a41d52374b062ee1ff">mlir::AsmParser::parseRSquare()</a>.</p>

</div>
</div>
<a id="ad736d3dd9c0d332b3dd23d7e6dd14963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad736d3dd9c0d332b3dd23d7e6dd14963">&#9670;&nbsp;</a></span>parseDynamicIndexList() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::parseDynamicIndexList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a> &amp;&#160;</td>
          <td class="paramname"><em>integers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a7dffb2feeebaff96012a0f11534ecb42">DenseBoolArrayAttr</a> &amp;&#160;</td>
          <td class="paramname"><em>scalableVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; *&#160;</td>
          <td class="paramname"><em>valueTypes</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a>&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parser hook for custom directive in assemblyFormat. </p>
<p>custom&lt;DynamicIndexList&gt;($values, $integers) custom&lt;DynamicIndexList&gt;($values, $integers, type($values))</p>
<p>where <code>values</code> is of ODS type <code>Variadic&lt;*&gt;</code> and <code>integers</code> is of ODS type <code>I64ArrayAttr</code>. Parse a mixed list with either (1) static integer values or (2) SSA values. Fill <code>integers</code> with the integer ArrayAttr, where <code>kDynamic</code> encodes the position of SSA values. Add the parsed SSA values to <code>values</code> in-order. If <code>valueTypes</code> is non-null, fill it with types corresponding to values; otherwise the caller must handle the types.</p>
<p>E.g. after parsing "[%arg0 : index, 7, 42, %arg42 : i32]":</p><ol type="1">
<li><code>result</code> is filled with the i64 ArrayAttr "[`kDynamic`, 7, 42,
  `kDynamic`]"</li>
<li><code>ssa</code> is filled with "[%arg0, %arg1]".</li>
</ol>
<p>Indices can be scalable. For example, "4" in "[2, [4], 8]" is scalable. This notation is similar to how scalable dims are marked when defining Vectors. For each value in <code>integers</code>, the corresponding <code>bool</code> in <code>scalableVals</code> encodes whether it's a scalable index. </p>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00148">148</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf38020e304fa596401f15d1eb30e1d">mlir::AsmParser::getBuilder()</a>, <a class="el" href="Builders_8cpp_source.html#l00191">mlir::Builder::getDenseBoolArrayAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00207">mlir::Builder::getDenseI64ArrayAttr()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a8d00f93debeb1567ae8f7bbb76cdea37">mlir::AsmParser::getNameLoc()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a709cff503c00735e0a35ecd795364a2a">mlir::AsmParser::parseColonType()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2839f5b817f7fd118a6b0381da695436">mlir::AsmParser::parseCommaSeparatedList()</a>, <a class="el" href="OpImplementation_8h_source.html#l00715">mlir::AsmParser::parseInteger()</a>, <a class="el" href="classmlir_1_1AsmParser.html#aed41da9f5ed12ea4b41136ef1b6239dd">mlir::AsmParser::parseOptionalLSquare()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a8fd765b541880aa1f11ca238ce62ad9d">mlir::OpAsmParser::parseOptionalOperand()</a>, and <a class="el" href="classmlir_1_1AsmParser.html#aacb77758ffb3701ad5ede6299de580f0">mlir::AsmParser::parseOptionalRSquare()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ViewLikeInterface_8h_source.html#l00147">parseDynamicIndexList()</a>, and <a class="el" href="Dialect_2Transform_2Utils_2Utils_8cpp_source.html#l00033">mlir::transform::parsePackedOrDynamicIndexList()</a>.</p>

</div>
</div>
<a id="a8511448207eb11107861cc37482f7c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8511448207eb11107861cc37482f7c56">&#9670;&nbsp;</a></span>parseDynamicIndexList() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::parseDynamicIndexList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a> &amp;&#160;</td>
          <td class="paramname"><em>integers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a>&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8h_source.html#l00156">156</a> of file <a class="el" href="ViewLikeInterface_8h_source.html">ViewLikeInterface.h</a>.</p>

<p class="reference">References <a class="el" href="ViewLikeInterface_8cpp_source.html#l00148">parseDynamicIndexList()</a>.</p>

</div>
</div>
<a id="a0a67dbd082125f72a4a5b17e4b659d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a67dbd082125f72a4a5b17e4b659d17">&#9670;&nbsp;</a></span>parseDynamicIndexList() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::parseDynamicIndexList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a> &amp;&#160;</td>
          <td class="paramname"><em>integers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a7dffb2feeebaff96012a0f11534ecb42">DenseBoolArrayAttr</a> &amp;&#160;</td>
          <td class="paramname"><em>scalableVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a>&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8h_source.html#l00165">165</a> of file <a class="el" href="ViewLikeInterface_8h_source.html">ViewLikeInterface.h</a>.</p>

<p class="reference">References <a class="el" href="ViewLikeInterface_8cpp_source.html#l00148">parseDynamicIndexList()</a>.</p>

</div>
</div>
<a id="a113026edf72f8e99369fc9128e2e0da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113026edf72f8e99369fc9128e2e0da2">&#9670;&nbsp;</a></span>parseDynamicIndexList() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::parseDynamicIndexList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a> &amp;&#160;</td>
          <td class="paramname"><em>integers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; *&#160;</td>
          <td class="paramname"><em>valueTypes</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a>&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8h_source.html#l00147">147</a> of file <a class="el" href="ViewLikeInterface_8h_source.html">ViewLikeInterface.h</a>.</p>

<p class="reference">References <a class="el" href="ViewLikeInterface_8cpp_source.html#l00148">parseDynamicIndexList()</a>.</p>

</div>
</div>
<a id="acda383f3d69ddb866ea67abc7ba9e75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda383f3d69ddb866ea67abc7ba9e75e">&#9670;&nbsp;</a></span>parseIntegerSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> mlir::parseIntegerSet </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8d10077c7edf58c1152a1170257d739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d10077c7edf58c1152a1170257d739">&#9670;&nbsp;</a></span>parsePassPipeline() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::parsePassPipeline </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>pipeline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>errorStream</em> = <code>llvm::errs()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the textual representation of a pass pipeline, adding the result to 'pm' on success. </p>
<p>Returns failure if the given pipeline was invalid. 'errorStream' is the output stream used to emit errors found during parsing. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8cpp_source.html#l00753">753</a> of file <a class="el" href="PassRegistry_8cpp_source.html">PassRegistry.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassRegistry_8cpp_source.html#l00990">mlir::PassPipelineCLParser::addToPipeline()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00514">mlir::PassReproducerOptions::apply()</a>, <a class="el" href="CAPI_2IR_2Pass_8cpp_source.html#l00087">mlirOpPassManagerAddPipeline()</a>, <a class="el" href="CAPI_2IR_2Pass_8cpp_source.html#l00102">mlirParsePassPipeline()</a>, and <a class="el" href="PassRegistry_8cpp_source.html#l00767">parsePassPipeline()</a>.</p>

</div>
</div>
<a id="aef5abaea7950d9dc385a018dbbb40d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5abaea7950d9dc385a018dbbb40d0b">&#9670;&nbsp;</a></span>parsePassPipeline() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt; mlir::parsePassPipeline </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>pipeline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>errorStream</em> = <code>llvm::errs()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the given textual representation of a pass pipeline, and return the parsed pipeline on success. </p>
<p>The given pipeline string should be wrapped with the desired type of operation to root the created operation, i.e. <code>builtin.module(cse)</code> over <code>cse</code>. Returns failure if the given pipeline was invalid. 'errorStream' is the output stream used to emit errors found during parsing. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8cpp_source.html#l00767">767</a> of file <a class="el" href="PassRegistry_8cpp_source.html">PassRegistry.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassRegistry_8cpp_source.html#l00753">parsePassPipeline()</a>.</p>

</div>
</div>
<a id="a3ee9c22e4e76e3de2f4c6da9783145a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee9c22e4e76e3de2f4c6da9783145a4">&#9670;&nbsp;</a></span>parseSemiFunctionType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::parseSemiFunctionType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>argumentType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Syntax_8cpp_source.html#l00028">28</a> of file <a class="el" href="Syntax_8cpp_source.html">Syntax.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#aadaac62d4dff4fde5f3a8b9ee355d923">mlir::AsmParser::parseArrow()</a>, <a class="el" href="classmlir_1_1AsmParser.html#aca8bb7b19bcdc7638597791aff1bafed">mlir::AsmParser::parseOptionalLParen()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a33657a4e5f2cd8018b6d57d468b5f04a">mlir::AsmParser::parseRParen()</a>, <a class="el" href="classmlir_1_1AsmParser.html#ab85d23c93adf11e18d6507779bf95fad">mlir::AsmParser::parseType()</a>, and <a class="el" href="AsmPrinter_8cpp_source.html#l00077">mlir::AsmParser::parseTypeList()</a>.</p>

</div>
</div>
<a id="a095b024ace01a15b05be2f298195850e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095b024ace01a15b05be2f298195850e">&#9670;&nbsp;</a></span>parseSemiFunctionType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::parseSemiFunctionType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>argumentType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>resultType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a single non-function type or a function type with at least one argument. </p>
<p>This allows for the following syntax:</p>
<ul>
<li>type: just the argument type;</li>
<li><code>(</code> type <code>)</code> <code>-&gt;</code> type: one argument and one result type;</li>
<li><code>(</code> type <code>)</code> <code>-&gt;</code> <code>(</code> comma-separated-type-list <code>)</code>: one argument and multiple result types.</li>
</ul>
<p>Unlike FunctionType, this allows and requires one to omit the parens around the argument type in absence of result types, and does not accept the trailing <code>-&gt; ()</code> construct, which makes the syntax nicer for operations. </p>

<p class="definition">Definition at line <a class="el" href="Syntax_8cpp_source.html#l00014">14</a> of file <a class="el" href="Syntax_8cpp_source.html">Syntax.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#aadaac62d4dff4fde5f3a8b9ee355d923">mlir::AsmParser::parseArrow()</a>, <a class="el" href="classmlir_1_1AsmParser.html#aca8bb7b19bcdc7638597791aff1bafed">mlir::AsmParser::parseOptionalLParen()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a33657a4e5f2cd8018b6d57d468b5f04a">mlir::AsmParser::parseRParen()</a>, and <a class="el" href="classmlir_1_1AsmParser.html#ab85d23c93adf11e18d6507779bf95fad">mlir::AsmParser::parseType()</a>.</p>

</div>
</div>
<a id="ab0f975095772c8ece0dbda8bf7f455eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f975095772c8ece0dbda8bf7f455eb">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">const llvm::SourceMgr &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated SourceMgr and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. If <code>sourceFileLoc</code> is non-null, it is populated with a file location representing the start of the source file that is being parsed. </p>

<p class="definition">Definition at line <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00020">20</a> of file <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="MLIRServer_8cpp_source.html#l01350">mlir::lsp::MLIRServer::convertFromBytecode()</a>, <a class="el" href="MlirQueryMain_8cpp_source.html#l00031">mlirQueryMain()</a>, and <a class="el" href="ParseUtilities_8h_source.html#l00027">parseSourceFileForTool()</a>.</p>

</div>
</div>
<a id="a8735a3d1b2704c1497e7c4b8173e8d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8735a3d1b2704c1497e7c4b8173e8d99">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT  = Operation *&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ContainerOpT&gt; mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">const llvm::SourceMgr &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated SourceMgr. </p>
<p>If the source IR contained a single instance of <code>ContainerOpT</code>, it is returned. Otherwise, a new instance of <code>ContainerOpT</code> is constructed containing all of the parsed operations. If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context, and failure is returned. <code>ContainerOpT</code> is required to have a single region containing a single block, and must implement the <code>SingleBlockImplicitTerminator</code> trait. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00177">177</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

</div>
</div>
<a id="a537a80c31d8487a710f53cd9a38e390a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537a80c31d8487a710f53cd9a38e390a">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR). </p>
<p>This is useful, for example, to avoid copying some large resources into the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> and instead referencing the data directly from the input buffers. </p>

<p class="definition">Definition at line <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00034">34</a> of file <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

<p class="reference">References <a class="el" href="AST_2Context_8h_source.html#l00042">mlir::pdll::ast::Context::getDiagEngine()</a>.</p>

</div>
</div>
<a id="a2b9ed7461f16d832b9a3d5c1c444ff7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9ed7461f16d832b9a3d5c1c444ff7e">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT  = Operation *&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ContainerOpT&gt; mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR). </p>
<p>This is useful, for example, to avoid copying some large resources into the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> and instead referencing the data directly from the input buffers. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00187">187</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

</div>
</div>
<a id="a006a32917056b7f14d65e9ea5cc08392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006a32917056b7f14d65e9ea5cc08392">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated filename and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. If <code>sourceFileLoc</code> is non-null, it is populated with a file location representing the start of the source file that is being parsed. </p>

<p class="definition">Definition at line <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00049">49</a> of file <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

</div>
</div>
<a id="a54875232f3a58ed939964dc275d1e36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54875232f3a58ed939964dc275d1e36f">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR). </p>
<p>This is useful, for example, to avoid copying some large resources into the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> and instead referencing the data directly from the input buffers. </p>

<p class="definition">Definition at line <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00082">82</a> of file <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

</div>
</div>
<a id="af9e06cd142a5019f145069349181e2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e06cd142a5019f145069349181e2e0">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT  = Operation *&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ContainerOpT&gt; mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An overload with a source manager that may have references taken during the parsing process, and whose lifetime can be freely extended (such that the source manager is not destroyed before the parsed IR). </p>
<p>This is useful, for example, to avoid copying some large resources into the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> and instead referencing the data directly from the input buffers. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00227">227</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

</div>
</div>
<a id="a13ad011b0b3c1635c410fe60bfd557c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ad011b0b3c1635c410fe60bfd557c2">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SourceMgr &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated filename using the provided SourceMgr and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. If <code>sourceFileLoc</code> is non-null, it is populated with a file location representing the start of the source file that is being parsed. </p>

<p class="definition">Definition at line <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00074">74</a> of file <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

</div>
</div>
<a id="a3f46d0b9658a27fa31f7ce98851ca7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f46d0b9658a27fa31f7ce98851ca7fe">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT  = Operation *&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ContainerOpT&gt; mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SourceMgr &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated filename using the provided SourceMgr. </p>
<p>If the source IR contained a single instance of <code>ContainerOpT</code>, it is returned. Otherwise, a new instance of <code>ContainerOpT</code> is constructed containing all of the parsed operations. If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context, and failure is returned. <code>ContainerOpT</code> is required to have a single region containing a single block, and must implement the <code>SingleBlockImplicitTerminator</code> trait. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00215">215</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

</div>
</div>
<a id="a731c3e653fe7b19e18f2ca619aa763fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731c3e653fe7b19e18f2ca619aa763fa">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT  = Operation *&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ContainerOpT&gt; mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated filename. </p>
<p>If the source IR contained a single instance of <code>ContainerOpT</code>, it is returned. Otherwise, a new instance of <code>ContainerOpT</code> is constructed containing all of the parsed operations. If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context, and failure is returned. <code>ContainerOpT</code> is required to have a single region containing a single block, and must implement the <code>SingleBlockImplicitTerminator</code> trait. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00201">201</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

</div>
</div>
<a id="a718d37dc4122f9a0851238684eb13a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718d37dc4122f9a0851238684eb13a39">&#9670;&nbsp;</a></span>parseSourceFileForTool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; mlir::parseSourceFileForTool </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>insertImplicitModule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated SourceMgr. </p>
<p>If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context. If 'insertImplicitModule' is true a top-level 'builtin.module' op will be inserted that contains the parsed IR, unless one exists already. </p>

<p class="definition">Definition at line <a class="el" href="ParseUtilities_8h_source.html#l00027">27</a> of file <a class="el" href="ParseUtilities_8h_source.html">ParseUtilities.h</a>.</p>

<p class="reference">References <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00020">parseSourceFile()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirReduceMain_8cpp_source.html#l00032">loadModule()</a>, and <a class="el" href="JitRunner_8cpp_source.html#l00134">parseMLIRInput()</a>.</p>

</div>
</div>
<a id="a80178c9e23c4fd7db357124cbe19651a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80178c9e23c4fd7db357124cbe19651a">&#9670;&nbsp;</a></span>parseSourceString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::parseSourceString </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>sourceStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>sourceName</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the IR string and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. <code>sourceName</code> is used as the file name of the source; any IR without locations will get a <code>FileLineColLoc</code> location with <code>sourceName</code> as the file name. If <code>sourceFileLoc</code> is non-null, it is populated with a file location representing the start of the source file that is being parsed. </p>

<p class="definition">Definition at line <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00090">90</a> of file <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_8cpp_source.html#l00493">mlirOperationCreateParse()</a>, and <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00245">parseSourceString()</a>.</p>

</div>
</div>
<a id="a1bfecc94be370f449013ec1f80818da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bfecc94be370f449013ec1f80818da8">&#9670;&nbsp;</a></span>parseSourceString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT  = Operation *&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ContainerOpT&gt; mlir::parseSourceString </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>sourceStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>sourceName</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the provided string containing MLIR. </p>
<p>If the source IR contained a single instance of <code>ContainerOpT</code>, it is returned. Otherwise, a new instance of <code>ContainerOpT</code> is constructed containing all of the parsed operations. If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context, and failure is returned. <code>ContainerOpT</code> is required to have a single region containing a single block, and must implement the <code>SingleBlockImplicitTerminator</code> trait. <code>sourceName</code> is used as the file name of the source; any IR without locations will get a <code>FileLineColLoc</code> location with <code>sourceName</code> as the file name. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00245">245</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="AsmState_8h_source.html#l00474">mlir::ParserConfig::getContext()</a>, and <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00090">parseSourceString()</a>.</p>

</div>
</div>
<a id="abab8375de28e1d1916659a658e7ad318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab8375de28e1d1916659a658e7ad318">&#9670;&nbsp;</a></span>parseType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::parseType </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>typeStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>numRead</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isKnownNullTerminated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses a single MLIR type to an MLIR context if it was valid. </p>
<p>If not, an error diagnostic is emitted to the context. If <code>numRead</code> is provided, it is set to the number of consumed characters on succesful parse. Otherwise, parsing fails if the entire string is not consumed. Some internal copying can be skipped if the source string is known to be null terminated. </p>

<p class="reference">Referenced by <a class="el" href="IR_8cpp_source.html#l01046">mlirTypeParseGet()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00090">parseExtTypeParams()</a>, and <a class="el" href="AsmPrinter_8cpp_source.html#l00077">mlir::AsmParser::parseTypeList()</a>.</p>

</div>
</div>
<a id="aee7856a3b7ff811204524bbc9959c8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7856a3b7ff811204524bbc9959c8c9">&#9670;&nbsp;</a></span>populateAffineToStdConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateAffineToStdConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the Affine dialect to the Standard dialect, in particular convert structured affine control flow into CFG branch-based control flow. </p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00528">528</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ad6a984b6da6b0bf690f727bd2e20dd31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a984b6da6b0bf690f727bd2e20dd31">&#9670;&nbsp;</a></span>populateAffineToVectorConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateAffineToVectorConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert vector-related Affine ops to the <a class="el" href="structVector.html">Vector</a> dialect. </p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00546">546</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a62a3e582e3af3713bff9b27e6a924cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a3e582e3af3713bff9b27e6a924cf3">&#9670;&nbsp;</a></span>populateAMDGPUToROCDLConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateAMDGPUToROCDLConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1amdgpu_1_1Chipset.html">amdgpu::Chipset</a>&#160;</td>
          <td class="paramname"><em>chipset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Note: The <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> target does not support the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> bfloat type at this time and so this function will add conversions to change all <code>bfloat</code> uses to <code>i16</code>. </p>

<p class="definition">Definition at line <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l01057">1057</a> of file <a class="el" href="AMDGPUToROCDL_8cpp_source.html">AMDGPUToROCDL.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="ae2932952899b602b89ed345a2fcaa317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2932952899b602b89ed345a2fcaa317">&#9670;&nbsp;</a></span>populateAMXLegalizeForLLVMExportPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateAMXLegalizeForLLVMExportPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to lower AMX ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00205">205</a> of file <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="a16ee9c5848e5edb1b56af1c937f9bb07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ee9c5848e5edb1b56af1c937f9bb07">&#9670;&nbsp;</a></span>populateAnyFunctionOpInterfaceTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateAnyFunctionOpInterfaceTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l02942">2942</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="adc52e1e0b9c1d604f07abeb1c33cd6eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc52e1e0b9c1d604f07abeb1c33cd6eb">&#9670;&nbsp;</a></span>populateArithToEmitCPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateArithToEmitCPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArithToEmitC_8cpp_source.html#l00742">742</a> of file <a class="el" href="ArithToEmitC_8cpp_source.html">ArithToEmitC.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="TypeConversions_8cpp_source.html#l00032">populateEmitCSizeTTypeConversions()</a>.</p>

</div>
</div>
<a id="afe2a83e0a6a467d1838b6dd39f65fb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2a83e0a6a467d1838b6dd39f65fb6d">&#9670;&nbsp;</a></span>populateArmSMEToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateArmSMEToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from the ArmSME dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVM_8cpp_source.html#l00975">975</a> of file <a class="el" href="ArmSMEToLLVM_8cpp_source.html">ArmSMEToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00167">mlir::TypeConverter::addConversion()</a>, and <a class="el" href="Dialect_2ArmSME_2IR_2Utils_8cpp_source.html#l00029">mlir::arm_sme::isValidSMETileVectorType()</a>.</p>

</div>
</div>
<a id="a726da53640cac549a26c8eb0396fb0e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726da53640cac549a26c8eb0396fb0e6">&#9670;&nbsp;</a></span>populateArmSMEToSCFConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateArmSMEToSCFConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the ArmSME dialect to SCF. </p>

<p class="definition">Definition at line <a class="el" href="ArmSMEToSCF_8cpp_source.html#l00392">392</a> of file <a class="el" href="ArmSMEToSCF_8cpp_source.html">ArmSMEToSCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ab4e0bc56426ca98e9bddc31e4ec82d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e0bc56426ca98e9bddc31e4ec82d35">&#9670;&nbsp;</a></span>populateArmSVELegalizeForLLVMExportPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateArmSVELegalizeForLLVMExportPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to lower ArmSVE ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>
<p>Populate the given list with patterns that convert from ArmSVE to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ArmSVE_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00202">202</a> of file <a class="el" href="ArmSVE_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00229">mlir::LLVMTypeConverter::getContext()</a>.</p>

</div>
</div>
<a id="aa9ea90e10c603e639fe6b6cbc9f24265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ea90e10c603e639fe6b6cbc9f24265">&#9670;&nbsp;</a></span>populateAsyncFuncToAsyncRuntimeConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateAsyncFuncToAsyncRuntimeConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00853">853</a> of file <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html">AsyncToAsyncRuntime.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00844">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a9659670212051d0795efd99cf38772ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9659670212051d0795efd99cf38772ed">&#9670;&nbsp;</a></span>populateAsyncStructuralTypeConversionsAndLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateAsyncStructuralTypeConversionsAndLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns for async structural type conversions. </p>
<p>A "structural" type conversion is one where the underlying ops are completely agnostic to the actual types involved and simply need to update their types. An example of this is async.execute &ndash; the async.execute op and the corresponding async.yield ops need to update their types accordingly to the <a class="el" href="classmlir_1_1TypeConverter.html" title="Type conversion class.">TypeConverter</a>, but otherwise don't care what type conversions are happening. </p>

<p class="definition">Definition at line <a class="el" href="AsyncToLLVM_8cpp_source.html#l01149">1149</a> of file <a class="el" href="AsyncToLLVM_8cpp_source.html">AsyncToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00167">mlir::TypeConverter::addConversion()</a>, <a class="el" href="DialectConversion_8h_source.html#l00844">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02683">mlir::TypeConverter::convertType()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">get()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="aacf0dbbf2d29448b8f9d7783f060d2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf0dbbf2d29448b8f9d7783f060d2aa">&#9670;&nbsp;</a></span>populateBranchOpInterfaceTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateBranchOpInterfaceTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(BranchOpInterface branchOp, int idx)&gt;&#160;</td>
          <td class="paramname"><em>shouldConvertBranchOperand</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a pattern to the given pattern list to rewrite branch operations to use operands that have been legalized by the conversion framework. </p>
<p>This can only be done if the branch operation implements the BranchOpInterface. Only needed for partial conversions.</p>
<p>If for some branch ops, we need to convert/legalize only a sub-set of the op's operands, such filtering behavior can be specified in shouldConvertBranchOperand. This callback should return true if branchOp's operand at index idx should be converted. </p>

</div>
</div>
<a id="a5c9ab382a920a458ce63cd4534dcb273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9ab382a920a458ce63cd4534dcb273">&#9670;&nbsp;</a></span>populateBuiltinFuncToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateBuiltinFuncToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating the builtin <code>func</code> op to the SPIR-V dialect. </p>
<p>These patterns do not handle shader interface/ABI; they convert function parameters to be of SPIR-V allowed types. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l01576">1576</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ab2564dc4e65f0be3ee7ceb257b620e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2564dc4e65f0be3ee7ceb257b620e80">&#9670;&nbsp;</a></span>populateCallOpTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateCallOpTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a pattern to the given pattern list to convert the operand and result types of a CallOp with the given type converter. </p>

<p class="definition">Definition at line <a class="el" href="FuncConversions_8cpp_source.html#l00046">46</a> of file <a class="el" href="FuncConversions_8cpp_source.html">FuncConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Arith_2Transforms_2EmulateNarrowType_8cpp_source.html#l00053">mlir::arith::populateArithNarrowTypeEmulationPatterns()</a>, and <a class="el" href="Arith_2Transforms_2EmulateWideInt_8cpp_source.html#l01124">mlir::arith::populateArithWideIntEmulationPatterns()</a>.</p>

</div>
</div>
<a id="a6657dab425bc62dafe146c813979dc2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6657dab425bc62dafe146c813979dc2b">&#9670;&nbsp;</a></span>populateCommutativityUtilsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateCommutativityUtilsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the commutativity utility patterns. </p>

<p class="definition">Definition at line <a class="el" href="CommutativityUtils_8cpp_source.html#l00312">312</a> of file <a class="el" href="CommutativityUtils_8cpp_source.html">CommutativityUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="af655a0b587c08462a963b23b6c656ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af655a0b587c08462a963b23b6c656ca5">&#9670;&nbsp;</a></span>populateComplexToLibmConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateComplexToLibmConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Complex to Libm calls. </p>

<p class="definition">Definition at line <a class="el" href="ComplexToLibm_8cpp_source.html#l00100">100</a> of file <a class="el" href="ComplexToLibm_8cpp_source.html">ComplexToLibm.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ab48ef5a36418902001d584219b110c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48ef5a36418902001d584219b110c25">&#9670;&nbsp;</a></span>populateComplexToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateComplexToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Complex to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ComplexToLLVM_8cpp_source.html#l00325">325</a> of file <a class="el" href="ComplexToLLVM_8cpp_source.html">ComplexToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="ac59f15aca5e1be49c639ee5b12e611f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59f15aca5e1be49c639ee5b12e611f2">&#9670;&nbsp;</a></span>populateComplexToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateComplexToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating Complex ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="ComplexToSPIRV_8cpp_source.html#l00105">105</a> of file <a class="el" href="ComplexToSPIRV_8cpp_source.html">ComplexToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a09be0ab6e12c19fefea09a6cb423c54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09be0ab6e12c19fefea09a6cb423c54d">&#9670;&nbsp;</a></span>populateComplexToStandardConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateComplexToStandardConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Complex to Standard. </p>

<p class="definition">Definition at line <a class="el" href="ComplexToStandard_8cpp_source.html#l01311">1311</a> of file <a class="el" href="ComplexToStandard_8cpp_source.html">ComplexToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a1bd3c63a12bd65ca2208a6353dbc9186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd3c63a12bd65ca2208a6353dbc9186">&#9670;&nbsp;</a></span>populateConversionTargetFromOperation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateConversionTargetFromOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively walk the IR and collect all dialects implementing the interface, and populate the conversion patterns. </p>

<p class="definition">Definition at line <a class="el" href="ToLLVMInterface_8cpp_source.html#l00016">16</a> of file <a class="el" href="ToLLVMInterface_8cpp_source.html">ToLLVMInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00793">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="a45f6113274b77800e7c3b22dd83771e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f6113274b77800e7c3b22dd83771e0">&#9670;&nbsp;</a></span>populateConvertArmNeon2dToIntrPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateConvertArmNeon2dToIntrPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns for the lowering of Arm NEON 2D ops to intrinsics. </p>
<p>See createConvertArmNeon2dToIntrPass. </p>

<p class="definition">Definition at line <a class="el" href="ArmNeon2dToIntr_8cpp_source.html#l00070">70</a> of file <a class="el" href="ArmNeon2dToIntr_8cpp_source.html">ArmNeon2dToIntr.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ae6e66615eb7e50976ed8c89b2bb05adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e66615eb7e50976ed8c89b2bb05adc">&#9670;&nbsp;</a></span>populateConvertShapeConstraintsConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateConvertShapeConstraintsConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertShapeConstraints_8cpp_source.html#l00044">44</a> of file <a class="el" href="ConvertShapeConstraints_8cpp_source.html">ConvertShapeConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a3f6c390c632d0dfd004c2b3459720f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6c390c632d0dfd004c2b3459720f45">&#9670;&nbsp;</a></span>populateDecomposeCallGraphTypesPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateDecomposeCallGraphTypesPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueDecomposer.html">ValueDecomposer</a> &amp;&#160;</td>
          <td class="paramname"><em>decomposer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the patterns needed to drive the conversion process for decomposing call graph types with the given <code><a class="el" href="classmlir_1_1ValueDecomposer.html" title="This class provides a hook that expands one Value into multiple Value&#39;s, with a TypeConverter-inspire...">ValueDecomposer</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="DecomposeCallGraphTypes_8cpp_source.html#l00190">190</a> of file <a class="el" href="DecomposeCallGraphTypes_8cpp_source.html">DecomposeCallGraphTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="a5f173d8afb5bfa9aca23651433c1c3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f173d8afb5bfa9aca23651433c1c3a1">&#9670;&nbsp;</a></span>populateEmitCSizeTTypeConversions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateEmitCSizeTTypeConversions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeConversions_8cpp_source.html#l00032">32</a> of file <a class="el" href="TypeConversions_8cpp_source.html">TypeConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00188">mlir::TypeConverter::addArgumentMaterialization()</a>, <a class="el" href="DialectConversion_8h_source.html#l00167">mlir::TypeConverter::addConversion()</a>, <a class="el" href="DialectConversion_8h_source.html#l00199">mlir::TypeConverter::addSourceMaterialization()</a>, <a class="el" href="DialectConversion_8h_source.html#l00208">mlir::TypeConverter::addTargetMaterialization()</a>, and <a class="el" href="BytecodeImplementation_8h_source.html#l00509">get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithToEmitC_8cpp_source.html#l00742">populateArithToEmitCPatterns()</a>.</p>

</div>
</div>
<a id="a4b6bf3e42ad0de0e8b55002b0ec60756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6bf3e42ad0de0e8b55002b0ec60756">&#9670;&nbsp;</a></span>populateExpandAcoshPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandAcoshPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00659">659</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00172">convertAcoshOp()</a>.</p>

</div>
</div>
<a id="ad90a77b67aaeebb4186d1c5906618ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90a77b67aaeebb4186d1c5906618ac4">&#9670;&nbsp;</a></span>populateExpandAsinhPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandAsinhPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00655">655</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00156">convertAsinhOp()</a>.</p>

</div>
</div>
<a id="ae611d296fc5c823d51a12603ec8f5145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae611d296fc5c823d51a12603ec8f5145">&#9670;&nbsp;</a></span>populateExpandAtanhPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandAtanhPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00663">663</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00188">convertAtanhOp()</a>.</p>

</div>
</div>
<a id="ac9d2110655a5086ecee6eac3405c8e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d2110655a5086ecee6eac3405c8e25">&#9670;&nbsp;</a></span>populateExpandCeilFPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandCeilFPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00671">671</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00248">convertCeilOp()</a>.</p>

</div>
</div>
<a id="a9d4e84ddbc3228f4fc5592ef3892171b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4e84ddbc3228f4fc5592ef3892171b">&#9670;&nbsp;</a></span>populateExpandCoshPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandCoshPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00643">643</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00088">convertCoshOp()</a>.</p>

</div>
</div>
<a id="ad882bbe96acab6803e205bac71f694fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad882bbe96acab6803e205bac71f694fe">&#9670;&nbsp;</a></span>populateExpandCtlzPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandCtlzPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00635">635</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00444">convertCtlzOp()</a>.</p>

</div>
</div>
<a id="ab7d2ac5ca6fe4c18adb5d7c32da4d914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d2ac5ca6fe4c18adb5d7c32da4d914">&#9670;&nbsp;</a></span>populateExpandExp2FPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandExp2FPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00675">675</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00372">convertExp2fOp()</a>.</p>

</div>
</div>
<a id="af4d52687fa07fb3c88f0d4f19471094a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d52687fa07fb3c88f0d4f19471094a">&#9670;&nbsp;</a></span>populateExpandFloorFPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandFloorFPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00691">691</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00223">convertFloorOp()</a>.</p>

</div>
</div>
<a id="a377a5d6d036008ba5e6416dc651dba6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377a5d6d036008ba5e6416dc651dba6e">&#9670;&nbsp;</a></span>populateExpandFmaFPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandFmaFPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00667">667</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00206">convertFmaFOp()</a>.</p>

</div>
</div>
<a id="a53afead42f935771f9b0216159302004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53afead42f935771f9b0216159302004">&#9670;&nbsp;</a></span>populateExpandFPowIPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandFPowIPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00683">683</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00271">convertFPowIOp()</a>.</p>

</div>
</div>
<a id="a760b455909b9e4e765071fa20fbd6aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760b455909b9e4e765071fa20fbd6aef">&#9670;&nbsp;</a></span>populateExpandPowFPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandPowFPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00679">679</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00340">convertPowfOp()</a>.</p>

</div>
</div>
<a id="ae53fc446b430869ef74c6382f675b1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53fc446b430869ef74c6382f675b1ba">&#9670;&nbsp;</a></span>populateExpandRoundEvenPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandRoundEvenPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00695">695</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00487">convertRoundEvenOp()</a>.</p>

</div>
</div>
<a id="aa7559586e5b98d3d19dd9b234ee93b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7559586e5b98d3d19dd9b234ee93b39">&#9670;&nbsp;</a></span>populateExpandRoundFPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandRoundFPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00687">687</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00384">convertRoundOp()</a>.</p>

</div>
</div>
<a id="a2721b4426839ca6cc30843669e9bea6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2721b4426839ca6cc30843669e9bea6e">&#9670;&nbsp;</a></span>populateExpandRsqrtPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandRsqrtPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00699">699</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00619">convertRsqrtOp()</a>.</p>

</div>
</div>
<a id="a06045eacdfd93245579eba16924771b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06045eacdfd93245579eba16924771b5">&#9670;&nbsp;</a></span>populateExpandSinhPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandSinhPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00639">639</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00072">convertSinhOp()</a>.</p>

</div>
</div>
<a id="a2fbc60c17752a76af9b0f28ffa36d4f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbc60c17752a76af9b0f28ffa36d4f9">&#9670;&nbsp;</a></span>populateExpandTanhPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandTanhPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00651">651</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00111">convertTanhOp()</a>.</p>

</div>
</div>
<a id="a84e85fbc0b8884dd2405be7b78b0c8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e85fbc0b8884dd2405be7b78b0c8e7">&#9670;&nbsp;</a></span>populateExpandTanPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateExpandTanPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandPatterns_8cpp_source.html#l00647">647</a> of file <a class="el" href="ExpandPatterns_8cpp_source.html">ExpandPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandPatterns_8cpp_source.html#l00144">convertTanOp()</a>.</p>

</div>
</div>
<a id="a600f4579b547917666e45a3c6b25f068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600f4579b547917666e45a3c6b25f068">&#9670;&nbsp;</a></span>populateFinalizeMemRefToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateFinalizeMemRefToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert memory-related operations from the MemRef dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect. </p>

<p class="definition">Definition at line <a class="el" href="MemRefToLLVM_8cpp_source.html#l01669">1669</a> of file <a class="el" href="MemRefToLLVM_8cpp_source.html">MemRefToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="classmlir_1_1LowerToLLVMOptions.html#a6845f4f8fe1f99c04c90cd621e87f4b4ac6cc2ffb89010532e07c736361b52e95">mlir::LowerToLLVMOptions::AlignedAlloc</a>, <a class="el" href="LoweringOptions_8h_source.html#l00049">mlir::LowerToLLVMOptions::allocLowering</a>, <a class="el" href="TypeConverter_8h_source.html#l00107">mlir::LLVMTypeConverter::getOptions()</a>, and <a class="el" href="classmlir_1_1LowerToLLVMOptions.html#a6845f4f8fe1f99c04c90cd621e87f4b4a1131a914388fac73e5f07b0ba0aad523">mlir::LowerToLLVMOptions::Malloc</a>.</p>

</div>
</div>
<a id="a00c79fe894fb6efe41ad37b5219a7b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c79fe894fb6efe41ad37b5219a7b8a">&#9670;&nbsp;</a></span>populateFuncOpVectorRewritePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateFuncOpVectorRewritePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l01581">1581</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a2a9dfe9dd627a507aeeb36b66e8bd9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9dfe9dd627a507aeeb36b66e8bd9fb">&#9670;&nbsp;</a></span>populateFunctionOpInterfaceTypeConversionPattern() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncOpT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateFunctionOpInterfaceTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00645">645</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02935">populateFunctionOpInterfaceTypeConversionPattern()</a>.</p>

</div>
</div>
<a id="a0f92d5c679a9826ca11750ddfc2eef2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f92d5c679a9826ca11750ddfc2eef2f">&#9670;&nbsp;</a></span>populateFunctionOpInterfaceTypeConversionPattern() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateFunctionOpInterfaceTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>functionLikeOpName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a pattern to the given pattern list to convert the signature of a FunctionOpInterface op with the given type converter. </p>
<p>This only supports ops which use FunctionType to represent their type. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l02935">2935</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8h_source.html#l00645">populateFunctionOpInterfaceTypeConversionPattern()</a>.</p>

</div>
</div>
<a id="a51559adfe7e07f3de36209e85d8d035d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51559adfe7e07f3de36209e85d8d035d">&#9670;&nbsp;</a></span>populateFuncToEmitCPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateFuncToEmitCPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FuncToEmitC_8cpp_source.html#l00115">115</a> of file <a class="el" href="FuncToEmitC_8cpp_source.html">FuncToEmitC.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ad28dd26d18b33cefbf959b5e703a5a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28dd26d18b33cefbf959b5e703a5a7e">&#9670;&nbsp;</a></span>populateFuncToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateFuncToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SymbolTable.html">SymbolTable</a> *&#160;</td>
          <td class="paramname"><em>symbolTable</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the patterns to convert from the Func dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>
<p>The conversion patterns capture the <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> and the <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a> by reference meaning the references have to remain alive during the entire pattern lifetime.</p>
<p>The <code>symbolTable</code> parameter can be used to speed up function lookups in the module. It's good to provide it, but only if we know that the patterns will be applied to a single module and the symbols referenced by the symbol table will not be removed and new symbols will not be added during the usage of the patterns. If provided, the lookups will have O(calls) cumulative runtime, otherwise O(calls * functions). The symbol table is currently not needed if <code>converter.getOptions().useBarePtrCallConv</code> is <code>true</code>, but it's not an error to provide it anyway. </p>

<p class="definition">Definition at line <a class="el" href="FuncToLLVM_8cpp_source.html#l00729">729</a> of file <a class="el" href="FuncToLLVM_8cpp_source.html">FuncToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00724">populateFuncToLLVMFuncOpConversionPattern()</a>.</p>

</div>
</div>
<a id="a2fbd8e05d2cb08371e1749e025f1eb8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbd8e05d2cb08371e1749e025f1eb8a">&#9670;&nbsp;</a></span>populateFuncToLLVMFuncOpConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateFuncToLLVMFuncOpConversionPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the default pattern to convert a FuncOp to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect. </p>
<p>If <code>emitCWrappers</code> is set, the pattern will also produce functions that pass memref descriptors by pointer-to-structure in addition to the default unpacked form. </p>

<p class="definition">Definition at line <a class="el" href="FuncToLLVM_8cpp_source.html#l00724">724</a> of file <a class="el" href="FuncToLLVM_8cpp_source.html">FuncToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FuncToLLVM_8cpp_source.html#l00729">populateFuncToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a62bf9368c68fc8006128f4ff2f1c5001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62bf9368c68fc8006128f4ff2f1c5001">&#9670;&nbsp;</a></span>populateFuncToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateFuncToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating Func ops to SPIR-V ops. </p>
<p>Also adds the patterns to legalize ops not directly translated to SPIR-V dialect. </p>

<p class="definition">Definition at line <a class="el" href="FuncToSPIRV_8cpp_source.html#l00090">90</a> of file <a class="el" href="FuncToSPIRV_8cpp_source.html">FuncToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a1da469115de233ce1c98f2ff68cd67be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da469115de233ce1c98f2ff68cd67be">&#9670;&nbsp;</a></span>populateFuncTypeConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateFuncTypeConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OneToNFuncConversions_8cpp_source.html#l00075">75</a> of file <a class="el" href="OneToNFuncConversions_8cpp_source.html">OneToNFuncConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a9701a7692a76e65edd69bd6f22156776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9701a7692a76e65edd69bd6f22156776">&#9670;&nbsp;</a></span>populateGpuAllReducePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuAllReducePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to rewrite all-reduce ops within the GPU dialect. </p>

<p class="definition">Definition at line <a class="el" href="AllReduceLowering_8cpp_source.html#l00379">379</a> of file <a class="el" href="AllReduceLowering_8cpp_source.html">AllReduceLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l00091">populateGpuRewritePatterns()</a>.</p>

</div>
</div>
<a id="ab57dcf9ca48416677b4f10118916da61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57dcf9ca48416677b4f10118916da61">&#9670;&nbsp;</a></span>populateGpuBreakDownSubgroupReducePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuBreakDownSubgroupReducePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxShuffleBitwidth</em> = <code>32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to break down subgroup_reduce ops into smaller ones supported by the target of <code>size &lt;= maxShuffleBitwidth</code>, where <code>size</code> is the subgroup_reduce value bitwidth. </p>

<p class="definition">Definition at line <a class="el" href="SubgroupReduceLowering_8cpp_source.html#l00367">367</a> of file <a class="el" href="SubgroupReduceLowering_8cpp_source.html">SubgroupReduceLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ac0ea23f9a62b16d2214c2e70f282c5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ea23f9a62b16d2214c2e70f282c5c1">&#9670;&nbsp;</a></span>populateGpuDecomposeMemrefsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuDecomposeMemrefsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to decompose memrefs ops. </p>

<p class="definition">Definition at line <a class="el" href="DecomposeMemRefs_8cpp_source.html#l00227">227</a> of file <a class="el" href="DecomposeMemRefs_8cpp_source.html">DecomposeMemRefs.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00931">mlir::RewritePatternSet::insert()</a>.</p>

</div>
</div>
<a id="af5eff4e5da432d2edf4f655585785460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5eff4e5da432d2edf4f655585785460">&#9670;&nbsp;</a></span>populateGpuEliminateBarriersPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuEliminateBarriersPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase barriers that do not enforce conflicting memory side effects. </p>

<p class="definition">Definition at line <a class="el" href="EliminateBarriers_8cpp_source.html#l00618">618</a> of file <a class="el" href="EliminateBarriers_8cpp_source.html">EliminateBarriers.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00931">mlir::RewritePatternSet::insert()</a>.</p>

</div>
</div>
<a id="a352a5fec8fc09705220c6ed268d15709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352a5fec8fc09705220c6ed268d15709">&#9670;&nbsp;</a></span>populateGpuGlobalIdPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuGlobalIdPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to rewrite GlobalIdOp op within the GPU dialect. </p>

<p class="definition">Definition at line <a class="el" href="GlobalIdRewriter_8cpp_source.html#l00043">43</a> of file <a class="el" href="GlobalIdRewriter_8cpp_source.html">GlobalIdRewriter.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l00091">populateGpuRewritePatterns()</a>.</p>

</div>
</div>
<a id="a7feacef2681f1cb159920f8a6ed188ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7feacef2681f1cb159920f8a6ed188ad">&#9670;&nbsp;</a></span>populateGpuLowerClusteredSubgroupReduceToShufflePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuLowerClusteredSubgroupReduceToShufflePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>subgroupSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>shuffleBitwidth</em> = <code>32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disjoint counterpart of <code>populateGpuLowerSubgroupReduceToShufflePatterns</code> that only matches <code>gpu.subgroup_reduce</code> ops with a <code>cluster_size</code>. </p>

<p class="definition">Definition at line <a class="el" href="SubgroupReduceLowering_8cpp_source.html#l00383">383</a> of file <a class="el" href="SubgroupReduceLowering_8cpp_source.html">SubgroupReduceLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a6c34168191ab5b4336dd5a832eab08e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c34168191ab5b4336dd5a832eab08e0">&#9670;&nbsp;</a></span>populateGpuLowerSubgroupReduceToShufflePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuLowerSubgroupReduceToShufflePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>subgroupSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>shuffleBitwidth</em> = <code>32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to lower <code>gpu.subgroup_reduce</code> into <code>gpu.shuffle</code> ops over <code>shuffleBitwidth</code> scalar types. </p>
<p>Assumes that the subgroup has <code>subgroupSize</code> lanes. Uses the butterfly shuffle algorithm.</p>
<p>The patterns populated by this function will ignore ops with the <code>cluster_size</code> attribute. <code>populateGpuLowerClusteredSubgroupReduceToShufflePatterns</code> is the opposite. </p>

<p class="definition">Definition at line <a class="el" href="SubgroupReduceLowering_8cpp_source.html#l00375">375</a> of file <a class="el" href="SubgroupReduceLowering_8cpp_source.html">SubgroupReduceLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a07982150babf881946ef966e4d7842e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07982150babf881946ef966e4d7842e0">&#9670;&nbsp;</a></span>populateGpuMemorySpaceAttributeConversions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuMemorySpaceAttributeConversions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates memory space attribute conversion rules for lowering gpu.address_space to integer values. </p>

<p class="definition">Definition at line <a class="el" href="GPUToLLVMSPV_8cpp_source.html#l00444">444</a> of file <a class="el" href="GPUToLLVMSPV_8cpp_source.html">GPUToLLVMSPV.cpp</a>.</p>

<p class="reference">References <a class="el" href="GPUOpsLowering_8cpp_source.html#l00785">populateGpuMemorySpaceAttributeConversions()</a>.</p>

</div>
</div>
<a id="a9a64af4be39c0a24e5cf7dd18d7f619f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a64af4be39c0a24e5cf7dd18d7f619f">&#9670;&nbsp;</a></span>populateGpuMemorySpaceAttributeConversions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuMemorySpaceAttributeConversions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a2cc8d74e74ce84649cf5ee6135cd09a4">MemorySpaceMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates memory space attribute conversion rules for lowering gpu.address_space to integer values. </p>

<p class="definition">Definition at line <a class="el" href="GPUOpsLowering_8cpp_source.html#l00785">785</a> of file <a class="el" href="GPUOpsLowering_8cpp_source.html">GPUOpsLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00236">mlir::TypeConverter::addTypeAttributeConversion()</a>, and <a class="el" href="GPUOpsLowering_8cpp_source.html#l00631">wrapNumericMemorySpace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUToLLVMSPV_8cpp_source.html#l00444">populateGpuMemorySpaceAttributeConversions()</a>.</p>

</div>
</div>
<a id="a4ae1d309360c9e54edaa39ddb48d3ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae1d309360c9e54edaa39ddb48d3ea1">&#9670;&nbsp;</a></span>populateGpuRewritePatterns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuRewritePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collect all patterns to rewrite ops within the GPU dialect. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l00091">91</a> of file <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

<p class="reference">References <a class="el" href="AllReduceLowering_8cpp_source.html#l00379">populateGpuAllReducePatterns()</a>, <a class="el" href="GlobalIdRewriter_8cpp_source.html#l00043">populateGpuGlobalIdPatterns()</a>, and <a class="el" href="ShuffleRewriter_8cpp_source.html#l00097">populateGpuShufflePatterns()</a>.</p>

</div>
</div>
<a id="a1cdef2da7628821e92464510d6556332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cdef2da7628821e92464510d6556332">&#9670;&nbsp;</a></span>populateGpuShufflePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuShufflePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to rewrite shuffle ops within the GPU dialect. </p>

<p class="definition">Definition at line <a class="el" href="ShuffleRewriter_8cpp_source.html#l00097">97</a> of file <a class="el" href="ShuffleRewriter_8cpp_source.html">ShuffleRewriter.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2GPU_2Transforms_2Passes_8h_source.html#l00091">populateGpuRewritePatterns()</a>.</p>

</div>
</div>
<a id="aff29070c95cb99fb8e350aa50259d4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff29070c95cb99fb8e350aa50259d4ff">&#9670;&nbsp;</a></span>populateGpuSubgroupReduceOpLoweringPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuSubgroupReduceOpLoweringPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate GpuSubgroupReduce pattern to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>. </p>
<p>It generates a specific nvvm op that is not available on every GPU. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00345">345</a> of file <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html">LowerGpuOpsToNVVMOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="ae64e765657131fd8d2a82f34f3ffcda7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64e765657131fd8d2a82f34f3ffcda7">&#9670;&nbsp;</a></span>populateGpuToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>kernelBarePtrCallConv</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> and populate converter for gpu types. </p>

<p class="definition">Definition at line <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l01724">1724</a> of file <a class="el" href="GPUToLLVMConversion_8cpp_source.html">GPUToLLVMConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="a15d3286013eff75a1bf8168b7f569308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d3286013eff75a1bf8168b7f569308">&#9670;&nbsp;</a></span>populateGpuToLLVMSPVConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuToLLVMSPVConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GPUToLLVMSPV_8cpp_source.html#l00415">415</a> of file <a class="el" href="GPUToLLVMSPV_8cpp_source.html">GPUToLLVMSPV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00229">mlir::LLVMTypeConverter::getContext()</a>.</p>

</div>
</div>
<a id="a1473896b49605a762f57d5c23466bca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1473896b49605a762f57d5c23466bca5">&#9670;&nbsp;</a></span>populateGpuToNVVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuToNVVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00350">350</a> of file <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html">LowerGpuOpsToNVVMOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">get()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00229">mlir::LLVMTypeConverter::getContext()</a>, <a class="el" href="NVVMDialect_8h_source.html#l00031">mlir::NVVM::kSharedMemoryAlignmentBit</a>, and <a class="el" href="BasicPtxBuilderInterface_8cpp_source.html#l00029">kSharedMemorySpace</a>.</p>

</div>
</div>
<a id="a49059e037af730c35fa299678d4fceab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49059e037af730c35fa299678d4fceab">&#9670;&nbsp;</a></span>populateGpuToROCDLConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuToROCDLConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1gpu_1_1amd.html#a8637afbd01b984be30dbd1cdb78ae45f">gpu::amd::Runtime</a>&#160;</td>
          <td class="paramname"><em>runtime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a>. </p>
<p>If <code>runtime</code> is Unknown, gpu.printf will not be lowered The resulting pattern set should be run over a gpu.module op </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00355">355</a> of file <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html">LowerGpuOpsToROCDLOps.cpp</a>.</p>

</div>
</div>
<a id="aa38792a214e31cdbf60cb4b3f859767d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38792a214e31cdbf60cb4b3f859767d">&#9670;&nbsp;</a></span>populateGPUToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGPUToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating GPU Ops to SPIR-V ops. </p>
<p>For a gpu.func to be converted, it should have a spirv.entry_point_abi attribute. </p>

<p class="definition">Definition at line <a class="el" href="GPUToSPIRV_8cpp_source.html#l00732">732</a> of file <a class="el" href="GPUToSPIRV_8cpp_source.html">GPUToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="af9d1cd185a90ffc654522763de411592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d1cd185a90ffc654522763de411592">&#9670;&nbsp;</a></span>populateGpuWMMAToNVVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuWMMAToNVVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert WMMA ops from GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="WmmaOpsToNvvm_8cpp_source.html#l00390">390</a> of file <a class="el" href="WmmaOpsToNvvm_8cpp_source.html">WmmaOpsToNvvm.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="a875bfbc01fd879b9697d28ef7856b4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875bfbc01fd879b9697d28ef7856b4f7">&#9670;&nbsp;</a></span>populateGpuWMMAToSPIRVCoopMatrixKHRConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuWMMAToSPIRVCoopMatrixKHRConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert WMMA ops from GPU dialect to SPIRV, using the KHR Cooperative Matrix extension. </p>

<p class="definition">Definition at line <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html#l00295">295</a> of file <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html">WmmaOpsToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="aeac82ef141dff9c99336d99169954925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac82ef141dff9c99336d99169954925">&#9670;&nbsp;</a></span>populateLowerForeachToSCFPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateLowerForeachToSCFPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensorRewriting_8cpp_source.html#l01593">1593</a> of file <a class="el" href="SparseTensorRewriting_8cpp_source.html">SparseTensorRewriting.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a8f175c99ce23bb21e02b216876b31171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f175c99ce23bb21e02b216876b31171">&#9670;&nbsp;</a></span>populateLowerSparseIterationToSCFPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateLowerSparseIterationToSCFPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseIterationToScf_8cpp_source.html#l00436">436</a> of file <a class="el" href="SparseIterationToScf_8cpp_source.html">SparseIterationToScf.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a9848c16612b09d5d062b7e49564e8659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9848c16612b09d5d062b7e49564e8659">&#9670;&nbsp;</a></span>populateLowerSparseOpsToForeachPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateLowerSparseOpsToForeachPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableRT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableConvert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensorRewriting_8cpp_source.html#l01577">1577</a> of file <a class="el" href="SparseTensorRewriting_8cpp_source.html">SparseTensorRewriting.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a747b91bacc09bde115c3e891deb5ebe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747b91bacc09bde115c3e891deb5ebe5">&#9670;&nbsp;</a></span>populateMathAlgebraicSimplificationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateMathAlgebraicSimplificationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AlgebraicSimplification_8cpp_source.html#l00224">224</a> of file <a class="el" href="AlgebraicSimplification_8cpp_source.html">AlgebraicSimplification.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ada84ecb306c38b4e2a547962acc98dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada84ecb306c38b4e2a547962acc98dfd">&#9670;&nbsp;</a></span>populateMathPolynomialApproximationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateMathPolynomialApproximationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1MathPolynomialApproximationOptions.html">MathPolynomialApproximationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PolynomialApproximation_8cpp_source.html#l01673">1673</a> of file <a class="el" href="PolynomialApproximation_8cpp_source.html">PolynomialApproximation.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a7d02c131fc732f88a4f4bbd96470b159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d02c131fc732f88a4f4bbd96470b159">&#9670;&nbsp;</a></span>populateMathToLibmConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateMathToLibmConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Math to Libm calls. </p>
<p>If log1pBenefit is present, use it instead of benefit for the Log1p op. </p>

<p class="definition">Definition at line <a class="el" href="MathToLibm_8cpp_source.html#l00162">162</a> of file <a class="el" href="MathToLibm_8cpp_source.html">MathToLibm.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a2210541bcd8d4217fe2fc09cf044495c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2210541bcd8d4217fe2fc09cf044495c">&#9670;&nbsp;</a></span>populateMathToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateMathToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>approximateLog1p</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathToLLVM_8cpp_source.html#l00301">301</a> of file <a class="el" href="MathToLLVM_8cpp_source.html">MathToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="afcb1e6c26cd3f8d24c93a96dfd84ee6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb1e6c26cd3f8d24c93a96dfd84ee6d">&#9670;&nbsp;</a></span>populateMathToROCDLConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateMathToROCDLConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Math to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> calls. </p>

<p class="definition">Definition at line <a class="el" href="MathToROCDL_8cpp_source.html#l00048">48</a> of file <a class="el" href="MathToROCDL_8cpp_source.html">MathToROCDL.cpp</a>.</p>

</div>
</div>
<a id="a6c5cdff8faeb322f48015571f5f4aae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5cdff8faeb322f48015571f5f4aae2">&#9670;&nbsp;</a></span>populateMathToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateMathToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating Math ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="MathToSPIRV_8cpp_source.html#l00465">465</a> of file <a class="el" href="MathToSPIRV_8cpp_source.html">MathToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a99266ebe2b3be9d39e425ef361013656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99266ebe2b3be9d39e425ef361013656">&#9670;&nbsp;</a></span>populateMemRefToEmitCConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateMemRefToEmitCConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefToEmitC_8cpp_source.html#l00182">182</a> of file <a class="el" href="MemRefToEmitC_8cpp_source.html">MemRefToEmitC.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a58637750147b089cca80eec8603b220f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58637750147b089cca80eec8603b220f">&#9670;&nbsp;</a></span>populateMemRefToEmitCTypeConversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateMemRefToEmitCTypeConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefToEmitC_8cpp_source.html#l00166">166</a> of file <a class="el" href="MemRefToEmitC_8cpp_source.html">MemRefToEmitC.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00167">mlir::TypeConverter::addConversion()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02683">mlir::TypeConverter::convertType()</a>, and <a class="el" href="BytecodeImplementation_8h_source.html#l00509">get()</a>.</p>

</div>
</div>
<a id="ad19383f60ade82f3ca68e0cabda60d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19383f60ade82f3ca68e0cabda60d42">&#9670;&nbsp;</a></span>populateMemRefToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateMemRefToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating MemRef ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="MemRefToSPIRV_8cpp_source.html#l00929">929</a> of file <a class="el" href="MemRefToSPIRV_8cpp_source.html">MemRefToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ab2ca5cbf58aa081676683b5b8111cc50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ca5cbf58aa081676683b5b8111cc50">&#9670;&nbsp;</a></span>populateMMAToSPIRVCoopMatrixTypeConversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateMMAToSPIRVCoopMatrixTypeConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">mlir::SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds <code>MMAMatrixType</code> conversions to SPIR-V cooperative matrix KHR type conversion to the type converter. </p>

<p class="definition">Definition at line <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html#l00307">307</a> of file <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html">WmmaOpsToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00167">mlir::TypeConverter::addConversion()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">get()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00140">mlir::gpu::MMAMatrixType::getElementType()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00142">mlir::gpu::MMAMatrixType::getOperand()</a>, and <a class="el" href="GPUDialect_8cpp_source.html#l00136">mlir::gpu::MMAMatrixType::getShape()</a>.</p>

</div>
</div>
<a id="a77bc264eaa4a13001177aa530bcd2313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77bc264eaa4a13001177aa530bcd2313">&#9670;&nbsp;</a></span>populateNVGPUToNVVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateNVGPUToNVVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NVGPUToNVVM_8cpp_source.html#l01704">1704</a> of file <a class="el" href="NVGPUToNVVM_8cpp_source.html">NVGPUToNVVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="a35eb3329af0ae57e8a63db9abeaf88e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35eb3329af0ae57e8a63db9abeaf88e5">&#9670;&nbsp;</a></span>populateNVVMToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateNVVMToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NVVMToLLVM_8cpp_source.html#l00111">111</a> of file <a class="el" href="NVVMToLLVM_8cpp_source.html">NVVMToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a78dbe1e49d3c836bbd8af92cbdfd1cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78dbe1e49d3c836bbd8af92cbdfd1cdd">&#9670;&nbsp;</a></span>populateOneToNFunctionOpInterfaceTypeConversionPattern() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncOpT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateOneToNFunctionOpInterfaceTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OneToNTypeConversion_8h_source.html#l00309">309</a> of file <a class="el" href="OneToNTypeConversion_8h_source.html">OneToNTypeConversion.h</a>.</p>

<p class="reference">References <a class="el" href="Transforms_2Utils_2OneToNTypeConversion_8cpp_source.html#l00468">populateOneToNFunctionOpInterfaceTypeConversionPattern()</a>.</p>

</div>
</div>
<a id="aea5920e66163417e3c13208bcdcd8a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea5920e66163417e3c13208bcdcd8a47">&#9670;&nbsp;</a></span>populateOneToNFunctionOpInterfaceTypeConversionPattern() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateOneToNFunctionOpInterfaceTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>functionLikeOpName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a pattern to the given pattern list to convert the signature of a FunctionOpInterface op with the given type converter. </p>
<p>This only supports ops which use FunctionType to represent their type. This is intended to be used with the 1:N dialect conversion. </p>

<p class="definition">Definition at line <a class="el" href="Transforms_2Utils_2OneToNTypeConversion_8cpp_source.html#l00468">468</a> of file <a class="el" href="Transforms_2Utils_2OneToNTypeConversion_8cpp_source.html">OneToNTypeConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneToNTypeConversion_8h_source.html#l00309">populateOneToNFunctionOpInterfaceTypeConversionPattern()</a>.</p>

</div>
</div>
<a id="a725b3caed685f9615fba2027124f359f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725b3caed685f9615fba2027124f359f">&#9670;&nbsp;</a></span>populateOpenACCToSCFConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateOpenACCToSCFConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the patterns to convert from the OpenACC dialect to OpenACC with SCF dialect. </p>

<p class="definition">Definition at line <a class="el" href="OpenACCToSCF_8cpp_source.html#l00061">61</a> of file <a class="el" href="OpenACCToSCF_8cpp_source.html">OpenACCToSCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a1111bfc29c10d7cd2ebba33996e38509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1111bfc29c10d7cd2ebba33996e38509">&#9670;&nbsp;</a></span>populateOpenMPToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateOpenMPToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from OpenMP to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00250">250</a> of file <a class="el" href="OpenMPToLLVM_8cpp_source.html">OpenMPToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00167">mlir::TypeConverter::addConversion()</a>.</p>

</div>
</div>
<a id="a1727b1783cbf671c6ee60cc2a5c2f132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1727b1783cbf671c6ee60cc2a5c2f132">&#9670;&nbsp;</a></span>populateParallelLoopToGPUPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateParallelLoopToGPUPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the conversion pattern from <code>scf.parallel</code> to <code>gpu.launch</code> to the provided pattern list. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPU_8cpp_source.html#l00676">676</a> of file <a class="el" href="SCFToGPU_8cpp_source.html">SCFToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a3114521ec355e66601d128ab0cb9426f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3114521ec355e66601d128ab0cb9426f">&#9670;&nbsp;</a></span>populatePolynomialApproximateErfPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populatePolynomialApproximateErfPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PolynomialApproximation_8cpp_source.html#l01668">1668</a> of file <a class="el" href="PolynomialApproximation_8cpp_source.html">PolynomialApproximation.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a350315b238bcca2eb1b91364e55deaf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350315b238bcca2eb1b91364e55deaf4">&#9670;&nbsp;</a></span>populatePolynomialApproximateTanhPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populatePolynomialApproximateTanhPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PolynomialApproximation_8cpp_source.html#l01663">1663</a> of file <a class="el" href="PolynomialApproximation_8cpp_source.html">PolynomialApproximation.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a10daa5ecf515d29ea9079368f9b9b08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10daa5ecf515d29ea9079368f9b9b08d">&#9670;&nbsp;</a></span>populatePrepareVectorToMMAPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populatePrepareVectorToMMAPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useNvGpu</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to transform vector ops into a canonical form to convert to MMA matrix operations. </p>
<p>If <code>useNvGpu</code> is true, then the patterns will populated will prepare for conversion to <code>nvgpu</code> mma operations rather than the <code>gpu</code> dialect WMMA operations. </p>

<p class="definition">Definition at line <a class="el" href="VectorToGPU_8cpp_source.html#l01229">1229</a> of file <a class="el" href="VectorToGPU_8cpp_source.html">VectorToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02084">mlir::vector::populateVectorContractCanonicalizeMatmulToMMT()</a>.</p>

</div>
</div>
<a id="a667f68e2860101c8caec8f46732e316e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667f68e2860101c8caec8f46732e316e">&#9670;&nbsp;</a></span>populatePreSparsificationRewriting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populatePreSparsificationRewriting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensorRewriting_8cpp_source.html#l01570">1570</a> of file <a class="el" href="SparseTensorRewriting_8cpp_source.html">SparseTensorRewriting.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ac260b877914dd5ce7bf80eb50ff87a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac260b877914dd5ce7bf80eb50ff87a4b">&#9670;&nbsp;</a></span>populateRemoveShapeConstraintsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateRemoveShapeConstraintsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RemoveShapeConstraints_8cpp_source.html#l00064">64</a> of file <a class="el" href="RemoveShapeConstraints_8cpp_source.html">RemoveShapeConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="adb212d1d50001fc703faf9a1575ccd2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb212d1d50001fc703faf9a1575ccd2a">&#9670;&nbsp;</a></span>populateReturnOpTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateReturnOpTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a pattern to the given pattern list to rewrite <code>return</code> ops to use operands that have been legalized by the conversion framework. </p>

<p class="definition">Definition at line <a class="el" href="FuncConversions_8cpp_source.html#l00140">140</a> of file <a class="el" href="FuncConversions_8cpp_source.html">FuncConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Arith_2Transforms_2EmulateNarrowType_8cpp_source.html#l00053">mlir::arith::populateArithNarrowTypeEmulationPatterns()</a>, and <a class="el" href="Arith_2Transforms_2EmulateWideInt_8cpp_source.html#l01124">mlir::arith::populateArithWideIntEmulationPatterns()</a>.</p>

</div>
</div>
<a id="a2162d2bc9640db32d4ae88c12ef3bd23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2162d2bc9640db32d4ae88c12ef3bd23">&#9670;&nbsp;</a></span>populateReturnOpVectorRewritePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateReturnOpVectorRewritePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l01585">1585</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a9fc663ae01ea2b6384c3f6ce299be3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc663ae01ea2b6384c3f6ce299be3b0">&#9670;&nbsp;</a></span>populateSCFToControlFlowConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSCFToControlFlowConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert SCF operations to CFG branch-based operations within the ControlFlow dialect. </p>

<p class="definition">Definition at line <a class="el" href="SCFToControlFlow_8cpp_source.html#l00708">708</a> of file <a class="el" href="SCFToControlFlow_8cpp_source.html">SCFToControlFlow.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a558ec60b7aaa291cc8bc55442f4e18c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558ec60b7aaa291cc8bc55442f4e18c6">&#9670;&nbsp;</a></span>populateSCFToEmitCConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSCFToEmitCConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert SCF operations to the EmitC dialect. </p>

<p class="definition">Definition at line <a class="el" href="SCFToEmitC_8cpp_source.html#l00245">245</a> of file <a class="el" href="SCFToEmitC_8cpp_source.html">SCFToEmitC.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a8ca1349510877edff1b6a3fe7249226c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca1349510877edff1b6a3fe7249226c">&#9670;&nbsp;</a></span>populateSCFToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSCFToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ScfToSPIRVContext.html">ScfToSPIRVContext</a> &amp;&#160;</td>
          <td class="paramname"><em>scfToSPIRVContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects a set of patterns to lower from scf.for, scf.if, and loop.terminator to CFG operations within the SPIR-V dialect. </p>

<p class="definition">Definition at line <a class="el" href="SCFToSPIRV_8cpp_source.html#l00439">439</a> of file <a class="el" href="SCFToSPIRV_8cpp_source.html">SCFToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="SCFToSPIRV_8h_source.html#l00029">mlir::ScfToSPIRVContext::getImpl()</a>.</p>

</div>
</div>
<a id="a068b739b7424900d4d98c15c81e4609e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068b739b7424900d4d98c15c81e4609e">&#9670;&nbsp;</a></span>populateShapeRewritePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateShapeRewritePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects a set of patterns to rewrite ops within the Shape dialect. </p>

<p class="definition">Definition at line <a class="el" href="ShapeToShapeLowering_8cpp_source.html#l00081">81</a> of file <a class="el" href="ShapeToShapeLowering_8cpp_source.html">ShapeToShapeLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a9d32c331310df6a35924ac128fa789f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d32c331310df6a35924ac128fa789f3">&#9670;&nbsp;</a></span>populateShapeToStandardConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateShapeToStandardConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ShapeToStandard_8cpp_source.html#l00708">708</a> of file <a class="el" href="ShapeToStandard_8cpp_source.html">ShapeToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="aacaa4c3b727375b5ba2dc196a70a42bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacaa4c3b727375b5ba2dc196a70a42bb">&#9670;&nbsp;</a></span>populateSparseAssembler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSparseAssembler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseAssembler_8cpp_source.html#l00250">250</a> of file <a class="el" href="SparseAssembler_8cpp_source.html">SparseAssembler.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a6168f425252f728e066433be9ee022b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6168f425252f728e066433be9ee022b2">&#9670;&nbsp;</a></span>populateSparseBufferRewriting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSparseBufferRewriting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableBufferInitialization</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseBufferRewriting_8cpp_source.html#l01425">1425</a> of file <a class="el" href="SparseBufferRewriting_8cpp_source.html">SparseBufferRewriting.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ad48873e0e6f944a5579b28be3cc1c944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48873e0e6f944a5579b28be3cc1c944">&#9670;&nbsp;</a></span>populateSparseGPUCodegenPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSparseGPUCodegenPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseGPUCodegen_8cpp_source.html#l01325">1325</a> of file <a class="el" href="SparseGPUCodegen_8cpp_source.html">SparseGPUCodegen.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a41ac451ba0b1c3393df013233d3c93c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ac451ba0b1c3393df013233d3c93c2">&#9670;&nbsp;</a></span>populateSparseGPULibgenPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSparseGPULibgenPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableRT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseGPUCodegen_8cpp_source.html#l01330">1330</a> of file <a class="el" href="SparseGPUCodegen_8cpp_source.html">SparseGPUCodegen.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a3deec09ef78fca6282e45bfd4649d7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3deec09ef78fca6282e45bfd4649d7e7">&#9670;&nbsp;</a></span>populateSparseReinterpretMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSparseReinterpretMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a855a7d93430958efaaf3a6f69e3dac1c">ReinterpretMapScope</a>&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseReinterpretMap_8cpp_source.html#l00790">790</a> of file <a class="el" href="SparseReinterpretMap_8cpp_source.html">SparseReinterpretMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>, <a class="el" href="namespacemlir.html#a855a7d93430958efaaf3a6f69e3dac1ca34bdbffdb1c0e1b603f58fc0d49548b6">kAll</a>, <a class="el" href="namespacemlir.html#a855a7d93430958efaaf3a6f69e3dac1ca301ae8b60ff2983a1038cc11eb53089b">kExceptGeneric</a>, and <a class="el" href="namespacemlir.html#a855a7d93430958efaaf3a6f69e3dac1cafb396f5b35d10c817b375435e3432d4b">kGenericOnly</a>.</p>

</div>
</div>
<a id="a271ea308903cf0d605df0c3ba5f13b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271ea308903cf0d605df0c3ba5f13b6c">&#9670;&nbsp;</a></span>populateSparseTensorCodegenPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSparseTensorCodegenPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createSparseDeallocs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableBufferInitialization</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up sparse tensor codegen rules. </p>
<p>Populates the given patterns list with conversion rules required for the sparsification of linear algebra operations. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorCodegen_8cpp_source.html#l01606">1606</a> of file <a class="el" href="SparseTensorCodegen_8cpp_source.html">SparseTensorCodegen.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a5a109a00c2dac890cb8db767e9a9982d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a109a00c2dac890cb8db767e9a9982d">&#9670;&nbsp;</a></span>populateSparseTensorConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSparseTensorConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up sparse tensor conversion rules. </p>
<p>Populates the given patterns list with conversion rules required for the sparsification of linear algebra operations. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorConversion_8cpp_source.html#l00912">912</a> of file <a class="el" href="SparseTensorConversion_8cpp_source.html">SparseTensorConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a76dc06de29760922469c1e4bd10a62c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76dc06de29760922469c1e4bd10a62c9">&#9670;&nbsp;</a></span>populateSparseVectorizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSparseVectorizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>vectorLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableVLAVectorization</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableSIMDIndex32</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the given patterns list with vectorization rules. </p>

<p class="definition">Definition at line <a class="el" href="SparseVectorization_8cpp_source.html#l00662">662</a> of file <a class="el" href="SparseVectorization_8cpp_source.html">SparseVectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a86f7f8933f0baf6ebeddfdc698327c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f7f8933f0baf6ebeddfdc698327c31">&#9670;&nbsp;</a></span>populateSparsificationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSparsificationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up sparsification rewriting rules with the given options. </p>
<p>Populates the given patterns list with rewriting rules required for the sparsification of linear algebra operations. </p>

<p class="definition">Definition at line <a class="el" href="Sparsification_8cpp_source.html#l01486">1486</a> of file <a class="el" href="Sparsification_8cpp_source.html">Sparsification.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="aa47a30210dfc5deae1daa2e2c8840d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47a30210dfc5deae1daa2e2c8840d8f">&#9670;&nbsp;</a></span>populateSPIRVToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSPIRVToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spirv::ClientAPI&#160;</td>
          <td class="paramname"><em>clientAPIForAddressSpaceMapping</em> = <code>spirv::ClientAPI::Unknown</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the given list with patterns that convert from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01539">1539</a> of file <a class="el" href="SPIRVToLLVM_8cpp_source.html">SPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a6ee4e0b9121971b2ca8fcc16640d457f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee4e0b9121971b2ca8fcc16640d457f">&#9670;&nbsp;</a></span>populateSPIRVToLLVMFunctionConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSPIRVToLLVMFunctionConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the given list with patterns for function conversion from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01657">1657</a> of file <a class="el" href="SPIRVToLLVM_8cpp_source.html">SPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="abe47840c56acca273d219c5fc82b179d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe47840c56acca273d219c5fc82b179d">&#9670;&nbsp;</a></span>populateSPIRVToLLVMModuleConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSPIRVToLLVMModuleConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the given patterns for module conversion from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01662">1662</a> of file <a class="el" href="SPIRVToLLVM_8cpp_source.html">SPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a35333950f5d30c0990ebca7da9dd882c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35333950f5d30c0990ebca7da9dd882c">&#9670;&nbsp;</a></span>populateSPIRVToLLVMTypeConversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateSPIRVToLLVMTypeConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spirv::ClientAPI&#160;</td>
          <td class="paramname"><em>clientAPIForAddressSpaceMapping</em> = <code>spirv::ClientAPI::Unknown</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates type conversions with additional SPIR-V types. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01523">1523</a> of file <a class="el" href="SPIRVToLLVM_8cpp_source.html">SPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00167">mlir::TypeConverter::addConversion()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00258">convertArrayType()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00273">convertPointerType()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00284">convertRuntimeArrayType()</a>, and <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00294">convertStructType()</a>.</p>

</div>
</div>
<a id="ab05749dd321afd1862ad40e29349e733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05749dd321afd1862ad40e29349e733">&#9670;&nbsp;</a></span>populateStageSparseOperationsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateStageSparseOperationsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up StageSparseOperation rewriting rules. </p>

<p class="definition">Definition at line <a class="el" href="StageSparseOperations_8cpp_source.html#l00071">71</a> of file <a class="el" href="StageSparseOperations_8cpp_source.html">StageSparseOperations.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a07d707e1aa02507e261dec9e171b37d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d707e1aa02507e261dec9e171b37d1">&#9670;&nbsp;</a></span>populateStorageSpecifierToLLVMPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateStorageSpecifierToLLVMPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseStorageSpecifierToLLVM_8cpp_source.html#l00353">353</a> of file <a class="el" href="SparseStorageSpecifierToLLVM_8cpp_source.html">SparseStorageSpecifierToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a5b8ecf548ab4c5b21eddf5ee62e618e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8ecf548ab4c5b21eddf5ee62e618e8">&#9670;&nbsp;</a></span>populateTensorToLinalgPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateTensorToLinalgPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating tensor ops to Linalg ops. </p>

<p class="definition">Definition at line <a class="el" href="TensorToLinalg_8cpp_source.html#l00027">27</a> of file <a class="el" href="TensorToLinalg_8cpp_source.html">TensorToLinalg.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a0ba8a125094bd28e1f1db4858eb5ff52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba8a125094bd28e1f1db4858eb5ff52">&#9670;&nbsp;</a></span>populateTensorToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateTensorToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>byteCountThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating tensor ops to SPIR-V ops. </p>
<p>Note: Normally tensors will be stored in buffers before converting to SPIR-V, given that is how a large amount of data is sent to the GPU. However, SPIR-V supports converting from tensors directly too. This is for the cases where the tensor just contains a small amount of elements and it makes sense to directly inline them as a small data array in the shader. To handle this, internally the conversion might create new local variables. SPIR-V consumers in GPU drivers may or may not optimize that away. So this has implications over register pressure. Therefore, a threshold is used to control when the patterns should kick in. </p>

<p class="definition">Definition at line <a class="el" href="TensorToSPIRV_8cpp_source.html#l00106">106</a> of file <a class="el" href="TensorToSPIRV_8cpp_source.html">TensorToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a54519be832df231094e4e22a067bde19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54519be832df231094e4e22a067bde19">&#9670;&nbsp;</a></span>populateUpliftToFMAPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateUpliftToFMAPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="UpliftToFMA_8cpp_source.html#l00077">77</a> of file <a class="el" href="UpliftToFMA_8cpp_source.html">UpliftToFMA.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00931">mlir::RewritePatternSet::insert()</a>.</p>

</div>
</div>
<a id="a7fdbf57d9d955aea59286a07c5c3c03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdbf57d9d955aea59286a07c5c3c03a">&#9670;&nbsp;</a></span>populateVectorReductionToSPIRVDotProductPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateVectorReductionToSPIRVDotProductPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns to convert vector reduction of the form: </p>
<div class="fragment"><div class="line">vector.reduction &lt;add&gt;, (muli (ext %lhs), (ext %rhs)), [%acc]</div>
</div><!-- fragment --><p>to SPIR-V integer dot product ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSPIRV_8cpp_source.html#l00976">976</a> of file <a class="el" href="VectorToSPIRV_8cpp_source.html">VectorToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ae512bcd2d0e2cc4f8ddb82e2922ccc8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae512bcd2d0e2cc4f8ddb82e2922ccc8b">&#9670;&nbsp;</a></span>populateVectorToArmSMEPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateVectorToArmSMEPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to lower <a class="el" href="structVector.html">Vector</a> ops to ArmSME ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="VectorToArmSME_8cpp_source.html#l00795">795</a> of file <a class="el" href="VectorToArmSME_8cpp_source.html">VectorToArmSME.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="ac0e959362ad476f9889cf483664e0789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e959362ad476f9889cf483664e0789">&#9670;&nbsp;</a></span>populateVectorToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateVectorToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reassociateFPReductions</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force32BitVectorIndices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the <a class="el" href="structVector.html">Vector</a> dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>
<p>Populate the given list with patterns that convert from <a class="el" href="structVector.html">Vector</a> to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l01883">1883</a> of file <a class="el" href="ConvertVectorToLLVM_8cpp_source.html">ConvertVectorToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="TypeConverter_8h_source.html#l00105">mlir::LLVMTypeConverter::getDialect()</a>, <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00347">mlir::vector::populateVectorInsertExtractStridedSliceTransforms()</a>, and <a class="el" href="LowerVectorTransfer_8cpp_source.html#l00663">mlir::vector::populateVectorTransferLoweringPatterns()</a>.</p>

</div>
</div>
<a id="aeb11dbe1feb192f2f3de9500e820c7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb11dbe1feb192f2f3de9500e820c7a8">&#9670;&nbsp;</a></span>populateVectorToLLVMMatrixConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateVectorToLLVMMatrixConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from <a class="el" href="structVector.html">Vector</a> contractions to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> Matrix Intrinsics. </p>
<p>To lower to assembly, the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> flag -lower-matrix-intrinsics will be needed when invoking <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l01911">1911</a> of file <a class="el" href="ConvertVectorToLLVM_8cpp_source.html">ConvertVectorToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="a96c6c9c53e199da9b2def6f5e62eec02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c6c9c53e199da9b2def6f5e62eec02">&#9670;&nbsp;</a></span>populateVectorToSCFConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateVectorToSCFConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the <a class="el" href="structVector.html">Vector</a> dialect to SCF + func. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSCF_8cpp_source.html#l01684">1684</a> of file <a class="el" href="VectorToSCF_8cpp_source.html">VectorToSCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="aff2bafba6c8ae1b85a1abadc386f22a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2bafba6c8ae1b85a1abadc386f22a3">&#9670;&nbsp;</a></span>populateVectorToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateVectorToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating <a class="el" href="structVector.html">Vector</a> Ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSPIRV_8cpp_source.html#l00953">953</a> of file <a class="el" href="VectorToSPIRV_8cpp_source.html">VectorToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a94a6fd23ac57182bebb5185f7013e2fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a6fd23ac57182bebb5185f7013e2fa">&#9670;&nbsp;</a></span>populateVectorToXeGPUConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateVectorToXeGPUConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the vector to XeGPU ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorToXeGPU_8cpp_source.html#l00323">323</a> of file <a class="el" href="VectorToXeGPU_8cpp_source.html">VectorToXeGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a05930f6194dee5366651710de8da45c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05930f6194dee5366651710de8da45c9">&#9670;&nbsp;</a></span>populateX86VectorLegalizeForLLVMExportPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateX86VectorLegalizeForLLVMExportPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to lower X86Vector ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>
<p>Populate the given list with patterns that convert from X86Vector to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="X86Vector_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00161">161</a> of file <a class="el" href="X86Vector_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="a34ab168056505b09c113dda01ee42d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ab168056505b09c113dda01ee42d5e">&#9670;&nbsp;</a></span>printDimensionList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::printDimensionList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>dimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l04021">4021</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

</div>
</div>
<a id="a568cd5e110b674070bdd28be46158fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568cd5e110b674070bdd28be46158fce">&#9670;&nbsp;</a></span>printDynamicIndexList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::printDynamicIndexList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>integers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>scalables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>valueTypes</em> = <code><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a>&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Printer hook for custom directive in assemblyFormat. </p>
<p>custom&lt;DynamicIndexList&gt;($values, $integers) custom&lt;DynamicIndexList&gt;($values, $integers, type($values))</p>
<p>where <code>values</code> is of ODS type <code>Variadic&lt;*&gt;</code> and <code>integers</code> is of ODS type <code>I64ArrayAttr</code>. Prints a list with either (1) the static integer value in <code>integers</code> is <code>kDynamic</code> or (2) the next value otherwise. If <code>valueTypes</code> is non-empty, it is expected to contain as many elements as <code>values</code> indicating their types. This allows idiomatic printing of mixed value and integer attributes in a list. E.g. <code>[arg0 : index, 7, 42, arg42 : i32]</code>.</p>
<p>Indices can be scalable. For example, "4" in "[2, [4], 8]" is scalable. This notation is similar to how scalable dims are marked when defining Vectors. For each value in <code>integers</code>, the corresponding <code>bool</code> in <code>scalables</code> encodes whether it's a scalable index. If <code>scalableVals</code> is empty then assume that all indices are non-scalable. </p>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00113">113</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

</div>
</div>
<a id="aac3d9353398664321147f5b579f1d767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3d9353398664321147f5b579f1d767">&#9670;&nbsp;</a></span>printDynamicIndexList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::printDynamicIndexList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>integers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>valueTypes</em> = <code><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a>&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8h_source.html#l00112">112</a> of file <a class="el" href="ViewLikeInterface_8h_source.html">ViewLikeInterface.h</a>.</p>

</div>
</div>
<a id="a41d5e525ca50e6257e78416957f7778c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d5e525ca50e6257e78416957f7778c">&#9670;&nbsp;</a></span>printRegisteredPasses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::printRegisteredPasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the passes that were previously registered and stored in passRegistry. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8cpp_source.html#l00073">73</a> of file <a class="el" href="PassRegistry_8cpp_source.html">PassRegistry.cpp</a>.</p>

<p class="reference">References <a class="el" href="PolynomialApproximation_8cpp_source.html#l00213">max()</a>, and <a class="el" href="PassRegistry_8cpp_source.html#l00028">passRegistry</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00529">printRegisteredPassesAndReturn()</a>.</p>

</div>
</div>
<a id="a5759ad12a88abff67b9657ca557bbcf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5759ad12a88abff67b9657ca557bbcf3">&#9670;&nbsp;</a></span>printSemiFunctionType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::printSemiFunctionType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>argumentType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>resultType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Syntax_8cpp_source.html#l00071">71</a> of file <a class="el" href="Syntax_8cpp_source.html">Syntax.cpp</a>.</p>

</div>
</div>
<a id="a979423818fdead0e008345256a1e2d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979423818fdead0e008345256a1e2d10">&#9670;&nbsp;</a></span>printSemiFunctionType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::printSemiFunctionType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>argumentType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>resultType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints argument and result types in a syntax similar to that of FunctionType but allowing and requiring one to omit the parens around the argument type in absence of result types, and without the trailing <code>-&gt; ()</code>. </p>

<p class="definition">Definition at line <a class="el" href="Syntax_8cpp_source.html#l00055">55</a> of file <a class="el" href="Syntax_8cpp_source.html">Syntax.cpp</a>.</p>

</div>
</div>
<a id="ae1261e0343cefe25ab1724c67005b7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1261e0343cefe25ab1724c67005b7d2">&#9670;&nbsp;</a></span>projectDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::projectDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>projectedDimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressDimsFlag</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the map that results from projecting out the dimensions specified in <code>projectedDimensions</code>. </p>
<p>The projected dimensions are set to 0.</p>
<p>Example: 1) map : affine_map&lt;(d0, d1, d2) -&gt; (d0, d1)&gt; projected_dimensions : {2} result : affine_map&lt;(d0, d1) -&gt; (d0, d1)&gt;</p>
<p>2) map : affine_map&lt;(d0, d1) -&gt; (d0 + d1)&gt; projected_dimensions : {1} result : affine_map&lt;(d0) -&gt; (d0)&gt;</p>
<p>3) map : affine_map&lt;(d0, d1, d2) -&gt; (d0, d1)&gt; projected_dimensions : {1} result : affine_map&lt;(d0, d1) -&gt; (d0, 0)&gt;</p>
<p>This function also compresses the dims when the boolean flag is true. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00904">904</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00717">compressDims()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00918">getProjectedMap()</a>.</p>

</div>
</div>
<a id="ae5ec6082bc5758f83f4b0938b00b160d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ec6082bc5758f83f4b0938b00b160d">&#9670;&nbsp;</a></span>projectSymbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::projectSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>projectedSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressSymbolsFlag</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symbol counterpart of <code>projectDims</code>. </p>
<p>This function also compresses the symbols when the boolean flag is true. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00911">911</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00731">compressSymbols()</a>.</p>

</div>
</div>
<a id="a7173c36d6b113dcdb0599eb672526b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7173c36d6b113dcdb0599eb672526b43">&#9670;&nbsp;</a></span>promoteToWorkgroupMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::promoteToWorkgroupMemory </td>
          <td>(</td>
          <td class="paramtype">gpu::GPUFuncOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes a function argument to workgroup memory in the given function. </p>
<p>The copies will be inserted in the beginning and in the end of the function. </p>

</div>
</div>
<a id="af98f1102c5f82e37f4e4cf21be1736f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98f1102c5f82e37f4e4cf21be1736f8">&#9670;&nbsp;</a></span>readBytecodeFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::readBytecodeFile </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; llvm::SourceMgr &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An overload with a source manager whose main file buffer is used for parsing. </p>
<p>The lifetime of the source manager may be freely extended during parsing such that the source manager is not destroyed before the parsed IR. </p>

<p class="definition">Definition at line <a class="el" href="BytecodeReader_8cpp_source.html#l02592">2592</a> of file <a class="el" href="BytecodeReader_8cpp_source.html">BytecodeReader.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeReader_8cpp_source.html#l02571">readBytecodeFileImpl()</a>.</p>

</div>
</div>
<a id="ad3b71d67f0d7fe035e455a121e826f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b71d67f0d7fe035e455a121e826f08">&#9670;&nbsp;</a></span>readBytecodeFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::readBytecodeFile </td>
          <td>(</td>
          <td class="paramtype">llvm::MemoryBufferRef&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the operations defined within the given memory buffer, containing MLIR bytecode, into the provided block. </p>

<p class="definition">Definition at line <a class="el" href="BytecodeReader_8cpp_source.html#l02587">2587</a> of file <a class="el" href="BytecodeReader_8cpp_source.html">BytecodeReader.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeReader_8cpp_source.html#l02571">readBytecodeFileImpl()</a>.</p>

</div>
</div>
<a id="a2ef4c7804d8356c0813ce04f87b2b1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef4c7804d8356c0813ce04f87b2b1ff">&#9670;&nbsp;</a></span>readResourceHandle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult mlir::readResourceHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectBytecodeReader.html">DialectBytecodeReader</a> &amp;&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FailureOr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for resource handle reading that returns LogicalResult. </p>

<p class="definition">Definition at line <a class="el" href="BytecodeImplementation_8h_source.html#l00494">494</a> of file <a class="el" href="BytecodeImplementation_8h_source.html">BytecodeImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00152">mlir::DialectBytecodeReader::readResourceHandle()</a>.</p>

</div>
</div>
<a id="aaf251298609435109217ec8cfa535642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf251298609435109217ec8cfa535642">&#9670;&nbsp;</a></span>reconcileUnrealizedCasts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::reconcileUnrealizedCasts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; UnrealizedConversionCastOp &gt;&#160;</td>
          <td class="paramname"><em>castOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; UnrealizedConversionCastOp &gt; *&#160;</td>
          <td class="paramname"><em>remainingCastOps</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to reconcile all given UnrealizedConversionCastOps and store the left-over ops in <code>remainingCastOps</code> (if provided). </p>
<p>This function processes cast ops in a worklist-driven fashion. For each cast op, if the chain of input casts eventually reaches a cast op where the input types match the output types of the matched op, replace the matched op with the inputs.</p>
<p>Example: %1 = unrealized_conversion_cast %0 : !A to !B %2 = unrealized_conversion_cast %1 : !B to !C %3 = unrealized_conversion_cast %2 : !C to !A</p>
<p>In the above example, %0 can be used instead of %3 and all cast ops are folded away. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l02580">2580</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

</div>
</div>
<a id="afe55df95d48191f0fa2c5ab8f4e81e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe55df95d48191f0fa2c5ab8f4e81e34">&#9670;&nbsp;</a></span>registerAllDialects() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerAllDialects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add all the MLIR dialects to the provided registry. </p>

<p class="definition">Definition at line <a class="el" href="InitAllDialects_8h_source.html#l00106">106</a> of file <a class="el" href="InitAllDialects_8h_source.html">InitAllDialects.h</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00147">mlir::DialectRegistry::insert()</a>, <a class="el" href="AllInterfaces_8cpp_source.html#l00017">mlir::linalg::registerAllDialectInterfaceImplementations()</a>, <a class="el" href="AllocationOpInterfaceImpl_8cpp_source.html#l00061">mlir::memref::registerAllocationOpInterfaceExternalModels()</a>, <a class="el" href="Arith_2Transforms_2BufferDeallocationOpInterfaceImpl_8cpp_source.html#l00080">mlir::arith::registerBufferDeallocationOpInterfaceExternalModels()</a>, <a class="el" href="ControlFlow_2Transforms_2BufferDeallocationOpInterfaceImpl_8cpp_source.html#l00158">mlir::cf::registerBufferDeallocationOpInterfaceExternalModels()</a>, <a class="el" href="GPU_2Transforms_2BufferDeallocationOpInterfaceImpl_8cpp_source.html#l00032">mlir::gpu::registerBufferDeallocationOpInterfaceExternalModels()</a>, <a class="el" href="SCF_2Transforms_2BufferDeallocationOpInterfaceImpl_8cpp_source.html#l00076">mlir::scf::registerBufferDeallocationOpInterfaceExternalModels()</a>, <a class="el" href="Arith_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00207">mlir::arith::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00494">mlir::bufferization::func_ext::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="ControlFlow_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00064">mlir::cf::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="SCF_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l01353">mlir::scf::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="Shape_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00138">mlir::shape::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="SparseTensor_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00327">mlir::sparse_tensor::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="Tensor_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l01056">mlir::tensor::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="Vector_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00318">mlir::vector::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="MLProgram_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00151">mlir::ml_program::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="Arith_2Transforms_2BufferViewFlowOpInterfaceImpl_8cpp_source.html#l00039">mlir::arith::registerBufferViewFlowOpInterfaceExternalModels()</a>, <a class="el" href="MemRef_2Transforms_2BufferViewFlowOpInterfaceImpl_8cpp_source.html#l00043">mlir::memref::registerBufferViewFlowOpInterfaceExternalModels()</a>, <a class="el" href="CastInterfaces_8cpp_source.html#l00080">mlir::builtin::registerCastOpInterfaceExternalModels()</a>, <a class="el" href="TensorTransformOps_8cpp_source.html#l00071">mlir::tensor::registerFindPayloadReplacementOpInterfaceExternalModels()</a>, <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html#l00202">mlir::tensor::registerInferTypeOpInterfaceExternalModels()</a>, <a class="el" href="InlinerInterfaceImpl_8cpp_source.html#l00815">mlir::LLVM::registerInlinerInterface()</a>, <a class="el" href="MemRefMemorySlot_8cpp_source.html#l00349">mlir::memref::registerMemorySlotExternalModels()</a>, <a class="el" href="LLVM_2NVVM_2Target_8cpp_source.html#l00060">mlir::NVVM::registerNVVMTargetInterfaceExternalModels()</a>, <a class="el" href="LLVM_2ROCDL_2Target_8cpp_source.html#l00069">mlir::ROCDL::registerROCDLTargetInterfaceExternalModels()</a>, <a class="el" href="Linalg_2Transforms_2RuntimeOpVerification_8cpp_source.html#l00122">mlir::linalg::registerRuntimeVerifiableOpInterfaceExternalModels()</a>, <a class="el" href="MemRef_2Transforms_2RuntimeOpVerification_8cpp_source.html#l00334">mlir::memref::registerRuntimeVerifiableOpInterfaceExternalModels()</a>, <a class="el" href="ShardingInterfaceImpl_8cpp_source.html#l00076">mlir::tosa::registerShardingInterfaceExternalModels()</a>, <a class="el" href="SPIRV_2Target_8cpp_source.html#l00044">mlir::spirv::registerSPIRVTargetInterfaceExternalModels()</a>, <a class="el" href="Tensor_2Transforms_2SubsetInsertionOpInterfaceImpl_8cpp_source.html#l00087">mlir::tensor::registerSubsetOpInterfaceExternalModels()</a>, <a class="el" href="SubsetOpInterfaceImpl_8cpp_source.html#l00070">mlir::vector::registerSubsetOpInterfaceExternalModels()</a>, <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00935">mlir::tensor::registerTilingInterfaceExternalModels()</a>, <a class="el" href="Affine_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00097">mlir::affine::registerValueBoundsOpInterfaceExternalModels()</a>, <a class="el" href="Arith_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00151">mlir::arith::registerValueBoundsOpInterfaceExternalModels()</a>, <a class="el" href="MemRef_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00116">mlir::memref::registerValueBoundsOpInterfaceExternalModels()</a>, <a class="el" href="SCF_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00160">mlir::scf::registerValueBoundsOpInterfaceExternalModels()</a>, <a class="el" href="Tensor_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00115">mlir::tensor::registerValueBoundsOpInterfaceExternalModels()</a>, and <a class="el" href="Vector_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00045">mlir::vector::registerValueBoundsOpInterfaceExternalModels()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CAPI_2RegisterEverything_2RegisterEverything_8cpp_source.html#l00020">mlirRegisterAllDialects()</a>, and <a class="el" href="InitAllDialects_8h_source.html#l00197">registerAllDialects()</a>.</p>

</div>
</div>
<a id="a5fcd07e2ad26a58627d961ce8e544f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fcd07e2ad26a58627d961ce8e544f1b">&#9670;&nbsp;</a></span>registerAllDialects() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerAllDialects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append all the MLIR dialects to the registry contained in the given context. </p>

<p class="definition">Definition at line <a class="el" href="InitAllDialects_8h_source.html#l00197">197</a> of file <a class="el" href="InitAllDialects_8h_source.html">InitAllDialects.h</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00419">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="InitAllDialects_8h_source.html#l00106">registerAllDialects()</a>.</p>

</div>
</div>
<a id="af478d18d439a803300e8e086d32bbb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af478d18d439a803300e8e086d32bbb6e">&#9670;&nbsp;</a></span>registerAllExtensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerAllExtensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function may be called to register all MLIR dialect extensions with the provided registry. </p>
<p>If you're building a compiler, you generally shouldn't use this: you would individually register the specific extensions that are useful for the pipelines and transformations you are using. </p>

<p class="definition">Definition at line <a class="el" href="InitAllExtensions_8h_source.html#l00058">58</a> of file <a class="el" href="InitAllExtensions_8h_source.html">InitAllExtensions.h</a>.</p>

<p class="reference">References <a class="el" href="Func_2Extensions_2AllExtensions_8cpp_source.html#l00015">mlir::func::registerAllExtensions()</a>, <a class="el" href="Tensor_2Extensions_2AllExtensions_8cpp_source.html#l00014">mlir::tensor::registerAllExtensions()</a>, <a class="el" href="ArithToLLVM_8cpp_source.html#l00511">mlir::arith::registerConvertArithToLLVMInterface()</a>, <a class="el" href="ComplexToLLVM_8cpp_source.html#l00386">registerConvertComplexToLLVMInterface()</a>, <a class="el" href="ControlFlowToLLVM_8cpp_source.html#l00274">mlir::cf::registerConvertControlFlowToLLVMInterface()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00834">registerConvertFuncToLLVMInterface()</a>, <a class="el" href="IndexToLLVM_8cpp_source.html#l00393">mlir::index::registerConvertIndexToLLVMInterface()</a>, <a class="el" href="MathToLLVM_8cpp_source.html#l00358">registerConvertMathToLLVMInterface()</a>, <a class="el" href="MemRefToLLVM_8cpp_source.html#l01755">registerConvertMemRefToLLVMInterface()</a>, <a class="el" href="NVVMToLLVM_8cpp_source.html#l00115">registerConvertNVVMToLLVMInterface()</a>, <a class="el" href="UBToLLVM_8cpp_source.html#l00121">mlir::ub::registerConvertUBToLLVMInterface()</a>, <a class="el" href="DebugExtension_8cpp_source.html#l00034">mlir::transform::registerDebugExtension()</a>, <a class="el" href="IRDLExtension_8cpp_source.html#l00034">mlir::transform::registerIRDLExtension()</a>, <a class="el" href="LoopExtension_8cpp_source.html#l00034">mlir::transform::registerLoopExtension()</a>, <a class="el" href="PDLExtension_8cpp_source.html#l00069">mlir::transform::registerPDLExtension()</a>, <a class="el" href="AffineTransformOps_8cpp_source.html#l00178">mlir::affine::registerTransformDialectExtension()</a>, <a class="el" href="BufferizationTransformOps_8cpp_source.html#l00175">mlir::bufferization::registerTransformDialectExtension()</a>, <a class="el" href="DLTITransformOps_8cpp_source.html#l00082">mlir::dlti::registerTransformDialectExtension()</a>, <a class="el" href="FuncTransformOps_8cpp_source.html#l00257">mlir::func::registerTransformDialectExtension()</a>, <a class="el" href="GPUTransformOps_8cpp_source.html#l00944">mlir::gpu::registerTransformDialectExtension()</a>, <a class="el" href="DialectExtension_8cpp_source.html#l00060">mlir::linalg::registerTransformDialectExtension()</a>, <a class="el" href="MemRefTransformOps_8cpp_source.html#l00334">mlir::memref::registerTransformDialectExtension()</a>, <a class="el" href="namespacemlir_1_1nvgpu.html#ae64270d2058ef5fd99281df6e7de4464">mlir::nvgpu::registerTransformDialectExtension()</a>, <a class="el" href="namespacemlir_1_1scf.html#a131df27a14db6c8a12e643fa2a0a5603">mlir::scf::registerTransformDialectExtension()</a>, <a class="el" href="SparseTensorTransformOps_8cpp_source.html#l00057">mlir::sparse_tensor::registerTransformDialectExtension()</a>, <a class="el" href="TensorTransformOps_8cpp_source.html#l00258">mlir::tensor::registerTransformDialectExtension()</a>, and <a class="el" href="VectorTransformOps_8cpp_source.html#l00237">mlir::vector::registerTransformDialectExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CAPI_2RegisterEverything_2RegisterEverything_8cpp_source.html#l00020">mlirRegisterAllDialects()</a>.</p>

</div>
</div>
<a id="a5b51fcb4b20988958223a34812c119a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b51fcb4b20988958223a34812c119a3">&#9670;&nbsp;</a></span>registerAllFromLLVMIRTranslations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mlir::registerAllFromLLVMIRTranslations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers all dialects that can be translated from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR and the corresponding translation interfaces. </p>

<p class="definition">Definition at line <a class="el" href="All_8h_source.html#l00078">78</a> of file <a class="el" href="All_8h_source.html">All.h</a>.</p>

<p class="reference">References <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html#l00428">registerLLVMDialectImport()</a>, and <a class="el" href="LLVMIRToNVVMTranslation_8cpp_source.html#l00083">registerNVVMDialectImport()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00027">registerFromLLVMIRTranslation()</a>.</p>

</div>
</div>
<a id="a6f90059c48bfaae011de1a44d1d80683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f90059c48bfaae011de1a44d1d80683">&#9670;&nbsp;</a></span>registerAllGPUToLLVMIRTranslations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mlir::registerAllGPUToLLVMIRTranslations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers all the translations to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR required by GPU passes. </p>
<p>TODO: Remove this function when a safe dialect interface registration mechanism is implemented, see D157703. </p>

<p class="definition">Definition at line <a class="el" href="All_8h_source.html#l00063">63</a> of file <a class="el" href="All_8h_source.html">All.h</a>.</p>

<p class="reference">References <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html#l00036">registerBuiltinDialectTranslation()</a>, <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html#l00066">registerGPUDialectTranslation()</a>, <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00472">registerLLVMDialectTranslation()</a>, <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00297">registerNVVMDialectTranslation()</a>, <a class="el" href="SelectObjectAttr_8cpp_source.html#l00057">mlir::gpu::registerOffloadingLLVMTranslationInterfaceExternalModels()</a>, <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00218">registerROCDLDialectTranslation()</a>, and <a class="el" href="SPIRVToLLVMIRTranslation_8cpp_source.html#l00023">registerSPIRVDialectTranslation()</a>.</p>

</div>
</div>
<a id="afb552a159c6c887b98b3583dfd5cbe5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb552a159c6c887b98b3583dfd5cbe5d">&#9670;&nbsp;</a></span>registerAllPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerAllPasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InitAllPasses_8h_source.html#l00062">62</a> of file <a class="el" href="InitAllPasses_8h_source.html">InitAllPasses.h</a>.</p>

<p class="reference">References <a class="el" href="BufferizationPipelines_8cpp_source.html#l00037">mlir::bufferization::registerBufferizationPipelines()</a>, <a class="el" href="GPUToNVVMPipeline_8cpp_source.html#l00119">mlir::gpu::registerGPUToNVVMPipeline()</a>, <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00116">mlir::sparse_tensor::registerSparseTensorPipelines()</a>, and <a class="el" href="TosaToLinalgPass_8cpp_source.html#l00108">mlir::tosa::registerTosaToLinalgPipelines()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CAPI_2RegisterEverything_2RegisterEverything_8cpp_source.html#l00032">mlirRegisterAllPasses()</a>.</p>

</div>
</div>
<a id="ad1e68be8ebf61b3be9572769e19bc467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e68be8ebf61b3be9572769e19bc467">&#9670;&nbsp;</a></span>registerAllToLLVMIRTranslations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mlir::registerAllToLLVMIRTranslations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers all dialects that can be translated to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR and the corresponding translation interfaces. </p>

<p class="definition">Definition at line <a class="el" href="All_8h_source.html#l00039">39</a> of file <a class="el" href="All_8h_source.html">All.h</a>.</p>

<p class="reference">References <a class="el" href="AMXToLLVMIRTranslation_8cpp_source.html#l00045">registerAMXDialectTranslation()</a>, <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html#l00046">registerArmNeonDialectTranslation()</a>, <a class="el" href="ArmSMEToLLVMIRTranslation_8cpp_source.html#l00046">registerArmSMEDialectTranslation()</a>, <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html#l00045">registerArmSVEDialectTranslation()</a>, <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html#l00036">registerBuiltinDialectTranslation()</a>, <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html#l00066">registerGPUDialectTranslation()</a>, <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00472">registerLLVMDialectTranslation()</a>, <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00297">registerNVVMDialectTranslation()</a>, <a class="el" href="SelectObjectAttr_8cpp_source.html#l00057">mlir::gpu::registerOffloadingLLVMTranslationInterfaceExternalModels()</a>, <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00533">registerOpenACCDialectTranslation()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l03987">registerOpenMPDialectTranslation()</a>, <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00218">registerROCDLDialectTranslation()</a>, <a class="el" href="SPIRVToLLVMIRTranslation_8cpp_source.html#l00023">registerSPIRVDialectTranslation()</a>, <a class="el" href="VCIXToLLVMIRTranslation_8cpp_source.html#l00077">registerVCIXDialectTranslation()</a>, and <a class="el" href="X86VectorToLLVMIRTranslation_8cpp_source.html#l00046">registerX86VectorDialectTranslation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CAPI_2RegisterEverything_2RegisterEverything_8cpp_source.html#l00025">mlirRegisterAllLLVMTranslations()</a>.</p>

</div>
</div>
<a id="a8d16808b31b66905b067720d428adf61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d16808b31b66905b067720d428adf61">&#9670;&nbsp;</a></span>registerAllTranslations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerAllTranslations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InitAllTranslations_8h_source.html#l00028">28</a> of file <a class="el" href="InitAllTranslations_8h_source.html">InitAllTranslations.h</a>.</p>

<p class="reference">References <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00027">registerFromLLVMIRTranslation()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00058">registerFromSPIRVTranslation()</a>, <a class="el" href="Cpp_2TranslateRegistration_8cpp_source.html#l00026">registerToCppTranslation()</a>, <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00028">registerToLLVMIRTranslation()</a>, and <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00086">registerToSPIRVTranslation()</a>.</p>

</div>
</div>
<a id="a0465249a74e23df5fdc548001933239c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0465249a74e23df5fdc548001933239c">&#9670;&nbsp;</a></span>registerAMXDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerAMXDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the AMX dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="AMXToLLVMIRTranslation_8cpp_source.html#l00045">45</a> of file <a class="el" href="AMXToLLVMIRTranslation_8cpp_source.html">AMXToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00147">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="AMXToLLVMIRTranslation_8cpp_source.html#l00052">registerAMXDialectTranslation()</a>.</p>

</div>
</div>
<a id="aa4a637ec7428727c66f27117b9892f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a637ec7428727c66f27117b9892f1e">&#9670;&nbsp;</a></span>registerAMXDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerAMXDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the AMX dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="AMXToLLVMIRTranslation_8cpp_source.html#l00052">52</a> of file <a class="el" href="AMXToLLVMIRTranslation_8cpp_source.html">AMXToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00419">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="AMXToLLVMIRTranslation_8cpp_source.html#l00045">registerAMXDialectTranslation()</a>.</p>

</div>
</div>
<a id="ad495fac45c73eb07003f55e4c3c82ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad495fac45c73eb07003f55e4c3c82ca2">&#9670;&nbsp;</a></span>registerAndParseCLIOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, std::string &gt; mlir::registerAndParseCLIOptions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>toolName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register and parse command line options. </p>
<ul>
<li>toolName is used for the header displayed by <code>--help</code>.</li>
<li>registry should contain all the dialects that can be parsed in the source.</li>
<li>return std::pair&lt;std::string, std::string&gt; for inputFilename and outputFilename command line option values. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MlirOptMain_8cpp_source.html#l00493">493</a> of file <a class="el" href="MlirOptMain_8cpp_source.html">MlirOptMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00195">mlir::DialectRegistry::getDialectNames()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00205">registerAsmPrinterCLOptions()</a>, <a class="el" href="DebugCounter_8cpp_source.html#l00112">mlir::tracing::DebugCounter::registerCLOptions()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00209">mlir::MlirOptMainConfig::registerCLOptions()</a>, <a class="el" href="Timing_8cpp_source.html#l00614">registerDefaultTimingManagerCLOptions()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00090">registerMLIRContextCLOptions()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00140">registerPassManagerCLOptions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00612">MlirOptMain()</a>.</p>

</div>
</div>
<a id="ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad">&#9670;&nbsp;</a></span>registerArmNeonDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerArmNeonDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the ArmNeon dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html#l00046">46</a> of file <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html">ArmNeonToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00147">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html#l00054">registerArmNeonDialectTranslation()</a>.</p>

</div>
</div>
<a id="a559f20bb41c97729f2d089e6f7a72e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559f20bb41c97729f2d089e6f7a72e4e">&#9670;&nbsp;</a></span>registerArmNeonDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerArmNeonDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the ArmNeon dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html#l00054">54</a> of file <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html">ArmNeonToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00419">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html#l00046">registerArmNeonDialectTranslation()</a>.</p>

</div>
</div>
<a id="a44e3d0ed9dee8abc1c1da567b31f3520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e3d0ed9dee8abc1c1da567b31f3520">&#9670;&nbsp;</a></span>registerArmSMEDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerArmSMEDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the ArmSME dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVMIRTranslation_8cpp_source.html#l00046">46</a> of file <a class="el" href="ArmSMEToLLVMIRTranslation_8cpp_source.html">ArmSMEToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00147">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="ArmSMEToLLVMIRTranslation_8cpp_source.html#l00053">registerArmSMEDialectTranslation()</a>.</p>

</div>
</div>
<a id="a7e8ba95f7e3fc0b3d4885f3ae1b2926e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8ba95f7e3fc0b3d4885f3ae1b2926e">&#9670;&nbsp;</a></span>registerArmSMEDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerArmSMEDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the ArmSME dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="ArmSMEToLLVMIRTranslation_8cpp_source.html#l00053">53</a> of file <a class="el" href="ArmSMEToLLVMIRTranslation_8cpp_source.html">ArmSMEToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00419">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="ArmSMEToLLVMIRTranslation_8cpp_source.html#l00046">registerArmSMEDialectTranslation()</a>.</p>

</div>
</div>
<a id="a53be2d34e1d4e96ea100bbf93af35a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53be2d34e1d4e96ea100bbf93af35a2c">&#9670;&nbsp;</a></span>registerArmSVEDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerArmSVEDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the ArmSVE dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html#l00045">45</a> of file <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html">ArmSVEToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00147">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html#l00052">registerArmSVEDialectTranslation()</a>.</p>

</div>
</div>
<a id="afc9c160fac7074517c6f013864acee68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9c160fac7074517c6f013864acee68">&#9670;&nbsp;</a></span>registerArmSVEDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerArmSVEDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the ArmSVE dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html#l00052">52</a> of file <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html">ArmSVEToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00419">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html#l00045">registerArmSVEDialectTranslation()</a>.</p>

</div>
</div>
<a id="a894a08aa6ed051f55e57bc35859a379f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894a08aa6ed051f55e57bc35859a379f">&#9670;&nbsp;</a></span>registerAsmPrinterCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerAsmPrinterCLOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a set of useful command-line options that can be used to configure various flags within the <a class="el" href="classmlir_1_1AsmPrinter.html" title="This base class exposes generic asm printer hooks, usable across the various derived printers.">AsmPrinter</a>. </p>

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l00205">205</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l00201">clOptions</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00493">registerAndParseCLIOptions()</a>.</p>

</div>
</div>
<a id="a857314125d33fcc46a38cd3aca4d1d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857314125d33fcc46a38cd3aca4d1d12">&#9670;&nbsp;</a></span>registerBuiltinDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerBuiltinDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the translation from the builtin dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry. </p>

<p class="definition">Definition at line <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html#l00036">36</a> of file <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html">BuiltinToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00063">registerAllGPUToLLVMIRTranslations()</a>, <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html#l00042">registerBuiltinDialectTranslation()</a>.</p>

</div>
</div>
<a id="a1af1c7f18bef740745581f7130c8c46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af1c7f18bef740745581f7130c8c46e">&#9670;&nbsp;</a></span>registerBuiltinDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerBuiltinDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the translation from the builtin dialect in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html#l00042">42</a> of file <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html">BuiltinToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00419">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="BuiltinToLLVMIRTranslation_8cpp_source.html#l00036">registerBuiltinDialectTranslation()</a>.</p>

</div>
</div>
<a id="ae53cd627dc538a8da5a61d8ba621e603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53cd627dc538a8da5a61d8ba621e603">&#9670;&nbsp;</a></span>registerConversionPDLFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerConversionPDLFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the dialect conversion PDL functions with the given pattern set. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03125">3125</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02683">mlir::TypeConverter::convertType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02739">mlir::TypeConverter::convertTypes()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00917">mlir::detail::ConversionPatternRewriterImpl::currentTypeConverter</a>, <a class="el" href="PatternMatch_8h_source.html#l00829">mlir::RewritePatternSet::getPDLPatterns()</a>, and <a class="el" href="DialectConversion_8cpp_source.html#l03118">pdllConvertValues()</a>.</p>

</div>
</div>
<a id="a92e3131ae05feac332799cb2de81be2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e3131ae05feac332799cb2de81be2f">&#9670;&nbsp;</a></span>registerConvertComplexToLLVMInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerConvertComplexToLLVMInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ComplexToLLVM_8cpp_source.html#l00386">386</a> of file <a class="el" href="ComplexToLLVM_8cpp_source.html">ComplexToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllExtensions_8h_source.html#l00058">registerAllExtensions()</a>.</p>

</div>
</div>
<a id="a4cd7b1431f65dc7d952407a7e062e63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd7b1431f65dc7d952407a7e062e63f">&#9670;&nbsp;</a></span>registerConvertFuncToLLVMInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerConvertFuncToLLVMInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FuncToLLVM_8cpp_source.html#l00834">834</a> of file <a class="el" href="FuncToLLVM_8cpp_source.html">FuncToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllExtensions_8h_source.html#l00058">registerAllExtensions()</a>.</p>

</div>
</div>
<a id="af524bd5bb2e7831529a737536dee9e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af524bd5bb2e7831529a737536dee9e63">&#9670;&nbsp;</a></span>registerConvertMathToLLVMInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerConvertMathToLLVMInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathToLLVM_8cpp_source.html#l00358">358</a> of file <a class="el" href="MathToLLVM_8cpp_source.html">MathToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllExtensions_8h_source.html#l00058">registerAllExtensions()</a>.</p>

</div>
</div>
<a id="a064361570e348faf435496fbf4d5db7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064361570e348faf435496fbf4d5db7d">&#9670;&nbsp;</a></span>registerConvertMemRefToLLVMInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerConvertMemRefToLLVMInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefToLLVM_8cpp_source.html#l01755">1755</a> of file <a class="el" href="MemRefToLLVM_8cpp_source.html">MemRefToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllExtensions_8h_source.html#l00058">registerAllExtensions()</a>.</p>

</div>
</div>
<a id="af5ef9c68e63c5458b7258ecb9b48b8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ef9c68e63c5458b7258ecb9b48b8bf">&#9670;&nbsp;</a></span>registerConvertNVVMToLLVMInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerConvertNVVMToLLVMInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NVVMToLLVM_8cpp_source.html#l00115">115</a> of file <a class="el" href="NVVMToLLVM_8cpp_source.html">NVVMToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllExtensions_8h_source.html#l00058">registerAllExtensions()</a>.</p>

</div>
</div>
<a id="a8a1cfd257150164208f96531454b4d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1cfd257150164208f96531454b4d59">&#9670;&nbsp;</a></span>registerConvertToLLVMDependentDialectLoading()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerConvertToLLVMDependentDialectLoading </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the extension that will load dependent dialects for <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> conversion. </p>
<p>This is useful to implement a pass similar to "convert-to-llvm". </p>

<p class="definition">Definition at line <a class="el" href="ConvertToLLVMPass_8cpp_source.html#l00129">129</a> of file <a class="el" href="ConvertToLLVMPass_8cpp_source.html">ConvertToLLVMPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00217">mlir::DialectRegistry::addExtensions()</a>.</p>

</div>
</div>
<a id="a1da5a75b8bc3193908b0e222a6da1d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da5a75b8bc3193908b0e222a6da1d85">&#9670;&nbsp;</a></span>registerDefaultTimingManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerDefaultTimingManagerCLOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a set of useful command-line options that can be used to configure a <code><a class="el" href="classmlir_1_1DefaultTimingManager.html" title="Facilities for time measurement and report printing to an output stream.">DefaultTimingManager</a></code>. </p>
<p>The values of these options can be applied via the <code>applyDefaultTimingManagerCLOptions</code> method. </p>

<p class="definition">Definition at line <a class="el" href="Timing_8cpp_source.html#l00614">614</a> of file <a class="el" href="Timing_8cpp_source.html">Timing.cpp</a>.</p>

<p class="reference">References <a class="el" href="Timing_8cpp_source.html#l00612">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00493">registerAndParseCLIOptions()</a>.</p>

</div>
</div>
<a id="a7a267e7e7ec38e0a09285a20831414d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a267e7e7ec38e0a09285a20831414d3">&#9670;&nbsp;</a></span>registerFromLLVMIRTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerFromLLVMIRTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00027">27</a> of file <a class="el" href="ConvertFromLLVMIR_8cpp_source.html">ConvertFromLLVMIR.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">emitError()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">get()</a>, <a class="el" href="All_8h_source.html#l00078">registerAllFromLLVMIRTranslations()</a>, and <a class="el" href="ModuleImport_8cpp_source.html#l02202">translateLLVMIRToModule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00028">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="a51ef91a9901d4d87a042990ccb79f2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ef91a9901d4d87a042990ccb79f2be">&#9670;&nbsp;</a></span>registerFromSPIRVTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerFromSPIRVTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00058">58</a> of file <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00040">deserializeModule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00028">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="aa9427230420827cff7cd15f78924cdb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9427230420827cff7cd15f78924cdb4">&#9670;&nbsp;</a></span>registerGPUDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerGPUDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the GPU dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html#l00066">66</a> of file <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html">GPUToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00147">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00063">registerAllGPUToLLVMIRTranslations()</a>, <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html#l00073">registerGPUDialectTranslation()</a>.</p>

</div>
</div>
<a id="afe90c6efbbc0e7e7469f14619fd7445b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe90c6efbbc0e7e7469f14619fd7445b">&#9670;&nbsp;</a></span>registerGPUDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerGPUDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the GPU dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html#l00073">73</a> of file <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html">GPUToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00419">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="GPUToLLVMIRTranslation_8cpp_source.html#l00066">registerGPUDialectTranslation()</a>.</p>

</div>
</div>
<a id="ab01617995d72a114db65ee711b2422d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01617995d72a114db65ee711b2422d5">&#9670;&nbsp;</a></span>registerLLVMDialectImport() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerLLVMDialectImport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and its import from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry. </p>

<p class="definition">Definition at line <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html#l00428">428</a> of file <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html">LLVMIRToLLVMTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00147">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00078">registerAllFromLLVMIRTranslations()</a>, and <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html#l00435">registerLLVMDialectImport()</a>.</p>

</div>
</div>
<a id="a4a0110d23914c27f0140d63a8bb934d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0110d23914c27f0140d63a8bb934d4">&#9670;&nbsp;</a></span>registerLLVMDialectImport() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerLLVMDialectImport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and its import from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR with the given context. </p>

<p class="definition">Definition at line <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html#l00435">435</a> of file <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html">LLVMIRToLLVMTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00419">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="LLVMIRToLLVMTranslation_8cpp_source.html#l00428">registerLLVMDialectImport()</a>.</p>

</div>
</div>
<a id="a8b9759ca57d83ec47b341d58d966b9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9759ca57d83ec47b341d58d966b9e8">&#9670;&nbsp;</a></span>registerLLVMDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerLLVMDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00472">472</a> of file <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html">LLVMToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00147">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00063">registerAllGPUToLLVMIRTranslations()</a>, <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00479">registerLLVMDialectTranslation()</a>.</p>

</div>
</div>
<a id="a74024a3b8ec9af8d50db598772774a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74024a3b8ec9af8d50db598772774a96">&#9670;&nbsp;</a></span>registerLLVMDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerLLVMDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00479">479</a> of file <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html">LLVMToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00419">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00472">registerLLVMDialectTranslation()</a>.</p>

</div>
</div>
<a id="a5254079fbbd31a78a3430bff18df2d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5254079fbbd31a78a3430bff18df2d7c">&#9670;&nbsp;</a></span>registerMLIRContextCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerMLIRContextCLOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a set of useful command-line options that can be used to configure various flags within the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a>. </p>
<p>These flags are used when constructing an MLIR context for initialization. </p>

<p class="definition">Definition at line <a class="el" href="MLIRContext_8cpp_source.html#l00090">90</a> of file <a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00077">clOptions</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00493">registerAndParseCLIOptions()</a>.</p>

</div>
</div>
<a id="a59faf81890b27fbd773f3ae78f47a07b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59faf81890b27fbd773f3ae78f47a07b">&#9670;&nbsp;</a></span>registerNVVMDialectImport() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerNVVMDialectImport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and its import from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry. </p>

<p class="definition">Definition at line <a class="el" href="LLVMIRToNVVMTranslation_8cpp_source.html#l00083">83</a> of file <a class="el" href="LLVMIRToNVVMTranslation_8cpp_source.html">LLVMIRToNVVMTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00147">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00078">registerAllFromLLVMIRTranslations()</a>, and <a class="el" href="LLVMIRToNVVMTranslation_8cpp_source.html#l00090">registerNVVMDialectImport()</a>.</p>

</div>
</div>
<a id="add91ee93d64f27e24f1d6e1856893c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add91ee93d64f27e24f1d6e1856893c5b">&#9670;&nbsp;</a></span>registerNVVMDialectImport() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerNVVMDialectImport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and its import from <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR with the given context. </p>

<p class="definition">Definition at line <a class="el" href="LLVMIRToNVVMTranslation_8cpp_source.html#l00090">90</a> of file <a class="el" href="LLVMIRToNVVMTranslation_8cpp_source.html">LLVMIRToNVVMTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00419">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="LLVMIRToNVVMTranslation_8cpp_source.html#l00083">registerNVVMDialectImport()</a>.</p>

</div>
</div>
<a id="a2989267e0da323d644b3316b85b3942f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2989267e0da323d644b3316b85b3942f">&#9670;&nbsp;</a></span>registerNVVMDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerNVVMDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00297">297</a> of file <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html">NVVMToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00147">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00063">registerAllGPUToLLVMIRTranslations()</a>, <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00304">registerNVVMDialectTranslation()</a>.</p>

</div>
</div>
<a id="a00d03cc4e706acdb35969f4d4e78142a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d03cc4e706acdb35969f4d4e78142a">&#9670;&nbsp;</a></span>registerNVVMDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerNVVMDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00304">304</a> of file <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html">NVVMToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00419">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00297">registerNVVMDialectTranslation()</a>.</p>

</div>
</div>
<a id="ae9bc345c5d25bda3847f7ddf6cebe9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9bc345c5d25bda3847f7ddf6cebe9bc">&#9670;&nbsp;</a></span>registerOpenACCDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerOpenACCDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the OpenACC dialect and the translation to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00533">533</a> of file <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html">OpenACCToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00147">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00540">registerOpenACCDialectTranslation()</a>.</p>

</div>
</div>
<a id="a889d8518a5c67b981e76d27c9a256d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889d8518a5c67b981e76d27c9a256d86">&#9670;&nbsp;</a></span>registerOpenACCDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerOpenACCDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the OpenACC dialect and the translation in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00540">540</a> of file <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html">OpenACCToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00419">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00533">registerOpenACCDialectTranslation()</a>.</p>

</div>
</div>
<a id="a6ea20d97a32efd36c02468e54db4b2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea20d97a32efd36c02468e54db4b2e7">&#9670;&nbsp;</a></span>registerOpenMPDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerOpenMPDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the OpenMP dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l03987">3987</a> of file <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html">OpenMPToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00147">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l03994">registerOpenMPDialectTranslation()</a>.</p>

</div>
</div>
<a id="aaa35b353841b70d090e1ead360536308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa35b353841b70d090e1ead360536308">&#9670;&nbsp;</a></span>registerOpenMPDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerOpenMPDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the OpenMP dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l03994">3994</a> of file <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html">OpenMPToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00419">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l03987">registerOpenMPDialectTranslation()</a>.</p>

</div>
</div>
<a id="a5a4626059212aef6f3aa5fa7088ce667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4626059212aef6f3aa5fa7088ce667">&#9670;&nbsp;</a></span>registerPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a48db7fd5d49bfa7ca8c81e5a6a058683">PassAllocatorFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a specific dialect pass allocator function with the system, typically used through the <a class="el" href="structmlir_1_1PassRegistration.html" title="PassRegistration provides a global initializer that registers a Pass allocation routine for a concret...">PassRegistration</a> template. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8cpp_source.html#l00150">150</a> of file <a class="el" href="PassRegistry_8cpp_source.html">PassRegistry.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassRegistry_8cpp_source.html#l00028">passRegistry</a>, and <a class="el" href="PassRegistry_8cpp_source.html#l00032">passRegistryTypeIDs</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassRegistry_8h_source.html#l00156">mlir::PassRegistration&lt; ConcretePass &gt;::PassRegistration()</a>.</p>

</div>
</div>
<a id="aa5c4edce10b597637635af55bb162477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c4edce10b597637635af55bb162477">&#9670;&nbsp;</a></span>registerPassManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerPassManagerCLOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a set of useful command-line options that can be used to configure a pass manager. </p>
<p>The values of these options can be applied via the 'applyPassManagerCLOptions' method below. </p>

<p class="definition">Definition at line <a class="el" href="PassManagerOptions_8cpp_source.html#l00140">140</a> of file <a class="el" href="PassManagerOptions_8cpp_source.html">PassManagerOptions.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00493">registerAndParseCLIOptions()</a>.</p>

</div>
</div>
<a id="a83965c855ad737422194336251348893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83965c855ad737422194336251348893">&#9670;&nbsp;</a></span>registerPassPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerPassPipeline </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#af4ccb1e7accf2ec0c57b1aea967ccd02">PassRegistryFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(const <a class="el" href="classmlir_1_1detail_1_1PassOptions.html">detail::PassOptions</a> &amp;)&gt;)&gt;&#160;</td>
          <td class="paramname"><em>optHandler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a specific dialect pipeline registry function with the system, typically used through the <a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> template. </p>

<p class="reference">Referenced by <a class="el" href="PassRegistry_8h_source.html#l00201">mlir::PassPipelineRegistration&lt; EmptyPipelineOptions &gt;::PassPipelineRegistration()</a>, and <a class="el" href="PassRegistry_8h_source.html#l00178">mlir::PassPipelineRegistration&lt; Options &gt;::PassPipelineRegistration()</a>.</p>

</div>
</div>
<a id="ab895c88d57833ccee805eb3233c04ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab895c88d57833ccee805eb3233c04ca6">&#9670;&nbsp;</a></span>registerROCDLDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerROCDLDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00218">218</a> of file <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html">ROCDLToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00147">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00063">registerAllGPUToLLVMIRTranslations()</a>, <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00225">registerROCDLDialectTranslation()</a>.</p>

</div>
</div>
<a id="a4e522221c6652cb1450a6a3803125534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e522221c6652cb1450a6a3803125534">&#9670;&nbsp;</a></span>registerROCDLDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerROCDLDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00225">225</a> of file <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html">ROCDLToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00419">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00218">registerROCDLDialectTranslation()</a>.</p>

</div>
</div>
<a id="ad6971e37634f3b392e868dc60aefab9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6971e37634f3b392e868dc60aefab9a">&#9670;&nbsp;</a></span>registerSPIRVDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerSPIRVDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the SPIR-V dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVMIRTranslation_8cpp_source.html#l00023">23</a> of file <a class="el" href="SPIRVToLLVMIRTranslation_8cpp_source.html">SPIRVToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00147">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00063">registerAllGPUToLLVMIRTranslations()</a>, <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="SPIRVToLLVMIRTranslation_8cpp_source.html#l00027">registerSPIRVDialectTranslation()</a>.</p>

</div>
</div>
<a id="a74395e0d79520f9e47d1467c7d4dcb25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74395e0d79520f9e47d1467c7d4dcb25">&#9670;&nbsp;</a></span>registerSPIRVDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerSPIRVDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the SPIR-V dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVMIRTranslation_8cpp_source.html#l00027">27</a> of file <a class="el" href="SPIRVToLLVMIRTranslation_8cpp_source.html">SPIRVToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00419">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="SPIRVToLLVMIRTranslation_8cpp_source.html#l00023">registerSPIRVDialectTranslation()</a>.</p>

</div>
</div>
<a id="a9ed913befc935e3b4b3e622838655b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed913befc935e3b4b3e622838655b30">&#9670;&nbsp;</a></span>registerTestRoundtripDebugSPIRV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerTestRoundtripDebugSPIRV </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00137">137</a> of file <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00102">roundTripModule()</a>.</p>

</div>
</div>
<a id="a2b336390b16983a364b2d95bd2a64a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b336390b16983a364b2d95bd2a64a2f">&#9670;&nbsp;</a></span>registerTestRoundtripSPIRV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerTestRoundtripSPIRV </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00126">126</a> of file <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00102">roundTripModule()</a>.</p>

</div>
</div>
<a id="a520bc0aa5f34c15a39f2202fdf521382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520bc0aa5f34c15a39f2202fdf521382">&#9670;&nbsp;</a></span>registerToCppTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerToCppTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Cpp_2TranslateRegistration_8cpp_source.html#l00026">26</a> of file <a class="el" href="Cpp_2TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00028">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="a003d72c96a8bffacc207ba165212e2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003d72c96a8bffacc207ba165212e2db">&#9670;&nbsp;</a></span>registerToLLVMIRTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerToLLVMIRTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00028">28</a> of file <a class="el" href="ConvertToLLVMIR_8cpp_source.html">ConvertToLLVMIR.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00028">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="af7f5d34c37689ae9b05537a040d9e0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f5d34c37689ae9b05537a040d9e0a0">&#9670;&nbsp;</a></span>registerToSPIRVTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerToSPIRVTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00086">86</a> of file <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00073">serializeModule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00028">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="a3a41d372a37300e7b09f82fbd8b2d425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a41d372a37300e7b09f82fbd8b2d425">&#9670;&nbsp;</a></span>registerTranslationCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerTranslationCLOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register command-line options used by the translation registry. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8cpp_source.html#l00039">39</a> of file <a class="el" href="Translation_8cpp_source.html">Translation.cpp</a>.</p>

<p class="reference">References <a class="el" href="Translation_8cpp_source.html#l00037">clOptions</a>.</p>

</div>
</div>
<a id="a8ea099d5836b931b596ca22c70878760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea099d5836b931b596ca22c70878760">&#9670;&nbsp;</a></span>registerVCIXDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerVCIXDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the VCIX dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry. </p>

<p class="definition">Definition at line <a class="el" href="VCIXToLLVMIRTranslation_8cpp_source.html#l00077">77</a> of file <a class="el" href="VCIXToLLVMIRTranslation_8cpp_source.html">VCIXToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00147">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="VCIXToLLVMIRTranslation_8cpp_source.html#l00084">registerVCIXDialectTranslation()</a>.</p>

</div>
</div>
<a id="a134adbd787b504667bef30d219adfed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134adbd787b504667bef30d219adfed8">&#9670;&nbsp;</a></span>registerVCIXDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerVCIXDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the VCIX dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="VCIXToLLVMIRTranslation_8cpp_source.html#l00084">84</a> of file <a class="el" href="VCIXToLLVMIRTranslation_8cpp_source.html">VCIXToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00419">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="VCIXToLLVMIRTranslation_8cpp_source.html#l00077">registerVCIXDialectTranslation()</a>.</p>

</div>
</div>
<a id="a06a06304b237de21b74a8c5b3251ac35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a06304b237de21b74a8c5b3251ac35">&#9670;&nbsp;</a></span>registerX86VectorDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerX86VectorDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the X86Vector dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="X86VectorToLLVMIRTranslation_8cpp_source.html#l00046">46</a> of file <a class="el" href="X86VectorToLLVMIRTranslation_8cpp_source.html">X86VectorToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00147">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00039">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="X86VectorToLLVMIRTranslation_8cpp_source.html#l00054">registerX86VectorDialectTranslation()</a>.</p>

</div>
</div>
<a id="a087d9cf09c9d93a0bf0f287509afc5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087d9cf09c9d93a0bf0f287509afc5b4">&#9670;&nbsp;</a></span>registerX86VectorDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerX86VectorDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the X86Vector dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="X86VectorToLLVMIRTranslation_8cpp_source.html#l00054">54</a> of file <a class="el" href="X86VectorToLLVMIRTranslation_8cpp_source.html">X86VectorToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00419">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="X86VectorToLLVMIRTranslation_8cpp_source.html#l00046">registerX86VectorDialectTranslation()</a>.</p>

</div>
</div>
<a id="a24aeba82a83b5f51bfe338ed5156887a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24aeba82a83b5f51bfe338ed5156887a">&#9670;&nbsp;</a></span>reifyResultShapes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::reifyResultShapes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0a5ee68dc80640e6ac9c4a6011d18bc1">ReifiedRankedShapedTypeDims</a> &amp;&#160;</td>
          <td class="paramname"><em>reifiedReturnShapes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reify the shape of the result of an operation (typically in terms of the shape of its operands). </p>

<p class="definition">Definition at line <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00026">26</a> of file <a class="el" href="InferTypeOpInterface_8cpp_source.html">InferTypeOpInterface.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00147">mlir::bufferization::allocateTensorForShapedValue()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00074">mlir::tensor::getOrCreateDestination()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00160">reifyOrComputeDynamicSizes()</a>, <a class="el" href="Padding_8cpp_source.html#l00153">mlir::linalg::rewriteAsPaddedOp()</a>, and <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00424">mlir::linalg::rewriteInDestinationPassingStyle()</a>.</p>

</div>
</div>
<a id="a1fa0a7e84eb2af3d70c98d59fc9ccbd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa0a7e84eb2af3d70c98d59fc9ccbd3">&#9670;&nbsp;</a></span>removeDuplicateExprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::removeDuplicateExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map with the same dimension and symbol count as <code>map</code>, but whose results are the unique affine expressions of <code>map</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00783">783</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01240">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00343">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l02229">canonicalizeLoopBounds()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l02517">mlir::affine::createCanonicalizedAffineForOp()</a>.</p>

</div>
</div>
<a id="a15a5d204dd78ac563241168e6b2e40eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a5d204dd78ac563241168e6b2e40eb">&#9670;&nbsp;</a></span>replaceAllUsesInRegionWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::replaceAllUsesInRegionWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all uses of <code>orig</code> within the given region with <code>replacement</code>. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00032">32</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00212">mlir::Value::getUses()</a>, and <a class="el" href="IR_2Region_8h_source.html#l00222">mlir::Region::isAncestor()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01606">mlir::affine::coalesceLoops()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01057">collapseParallelLoops()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01388">convertOmpParallel()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01331">OmpParallelOpConversionManager::OmpParallelOpConversionManager()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01230">stripmineSink()</a>, and <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01340">OmpParallelOpConversionManager::~OmpParallelOpConversionManager()</a>.</p>

</div>
</div>
<a id="a210a664ca21b677121c83e0589945a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210a664ca21b677121c83e0589945a86">&#9670;&nbsp;</a></span>replaceLoopNestWithNewYields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; scf::ForOp &gt; mlir::replaceLoopNestWithNewYields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>loopNest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newIterOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a70a2f522a6f1ebf6ac3b3ba85a12b9e4">NewYieldValuesFn</a> &amp;&#160;</td>
          <td class="paramname"><em>newYieldValuesFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replaceIterOperandsUsesInLoop</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a perfectly nested loop nest to yield new values from the innermost loop and propagating it up through the loop nest. </p>
<p>This function</p><ul>
<li>Expects <code>loopNest</code> to be a perfectly nested loop with outer most loop first and innermost loop last.</li>
<li><code>newIterOperands</code> are the initialization values to be used for the outermost loop</li>
<li><code>newYielValueFn</code> is the callback that generates the new values to be yielded from within the innermost loop.</li>
<li>The original loops are not erased, but are left in a "no-op" state where the body of the loop just yields the basic block arguments that correspond to the initialization values of a loop. The original loops are dead after this method.</li>
<li>If <code>replaceIterOperandsUsesInLoop</code> is true, all uses of the <code>newIterOperands</code> within the generated new loop are replaced with the corresponding <code><a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a></code> in the loop body. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00040">40</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a id="a64a364dd32a6190474be758d1a6b9d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a364dd32a6190474be758d1a6b9d5f">&#9670;&nbsp;</a></span>reshapeLikeShapesAreCompatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::reshapeLikeShapesAreCompatible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; LogicalResult(const Twine &amp;)&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>collapsedShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>expandedShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociationMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isExpandingReshape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that shapes of the reshaped types using following rule: if a dimension in the collapsed type is static, then the corresponding dimensions in the expanded shape should be a) static b) the product should be same as the collaped shape. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00227">227</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">emitError()</a>, and <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>.</p>

</div>
</div>
<a id="a9eb183dcb73d44f0e0aedb09b73c7fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb183dcb73d44f0e0aedb09b73c7fd7">&#9670;&nbsp;</a></span>runRegionDCE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::runRegionDCE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns success if any operations or arguments were deleted, failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00470">470</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00413">deleteDeadness()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00363">propagateLiveness()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8cpp_source.html#l01043">simplifyRegions()</a>.</p>

</div>
</div>
<a id="a37afe16f80bc8bacb6914dd6f0b869c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37afe16f80bc8bacb6914dd6f0b869c0">&#9670;&nbsp;</a></span>setupDebuggerExecutionContextHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::setupDebuggerExecutionContextHook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1tracing_1_1ExecutionContext.html">tracing::ExecutionContext</a> &amp;&#160;</td>
          <td class="paramname"><em>executionContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DebuggerExecutionContextHook_8cpp_source.html#l00361">361</a> of file <a class="el" href="DebuggerExecutionContextHook_8cpp_source.html">DebuggerExecutionContextHook.cpp</a>.</p>

<p class="reference">References <a class="el" href="DebuggerExecutionContextHook_8cpp_source.html#l00331">debuggerCallBackFunction()</a>, and <a class="el" href="ExecutionContext_8h_source.html#l00080">mlir::tracing::ExecutionContext::setCallback()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CLOptionsSetup_8cpp_source.html#l00080">mlir::tracing::InstallDebugHandler::Impl::Impl()</a>.</p>

</div>
</div>
<a id="acbf369c69cfb613cd018ef4ce188809c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf369c69cfb613cd018ef4ce188809c">&#9670;&nbsp;</a></span>simplifyAffineExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::simplifyAffineExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify an affine expression by flattening and some amount of simple analysis. </p>
<p>Simplify the affine expression by flattening it and reconstructing it.</p>
<p>This has complexity linear in the number of nodes in 'expr'. Returns the simplified expression, which is the same as the input expression if it can't be simplified. When <code>expr</code> is semi-affine, a simplified semi-affine expression is constructed in the sorted order of dimension and symbol positions. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01556">1556</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01038">getAffineExprFromFlatForm()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00033">mlir::AffineExpr::getContext()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01081">getSemiAffineExprFromFlatForm()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00212">mlir::AffineExpr::isPureAffine()</a>, <a class="el" href="AffineExprVisitor_8h_source.html#l00377">mlir::SimpleAffineExprFlattener::localExprs</a>, <a class="el" href="AffineExprVisitor_8h_source.html#l00362">mlir::SimpleAffineExprFlattener::operandExprStack</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00551">simplifySemiAffine()</a>, and <a class="el" href="AffineExprVisitor_8h_source.html#l00150">mlir::AffineExprVisitor&lt; SubClass, RetTy &gt;::walkPostOrder()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00245">createPrivateMemRef()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01581">getConstDifference()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00537">mlir::FlatLinearConstraints::getSliceBounds()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00513">isModOfModSubtraction()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00932">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00982">mlir::MutableAffineMap::simplify()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00773">simplifyAffineMap()</a>.</p>

</div>
</div>
<a id="a014d8e82c51794d145267690b2b5bd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014d8e82c51794d145267690b2b5bd58">&#9670;&nbsp;</a></span>simplifyAffineMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::simplifyAffineMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies an affine map by simplifying its underlying <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> results. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00773">773</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01240">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00343">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResults()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01556">simplifyAffineExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00215">mlir::affine::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01070">composeAffineMapAndOperands()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00036">mlir::affine::AffineValueMap::difference()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01840">generatePointWiseCopy()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00507">mlir::affine::MemRefAccess::getAccessMap()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00044">getCleanupLoopLowerBound()</a>.</p>

</div>
</div>
<a id="ad38fea8480dfb78d9d3bd0736ccbfa2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38fea8480dfb78d9d3bd0736ccbfa2e">&#9670;&nbsp;</a></span>simplifyRegions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::simplifyRegions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mergeBlocks</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a set of structural simplifications over the given regions. </p>
<p>This includes transformations like unreachable block elimination, dead argument elimination, as well as some other DCE. This function returns success if any of the regions were simplified, failure otherwise. The provided rewriter is used to notify callers of operation and block deletion. Structurally similar blocks will be merged if the <code>mergeBlock</code> argument is true. Note this can lead to merged blocks with extra arguments.</p>
<p>This includes transformations like unreachable block elimination, dead argument elimination, as well as some other DCE. This function returns success if any of the regions were simplified, failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l01043">1043</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00931">dropRedundantArguments()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00183">eraseUnreachableBlocks()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00850">mergeIdenticalBlocks()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00470">runRegionDCE()</a>.</p>

</div>
</div>
<a id="aa6e007ae66428f560626d4ba3c58dfe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e007ae66428f560626d4ba3c58dfe2">&#9670;&nbsp;</a></span>sinkOperationsIntoLaunchOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::sinkOperationsIntoLaunchOp </td>
          <td>(</td>
          <td class="paramtype">gpu::LaunchOp&#160;</td>
          <td class="paramname"><em>launchOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>isSinkingBeneficiary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sink operations into the <code>launchOp</code> to reduce the number of values that are used within the region of the operation, but defined outside of the region. </p>

<p class="definition">Definition at line <a class="el" href="KernelOutlining_8cpp_source.html#l00123">123</a> of file <a class="el" href="KernelOutlining_8cpp_source.html">KernelOutlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="KernelOutlining_8cpp_source.html#l00092">extractBeneficiaryOps()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00067">getUsedValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="a35009cf90a73229f64f9090d4e5aa2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35009cf90a73229f64f9090d4e5aa2b7">&#9670;&nbsp;</a></span>sortTopologically() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sortTopologically </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>isOperandReady</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a block, sort its operations in topological order, excluding its terminator if it has one. </p>
<p>This sort is stable. </p>

<p class="definition">Definition at line <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00102">102</a> of file <a class="el" href="TopologicalSortUtils_8cpp_source.html">TopologicalSortUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00150">mlir::Block::back()</a>, <a class="el" href="Block_8h_source.html#l00146">mlir::Block::empty()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00745">mlir::Operation::hasTrait()</a>, <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00056">sortTopologically()</a>, and <a class="el" href="Block_8h_source.html#l00207">mlir::Block::without_terminator()</a>.</p>

</div>
</div>
<a id="adb95f9dc749d6a604340f83fd16b19f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb95f9dc749d6a604340f83fd16b19f9">&#9670;&nbsp;</a></span>sortTopologically() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sortTopologically </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>isOperandReady</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a block, sort a range operations in said block in topological order. </p>
<p>The main purpose is readability of graph regions, potentially faster processing of certain transformations and analyses, or fixing the SSA dominance of blocks that require it after transformations. The function sorts the given operations such that, as much as possible, all users appear after their producers.</p>
<p>For example:</p>
<div class="fragment"><div class="line">%0 = test.foo</div>
<div class="line">%1 = test.bar %0, %2</div>
<div class="line">%2 = test.baz</div>
</div><!-- fragment --><p>Will become:</p>
<div class="fragment"><div class="line">%0 = test.foo</div>
<div class="line">%1 = test.baz</div>
<div class="line">%2 = test.bar %0, %1</div>
</div><!-- fragment --><p>The sort also works on operations with regions and implicit captures. For example:</p>
<div class="fragment"><div class="line">%0 = test.foo {</div>
<div class="line">  test.baz %1</div>
<div class="line">  %1 = test.bar %2</div>
<div class="line">}</div>
<div class="line">%2 = test.foo</div>
</div><!-- fragment --><p>Will become:</p>
<div class="fragment"><div class="line">%0 = test.foo</div>
<div class="line">%1 = test.foo {</div>
<div class="line">  test.baz %2</div>
<div class="line">  %2 = test.bar %0</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that the sort is not recursive on nested regions. This sort is stable; if the operations are already topologically sorted, nothing changes.</p>
<p>Operations that form cycles are moved to the end of the block in order. If the sort is left with only operations that form a cycle, it breaks the cycle by marking the first encountered operation as ready and moving on.</p>
<p>The function optionally accepts a callback that can be provided by users to virtually break cycles early. It is called on top-level operations in the block with value uses at or below those operations. The function should return true to mark that value as ready to be scheduled.</p>
<p>For example, if <code>isOperandReady</code> is set to always mark edges from <code>foo.A</code> to <code>foo.B</code> as ready, these operations:</p>
<div class="fragment"><div class="line">%0 = foo.B(%1)</div>
<div class="line">%1 = foo.C(%2)</div>
<div class="line">%2 = foo.A(%0)</div>
</div><!-- fragment --><p>Are sorted as:</p>
<div class="fragment"><div class="line">%0 = foo.A(%2)</div>
<div class="line">%1 = foo.C(%0)</div>
<div class="line">%2 = foo.B(%1)</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00056">56</a> of file <a class="el" href="TopologicalSortUtils_8cpp_source.html">TopologicalSortUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00102">sortTopologically()</a>.</p>

</div>
</div>
<a id="a715b8c35aa2d5155832ef2f0c09db693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715b8c35aa2d5155832ef2f0c09db693">&#9670;&nbsp;</a></span>splitAndProcessBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::splitAndProcessBuffer </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; llvm::MemoryBuffer &gt;&#160;</td>
          <td class="paramname"><em>originalBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aafb0c2458571cd80ebb876d979e24346">ChunkBufferHandler</a>&#160;</td>
          <td class="paramname"><em>processChunkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>inputSplitMarker</em> = <code><a class="el" href="namespacemlir.html#a1349a176f4860c35697f441e414bf358">kDefaultSplitMarker</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>outputSplitMarker</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits the specified buffer on a marker (<code>// -----</code> by default), processes each chunk independently according to the normal <code>processChunkBuffer</code> logic, and writes all results to <code>os</code>. </p>
<p>This is used to allow a large number of small independent tests to be put into a single file. The input split marker is configurable. If it is empty, merging is disabled, which allows for merging split and non-split code paths. Output split markers (<code>//-----</code> by default) followed by a new line character, respectively, are placed between each of the processed output chunks. (The new line character is inserted even if the split marker is empty.) </p>

<p class="definition">Definition at line <a class="el" href="ToolUtilities_8cpp_source.html#l00021">21</a> of file <a class="el" href="ToolUtilities_8cpp_source.html">ToolUtilities.cpp</a>.</p>

</div>
</div>
<a id="a1053fc52d14c30b033f053dd93383659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1053fc52d14c30b033f053dd93383659">&#9670;&nbsp;</a></span>storageClassToAddressSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::storageClassToAddressSpace </td>
          <td>(</td>
          <td class="paramtype">spirv::ClientAPI&#160;</td>
          <td class="paramname"><em>clientAPI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spirv::StorageClass&#160;</td>
          <td class="paramname"><em>storageClass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVCommon_2AttrToLLVMConverter_8cpp_source.html#l00051">51</a> of file <a class="el" href="SPIRVCommon_2AttrToLLVMConverter_8cpp_source.html">AttrToLLVMConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="Runtimes_8h_source.html#l00018">mlir::gpu::amd::OpenCL</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00273">convertPointerType()</a>.</p>

</div>
</div>
<a id="a528c0559f393f6206d80cdb29394fa1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528c0559f393f6206d80cdb29394fa1c">&#9670;&nbsp;</a></span>structFuncArgTypeConverter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::structFuncArgTypeConverter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to convert function argument types. </p>
<p>Give structFuncArgTypeConverter access to memref-specific functions.</p>
<p>It converts a MemRef function argument to a list of non-aggregate types containing descriptor information, and an UnrankedmemRef function argument to a list containing the rank and a pointer to a descriptor struct. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00730">730</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02683">mlir::LLVMTypeConverter::convertType()</a>.</p>

</div>
</div>
<a id="ae71592b6a57d95558cc2094b140ec445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71592b6a57d95558cc2094b140ec445">&#9670;&nbsp;</a></span>TableGenLspServerMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::TableGenLspServerMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation for tools like <code>tblgen-lsp-server</code>. </p>

<p class="definition">Definition at line <a class="el" href="TableGenLspServerMain_8cpp_source.html#l00020">20</a> of file <a class="el" href="TableGenLspServerMain_8cpp_source.html">TableGenLspServerMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581aa603905470e2a5b8c13e96b579ef0dba">mlir::lsp::Logger::Debug</a>, <a class="el" href="Transport_8h_source.html#l00043">mlir::lsp::Delimited</a>, <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581a902b0d55fddef6f8d651fe1035b7d4bd">mlir::lsp::Logger::Error</a>, <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581a4059b0251f66a18cb56f544728796875">mlir::lsp::Logger::Info</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="tblgen-lsp-server_2LSPServer_8cpp_source.html#l00190">mlir::lsp::runTableGenLSPServer()</a>, <a class="el" href="Logging_8cpp_source.html#l00017">mlir::lsp::Logger::setLogLevel()</a>, and <a class="el" href="Transport_8h_source.html#l00041">mlir::lsp::Standard</a>.</p>

</div>
</div>
<a id="aa109c04ae9443b1c88bd605dec0fa9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa109c04ae9443b1c88bd605dec0fa9b6">&#9670;&nbsp;</a></span>thread_safe_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::raw_ostream &amp; mlir::thread_safe_nulls </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a raw output stream that simply discards the output, but in a thread-safe manner. </p>
<p>Similar to llvm::nulls. </p>

<p class="definition">Definition at line <a class="el" href="RawOstreamExtras_8cpp_source.html#l00012">12</a> of file <a class="el" href="RawOstreamExtras_8cpp_source.html">RawOstreamExtras.cpp</a>.</p>

</div>
</div>
<a id="ab15bd4c107bb9ea52b7fcc11c283c129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15bd4c107bb9ea52b7fcc11c283c129">&#9670;&nbsp;</a></span>tile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>, 8 &gt; mlir::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>forOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>targets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs tiling fo imperfectly nested loops (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under each of the <code>targets</code>. </p>
<p>Returns the new AffineForOps, one per each of (<code>forOps</code>, <code>targets</code>) pair, nested immediately under each of <code>targets</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01278">1278</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01230">stripmineSink()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01318">extractFixedOuterLoops()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01146">mlir::linalg::GeneralizeOuterUnitDimsPackOpPattern::matchAndRewrite()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00477">mlir::linalg::pack()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01291">tile()</a>.</p>

</div>
</div>
<a id="adb3ac25a4d763e0e5234f6b347c7f17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3ac25a4d763e0e5234f6b347c7f17a">&#9670;&nbsp;</a></span>tile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a> mlir::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>forOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs tiling (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under <code>target</code>. </p>
<p>Returns the new AffineForOps, one per <code>forOps</code>, nested immediately under <code>target</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01291">1291</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01278">tile()</a>.</p>

</div>
</div>
<a id="a76588ffa46e04caaa584360fa5cdde4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76588ffa46e04caaa584360fa5cdde4c">&#9670;&nbsp;</a></span>tilePerfectlyNested()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a> mlir::tilePerfectlyNested </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>rootForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile a nest of scf::ForOp loops rooted at <code>rootForOp</code> with the given (parametric) sizes. </p>
<p>Sizes are expected to be strictly positive values at runtime. If more sizes than loops are provided, discard the trailing values in sizes. Assumes the loop nest is permutable. Returns the newly created intra-tile loops. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01301">1301</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01215">getPerfectlyNestedLoopsImpl()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01583">mlir::affine::tile()</a>.</p>

</div>
</div>
<a id="afbb30909b4006046e7b4248b8d5a5a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb30909b4006046e7b4248b8d5a5a26">&#9670;&nbsp;</a></span>topologicalSort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::topologicalSort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>toSort</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts all operations in <code>toSort</code> topologically while also considering region semantics. </p>
<p>Does not support multi-sets. </p>

<p class="definition">Definition at line <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00283">283</a> of file <a class="el" href="TopologicalSortUtils_8cpp_source.html">TopologicalSortUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l00136">destructureSlot()</a>, and <a class="el" href="LoopFusionUtils_8cpp_source.html#l00358">promoteSingleIterReductionLoop()</a>.</p>

</div>
</div>
<a id="a23e5dd60111e86e0df4b52a7d3befd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e5dd60111e86e0df4b52a7d3befd33">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef mlir::toString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#ac84871bcca0aaa0176d43dbdbffe9a6c">AsmResourceEntryKind</a>&#160;</td>
          <td class="paramname"><em>kind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l01732">1732</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsmParserImpl_8h_source.html#l00261">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseBase64Bytes()</a>, and <a class="el" href="BytecodeReader_8cpp_source.html#l01631">mlir::BytecodeReader::Impl::read()</a>.</p>

</div>
</div>
<a id="af7fbeb913d35e020e382b9f6c82a2fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7fbeb913d35e020e382b9f6c82a2fa8">&#9670;&nbsp;</a></span>trailingNDimsContiguous()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::trailingNDimsContiguous </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return "true" if the last N dimensions of the given type are contiguous. </p>
<p>Examples:</p><ul>
<li>memref&lt;5x4x3x2xi8, strided&lt;[24, 6, 2, 1]&gt; is contiguous when considering both <em>all</em> and <em>only</em> the trailing 3 dims,</li>
<li>memref&lt;5x4x3x2xi8, strided&lt;[48, 6, 2, 1]&gt; is <em>only</em> contiguous when considering the trailing 3 dims. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00987">987</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00823">getStridesAndOffset()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00980">isLastMemrefDimUnitStride()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorUtils_8cpp_source.html#l00257">mlir::vector::isContiguousSlice()</a>.</p>

</div>
</div>
<a id="a7c9887613b4e793d34591b00a9732c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9887613b4e793d34591b00a9732c03">&#9670;&nbsp;</a></span>transformCFGToSCF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; bool &gt; mlir::transformCFGToSCF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1CFGToSCFInterface.html">CFGToSCFInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>dominanceInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transformation lifting any dialect implementing control flow graph operations to a dialect implementing structured control flow operations. </p>
<p><code>region</code> is the region that should be transformed. The implementation of <code>interface</code> is responsible for the conversion of the control flow operations to the structured control flow operations.</p>
<p>If the region contains only a single kind of return-like operation, all control flow graph operations will be converted successfully. Otherwise a single control flow graph operation branching to one block per return-like operation kind remains.</p>
<p>The transformation currently requires that all control flow graph operations have no side effects, implement the BranchOpInterface and does not have any operation produced successor operands. Returns failure if any of the preconditions are violated or if any of the methods of <code>interface</code> failed. The IR is left in an unspecified state.</p>
<p>Otherwise, returns true or false if any changes to the IR have been made. </p>

<p class="definition">Definition at line <a class="el" href="CFGToSCF_8cpp_source.html#l01276">1276</a> of file <a class="el" href="CFGToSCF_8cpp_source.html">CFGToSCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00248">mlir::OpBuilder::atBlockBegin()</a>, <a class="el" href="CFGToSCF_8cpp_source.html#l01229">checkTransformationPreconditions()</a>, <a class="el" href="CFGToSCF_8cpp_source.html#l01213">createSingleExitBlocksForReturnLike()</a>, <a class="el" href="IR_2Region_8h_source.html#l00060">mlir::Region::empty()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="classmlir_1_1CFGToSCFInterface.html#a4e08775d01751ceca749ca511f67b628">mlir::CFGToSCFInterface::getCFGSwitchValue()</a>, <a class="el" href="IR_2Region_8cpp_source.html#l00031">mlir::Region::getLoc()</a>, <a class="el" href="Block_8cpp_source.html#l00026">mlir::Block::getParent()</a>, <a class="el" href="classmlir_1_1CFGToSCFInterface.html#a951d10ba77059063fb5bf916e5d1dc47">mlir::CFGToSCFInterface::getUndefValue()</a>, <a class="el" href="IR_2Region_8h_source.html#l00068">mlir::Region::hasOneBlock()</a>, <a class="el" href="Dominance_8cpp_source.html#l00037">mlir::detail::DominanceInfoBase&lt; IsPostDom &gt;::invalidate()</a>, <a class="el" href="CFGToSCF_8cpp_source.html#l00803">transformCyclesToSCFLoops()</a>, and <a class="el" href="CFGToSCF_8cpp_source.html#l00950">transformToStructuredCFBranches()</a>.</p>

</div>
</div>
<a id="a2f93379e5dbb5551bbe57170230a1d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f93379e5dbb5551bbe57170230a1d92">&#9670;&nbsp;</a></span>translateDataLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataLayoutSpecInterface mlir::translateDataLayout </td>
          <td>(</td>
          <td class="paramtype">const llvm::DataLayout &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate the given <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> data layout into an MLIR equivalent using the DLTI dialect. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutImporter_8cpp_source.html#l00327">327</a> of file <a class="el" href="DataLayoutImporter_8cpp_source.html">DataLayoutImporter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutImporter_8h_source.html#l00056">mlir::LLVM::detail::DataLayoutImporter::getDataLayout()</a>.</p>

</div>
</div>
<a id="a1617ff95451ab9fa7888fbbe841e8193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1617ff95451ab9fa7888fbbe841e8193">&#9670;&nbsp;</a></span>translateLLVMIRToModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt; mlir::translateLLVMIRToModule </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; llvm::Module &gt;&#160;</td>
          <td class="paramname"><em>llvmModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>emitExpensiveWarnings</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dropDICompositeTypeElements</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> module into an MLIR module living in the given context. </p>
<p>The translation supports operations from any dialect that has a registered implementation of the <a class="el" href="classmlir_1_1LLVMImportDialectInterface.html" title="Base class for dialect interfaces used to import LLVM IR.">LLVMImportDialectInterface</a>. It returns nullptr if the translation fails and reports errors using the error handler registered with the MLIR context. The <code>emitExpensiveWarnings</code> option controls if expensive but uncritical diagnostics should be emitted. The <code>dropDICompositeTypeElements</code> option controls if DICompositeTypes should be imported without elements. If set, the option avoids the recursive traversal of composite type debug information, which can be expensive for adversarial inputs. </p>

<p class="definition">Definition at line <a class="el" href="ModuleImport_8cpp_source.html#l02202">2202</a> of file <a class="el" href="ModuleImport_8cpp_source.html">ModuleImport.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleImport_8cpp_source.html#l00587">mlir::LLVM::ModuleImport::convertComdats()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00615">mlir::LLVM::ModuleImport::convertDataLayout()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00630">mlir::LLVM::ModuleImport::convertFunctions()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00597">mlir::LLVM::ModuleImport::convertGlobals()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00538">mlir::LLVM::ModuleImport::convertMetadata()</a>, <a class="el" href="OwningOpRef_8h_source.html#l00051">mlir::OwningOpRef&lt; OpTy &gt;::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">get()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00448">mlir::MLIRContext::getAvailableDialects()</a>, <a class="el" href="ModuleImport_8h_source.html#l00056">mlir::LLVM::ModuleImport::initializeImportInterface()</a>, and <a class="el" href="MLIRContext_8cpp_source.html#l00575">mlir::MLIRContext::loadAllAvailableDialects()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00027">registerFromLLVMIRTranslation()</a>.</p>

</div>
</div>
<a id="a077184b26527c49e3469c2c25ff73861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077184b26527c49e3469c2c25ff73861">&#9670;&nbsp;</a></span>translateModuleToLLVMIR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::Module&gt; mlir::translateModuleToLLVMIR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>llvmContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;LLVMDialectModule&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disableVerification</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates a given <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect <code>module</code> into an <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR module living in the given context. </p>
<p>Operates on any operation from dialects that provide a registered implementation of the <a class="el" href="classmlir_1_1LLVMTranslationDialectInterface.html" title="Base class for dialect interfaces providing translation to LLVM IR.">LLVMTranslationDialectInterface</a>. Returns nullptr when the translation fails. Verifies the produced <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> module, except when <code>disableVerification</code> is set. </p>

<p class="reference">Referenced by <a class="el" href="LLVMIR_8cpp_source.html#l00024">mlirTranslateModuleToLLVMIR()</a>, and <a class="el" href="ModuleToObject_8cpp_source.html#l00106">mlir::LLVM::ModuleToObject::translateToLLVMIR()</a>.</p>

</div>
</div>
<a id="ad4695076b1d2f75930c85058c6b42084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4695076b1d2f75930c85058c6b42084">&#9670;&nbsp;</a></span>tryToDestructureMemorySlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::tryToDestructureMemorySlots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DestructurableAllocationOpInterface &gt;&#160;</td>
          <td class="paramname"><em>allocators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1SROAStatistics.html">SROAStatistics</a>&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to destructure the slots of destructurable allocators. </p>
<p>Iteratively retries the destructuring of all slots as destructuring one slot might enable subsequent destructuring. Returns failure if no slot was destructured. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l00197">197</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SROA_8cpp_source.html#l00047">computeDestructuringInfo()</a>, and <a class="el" href="SROA_8cpp_source.html#l00136">destructureSlot()</a>.</p>

</div>
</div>
<a id="ae2434626306ac343fdef7bf1e3c10459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2434626306ac343fdef7bf1e3c10459">&#9670;&nbsp;</a></span>tryToPromoteMemorySlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::tryToPromoteMemorySlots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; PromotableAllocationOpInterface &gt;&#160;</td>
          <td class="paramname"><em>allocators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>dominance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Mem2RegStatistics.html">Mem2RegStatistics</a>&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to promote the memory slots of the provided allocators. </p>
<p>Iteratively retries the promotion of all slots as promoting one slot might enable subsequent promotions. Succeeds if at least one memory slot was promoted. </p>

<p class="definition">Definition at line <a class="el" href="Mem2Reg_8cpp_source.html#l00643">643</a> of file <a class="el" href="Mem2Reg_8cpp_source.html">Mem2Reg.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemorySlotInterfaces_8h_source.html#l00022">mlir::MemorySlot::ptr</a>, and <a class="el" href="Value_8h_source.html#l00218">mlir::Value::use_empty()</a>.</p>

</div>
</div>
<a id="ae4b1ba650fd43b50351e92bbb75bd4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b1ba650fd43b50351e92bbb75bd4c0">&#9670;&nbsp;</a></span>verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::verify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verifyRecursively</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform (potentially expensive) checks of invariants, used to detect compiler bugs, on this operation and any nested operations. </p>
<p>On error, this reports the error through the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> and returns failure. If <code>verifyRecursively</code> is false, this assumes that nested operations have already been properly verified, and does not recursively invoke the verifier on nested operations. </p>

<p class="definition">Definition at line <a class="el" href="Verifier_8cpp_source.html#l00426">426</a> of file <a class="el" href="Verifier_8cpp_source.html">Verifier.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00897">applyPatternsAndFoldGreedily()</a>, <a class="el" href="MLIRGen_8cpp_source.html#l00624">mlir::pdll::codegenPDLLToMLIR()</a>, <a class="el" href="Tester_8cpp_source.html#l00027">mlir::Tester::isInteresting()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l01144">mlir::detail::Parser::parseStridedLayoutAttr()</a>, <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00090">mlir::transform::detail::parseTransformModuleFromFile()</a>, <a class="el" href="ExtensibleDialect_8h_source.html#l00400">mlir::DynamicOpDefinition::setVerifyFn()</a>, <a class="el" href="ExtensibleDialect_8h_source.html#l00407">mlir::DynamicOpDefinition::setVerifyRegionFn()</a>, <a class="el" href="RunnerUtils_8h_source.html#l00290">impl::MemRefDataVerifier&lt; T &gt;::verify()</a>, <a class="el" href="MlirOptMain_8h_source.html#l00173">mlir::MlirOptMainConfig::verifyDiagnostics()</a>, <a class="el" href="MlirOptMain_8h_source.html#l00180">mlir::MlirOptMainConfig::verifyPasses()</a>, and <a class="el" href="MlirOptMain_8h_source.html#l00187">mlir::MlirOptMainConfig::verifyRoundtrip()</a>.</p>

</div>
</div>
<a id="a961cf9926486f7d6e7160efa8f846d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961cf9926486f7d6e7160efa8f846d64">&#9670;&nbsp;</a></span>verifyCompatibleDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::verifyCompatibleDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>dims</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dimensions are compatible if all non-dynamic dims are equal. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00104">104</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeUtilities_8cpp_source.html#l00120">verifyCompatibleShapes()</a>.</p>

</div>
</div>
<a id="acb414ad1d507c2ab841305c273f4deb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb414ad1d507c2ab841305c273f4deb8">&#9670;&nbsp;</a></span>verifyCompatibleShape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::verifyCompatibleShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns success if the given two shapes are compatible. </p>
<p>That is, they have the same size and each pair of the elements are equal or one of them is dynamic. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00058">58</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeUtilities_8cpp_source.html#l00077">verifyCompatibleShape()</a>, and <a class="el" href="TypeUtilities_8cpp_source.html#l00095">verifyCompatibleShapes()</a>.</p>

</div>
</div>
<a id="ac54e5e6c31f51ef648f7c03652a29ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54e5e6c31f51ef648f7c03652a29ce6">&#9670;&nbsp;</a></span>verifyCompatibleShape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::verifyCompatibleShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns success if the given two types have compatible shape. </p>
<p>That is, they are both scalars (not shaped), or they are both shaped types and at least one is unranked or they have compatible dimensions. Dimensions are compatible if at least one is dynamic or both are equal. The element type does not matter. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00077">77</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeUtilities_8cpp_source.html#l00058">verifyCompatibleShape()</a>.</p>

</div>
</div>
<a id="a132fff065736d8e977fe8179f2e7086c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132fff065736d8e977fe8179f2e7086c">&#9670;&nbsp;</a></span>verifyCompatibleShapes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::verifyCompatibleShapes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns success if all given types have compatible shapes. </p>
<p>That is, they are all scalars (not shaped), or they are all shaped types and any ranked shapes have compatible dimensions. The element type does not matter.</p>
<p>That is, they are all scalars (not shaped), or they are all shaped types and any ranked shapes have compatible dimensions. Dimensions are compatible if all non-dynamic dims are equal. The element type does not matter. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00120">120</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeUtilities_8cpp_source.html#l00104">verifyCompatibleDims()</a>.</p>

</div>
</div>
<a id="a2801a1733326688cf0c9bee8d633f234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2801a1733326688cf0c9bee8d633f234">&#9670;&nbsp;</a></span>verifyCompatibleShapes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::verifyCompatibleShapes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>types1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>types2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns success if the given two arrays have the same number of elements and each pair wise entries have compatible shape. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00095">95</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeUtilities_8cpp_source.html#l00058">verifyCompatibleShape()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithOps_8cpp_source.html#l01263">areValidCastInputsAndOutputs()</a>.</p>

</div>
</div>
<a id="ad1a1c57fc94caa37e2b98499a48eea86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a1c57fc94caa37e2b98499a48eea86">&#9670;&nbsp;</a></span>verifyListOfOperandsOrIntegers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::verifyListOfOperandsOrIntegers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>expectedNumElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that a the <code>values</code> has as many elements as the number of entries in <code>attr</code> for which <code>isDynamic</code> evaluates to true. </p>
<p>Include the definitions of the loop-like interfaces. </p>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00020">20</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

</div>
</div>
<a id="a59e37ef38e035b072204c4cc6f2bc6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e37ef38e035b072204c4cc6f2bc6a5">&#9670;&nbsp;</a></span>verifyReshapeLikeTypes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult mlir::verifyReshapeLikeTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Op.html">Op</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>expandedType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>collapsedType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isExpansion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common verifier for reshape-like types. </p>
<p>Fills <code>expandedType</code> and <code>collapsedType</code> with the proper <code>src</code> or <code>result</code> type. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00137">137</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

</div>
</div>
<a id="a036e7ce3c7c3bf73fc0a653cd98bb7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036e7ce3c7c3bf73fc0a653cd98bb7c0">&#9670;&nbsp;</a></span>visitUsedValuesDefinedAbove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::visitUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <code>callback</code> for each use of a value within any of the regions provided that was defined in one of the ancestors. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00061">61</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00040">visitUsedValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="ae644ec0854505ef60f12c23b96de595b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae644ec0854505ef60f12c23b96de595b">&#9670;&nbsp;</a></span>visitUsedValuesDefinedAbove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::visitUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <code>callback</code> for each use of a value within <code>region</code> or its descendants that was defined at the ancestors of the <code>limit</code>. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00040">40</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8cpp_source.html#l00045">mlir::Region::getParentRegion()</a>, <a class="el" href="IR_2Region_8h_source.html#l00222">mlir::Region::isAncestor()</a>, and <a class="el" href="IR_2Region_8h_source.html#l00285">mlir::Region::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8cpp_source.html#l00067">getUsedValuesDefinedAbove()</a>, <a class="el" href="SCFTransformOps_8cpp_source.html#l00465">isOpSibling()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00061">visitUsedValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="a95bf64684e4364416fb8d648c251d41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95bf64684e4364416fb8d648c251d41b">&#9670;&nbsp;</a></span>walkSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1WalkContinuation.html">WalkContinuation</a> mlir::walkSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">mlir::ValueRange</a>&#160;</td>
          <td class="paramname"><em>rootValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#afb40c25041db8d506e4b23fb8c86d5c6">WalkCallback</a>&#160;</td>
          <td class="paramname"><em>walkCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walks the slice starting from the <code>rootValues</code> using a depth-first traversal. </p>
<p>The walk calls the provided <code>walkCallback</code> for each value encountered in the slice and uses the returned walk continuation to determine how to proceed. </p>

<p class="definition">Definition at line <a class="el" href="SliceWalk_8cpp_source.html#l00006">6</a> of file <a class="el" href="SliceWalk_8cpp_source.html">SliceWalk.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceWalk_8h_source.html#l00069">mlir::WalkContinuation::getNextValues()</a>, <a class="el" href="SliceWalk_8h_source.html#l00055">mlir::WalkContinuation::skip()</a>, <a class="el" href="SliceWalk_8h_source.html#l00066">mlir::WalkContinuation::wasAdvancedTo()</a>, <a class="el" href="SliceWalk_8h_source.html#l00060">mlir::WalkContinuation::wasInterrupted()</a>, and <a class="el" href="SliceWalk_8h_source.html#l00063">mlir::WalkContinuation::wasSkipped()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InlinerInterfaceImpl_8cpp_source.html#l00229">getUnderlyingObjectSet()</a>.</p>

</div>
</div>
<a id="a655db45ed8c23d04d5ed5ee0abe041ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655db45ed8c23d04d5ed5ee0abe041ad">&#9670;&nbsp;</a></span>wouldOpBeTriviallyDead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::wouldOpBeTriviallyDead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the given operation would be dead if unused, and has no side effects on memory that would prevent erasing. </p>
<p>This is equivalent to checking <code>isOpTriviallyDead</code> if <code>op</code> was unused.</p>
<p>Note: Terminators and symbols are never considered to be trivially dead. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00301">301</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

</div>
</div>
<a id="ae17b909cf0c32c717226432e6a65f61e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17b909cf0c32c717226432e6a65f61e">&#9670;&nbsp;</a></span>writeBytecodeToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::writeBytecodeToFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1BytecodeWriterConfig.html">BytecodeWriterConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the bytecode for the given operation to the provided output stream. </p>
<p>For streams where it matters, the given stream should be in "binary" mode. It only ever fails if setDesiredByteCodeVersion can't be honored. </p>

<p class="definition">Definition at line <a class="el" href="BytecodeWriter_8cpp_source.html#l01345">1345</a> of file <a class="el" href="BytecodeWriter_8cpp_source.html">BytecodeWriter.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a52f52f0c5e268decd5b4ff95c42ea054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f52f0c5e268decd5b4ff95c42ea054">&#9670;&nbsp;</a></span>has_sub_attr_or_type_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mlir::has_sub_attr_or_type_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    (!llvm::is_detected&lt;detail::has_default_sub_element_handler_t, Ts&gt;::value ||</div>
<div class="line">     ...)</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00417">417</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttrTypeSubElements_8h_source.html#l00557">mlir::detail::replaceImmediateSubElementsImpl()</a>, and <a class="el" href="AttrTypeSubElements_8h_source.html#l00518">mlir::detail::walkImmediateSubElementsImpl()</a>.</p>

</div>
</div>
<a id="a1349a176f4860c35697f441e414bf358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1349a176f4860c35697f441e414bf358">&#9670;&nbsp;</a></span>kDefaultSplitMarker</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* const mlir::kDefaultSplitMarker = &quot;// -----&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2887883f00b094c5ca61c631d7b093a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2887883f00b094c5ca61c631d7b093a0">&#9670;&nbsp;</a></span>kDeriveIndexBitwidthFromDataLayout</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned mlir::kDeriveIndexBitwidthFromDataLayout = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> to pass as bitwidth for the index type when the converter is expected to derive the bitwidth from the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> data layout. </p>

<p class="definition">Definition at line <a class="el" href="LoweringOptions_8h_source.html#l00026">26</a> of file <a class="el" href="LoweringOptions_8h_source.html">LoweringOptions.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoweringOptions_8h_source.html#l00059">mlir::LowerToLLVMOptions::overrideIndexBitwidth()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 7 2024 08:32:18 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
