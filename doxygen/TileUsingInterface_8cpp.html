<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/SCF/Transforms/TileUsingInterface.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">20.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_d7bf56b426f340e7a9442bd07d045545.html">SCF</a></li><li class="navelem"><a class="el" href="dir_c5fb1dbd194462dcd31045c7634a832a.html">Transforms</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TileUsingInterface.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="TileUsingInterface_8h_source.html">mlir/Dialect/SCF/Transforms/TileUsingInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Arith_2IR_2Arith_8h_source.html">mlir/Dialect/Arith/IR/Arith.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Arith_2Utils_2Utils_8h_source.html">mlir/Dialect/Arith/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="FuncOps_8h_source.html">mlir/Dialect/Func/IR/FuncOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html">mlir/Dialect/SCF/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Tensor_2IR_2Tensor_8h_source.html">mlir/Dialect/Tensor/IR/Tensor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IndexingUtils_8h_source.html">mlir/Dialect/Utils/IndexingUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dominance_8h_source.html">mlir/IR/Dominance.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Matchers_8h_source.html">mlir/IR/Matchers.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">mlir/IR/PatternMatch.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DestinationStyleOpInterface_8h_source.html">mlir/Interfaces/DestinationStyleOpInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TilingInterface_8h_source.html">mlir/Interfaces/TilingInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="FrozenRewritePatternSet_8h_source.html">mlir/Rewrite/FrozenRewritePatternSet.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="GreedyPatternRewriteDriver_8h_source.html">mlir/Transforms/GreedyPatternRewriteDriver.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/TypeSwitch.h&quot;</code><br />
<code>#include &quot;llvm/Support/Debug.h&quot;</code><br />
<code>#include &lt;optional&gt;</code><br />
</div>
<p><a href="TileUsingInterface_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;tile-using-interface&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a505d4f42e1beb901ab163d108b0c8db9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a> = std::function&lt; LogicalResult(<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newBbArgs, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;tiledValues, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt; &amp;resultOffsets, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt; &amp;resultSizes)&gt;</td></tr>
<tr class="memdesc:a505d4f42e1beb901ab163d108b0c8db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that allows returning additional yielded values during <code>yieldTiledValuesAndReplace</code>.  <a href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">More...</a><br /></td></tr>
<tr class="separator:a505d4f42e1beb901ab163d108b0c8db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0b0f1d605335ebbc8fafee8571e85d7f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a0b0f1d605335ebbc8fafee8571e85d7f">fillInterchangeVector</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; interchangeVector, size_t iterationDomainSize)</td></tr>
<tr class="memdesc:a0b0f1d605335ebbc8fafee8571e85d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to adjust the interchange vector to match the iteration domain.  <a href="TileUsingInterface_8cpp.html#a0b0f1d605335ebbc8fafee8571e85d7f">More...</a><br /></td></tr>
<tr class="separator:a0b0f1d605335ebbc8fafee8571e85d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14af9e169e5c3e9655ff5d55ea0cfede"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a14af9e169e5c3e9655ff5d55ea0cfede">verifyTileSizeOptions</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, const <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html">scf::SCFTilingOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a14af9e169e5c3e9655ff5d55ea0cfede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the tile size options are set in a consistent manner.  <a href="TileUsingInterface_8cpp.html#a14af9e169e5c3e9655ff5d55ea0cfede">More...</a><br /></td></tr>
<tr class="separator:a14af9e169e5c3e9655ff5d55ea0cfede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad85bf3fd0f4e53a5ad346ef48397438"><td class="memItemLeft" align="right" valign="top">static std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#aad85bf3fd0f4e53a5ad346ef48397438">getUserTileSizesAndNumThreads</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; iterationDomain, const <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html">scf::SCFTilingOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:aad85bf3fd0f4e53a5ad346ef48397438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to instantiate the tile sizes and/or number of threads specified by the user.  <a href="TileUsingInterface_8cpp.html#aad85bf3fd0f4e53a5ad346ef48397438">More...</a><br /></td></tr>
<tr class="separator:aad85bf3fd0f4e53a5ad346ef48397438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f120026f0543a159d581745ebe012a7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a9f120026f0543a159d581745ebe012a7">checkSafeToTileToForall</a> (TilingInterface op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads)</td></tr>
<tr class="memdesc:a9f120026f0543a159d581745ebe012a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any of the tiled loops are not parallel.  <a href="TileUsingInterface_8cpp.html#a9f120026f0543a159d581745ebe012a7">More...</a><br /></td></tr>
<tr class="separator:a9f120026f0543a159d581745ebe012a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6dd85d4816fccaea1880b659d13c74"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#abb6dd85d4816fccaea1880b659d13c74">tileDividesIterationDomain</a> (<a class="el" href="structmlir_1_1Range.html">Range</a> loopRange)</td></tr>
<tr class="memdesc:abb6dd85d4816fccaea1880b659d13c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>stride</code> evenly divides the trip count <code>size - offset</code>.  <a href="TileUsingInterface_8cpp.html#abb6dd85d4816fccaea1880b659d13c74">More...</a><br /></td></tr>
<tr class="separator:abb6dd85d4816fccaea1880b659d13c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880e291006bd7a102432578ee0957069"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a880e291006bd7a102432578ee0957069">getBoundedTileSize</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="structmlir_1_1Range.html">Range</a> loopRange, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> offset, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> tileSize)</td></tr>
<tr class="memdesc:a880e291006bd7a102432578ee0957069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bounded tile size given the current <code>offset</code>, <code>loopRange</code> and <code>tileSize</code>, i.e., <code>min(tileSize, range.end() - offset)</code>.  <a href="TileUsingInterface_8cpp.html#a880e291006bd7a102432578ee0957069">More...</a><br /></td></tr>
<tr class="separator:a880e291006bd7a102432578ee0957069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5414ba15ec7505cbe18cda75476c7082"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a5414ba15ec7505cbe18cda75476c7082">canOmitTileOffsetInBoundsCheck</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> tileSize, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> numThreads, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> iterationSize)</td></tr>
<tr class="memdesc:a5414ba15ec7505cbe18cda75476c7082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the maximum tile offset <code>tileSize * numThreads-1</code> is less than <code>iterationSize</code>.  <a href="TileUsingInterface_8cpp.html#a5414ba15ec7505cbe18cda75476c7082">More...</a><br /></td></tr>
<tr class="separator:a5414ba15ec7505cbe18cda75476c7082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c940c8e51be1cf412745431d087056"><td class="memItemLeft" align="right" valign="top">static std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a86c940c8e51be1cf412745431d087056">getTileOffsetAndSizes</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; iterationDomain, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads)</td></tr>
<tr class="memdesc:a86c940c8e51be1cf412745431d087056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the <code>OpFoldResult</code>s that represents the multi-dimensional <code>offset</code>s and <code>size</code>s of the tile of the iteration space that the innermost loop body of the generated tiled loops corresponds to.  <a href="TileUsingInterface_8cpp.html#a86c940c8e51be1cf412745431d087056">More...</a><br /></td></tr>
<tr class="separator:a86c940c8e51be1cf412745431d087056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda80cd33074b6273520daf966406fa8"><td class="memItemLeft" align="right" valign="top">static std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#abda80cd33074b6273520daf966406fa8">getLoopBounds</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; loopRanges, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes)</td></tr>
<tr class="memdesc:abda80cd33074b6273520daf966406fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to return the bounds of the loops to be generated.  <a href="TileUsingInterface_8cpp.html#abda80cd33074b6273520daf966406fa8">More...</a><br /></td></tr>
<tr class="separator:abda80cd33074b6273520daf966406fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac306562a8fbc59e01746c58da2cdd7ed"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#ac306562a8fbc59e01746c58da2cdd7ed">cloneOpAndUpdateDestinationArgs</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newDestArgs)</td></tr>
<tr class="memdesc:ac306562a8fbc59e01746c58da2cdd7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones the operation and updates the destination if the operation implements the <code>DestinationStyleOpInterface</code>.  <a href="TileUsingInterface_8cpp.html#ac306562a8fbc59e01746c58da2cdd7ed">More...</a><br /></td></tr>
<tr class="separator:ac306562a8fbc59e01746c58da2cdd7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2945e64b5676eb54ff016a7ba1eee5"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a8b2945e64b5676eb54ff016a7ba1eee5">generateLoopNestUsingForOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; loopRanges, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> destinationTensors, <a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a> yieldTiledValuesFn, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; LoopLikeOpInterface &gt; &amp;loops)</td></tr>
<tr class="memdesc:a8b2945e64b5676eb54ff016a7ba1eee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the tile-loop nest using <code>scf.for</code> operation.  <a href="TileUsingInterface_8cpp.html#a8b2945e64b5676eb54ff016a7ba1eee5">More...</a><br /></td></tr>
<tr class="separator:a8b2945e64b5676eb54ff016a7ba1eee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68c84503ecbbb94571d6f8f72d636a2"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#af68c84503ecbbb94571d6f8f72d636a2">generateLoopNestUsingForallOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; loopRanges, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; mappingVector, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> destinationTensors, <a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a> tiledBodyFn, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; LoopLikeOpInterface &gt; &amp;loops)</td></tr>
<tr class="memdesc:af68c84503ecbbb94571d6f8f72d636a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the tile-loop nest using <code>scf.forall</code> operation.  <a href="TileUsingInterface_8cpp.html#af68c84503ecbbb94571d6f8f72d636a2">More...</a><br /></td></tr>
<tr class="separator:af68c84503ecbbb94571d6f8f72d636a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ddc49055cfe22ac09d348a0e6220e0"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#ab5ddc49055cfe22ac09d348a0e6220e0">generateLoopNest</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, const <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html">scf::SCFTilingOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; loopRanges, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> destinationTensors, <a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a> tiledBodyFn, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; LoopLikeOpInterface &gt; &amp;loops)</td></tr>
<tr class="memdesc:ab5ddc49055cfe22ac09d348a0e6220e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the tile-loop nest using the loop construct specifed in <code>options</code>.  <a href="TileUsingInterface_8cpp.html#ab5ddc49055cfe22ac09d348a0e6220e0">More...</a><br /></td></tr>
<tr class="separator:ab5ddc49055cfe22ac09d348a0e6220e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88598dd179a90f26e657f7f024a6f332"><td class="memTemplParams" colspan="2">template&lt;typename LoopType &gt; </td></tr>
<tr class="memitem:a88598dd179a90f26e657f7f024a6f332"><td class="memTemplItemLeft" align="right" valign="top">FailureOr&lt; LoopLikeOpInterface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a88598dd179a90f26e657f7f024a6f332">yieldTiledValuesAndReplaceLoop</a> (LoopType loopOp, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newInitOperands, <a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a> yieldTiledValuesFn)</td></tr>
<tr class="memdesc:a88598dd179a90f26e657f7f024a6f332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the specified additional <code>newInitOperands</code> operands to the loops existing <code>init</code> operands (or similar), and replace <code>loopOp</code> with the new loop that has the additional init operands.  <a href="TileUsingInterface_8cpp.html#a88598dd179a90f26e657f7f024a6f332">More...</a><br /></td></tr>
<tr class="separator:a88598dd179a90f26e657f7f024a6f332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5901df24969e8438ea1ce98c323a52"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aaf5901df24969e8438ea1ce98c323a52"><td class="memTemplItemLeft" align="right" valign="top">FailureOr&lt; LoopLikeOpInterface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#aaf5901df24969e8438ea1ce98c323a52">yieldTiledValuesAndReplaceLoop&lt; scf::ForOp &gt;</a> (scf::ForOp loopOp, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newInitOperands, <a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a> yieldTiledValuesFn)</td></tr>
<tr class="memdesc:aaf5901df24969e8438ea1ce98c323a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <code>yieldTiledValuesAndReplaceLoop</code> for <code>scf.for</code>.  <a href="TileUsingInterface_8cpp.html#aaf5901df24969e8438ea1ce98c323a52">More...</a><br /></td></tr>
<tr class="separator:aaf5901df24969e8438ea1ce98c323a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b85791a9ab89de7ca013a1c7b88653"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a34b85791a9ab89de7ca013a1c7b88653"><td class="memTemplItemLeft" align="right" valign="top">FailureOr&lt; LoopLikeOpInterface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a34b85791a9ab89de7ca013a1c7b88653">yieldTiledValuesAndReplaceLoop&lt; scf::ForallOp &gt;</a> (scf::ForallOp loopOp, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newInitOperands, <a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a> yieldTiledValuesFn)</td></tr>
<tr class="memdesc:a34b85791a9ab89de7ca013a1c7b88653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <code>yieldTiledValuesAndReplaceLoop</code> for <code>scf.forall</code>  <a href="TileUsingInterface_8cpp.html#a34b85791a9ab89de7ca013a1c7b88653">More...</a><br /></td></tr>
<tr class="separator:a34b85791a9ab89de7ca013a1c7b88653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8891f33aac7261d1c7916cf144c991"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; LoopLikeOpInterface &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a4f8891f33aac7261d1c7916cf144c991">yieldTiledValuesAndReplaceLoop</a> (LoopLikeOpInterface loopLikeOp, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newInitOperands, <a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a> yieldTiledValuesFn)</td></tr>
<tr class="memdesc:a4f8891f33aac7261d1c7916cf144c991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <code>yieldTiledValuesAndReplaceLoop</code> for <code>LoopLikeOpInterface</code>, that just dispatches to the implementation for each supported loop type.  <a href="TileUsingInterface_8cpp.html#a4f8891f33aac7261d1c7916cf144c991">More...</a><br /></td></tr>
<tr class="separator:a4f8891f33aac7261d1c7916cf144c991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba6980331e472f54032c57818013e68"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#acba6980331e472f54032c57818013e68">addInitOperandsToLoopNest</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt; loops, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newInitValues, <a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a> getNewTiledYieldsFn)</td></tr>
<tr class="memdesc:acba6980331e472f54032c57818013e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to add new init values to a loop nest.  <a href="TileUsingInterface_8cpp.html#acba6980331e472f54032c57818013e68">More...</a><br /></td></tr>
<tr class="separator:acba6980331e472f54032c57818013e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c50f9432b1225386223125ae77df4d"><td class="memItemLeft" align="right" valign="top">static std::tuple&lt; <a class="el" href="classmlir_1_1OpResult.html">OpResult</a>, std::optional&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#ab4c50f9432b1225386223125ae77df4d">getUntiledProducerFromSliceSource</a> (<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *source, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LoopLikeOpInterface &gt; loops)</td></tr>
<tr class="memdesc:ab4c50f9432b1225386223125ae77df4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the untiled producer whose slice is used in a tiled consumer.  <a href="TileUsingInterface_8cpp.html#ab4c50f9432b1225386223125ae77df4d">More...</a><br /></td></tr>
<tr class="separator:ab4c50f9432b1225386223125ae77df4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c60be984a912b6e26bba0f55834ebba"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a2c60be984a912b6e26bba0f55834ebba">checkAssumptionForFusingConsumer</a> (tensor::InsertSliceOp candidateSliceOp)</td></tr>
<tr class="memdesc:a2c60be984a912b6e26bba0f55834ebba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function that checks whether the only use of the result of a tensor.insert_slice op is in a scf.yield op.  <a href="TileUsingInterface_8cpp.html#a2c60be984a912b6e26bba0f55834ebba">More...</a><br /></td></tr>
<tr class="separator:a2c60be984a912b6e26bba0f55834ebba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc5608946a4c1b49b57fcbf9f2bdab0"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#afcc5608946a4c1b49b57fcbf9f2bdab0">getConsumerFromUses</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val, <a class="el" href="classmlir_1_1Block.html">Block</a> *containingOpBlock)</td></tr>
<tr class="memdesc:afcc5608946a4c1b49b57fcbf9f2bdab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches the OpOperand of the only user (and use) of the value <code>val</code> which implements <code>TilingInterface</code> and <code>DestinationStyleOpInterface</code>.  <a href="TileUsingInterface_8cpp.html#afcc5608946a4c1b49b57fcbf9f2bdab0">More...</a><br /></td></tr>
<tr class="separator:afcc5608946a4c1b49b57fcbf9f2bdab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac178d5feac315d618342825c69ceca"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; scf::ForOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#abac178d5feac315d618342825c69ceca">getPerfectlyNestedLoopsOutsideOf</a> (scf::ForOp loop)</td></tr>
<tr class="memdesc:abac178d5feac315d618342825c69ceca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the perfectly nested loops outside of given loop(included) sorted from outer to inner.  <a href="TileUsingInterface_8cpp.html#abac178d5feac315d618342825c69ceca">More...</a><br /></td></tr>
<tr class="separator:abac178d5feac315d618342825c69ceca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8704aceeb85391aa7b74a413f2fe9962"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a8704aceeb85391aa7b74a413f2fe9962">getUntiledConsumerFromSlice</a> (tensor::InsertSliceOp candidateSliceOp)</td></tr>
<tr class="memdesc:a8704aceeb85391aa7b74a413f2fe9962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the untiled consumer of a scf.for's result which is yielded by a tensor.insert_slice.  <a href="TileUsingInterface_8cpp.html#a8704aceeb85391aa7b74a413f2fe9962">More...</a><br /></td></tr>
<tr class="separator:a8704aceeb85391aa7b74a413f2fe9962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea889b97c9ef93a3131ef6a1f1c5a48"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#aeea889b97c9ef93a3131ef6a1f1c5a48">getUntiledConsumerFromSlice</a> (tensor::ParallelInsertSliceOp candidateSliceOp)</td></tr>
<tr class="memdesc:aeea889b97c9ef93a3131ef6a1f1c5a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the first untiled consumer of a scf.forall's result which is yielded by a tensor.parallel_insert_slice.  <a href="TileUsingInterface_8cpp.html#aeea889b97c9ef93a3131ef6a1f1c5a48">More...</a><br /></td></tr>
<tr class="separator:aeea889b97c9ef93a3131ef6a1f1c5a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f6545bdb5cac6300e359f790b61597"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a06f6545bdb5cac6300e359f790b61597">checkAssumptionForLoop</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *loopOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *consumerOp)</td></tr>
<tr class="memdesc:a06f6545bdb5cac6300e359f790b61597"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility currently checks whether the loop either :-.  <a href="TileUsingInterface_8cpp.html#a06f6545bdb5cac6300e359f790b61597">More...</a><br /></td></tr>
<tr class="separator:a06f6545bdb5cac6300e359f790b61597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8c201b1a6ac92890b96a0e9bc3e22b"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a1a8c201b1a6ac92890b96a0e9bc3e22b">getUntiledConsumerFromSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *sliceOp)</td></tr>
<tr class="memdesc:a1a8c201b1a6ac92890b96a0e9bc3e22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility to fetch an untiled consumer of tensor.insert_slice/tensor.parallel_insert_slice.  <a href="TileUsingInterface_8cpp.html#a1a8c201b1a6ac92890b96a0e9bc3e22b">More...</a><br /></td></tr>
<tr class="separator:a1a8c201b1a6ac92890b96a0e9bc3e22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&nbsp;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;tile-using-interface&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00033">33</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a505d4f42e1beb901ab163d108b0c8db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505d4f42e1beb901ab163d108b0c8db9">&#9670;&nbsp;</a></span>YieldTiledValuesFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a> =  std::function&lt;LogicalResult( <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newBbArgs, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &amp;tiledValues, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; &gt; &amp;resultOffsets, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; &gt; &amp;resultSizes)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that allows returning additional yielded values during <code>yieldTiledValuesAndReplace</code>. </p>
<ul>
<li><code>ivs</code> induction variable for the loop.</li>
<li><code>newBbArgs</code> basic block arguments corresponding to newly added iter_args.</li>
<li><code>tiledValues</code> the tiled values to return. Must be of same size as <code>newbbArgs</code>, each element of this array is inserted into the corresponding element in <code>newbbArgs</code>.</li>
<li><code>resultOffsets</code> is of the same size as <code>tiledValues</code> and represents the offsets to use when inserting corresponding element from <code>tiledValues</code> into the element from <code>newBbArgs</code>.</li>
<li><code>resultSizes</code> is of the same size as <code>tiledValues</code> and represents the size of the corresponding element from <code>tiledValues</code> inserted into the element from <code>newBbArgs</code>. In case the method needs to return <code>failure()</code> the method is expected to clean up any inserted operations. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00365">365</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acba6980331e472f54032c57818013e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba6980331e472f54032c57818013e68">&#9670;&nbsp;</a></span>addInitOperandsToLoopNest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult addInitOperandsToLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt;&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newInitValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a>&#160;</td>
          <td class="paramname"><em>getNewTiledYieldsFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to add new init values to a loop nest. </p>
<p>Updates <code>loops</code> in-place with new loops that use the <code>newInitValues</code>. The outer-loops are updated to yield the new result values of the inner loop. For the innermost loop, the call back <code>getNewYields</code> is invoked to get the additional values to yield form the innermost loop. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00716">716</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00339">mlir::RewriterBase::mergeBlocks()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00133">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00536">mlir::RewriterBase::replaceOpWithNewOp()</a>, <a class="el" href="Builders_8h_source.html#l00406">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00580">yieldTiledValuesAndReplaceLoop()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l01743">mlir::scf::tileAndFuseConsumerOfSlice()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l01194">mlir::scf::yieldReplacementForFusedProducer()</a>.</p>

</div>
</div>
<a id="a5414ba15ec7505cbe18cda75476c7082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5414ba15ec7505cbe18cda75476c7082">&#9670;&nbsp;</a></span>canOmitTileOffsetInBoundsCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool canOmitTileOffsetInBoundsCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>tileSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>iterationSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the maximum tile offset <code>tileSize * numThreads-1</code> is less than <code>iterationSize</code>. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00230">230</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00105">mlir::getConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00245">getTileOffsetAndSizes()</a>.</p>

</div>
</div>
<a id="a2c60be984a912b6e26bba0f55834ebba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c60be984a912b6e26bba0f55834ebba">&#9670;&nbsp;</a></span>checkAssumptionForFusingConsumer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult checkAssumptionForFusingConsumer </td>
          <td>(</td>
          <td class="paramtype">tensor::InsertSliceOp&#160;</td>
          <td class="paramname"><em>candidateSliceOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A utility function that checks whether the only use of the result of a tensor.insert_slice op is in a scf.yield op. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l01560">1560</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, and <a class="el" href="Value_8h_source.html#l00212">mlir::Value::getUses()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l01662">getUntiledConsumerFromSlice()</a>.</p>

</div>
</div>
<a id="a06f6545bdb5cac6300e359f790b61597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f6545bdb5cac6300e359f790b61597">&#9670;&nbsp;</a></span>checkAssumptionForLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult checkAssumptionForLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>loopOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>consumerOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This utility currently checks whether the loop either :-. </p>
<ol type="1">
<li>Yields exactly one result.</li>
<li>Has consumer op as its first user and other users to be in the same containing block as that of consumer op's. Currently we clone the loop op right before the consumer op in order to maintain a valid def-use chain. This utility thus helps ensuring that no invalid IR is formed due to the same. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l01709">1709</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00399">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00869">mlir::Operation::getUsers()</a>, and <a class="el" href="IR_2Operation_8cpp_source.html#l00386">mlir::Operation::isBeforeInBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l01743">mlir::scf::tileAndFuseConsumerOfSlice()</a>.</p>

</div>
</div>
<a id="a9f120026f0543a159d581745ebe012a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f120026f0543a159d581745ebe012a7">&#9670;&nbsp;</a></span>checkSafeToTileToForall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void checkSafeToTileToForall </td>
          <td>(</td>
          <td class="paramtype">TilingInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>numThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if any of the tiled loops are not parallel. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00156">156</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

</div>
</div>
<a id="ac306562a8fbc59e01746c58da2cdd7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac306562a8fbc59e01746c58da2cdd7ed">&#9670;&nbsp;</a></span>cloneOpAndUpdateDestinationArgs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Operation.html">Operation</a>* cloneOpAndUpdateDestinationArgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newDestArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clones the operation and updates the destination if the operation implements the <code>DestinationStyleOpInterface</code>. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00373">373</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l01079">mlir::scf::tileAndFuseProducerOfSlice()</a>.</p>

</div>
</div>
<a id="a0b0f1d605335ebbc8fafee8571e85d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0f1d605335ebbc8fafee8571e85d7f">&#9670;&nbsp;</a></span>fillInterchangeVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t&gt; fillInterchangeVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>interchangeVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iterationDomainSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper method to adjust the interchange vector to match the iteration domain. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00060">60</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

</div>
</div>
<a id="ab5ddc49055cfe22ac09d348a0e6220e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ddc49055cfe22ac09d348a0e6220e0">&#9670;&nbsp;</a></span>generateLoopNest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult generateLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html">scf::SCFTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>loopRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>destinationTensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a>&#160;</td>
          <td class="paramname"><em>tiledBodyFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; LoopLikeOpInterface &gt; &amp;&#160;</td>
          <td class="paramname"><em>loops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the tile-loop nest using the loop construct specifed in <code>options</code>. </p>
<ul>
<li><code>options</code>: Tiling options specified.</li>
<li><code>loopRanges</code> specifies the lb, ub and step of the untiled iteration space.</li>
<li><code>tileSizes</code> is the tile sizes to use. Zero represent untiled loops.</li>
<li><code>destinationTensors</code> are the init values to use for the outer most loop.</li>
<li><code>yieldTiledValuesFn</code> is called to generated the loop body of the inner most loop.</li>
<li><code>loops</code> is an in-out parameter into which the generated loops are populated. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00546">546</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html#ac0de119f731019cc6d8acb08187198cda5c060ed3dfd4303086b9d03f1930d71d">mlir::scf::SCFTilingOptions::ForallOp</a>, <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html#ac0de119f731019cc6d8acb08187198cda8f94688c23f91c9149d977e0fe921524">mlir::scf::SCFTilingOptions::ForOp</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00474">generateLoopNestUsingForallOp()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00393">generateLoopNestUsingForOp()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00017">mlir::isZeroIndex()</a>, <a class="el" href="PatternMatch_8h_source.html#l00718">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="af68c84503ecbbb94571d6f8f72d636a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68c84503ecbbb94571d6f8f72d636a2">&#9670;&nbsp;</a></span>generateLoopNestUsingForallOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult generateLoopNestUsingForallOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>loopRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>mappingVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>destinationTensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a>&#160;</td>
          <td class="paramname"><em>tiledBodyFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; LoopLikeOpInterface &gt; &amp;&#160;</td>
          <td class="paramname"><em>loops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the tile-loop nest using <code>scf.forall</code> operation. </p>
<ul>
<li><code>loopRanges</code> specifies the lb, ub and step of the untiled iteration space.</li>
<li><code>tileSizes</code> is the tile sizes to use. Zero represent untiled loops.</li>
<li><code>destinationTensors</code> are the init values to use for the outer most loop.</li>
<li><code>mappingVector</code> is the mapping attributes to use for loop construction. Can be empty.</li>
<li><code>yieldTiledValuesFn</code> is called to generated the loop body of the inner most loop.</li>
<li><code>loops</code> is an in-out parameter into which the generated loops are populated. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00474">474</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8cpp_source.html#l00297">mlir::Builder::getArrayAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00148">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00336">getLoopBounds()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00135">mlir::isConstantIntValue()</a>, <a class="el" href="PatternMatch_8h_source.html#l00718">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="Builders_8h_source.html#l00406">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="Builders_8h_source.html#l00444">mlir::OpBuilder::setInsertionPointToEnd()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00546">generateLoopNest()</a>.</p>

</div>
</div>
<a id="a8b2945e64b5676eb54ff016a7ba1eee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2945e64b5676eb54ff016a7ba1eee5">&#9670;&nbsp;</a></span>generateLoopNestUsingForOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult generateLoopNestUsingForOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>loopRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>destinationTensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a>&#160;</td>
          <td class="paramname"><em>yieldTiledValuesFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; LoopLikeOpInterface &gt; &amp;&#160;</td>
          <td class="paramname"><em>loops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the tile-loop nest using <code>scf.for</code> operation. </p>
<ul>
<li><code>loopRanges</code> specifies the lb, ub and step of the untiled iteration space.</li>
<li><code>tileSizes</code> is the tile sizes to use. Zero represent untiled loops.</li>
<li><code>destinationTensors</code> are the init values to use for the outer most loop.</li>
<li><code>yieldTiledValuesFn</code> is called to generated the loop body of the inner most loop.</li>
<li><code>loops</code> is an in-out parameter into which the generated loops are populated. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00393">393</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8cpp_source.html#l00148">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00336">getLoopBounds()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00112">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00718">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="Builders_8h_source.html#l00444">mlir::OpBuilder::setInsertionPointToEnd()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00546">generateLoopNest()</a>.</p>

</div>
</div>
<a id="a880e291006bd7a102432578ee0957069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880e291006bd7a102432578ee0957069">&#9670;&nbsp;</a></span>getBoundedTileSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> getBoundedTileSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Range.html">Range</a>&#160;</td>
          <td class="paramname"><em>loopRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>tileSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bounded tile size given the current <code>offset</code>, <code>loopRange</code> and <code>tileSize</code>, i.e., <code>min(tileSize, range.end() - offset)</code>. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00205">205</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00348">mlir::bindDims()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00362">mlir::bindSymbols()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01240">mlir::AffineMap::get()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00105">mlir::getConstantIntValue()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00112">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01298">mlir::affine::makeComposedFoldedAffineMin()</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00034">mlir::Range::offset</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00035">mlir::Range::size</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00190">tileDividesIterationDomain()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00245">getTileOffsetAndSizes()</a>.</p>

</div>
</div>
<a id="afcc5608946a4c1b49b57fcbf9f2bdab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc5608946a4c1b49b57fcbf9f2bdab0">&#9670;&nbsp;</a></span>getConsumerFromUses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FailureOr&lt;<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&gt; getConsumerFromUses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>containingOpBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetches the OpOperand of the only user (and use) of the value <code>val</code> which implements <code>TilingInterface</code> and <code>DestinationStyleOpInterface</code>. </p>
<p>Returns failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l01586">1586</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, and <a class="el" href="Value_8h_source.html#l00212">mlir::Value::getUses()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l01662">getUntiledConsumerFromSlice()</a>.</p>

</div>
</div>
<a id="abda80cd33074b6273520daf966406fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda80cd33074b6273520daf966406fa8">&#9670;&nbsp;</a></span>getLoopBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::tuple&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; &gt; getLoopBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>loopRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to return the bounds of the loops to be generated. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00336">336</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00135">mlir::isConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00474">generateLoopNestUsingForallOp()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00393">generateLoopNestUsingForOp()</a>.</p>

</div>
</div>
<a id="abac178d5feac315d618342825c69ceca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac178d5feac315d618342825c69ceca">&#9670;&nbsp;</a></span>getPerfectlyNestedLoopsOutsideOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;scf::ForOp&gt; getPerfectlyNestedLoopsOutsideOf </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>loop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the perfectly nested loops outside of given loop(included) sorted from outer to inner. </p>
<p>E.g.</p>
<div class="fragment"><div class="line">%0 = scf.for()</div>
<div class="line">  %1 = scf.for()</div>
<div class="line">    %2 = scf.for()</div>
<div class="line">       %3 = ...</div>
<div class="line">       yield %3</div>
<div class="line">    yield %2</div>
<div class="line">  yield %1</div>
</div><!-- fragment --><p>This function will return three perfectly nested loops: %0 + %1 + %2, when target inner loop is %2. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l01631">1631</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00151">mlir::Block::front()</a>, <a class="el" href="Block_8cpp_source.html#l00243">mlir::Block::getTerminator()</a>, and <a class="el" href="Block_8h_source.html#l00207">mlir::Block::without_terminator()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l01662">getUntiledConsumerFromSlice()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l01743">mlir::scf::tileAndFuseConsumerOfSlice()</a>.</p>

</div>
</div>
<a id="a86c940c8e51be1cf412745431d087056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c940c8e51be1cf412745431d087056">&#9670;&nbsp;</a></span>getTileOffsetAndSizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::tuple&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; &gt; getTileOffsetAndSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>iterationDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>numThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the <code>OpFoldResult</code>s that represents the multi-dimensional <code>offset</code>s and <code>size</code>s of the tile of the iteration space that the innermost loop body of the generated tiled loops corresponds to. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00245">245</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00348">mlir::bindDims()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00362">mlir::bindSymbols()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00230">canOmitTileOffsetInBoundsCheck()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00069">mlir::getAsOpFoldResult()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00205">getBoundedTileSize()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00148">mlir::Builder::getIndexAttr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00334">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00135">mlir::isConstantIntValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01192">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01305">mlir::affine::makeComposedFoldedAffineMax()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01298">mlir::affine::makeComposedFoldedAffineMin()</a>.</p>

</div>
</div>
<a id="a1a8c201b1a6ac92890b96a0e9bc3e22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8c201b1a6ac92890b96a0e9bc3e22b">&#9670;&nbsp;</a></span>getUntiledConsumerFromSlice() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FailureOr&lt;<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&gt; getUntiledConsumerFromSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>sliceOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A utility to fetch an untiled consumer of tensor.insert_slice/tensor.parallel_insert_slice. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l01729">1729</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="TileUsingInterface_8cpp_source.html#l01662">getUntiledConsumerFromSlice()</a>.</p>

</div>
</div>
<a id="a8704aceeb85391aa7b74a413f2fe9962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8704aceeb85391aa7b74a413f2fe9962">&#9670;&nbsp;</a></span>getUntiledConsumerFromSlice() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FailureOr&lt;<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&gt; getUntiledConsumerFromSlice </td>
          <td>(</td>
          <td class="paramtype">tensor::InsertSliceOp&#160;</td>
          <td class="paramname"><em>candidateSliceOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the untiled consumer of a scf.for's result which is yielded by a tensor.insert_slice. </p>
<p>This function makes the following assumptions :</p><ol type="1">
<li>tensor.insert_slice has scf.yield as its only user.</li>
<li>scf.for's corresponding result has only one use. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l01662">1662</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="TileUsingInterface_8cpp_source.html#l01560">checkAssumptionForFusingConsumer()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01586">getConsumerFromUses()</a>, <a class="el" href="Value_8cpp_source.html#l00216">mlir::OpOperand::getOperandNumber()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01631">getPerfectlyNestedLoopsOutsideOf()</a>, and <a class="el" href="Value_8h_source.html#l00212">mlir::Value::getUses()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l01729">getUntiledConsumerFromSlice()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l01743">mlir::scf::tileAndFuseConsumerOfSlice()</a>.</p>

</div>
</div>
<a id="aeea889b97c9ef93a3131ef6a1f1c5a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea889b97c9ef93a3131ef6a1f1c5a48">&#9670;&nbsp;</a></span>getUntiledConsumerFromSlice() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FailureOr&lt;<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&gt; getUntiledConsumerFromSlice </td>
          <td>(</td>
          <td class="paramtype">tensor::ParallelInsertSliceOp&#160;</td>
          <td class="paramname"><em>candidateSliceOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the first untiled consumer of a scf.forall's result which is yielded by a tensor.parallel_insert_slice. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l01683">1683</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01586">getConsumerFromUses()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>.</p>

</div>
</div>
<a id="ab4c50f9432b1225386223125ae77df4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c50f9432b1225386223125ae77df4d">&#9670;&nbsp;</a></span>getUntiledProducerFromSliceSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::tuple&lt;<a class="el" href="classmlir_1_1OpResult.html">OpResult</a>, std::optional&lt;<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&gt; &gt; getUntiledProducerFromSliceSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LoopLikeOpInterface &gt;&#160;</td>
          <td class="paramname"><em>loops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the untiled producer whose slice is used in a tiled consumer. </p>
<p>The method traverses the tile loop nest (<code>loops</code>) if needed, and returns the <code>iter_args</code> of the outer most that is encountered. Traversing the iter_args indicates that this is a destination operand of the consumer. If there was no loop traversal needed, the second value of the returned tuple is empty. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l01060">1060</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l01079">mlir::scf::tileAndFuseProducerOfSlice()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l01420">mlir::scf::tileConsumerAndFuseProducersUsingSCF()</a>.</p>

</div>
</div>
<a id="aad85bf3fd0f4e53a5ad346ef48397438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad85bf3fd0f4e53a5ad346ef48397438">&#9670;&nbsp;</a></span>getUserTileSizesAndNumThreads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::tuple&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; &gt; getUserTileSizesAndNumThreads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>iterationDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html">scf::SCFTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to instantiate the tile sizes and/or number of threads specified by the user. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00102">102</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

</div>
</div>
<a id="abb6dd85d4816fccaea1880b659d13c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6dd85d4816fccaea1880b659d13c74">&#9670;&nbsp;</a></span>tileDividesIterationDomain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool tileDividesIterationDomain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Range.html">Range</a>&#160;</td>
          <td class="paramname"><em>loopRange</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <code>stride</code> evenly divides the trip count <code>size - offset</code>. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00190">190</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00105">mlir::getConstantIntValue()</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00034">mlir::Range::offset</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00035">mlir::Range::size</a>, and <a class="el" href="StaticValueUtils_8h_source.html#l00036">mlir::Range::stride</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00205">getBoundedTileSize()</a>.</p>

</div>
</div>
<a id="a14af9e169e5c3e9655ff5d55ea0cfede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14af9e169e5c3e9655ff5d55ea0cfede">&#9670;&nbsp;</a></span>verifyTileSizeOptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult verifyTileSizeOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html">scf::SCFTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify the tile size options are set in a consistent manner. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00078">78</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html#ac0de119f731019cc6d8acb08187198cda5c060ed3dfd4303086b9d03f1930d71d">mlir::scf::SCFTilingOptions::ForallOp</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00222">mlir::isPermutationVector()</a>, <a class="el" href="PatternMatch_8h_source.html#l00718">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a4f8891f33aac7261d1c7916cf144c991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8891f33aac7261d1c7916cf144c991">&#9670;&nbsp;</a></span>yieldTiledValuesAndReplaceLoop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;LoopLikeOpInterface&gt; yieldTiledValuesAndReplaceLoop </td>
          <td>(</td>
          <td class="paramtype">LoopLikeOpInterface&#160;</td>
          <td class="paramname"><em>loopLikeOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newInitOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a>&#160;</td>
          <td class="paramname"><em>yieldTiledValuesFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of <code>yieldTiledValuesAndReplaceLoop</code> for <code>LoopLikeOpInterface</code>, that just dispatches to the implementation for each supported loop type. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00696">696</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00718">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00580">yieldTiledValuesAndReplaceLoop()</a>.</p>

</div>
</div>
<a id="a88598dd179a90f26e657f7f024a6f332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88598dd179a90f26e657f7f024a6f332">&#9670;&nbsp;</a></span>yieldTiledValuesAndReplaceLoop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LoopType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;LoopLikeOpInterface&gt; yieldTiledValuesAndReplaceLoop </td>
          <td>(</td>
          <td class="paramtype">LoopType&#160;</td>
          <td class="paramname"><em>loopOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newInitOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a>&#160;</td>
          <td class="paramname"><em>yieldTiledValuesFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append the specified additional <code>newInitOperands</code> operands to the loops existing <code>init</code> operands (or similar), and replace <code>loopOp</code> with the new loop that has the additional init operands. </p>
<p>The loop body of this loop is moved over to the new loop. <code>yieldTiledValuesFn</code> is called to get the new tiled values returned, and the offset and sizes at which the tiled value is inserted into the new region iter_args that correspond to the newly added init operands. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00580">580</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00718">mlir::RewriterBase::notifyMatchFailure()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00716">addInitOperandsToLoopNest()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00696">yieldTiledValuesAndReplaceLoop()</a>.</p>

</div>
</div>
<a id="a34b85791a9ab89de7ca013a1c7b88653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b85791a9ab89de7ca013a1c7b88653">&#9670;&nbsp;</a></span>yieldTiledValuesAndReplaceLoop&lt; scf::ForallOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;LoopLikeOpInterface&gt; <a class="el" href="TileUsingInterface_8cpp.html#a4f8891f33aac7261d1c7916cf144c991">yieldTiledValuesAndReplaceLoop</a>&lt; scf::ForallOp &gt; </td>
          <td>(</td>
          <td class="paramtype">scf::ForallOp&#160;</td>
          <td class="paramname"><em>loopOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newInitOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a>&#160;</td>
          <td class="paramname"><em>yieldTiledValuesFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of <code>yieldTiledValuesAndReplaceLoop</code> for <code>scf.forall</code> </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00580">580</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

</div>
</div>
<a id="aaf5901df24969e8438ea1ce98c323a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5901df24969e8438ea1ce98c323a52">&#9670;&nbsp;</a></span>yieldTiledValuesAndReplaceLoop&lt; scf::ForOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;LoopLikeOpInterface&gt; <a class="el" href="TileUsingInterface_8cpp.html#a4f8891f33aac7261d1c7916cf144c991">yieldTiledValuesAndReplaceLoop</a>&lt; scf::ForOp &gt; </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>loopOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newInitOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a>&#160;</td>
          <td class="paramname"><em>yieldTiledValuesFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of <code>yieldTiledValuesAndReplaceLoop</code> for <code>scf.for</code>. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00580">580</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 7 2024 08:32:17 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
