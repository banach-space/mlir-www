<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::vector Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">20.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1vector.html">vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::vector Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1vector_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1ScalableValueBoundsConstraintSet.html">ScalableValueBoundsConstraintSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version of <code><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html" title="A helper class to be used with ValueBoundsOpInterface.">ValueBoundsConstraintSet</a></code> that can solve for scalable bounds.  <a href="structmlir_1_1vector_1_1ScalableValueBoundsConstraintSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1VectorDim.html">VectorDim</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1LowerVectorsOptions.html">LowerVectorsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper structure used to hold the different options of LowerVectorsOp.  <a href="structmlir_1_1vector_1_1LowerVectorsOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1WarpExecuteOnLane0LoweringOptions.html">WarpExecuteOnLane0LoweringOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1UnrollVectorOptions.html">UnrollVectorOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options that control the vector unrolling.  <a href="structmlir_1_1vector_1_1UnrollVectorOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to control the behavior of vector transform patterns.  <a href="structmlir_1_1vector_1_1VectorTransformsOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1VscaleRange.html">VscaleRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1MaskableOpRewritePattern.html">MaskableOpRewritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern for ops that implement <code>MaskableOpInterface</code> and that <em>might</em> be masked (i.e.  <a href="structmlir_1_1vector_1_1MaskableOpRewritePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a00e8e971c19fdf979d14a69ebbbb2c8d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a00e8e971c19fdf979d14a69ebbbb2c8d">ConstantOrScalableBound</a> = <a class="el" href="structmlir_1_1vector_1_1ScalableValueBoundsConstraintSet_1_1ConstantOrScalableBound.html">ScalableValueBoundsConstraintSet::ConstantOrScalableBound</a></td></tr>
<tr class="separator:a00e8e971c19fdf979d14a69ebbbb2c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e87c5919acbac1e6dd95ffbdf7b588"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#ae3e87c5919acbac1e6dd95ffbdf7b588">DistributionMapFn</a> = std::function&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td></tr>
<tr class="separator:ae3e87c5919acbac1e6dd95ffbdf7b588"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a4ba6d4a825dbd36205be5322733056ef"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a4ba6d4a825dbd36205be5322733056ef">ConstantMaskKind</a> { <a class="el" href="namespacemlir_1_1vector.html#a4ba6d4a825dbd36205be5322733056efa5a26d218c82b9e4168d67628ecb0a0d1">AllFalse</a> = 0
, <a class="el" href="namespacemlir_1_1vector.html#a4ba6d4a825dbd36205be5322733056efa822b19813c2556c566eec6864da1319f">AllTrue</a>
 }</td></tr>
<tr class="memdesc:a4ba6d4a825dbd36205be5322733056ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predefined constant_mask kinds.  <a href="namespacemlir_1_1vector.html#a4ba6d4a825dbd36205be5322733056ef">More...</a><br /></td></tr>
<tr class="separator:a4ba6d4a825dbd36205be5322733056ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfee45e655b185bd625e2f7994dc2c50"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50">BroadcastableToResult</a> { <a class="el" href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50a505a83f220c02df2f85c3810cd9ceb38">Success</a> = 0
, <a class="el" href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50ac76fd47e5afe8e699733f0b655854c5a">SourceRankHigher</a> = 1
, <a class="el" href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50a2664c241558d7674e8ed4d5f63d2e463">DimensionMismatch</a> = 2
, <a class="el" href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50a578636e914af1c61d9d43b36a2076248">SourceTypeNotAVector</a> = 3
 }</td></tr>
<tr class="memdesc:acfee45e655b185bd625e2f7994dc2c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether <code>srcType</code> can be broadcast to <code>dstVectorType</code> under the semantics of the <code>vector.broadcast</code> op.  <a href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50">More...</a><br /></td></tr>
<tr class="separator:acfee45e655b185bd625e2f7994dc2c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa5d301133c3ac8bc64957d0a9eb7006a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#aa5d301133c3ac8bc64957d0a9eb7006a">registerValueBoundsOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:aa5d301133c3ac8bc64957d0a9eb7006a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2683abb4897d8bda306d12702ee2ca04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a2683abb4897d8bda306d12702ee2ca04">buildTerminatedBody</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a2683abb4897d8bda306d12702ee2ca04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default callback to build a region with a 'vector.yield' terminator with no arguments.  <a href="namespacemlir_1_1vector.html#a2683abb4897d8bda306d12702ee2ca04">More...</a><br /></td></tr>
<tr class="separator:a2683abb4897d8bda306d12702ee2ca04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5150a3f7aa4857a1863bd10fb551442a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50">BroadcastableToResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a5150a3f7aa4857a1863bd10fb551442a">isBroadcastableTo</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> srcType, VectorType dstVectorType, std::pair&lt; <a class="el" href="structmlir_1_1vector_1_1VectorDim.html">VectorDim</a>, <a class="el" href="structmlir_1_1vector_1_1VectorDim.html">VectorDim</a> &gt; *mismatchingDims=nullptr)</td></tr>
<tr class="separator:a5150a3f7aa4857a1863bd10fb551442a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901dfffd46bc2f80e977fdea83adc180"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a901dfffd46bc2f80e977fdea83adc180">populateVectorToVectorCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a901dfffd46bc2f80e977fdea83adc180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of vector-to-vector canonicalization patterns.  <a href="namespacemlir_1_1vector.html#a901dfffd46bc2f80e977fdea83adc180">More...</a><br /></td></tr>
<tr class="separator:a901dfffd46bc2f80e977fdea83adc180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec9916655c82acca22bdeb882303f0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a7ec9916655c82acca22bdeb882303f0f">populateFoldArithExtensionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a7ec9916655c82acca22bdeb882303f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns that fold arithmetic extension on floating point into vector contract for the backends with native support.  <a href="namespacemlir_1_1vector.html#a7ec9916655c82acca22bdeb882303f0f">More...</a><br /></td></tr>
<tr class="separator:a7ec9916655c82acca22bdeb882303f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc60b182ad08ffab9aa924a74e78129"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a2bc60b182ad08ffab9aa924a74e78129">populateElementwiseToVectorOpsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a2bc60b182ad08ffab9aa924a74e78129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns that fold elementwise op on vectors to the vector dialect.  <a href="namespacemlir_1_1vector.html#a2bc60b182ad08ffab9aa924a74e78129">More...</a><br /></td></tr>
<tr class="separator:a2bc60b182ad08ffab9aa924a74e78129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cb3b0a7edef27b564ca0603fedec4a"><td class="memItemLeft" align="right" valign="top">IntegerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#ae3cb3b0a7edef27b564ca0603fedec4a">getVectorSubscriptType</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;builder)</td></tr>
<tr class="memdesc:ae3cb3b0a7edef27b564ca0603fedec4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the integer type required for subscripts in the vector dialect.  <a href="namespacemlir_1_1vector.html#ae3cb3b0a7edef27b564ca0603fedec4a">More...</a><br /></td></tr>
<tr class="separator:ae3cb3b0a7edef27b564ca0603fedec4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0499bcd00b867b4665ddf0c939543cfb"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a0499bcd00b867b4665ddf0c939543cfb">getVectorSubscriptAttr</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;b, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="memdesc:a0499bcd00b867b4665ddf0c939543cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an integer array attribute containing the given values using the integer type required for subscripts in the vector dialect.  <a href="namespacemlir_1_1vector.html#a0499bcd00b867b4665ddf0c939543cfb">More...</a><br /></td></tr>
<tr class="separator:a0499bcd00b867b4665ddf0c939543cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf88d2bf2999298f815f0bc9ba05f2a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#abf88d2bf2999298f815f0bc9ba05f2a4">getVectorReductionOp</a> (arith::AtomicRMWKind op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> vector)</td></tr>
<tr class="memdesc:abf88d2bf2999298f815f0bc9ba05f2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value obtained by reducing the vector into a scalar using the operation kind associated with a binary AtomicRMWKind op.  <a href="namespacemlir_1_1vector.html#abf88d2bf2999298f815f0bc9ba05f2a4">More...</a><br /></td></tr>
<tr class="separator:abf88d2bf2999298f815f0bc9ba05f2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3221aacef9029612ded6c1d7bef1791c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a3221aacef9029612ded6c1d7bef1791c">getTransferMinorIdentityMap</a> (ShapedType shapedType, VectorType vectorType)</td></tr>
<tr class="memdesc:a3221aacef9029612ded6c1d7bef1791c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the default minor identity map suitable for a vector transfer.  <a href="namespacemlir_1_1vector.html#a3221aacef9029612ded6c1d7bef1791c">More...</a><br /></td></tr>
<tr class="separator:a3221aacef9029612ded6c1d7bef1791c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db9bda1f50ffdff9759b51bf49ddb86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a3db9bda1f50ffdff9759b51bf49ddb86">checkSameValueRAW</a> (TransferWriteOp defWrite, TransferReadOp read)</td></tr>
<tr class="memdesc:a3db9bda1f50ffdff9759b51bf49ddb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the transfer_write fully writes the data accessed by the transfer_read.  <a href="namespacemlir_1_1vector.html#a3db9bda1f50ffdff9759b51bf49ddb86">More...</a><br /></td></tr>
<tr class="separator:a3db9bda1f50ffdff9759b51bf49ddb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1125a16d0ba1e024d9b99d5b439a0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a6f1125a16d0ba1e024d9b99d5b439a0a">checkSameValueWAW</a> (TransferWriteOp write, TransferWriteOp priorWrite)</td></tr>
<tr class="memdesc:a6f1125a16d0ba1e024d9b99d5b439a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the write op fully over-write the priorWrite transfer_write op.  <a href="namespacemlir_1_1vector.html#a6f1125a16d0ba1e024d9b99d5b439a0a">More...</a><br /></td></tr>
<tr class="separator:a6f1125a16d0ba1e024d9b99d5b439a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd4b030a7ece80ee86e9b6c41895b82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a5fd4b030a7ece80ee86e9b6c41895b82">isDisjointTransferIndices</a> (VectorTransferOpInterface transferA, VectorTransferOpInterface transferB, bool testDynamicValueUsingBounds=false)</td></tr>
<tr class="memdesc:a5fd4b030a7ece80ee86e9b6c41895b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if we can prove that the transfer operations access disjoint memory, without requring the accessed tensor/memref to be the same.  <a href="namespacemlir_1_1vector.html#a5fd4b030a7ece80ee86e9b6c41895b82">More...</a><br /></td></tr>
<tr class="separator:a5fd4b030a7ece80ee86e9b6c41895b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629666d1e621e7ad850d28cecd82a263"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a629666d1e621e7ad850d28cecd82a263">isDisjointTransferSet</a> (VectorTransferOpInterface transferA, VectorTransferOpInterface transferB, bool testDynamicValueUsingBounds=false)</td></tr>
<tr class="memdesc:a629666d1e621e7ad850d28cecd82a263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if we can prove that the transfer operations access disjoint memory, requiring the operations to access the same tensor/memref.  <a href="namespacemlir_1_1vector.html#a629666d1e621e7ad850d28cecd82a263">More...</a><br /></td></tr>
<tr class="separator:a629666d1e621e7ad850d28cecd82a263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015472323cadf1a87aa5281a682eb0b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a015472323cadf1a87aa5281a682eb0b9">makeArithReduction</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, CombiningKind kind, <a class="el" href="classmlir_1_1Value.html">Value</a> v1, <a class="el" href="classmlir_1_1Value.html">Value</a> acc, arith::FastMathFlagsAttr fastmath=nullptr, <a class="el" href="classmlir_1_1Value.html">Value</a> mask=nullptr)</td></tr>
<tr class="memdesc:a015472323cadf1a87aa5281a682eb0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result value of reducing two scalar/vector values with the corresponding arith operation.  <a href="namespacemlir_1_1vector.html#a015472323cadf1a87aa5281a682eb0b9">More...</a><br /></td></tr>
<tr class="separator:a015472323cadf1a87aa5281a682eb0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d40ea32eb46ab63ab75c1b568ce4ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a75d40ea32eb46ab63ab75c1b568ce4ef">isParallelIterator</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:a75d40ea32eb46ab63ab75c1b568ce4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>attr</code> has "parallel" iterator type semantics.  <a href="namespacemlir_1_1vector.html#a75d40ea32eb46ab63ab75c1b568ce4ef">More...</a><br /></td></tr>
<tr class="separator:a75d40ea32eb46ab63ab75c1b568ce4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2393c85f5a124d20d5299d422b29a140"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a2393c85f5a124d20d5299d422b29a140">isReductionIterator</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:a2393c85f5a124d20d5299d422b29a140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>attr</code> has "reduction" iterator type semantics.  <a href="namespacemlir_1_1vector.html#a2393c85f5a124d20d5299d422b29a140">More...</a><br /></td></tr>
<tr class="separator:a2393c85f5a124d20d5299d422b29a140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817b87f0647b2d105ddb4ee8331c6e74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a817b87f0647b2d105ddb4ee8331c6e74">getAsIntegers</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; values)</td></tr>
<tr class="memdesc:a817b87f0647b2d105ddb4ee8331c6e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the integer numbers in <code>values</code>.  <a href="namespacemlir_1_1vector.html#a817b87f0647b2d105ddb4ee8331c6e74">More...</a><br /></td></tr>
<tr class="separator:a817b87f0647b2d105ddb4ee8331c6e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32acdf7a602e7b76f6784237c2f2fa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#af32acdf7a602e7b76f6784237c2f2fa2">getAsIntegers</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; foldResults)</td></tr>
<tr class="memdesc:af32acdf7a602e7b76f6784237c2f2fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the integer numbers in <code>foldResults</code>.  <a href="namespacemlir_1_1vector.html#af32acdf7a602e7b76f6784237c2f2fa2">More...</a><br /></td></tr>
<tr class="separator:af32acdf7a602e7b76f6784237c2f2fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c8f18ea2cde21d5f5585fe430d0494"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#ab5c8f18ea2cde21d5f5585fe430d0494">getAsValues</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; foldResults)</td></tr>
<tr class="memdesc:ab5c8f18ea2cde21d5f5585fe430d0494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <code>foldResults</code> into Values.  <a href="namespacemlir_1_1vector.html#ab5c8f18ea2cde21d5f5585fe430d0494">More...</a><br /></td></tr>
<tr class="separator:ab5c8f18ea2cde21d5f5585fe430d0494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a2f31604d067d92eed03a981b27cc5"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a30a2f31604d067d92eed03a981b27cc5">getConstantVscaleMultiplier</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a30a2f31604d067d92eed03a981b27cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>value</code> is a constant multiple of <code>vector.vscale</code> (e.g.  <a href="namespacemlir_1_1vector.html#a30a2f31604d067d92eed03a981b27cc5">More...</a><br /></td></tr>
<tr class="separator:a30a2f31604d067d92eed03a981b27cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561e2afa7c375df7a7dffe273c38b8de"><td class="memItemLeft" align="right" valign="top">VectorType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a561e2afa7c375df7a7dffe273c38b8de">inferTransferOpMaskType</a> (VectorType vecType, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> permMap)</td></tr>
<tr class="memdesc:a561e2afa7c375df7a7dffe273c38b8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infers the mask type for a transfer op given its vector type and permutation map.  <a href="namespacemlir_1_1vector.html#a561e2afa7c375df7a7dffe273c38b8de">More...</a><br /></td></tr>
<tr class="separator:a561e2afa7c375df7a7dffe273c38b8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7388851d413b45a98d71682285ce817"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#aa7388851d413b45a98d71682285ce817">createMaskOpRegion</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *maskableOp)</td></tr>
<tr class="memdesc:aa7388851d413b45a98d71682285ce817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the vector.yield-ended region of a vector.mask op with <code>maskableOp</code> as masked operation.  <a href="namespacemlir_1_1vector.html#aa7388851d413b45a98d71682285ce817">More...</a><br /></td></tr>
<tr class="separator:aa7388851d413b45a98d71682285ce817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f68d86708480673ecc59b2714973a65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a4f68d86708480673ecc59b2714973a65">maskOperation</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *maskableOp, <a class="el" href="classmlir_1_1Value.html">Value</a> mask, <a class="el" href="classmlir_1_1Value.html">Value</a> passthru=<a class="el" href="classmlir_1_1Value.html">Value</a>())</td></tr>
<tr class="memdesc:a4f68d86708480673ecc59b2714973a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector.mask operation around a maskable operation.  <a href="namespacemlir_1_1vector.html#a4f68d86708480673ecc59b2714973a65">More...</a><br /></td></tr>
<tr class="separator:a4f68d86708480673ecc59b2714973a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af92ace2e0cbd151cca52cf528a500a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a5af92ace2e0cbd151cca52cf528a500a">selectPassthru</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Value.html">Value</a> mask, <a class="el" href="classmlir_1_1Value.html">Value</a> newValue, <a class="el" href="classmlir_1_1Value.html">Value</a> passthru)</td></tr>
<tr class="memdesc:a5af92ace2e0cbd151cca52cf528a500a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector select operation that picks values from <code>newValue</code> or <code>passthru</code> for each result vector lane based on <code>mask</code>.  <a href="namespacemlir_1_1vector.html#a5af92ace2e0cbd151cca52cf528a500a">More...</a><br /></td></tr>
<tr class="separator:a5af92ace2e0cbd151cca52cf528a500a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6867327b882d46f26e5f318a023508b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a6867327b882d46f26e5f318a023508b9">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a6867327b882d46f26e5f318a023508b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3d017bb3f90cb64c531e7b6a4b0606"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a8c3d017bb3f90cb64c531e7b6a4b0606">registerBufferizableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a8c3d017bb3f90cb64c531e7b6a4b0606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9b492143f4e66a332ea007fad57beb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#aae9b492143f4e66a332ea007fad57beb">populateVectorContractLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1, bool disableOuterProductLowering=false)</td></tr>
<tr class="memdesc:aae9b492143f4e66a332ea007fad57beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <a href="namespacemlir_1_1vector.html#aae9b492143f4e66a332ea007fad57beb">More...</a><br /></td></tr>
<tr class="separator:aae9b492143f4e66a332ea007fad57beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991e613d3d19627fd75f7c874a8e0fad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a991e613d3d19627fd75f7c874a8e0fad">populateVectorOuterProductLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a991e613d3d19627fd75f7c874a8e0fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <a href="namespacemlir_1_1vector.html#a991e613d3d19627fd75f7c874a8e0fad">More...</a><br /></td></tr>
<tr class="separator:a991e613d3d19627fd75f7c874a8e0fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa136544741125dce255ad55a91f2067a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#aa136544741125dce255ad55a91f2067a">populateVectorMultiReductionLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, VectorMultiReductionLowering <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:aa136544741125dce255ad55a91f2067a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert vector.multi_reduction op into a sequence of vector.reduction ops.  <a href="namespacemlir_1_1vector.html#aa136544741125dce255ad55a91f2067a">More...</a><br /></td></tr>
<tr class="separator:aa136544741125dce255ad55a91f2067a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88033aae0cb3a6e60cbca725c347676f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a88033aae0cb3a6e60cbca725c347676f">populateVectorBroadcastLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a88033aae0cb3a6e60cbca725c347676f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <a href="namespacemlir_1_1vector.html#a88033aae0cb3a6e60cbca725c347676f">More...</a><br /></td></tr>
<tr class="separator:a88033aae0cb3a6e60cbca725c347676f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec71309405318dd0ed6b2b31ded892c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a9ec71309405318dd0ed6b2b31ded892c">populateVectorMaskOpLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a9ec71309405318dd0ed6b2b31ded892c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <a href="namespacemlir_1_1vector.html#a9ec71309405318dd0ed6b2b31ded892c">More...</a><br /></td></tr>
<tr class="separator:a9ec71309405318dd0ed6b2b31ded892c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa279bf22c17b61f1bf71e434dce3f158"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#aa279bf22c17b61f1bf71e434dce3f158">populateScalarVectorTransferLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit, bool allowMultipleUses)</td></tr>
<tr class="memdesc:aa279bf22c17b61f1bf71e434dce3f158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects patterns that lower scalar vector transfer ops to memref loads and stores when beneficial.  <a href="namespacemlir_1_1vector.html#aa279bf22c17b61f1bf71e434dce3f158">More...</a><br /></td></tr>
<tr class="separator:aa279bf22c17b61f1bf71e434dce3f158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43189fd7073752a0dc3e3ac6274a1513"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a43189fd7073752a0dc3e3ac6274a1513">populateVectorShapeCastLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a43189fd7073752a0dc3e3ac6274a1513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <a href="namespacemlir_1_1vector.html#a43189fd7073752a0dc3e3ac6274a1513">More...</a><br /></td></tr>
<tr class="separator:a43189fd7073752a0dc3e3ac6274a1513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161fa2534b0f4f3650c70dad7d14652d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a161fa2534b0f4f3650c70dad7d14652d">populateVectorTransposeLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a161fa2534b0f4f3650c70dad7d14652d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <a href="namespacemlir_1_1vector.html#a161fa2534b0f4f3650c70dad7d14652d">More...</a><br /></td></tr>
<tr class="separator:a161fa2534b0f4f3650c70dad7d14652d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2dd6fac5a93d9d6808bf8737db1cbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a4c2dd6fac5a93d9d6808bf8737db1cbb">populateVectorTransferLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, std::optional&lt; unsigned &gt; maxTransferRank=std::nullopt, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a4c2dd6fac5a93d9d6808bf8737db1cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <a href="namespacemlir_1_1vector.html#a4c2dd6fac5a93d9d6808bf8737db1cbb">More...</a><br /></td></tr>
<tr class="separator:a4c2dd6fac5a93d9d6808bf8737db1cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c619a126f79a49fafb2f76bbc67606"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a13c619a126f79a49fafb2f76bbc67606">populateVectorTransferPermutationMapLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a13c619a126f79a49fafb2f76bbc67606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of transfer read/write lowering patterns that simplify the permutation map (e.g., converting it to a minor identity map) by inserting broadcasts and transposes.  <a href="namespacemlir_1_1vector.html#a13c619a126f79a49fafb2f76bbc67606">More...</a><br /></td></tr>
<tr class="separator:a13c619a126f79a49fafb2f76bbc67606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc33a6788e2401e592cce83b6c68c42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#afbc33a6788e2401e592cce83b6c68c42">populateVectorScanLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:afbc33a6788e2401e592cce83b6c68c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <a href="namespacemlir_1_1vector.html#afbc33a6788e2401e592cce83b6c68c42">More...</a><br /></td></tr>
<tr class="separator:afbc33a6788e2401e592cce83b6c68c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439f87d998fc217be9e760851e5c7a63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a439f87d998fc217be9e760851e5c7a63">populateVectorGatherLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a439f87d998fc217be9e760851e5c7a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <a href="namespacemlir_1_1vector.html#a439f87d998fc217be9e760851e5c7a63">More...</a><br /></td></tr>
<tr class="separator:a439f87d998fc217be9e760851e5c7a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2010f10ca9e7f5df4aed9571180e3c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#ad2010f10ca9e7f5df4aed9571180e3c5">populateVectorMaskLoweringPatternsForSideEffectingOps</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ad2010f10ca9e7f5df4aed9571180e3c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates instances of <code>MaskOpRewritePattern</code> to lower masked operations with <code>vector.mask</code>.  <a href="namespacemlir_1_1vector.html#ad2010f10ca9e7f5df4aed9571180e3c5">More...</a><br /></td></tr>
<tr class="separator:ad2010f10ca9e7f5df4aed9571180e3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d67a015516dec992613685a6bb1a20b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a6d67a015516dec992613685a6bb1a20b">populateVectorMaskedLoadStoreEmulationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a6d67a015516dec992613685a6bb1a20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <a href="namespacemlir_1_1vector.html#a6d67a015516dec992613685a6bb1a20b">More...</a><br /></td></tr>
<tr class="separator:a6d67a015516dec992613685a6bb1a20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c07e592cdd88b811669bd163b93378"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#ad3c07e592cdd88b811669bd163b93378">populateVectorInterleaveLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, int64_t targetRank=1, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:ad3c07e592cdd88b811669bd163b93378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <a href="namespacemlir_1_1vector.html#ad3c07e592cdd88b811669bd163b93378">More...</a><br /></td></tr>
<tr class="separator:ad3c07e592cdd88b811669bd163b93378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e5072e435d0da63d65e437f724e246"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a33e5072e435d0da63d65e437f724e246">populateVectorInterleaveToShufflePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="separator:a33e5072e435d0da63d65e437f724e246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cad1ef496d64e01a0d7aaa62432e1d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a8cad1ef496d64e01a0d7aaa62432e1d9">populateVectorBitCastLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, int64_t targetRank=1, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a8cad1ef496d64e01a0d7aaa62432e1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the pattern set with the following patterns:  <a href="namespacemlir_1_1vector.html#a8cad1ef496d64e01a0d7aaa62432e1d9">More...</a><br /></td></tr>
<tr class="separator:a8cad1ef496d64e01a0d7aaa62432e1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555cfa7abe7f1b002abcfff16083f064"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a555cfa7abe7f1b002abcfff16083f064">createLowerVectorMaskPass</a> ()</td></tr>
<tr class="memdesc:a555cfa7abe7f1b002abcfff16083f064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the <code>vector.mask</code> lowering pass.  <a href="namespacemlir_1_1vector.html#a555cfa7abe7f1b002abcfff16083f064">More...</a><br /></td></tr>
<tr class="separator:a555cfa7abe7f1b002abcfff16083f064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26015b9a6577ffa18fb62c89008c20cb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a26015b9a6577ffa18fb62c89008c20cb">createLowerVectorMultiReductionPass</a> (VectorMultiReductionLowering option=VectorMultiReductionLowering::InnerParallel)</td></tr>
<tr class="memdesc:a26015b9a6577ffa18fb62c89008c20cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the <code>vector.multi_reduction</code> lowering pass.  <a href="namespacemlir_1_1vector.html#a26015b9a6577ffa18fb62c89008c20cb">More...</a><br /></td></tr>
<tr class="separator:a26015b9a6577ffa18fb62c89008c20cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e106dc1b48251f4b3e11566df14078a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a5e106dc1b48251f4b3e11566df14078a">registerSubsetOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a5e106dc1b48251f4b3e11566df14078a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c711eddaf2b505fc007762dc805ecf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a6c711eddaf2b505fc007762dc805ecf0">populateWarpExecuteOnLane0OpToScfForPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="structmlir_1_1vector_1_1WarpExecuteOnLane0LoweringOptions.html">WarpExecuteOnLane0LoweringOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="separator:a6c711eddaf2b505fc007762dc805ecf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8461b000c4283d776959689802a7dea7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a8461b000c4283d776959689802a7dea7">populateVectorContractCanonicalizeMatmulToMMT</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, std::function&lt; LogicalResult(vector::ContractionOp)&gt; constraint=[](vector::ContractionOp) { return success();}, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>=1)</td></tr>
<tr class="memdesc:a8461b000c4283d776959689802a7dea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalization of a <code>vector.contraction a, b, c</code> with row-major matmul semantics to a contraction with MMT semantics (matrix matrix multiplication with the RHS transposed).  <a href="namespacemlir_1_1vector.html#a8461b000c4283d776959689802a7dea7">More...</a><br /></td></tr>
<tr class="separator:a8461b000c4283d776959689802a7dea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c39668001ee9e2ba767b172123f1d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#aa2c39668001ee9e2ba767b172123f1d8">populateVectorReductionToContractPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:aa2c39668001ee9e2ba767b172123f1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect patterns to convert reduction op to vector.contract and fold transpose/broadcast ops into the contract.  <a href="namespacemlir_1_1vector.html#aa2c39668001ee9e2ba767b172123f1d8">More...</a><br /></td></tr>
<tr class="separator:aa2c39668001ee9e2ba767b172123f1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac789257ecc17a3ca9c07a9178fb530a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#ac789257ecc17a3ca9c07a9178fb530a3">populateVectorTransferFullPartialPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:ac789257ecc17a3ca9c07a9178fb530a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate <code>patterns</code> with the following patterns.  <a href="namespacemlir_1_1vector.html#ac789257ecc17a3ca9c07a9178fb530a3">More...</a><br /></td></tr>
<tr class="separator:ac789257ecc17a3ca9c07a9178fb530a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29269f57c53624b09c7c7ffbb10cc85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#aa29269f57c53624b09c7c7ffbb10cc85">populateVectorTransferCollapseInnerMostContiguousDimsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:aa29269f57c53624b09c7c7ffbb10cc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to reduce the rank of the operands of vector transfer ops to operate on the largest contigious vector.  <a href="namespacemlir_1_1vector.html#aa29269f57c53624b09c7c7ffbb10cc85">More...</a><br /></td></tr>
<tr class="separator:aa29269f57c53624b09c7c7ffbb10cc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848e82989f2072855d837185e7e7694a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a848e82989f2072855d837185e7e7694a">populateSinkVectorOpsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a848e82989f2072855d837185e7e7694a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns that remove redundant <a class="el" href="structVector.html">Vector</a> Ops by re-ordering them with e.g.  <a href="namespacemlir_1_1vector.html#a848e82989f2072855d837185e7e7694a">More...</a><br /></td></tr>
<tr class="separator:a848e82989f2072855d837185e7e7694a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e660a087efe580b67b684a49acb83be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a5e660a087efe580b67b684a49acb83be">populateChainedVectorReductionFoldingPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a5e660a087efe580b67b684a49acb83be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns that fold chained vector reductions.  <a href="namespacemlir_1_1vector.html#a5e660a087efe580b67b684a49acb83be">More...</a><br /></td></tr>
<tr class="separator:a5e660a087efe580b67b684a49acb83be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38f9aa565f0a664dc5bdcf208a0d1d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#ad38f9aa565f0a664dc5bdcf208a0d1d1">populateBreakDownVectorReductionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, unsigned maxNumElementsToExtract=2, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:ad38f9aa565f0a664dc5bdcf208a0d1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to break down vector reductions into a series of arith reductions over vector elements.  <a href="namespacemlir_1_1vector.html#ad38f9aa565f0a664dc5bdcf208a0d1d1">More...</a><br /></td></tr>
<tr class="separator:ad38f9aa565f0a664dc5bdcf208a0d1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a5f5c20fcd404c551461d5b178db40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#aa0a5f5c20fcd404c551461d5b178db40">populateVectorInsertExtractStridedSliceDecompositionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:aa0a5f5c20fcd404c551461d5b178db40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate <code>patterns</code> with the following patterns.  <a href="namespacemlir_1_1vector.html#aa0a5f5c20fcd404c551461d5b178db40">More...</a><br /></td></tr>
<tr class="separator:aa0a5f5c20fcd404c551461d5b178db40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31240a19ebf99d76b171bf5740c2788f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a31240a19ebf99d76b171bf5740c2788f">populateVectorExtractStridedSliceToExtractInsertChainPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, std::function&lt; bool(ExtractStridedSliceOp)&gt; controlFn=nullptr, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a31240a19ebf99d76b171bf5740c2788f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate <code>patterns</code> with a pattern to breaks down 1-D extract_strided_slice ops into a chain of Extract ops to extract each element from the source, and then a chain of Insert ops to insert to the target vector.  <a href="namespacemlir_1_1vector.html#a31240a19ebf99d76b171bf5740c2788f">More...</a><br /></td></tr>
<tr class="separator:a31240a19ebf99d76b171bf5740c2788f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24725f068970593e59e43b897256c302"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a24725f068970593e59e43b897256c302">populateBreakDownVectorBitCastOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, std::function&lt; bool(BitCastOp)&gt; controlFn=nullptr, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a24725f068970593e59e43b897256c302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate <code>patterns</code> with a pattern to break down 1-D vector.bitcast ops based on the destination vector shape.  <a href="namespacemlir_1_1vector.html#a24725f068970593e59e43b897256c302">More...</a><br /></td></tr>
<tr class="separator:a24725f068970593e59e43b897256c302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe6e410da8807fa4e5764fd09bd1f8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#adfe6e410da8807fa4e5764fd09bd1f8b">populateVectorInsertExtractStridedSliceTransforms</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:adfe6e410da8807fa4e5764fd09bd1f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate <code>patterns</code> with the following patterns.  <a href="namespacemlir_1_1vector.html#adfe6e410da8807fa4e5764fd09bd1f8b">More...</a><br /></td></tr>
<tr class="separator:adfe6e410da8807fa4e5764fd09bd1f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e2c03cbbc4d9435b42777340ecefaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#ac2e2c03cbbc4d9435b42777340ecefaa">populateVectorUnrollPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="structmlir_1_1vector_1_1UnrollVectorOptions.html">UnrollVectorOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:ac2e2c03cbbc4d9435b42777340ecefaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of pattern to unroll vector operations to a smaller shapes.  <a href="namespacemlir_1_1vector.html#ac2e2c03cbbc4d9435b42777340ecefaa">More...</a><br /></td></tr>
<tr class="separator:ac2e2c03cbbc4d9435b42777340ecefaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fbbc879aa374f81b77fec292c3ec33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a39fbbc879aa374f81b77fec292c3ec33">populateShapeCastFoldingPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a39fbbc879aa374f81b77fec292c3ec33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of vector.shape_cast folding patterns.  <a href="namespacemlir_1_1vector.html#a39fbbc879aa374f81b77fec292c3ec33">More...</a><br /></td></tr>
<tr class="separator:a39fbbc879aa374f81b77fec292c3ec33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd091159bea6b87de599da44e4b7611"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#adfd091159bea6b87de599da44e4b7611">populateCastAwayVectorLeadingOneDimPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:adfd091159bea6b87de599da44e4b7611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of leading one dimension removal patterns.  <a href="namespacemlir_1_1vector.html#adfd091159bea6b87de599da44e4b7611">More...</a><br /></td></tr>
<tr class="separator:adfd091159bea6b87de599da44e4b7611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562524e33c5d6d7982e318c9b2cf20e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a562524e33c5d6d7982e318c9b2cf20e0">populateVectorTransferDropUnitDimsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a562524e33c5d6d7982e318c9b2cf20e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of one dimension removal patterns.  <a href="namespacemlir_1_1vector.html#a562524e33c5d6d7982e318c9b2cf20e0">More...</a><br /></td></tr>
<tr class="separator:a562524e33c5d6d7982e318c9b2cf20e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152e1e5d3a703fe809ee1b23dfb8631c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a152e1e5d3a703fe809ee1b23dfb8631c">populateDropUnitDimWithShapeCastPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a152e1e5d3a703fe809ee1b23dfb8631c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns that use vector.shape_cast to help fold unit dims.  <a href="namespacemlir_1_1vector.html#a152e1e5d3a703fe809ee1b23dfb8631c">More...</a><br /></td></tr>
<tr class="separator:a152e1e5d3a703fe809ee1b23dfb8631c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5d23a414967805d3efa498da76ee9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a1e5d23a414967805d3efa498da76ee9f">populateFlattenVectorTransferPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, unsigned targetVectorBitwidth=std::numeric_limits&lt; unsigned &gt;::<a class="el" href="PolynomialApproximation_8cpp.html#acbcaffd2f4cbc4dd948549fd577631eb">max</a>(), <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a1e5d23a414967805d3efa498da76ee9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to flatten n-D vector transfers on contiguous memref.  <a href="namespacemlir_1_1vector.html#a1e5d23a414967805d3efa498da76ee9f">More...</a><br /></td></tr>
<tr class="separator:a1e5d23a414967805d3efa498da76ee9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa78aa2fd99a07cb2716707d79fc601"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a5fa78aa2fd99a07cb2716707d79fc601">populateBubbleVectorBitCastOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a5fa78aa2fd99a07cb2716707d79fc601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns that bubble up/down bitcast ops.  <a href="namespacemlir_1_1vector.html#a5fa78aa2fd99a07cb2716707d79fc601">More...</a><br /></td></tr>
<tr class="separator:a5fa78aa2fd99a07cb2716707d79fc601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956c19ab091edb09330a40669b46700e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a956c19ab091edb09330a40669b46700e">populateVectorMaskMaterializationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool force32BitVectorIndices, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a956c19ab091edb09330a40669b46700e"><td class="mdescLeft">&#160;</td><td class="mdescRight">These patterns materialize masks for various vector ops such as transfers.  <a href="namespacemlir_1_1vector.html#a956c19ab091edb09330a40669b46700e">More...</a><br /></td></tr>
<tr class="separator:a956c19ab091edb09330a40669b46700e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b818b615e83ba52295ba49932a9564"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a75b818b615e83ba52295ba49932a9564">populateVectorNarrowTypeEmulationPatterns</a> (const <a class="el" href="classmlir_1_1arith_1_1NarrowTypeEmulationConverter.html">arith::NarrowTypeEmulationConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a75b818b615e83ba52295ba49932a9564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for emulating vector operations over narrow types with ops over wider types.  <a href="namespacemlir_1_1vector.html#a75b818b615e83ba52295ba49932a9564">More...</a><br /></td></tr>
<tr class="separator:a75b818b615e83ba52295ba49932a9564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a013aa5d2cfebec7af08d05b7c7a24"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a86a013aa5d2cfebec7af08d05b7c7a24">rewriteBitCastOfTruncI</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, vector::BitCastOp bitCastOp, arith::TruncIOp truncOp, vector::BroadcastOp maybeBroadcastOp)</td></tr>
<tr class="memdesc:a86a013aa5d2cfebec7af08d05b7c7a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a vector <code>bitcast(trunci)</code> to use a more efficient sequence of vector operations comprising <code>shuffle</code> and <code>bitwise</code> ops.  <a href="namespacemlir_1_1vector.html#a86a013aa5d2cfebec7af08d05b7c7a24">More...</a><br /></td></tr>
<tr class="separator:a86a013aa5d2cfebec7af08d05b7c7a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca0b5d1e5bdaae4f8f5b6445c8302db"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#aeca0b5d1e5bdaae4f8f5b6445c8302db">rewriteExtOfBitCast</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *extOp, vector::BitCastOp bitCastOp, vector::BroadcastOp maybeBroadcastOp)</td></tr>
<tr class="memdesc:aeca0b5d1e5bdaae4f8f5b6445c8302db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a vector <code>ext(bitcast)</code> to use a more efficient sequence of vector operations comprising <code>shuffle</code> and <code>bitwise</code> ops.  <a href="namespacemlir_1_1vector.html#aeca0b5d1e5bdaae4f8f5b6445c8302db">More...</a><br /></td></tr>
<tr class="separator:aeca0b5d1e5bdaae4f8f5b6445c8302db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156930655d3fc40716c9264f1e74044e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a156930655d3fc40716c9264f1e74044e">populateVectorNarrowTypeRewritePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a156930655d3fc40716c9264f1e74044e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for rewriting vector operations over narrow types with ops over wider types.  <a href="namespacemlir_1_1vector.html#a156930655d3fc40716c9264f1e74044e">More...</a><br /></td></tr>
<tr class="separator:a156930655d3fc40716c9264f1e74044e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c67458578e96f16136e500f923de76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#ae1c67458578e96f16136e500f923de76">populateVectorTransposeNarrowTypeRewritePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:ae1c67458578e96f16136e500f923de76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for emulating a sub-byte vector transpose.  <a href="namespacemlir_1_1vector.html#ae1c67458578e96f16136e500f923de76">More...</a><br /></td></tr>
<tr class="separator:ae1c67458578e96f16136e500f923de76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2590b4049cfbe0675e37392dd7bc8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#aee2590b4049cfbe0675e37392dd7bc8f">populateVectorLinearizeTypeConversionsAndLegality</a> (<a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, unsigned targetBitWidth)</td></tr>
<tr class="memdesc:aee2590b4049cfbe0675e37392dd7bc8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns for ND vectors (N &gt;= 2) linearization and sets up the provided <a class="el" href="classmlir_1_1ConversionTarget.html" title="This class describes a specific conversion target.">ConversionTarget</a> with the appropriate legality configuration for the ops to get converted properly.  <a href="namespacemlir_1_1vector.html#aee2590b4049cfbe0675e37392dd7bc8f">More...</a><br /></td></tr>
<tr class="separator:aee2590b4049cfbe0675e37392dd7bc8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b7ac5247b3dc61df68ccd19bd7e854"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a29b7ac5247b3dc61df68ccd19bd7e854">populateVectorLinearizeShuffleLikeOpsPatterns</a> (const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, unsigned targetBitWidth)</td></tr>
<tr class="memdesc:a29b7ac5247b3dc61df68ccd19bd7e854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns for linearizing ND (N &gt;= 2) vector operations to 1D vector shuffle operations.  <a href="namespacemlir_1_1vector.html#a29b7ac5247b3dc61df68ccd19bd7e854">More...</a><br /></td></tr>
<tr class="separator:a29b7ac5247b3dc61df68ccd19bd7e854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e81512618f45b287d46448b0089ff88"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a1e81512618f45b287d46448b0089ff88">splitFullAndPartialTransfer</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, VectorTransferOpInterface xferOp, <a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>=<a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a>(), scf::IfOp *ifOp=nullptr)</td></tr>
<tr class="memdesc:a1e81512618f45b287d46448b0089ff88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a vector.transfer operation into an in-bounds (i.e., no out-of-bounds masking) fastpath and a slowpath.  <a href="namespacemlir_1_1vector.html#a1e81512618f45b287d46448b0089ff88">More...</a><br /></td></tr>
<tr class="separator:a1e81512618f45b287d46448b0089ff88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ac1b62d7c1228fac70b59c19a63b58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a86ac1b62d7c1228fac70b59c19a63b58">transferOpflowOpt</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *rootOp)</td></tr>
<tr class="memdesc:a86ac1b62d7c1228fac70b59c19a63b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements transfer op write to read forwarding and dead transfer write optimizations.  <a href="namespacemlir_1_1vector.html#a86ac1b62d7c1228fac70b59c19a63b58">More...</a><br /></td></tr>
<tr class="separator:a86ac1b62d7c1228fac70b59c19a63b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0b351193a1913c56e4f84f15e86f6d"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a0c0b351193a1913c56e4f84f15e86f6d">castAwayContractionLeadingOneDim</a> (vector::ContractionOp contractOp, MaskingOpInterface maskingOp, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter)</td></tr>
<tr class="memdesc:a0c0b351193a1913c56e4f84f15e86f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast away the leading unit dim, if exists, for the given contract op.  <a href="namespacemlir_1_1vector.html#a0c0b351193a1913c56e4f84f15e86f6d">More...</a><br /></td></tr>
<tr class="separator:a0c0b351193a1913c56e4f84f15e86f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09a4c24cd4f1765fa613e5f4d3cbeee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#ad09a4c24cd4f1765fa613e5f4d3cbeee">eliminateVectorMasks</a> (<a class="el" href="classmlir_1_1IRRewriter.html">IRRewriter</a> &amp;rewriter, FunctionOpInterface function, std::optional&lt; <a class="el" href="structmlir_1_1vector_1_1VscaleRange.html">VscaleRange</a> &gt; vscaleRange={})</td></tr>
<tr class="memdesc:ad09a4c24cd4f1765fa613e5f4d3cbeee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to eliminate redundant vector masks by replacing them with all-true constants at the top of the function (which results in the masks folding away).  <a href="namespacemlir_1_1vector.html#ad09a4c24cd4f1765fa613e5f4d3cbeee">More...</a><br /></td></tr>
<tr class="separator:ad09a4c24cd4f1765fa613e5f4d3cbeee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bd96ceaaff937da9c8067138e02591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#ab0bd96ceaaff937da9c8067138e02591">createOrFoldDimOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> source, int64_t dim)</td></tr>
<tr class="memdesc:ab0bd96ceaaff937da9c8067138e02591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that creates a memref::DimOp or tensor::DimOp depending on the type of <code>source</code>.  <a href="namespacemlir_1_1vector.html#ab0bd96ceaaff937da9c8067138e02591">More...</a><br /></td></tr>
<tr class="separator:ab0bd96ceaaff937da9c8067138e02591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87dd4973a2bd2cac230734188a21c995"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a87dd4973a2bd2cac230734188a21c995">isTranspose2DSlice</a> (vector::TransposeOp op)</td></tr>
<tr class="memdesc:a87dd4973a2bd2cac230734188a21c995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns two dims that are greater than one if the transposition is applied on a 2D slice.  <a href="namespacemlir_1_1vector.html#a87dd4973a2bd2cac230734188a21c995">More...</a><br /></td></tr>
<tr class="separator:a87dd4973a2bd2cac230734188a21c995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2098102a54883ea02ee203ebabb4012e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a2098102a54883ea02ee203ebabb4012e">isContiguousSlice</a> (MemRefType memrefType, VectorType vectorType)</td></tr>
<tr class="memdesc:a2098102a54883ea02ee203ebabb4012e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <code>vectorType</code> is a contiguous slice of <code>memrefType</code>.  <a href="namespacemlir_1_1vector.html#a2098102a54883ea02ee203ebabb4012e">More...</a><br /></td></tr>
<tr class="separator:a2098102a54883ea02ee203ebabb4012e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf889b1d187dae58df0a17542b919ad"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1StaticTileOffsetRange.html">StaticTileOffsetRange</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#aabf889b1d187dae58df0a17542b919ad">createUnrollIterator</a> (VectorType vType, int64_t targetRank=1)</td></tr>
<tr class="memdesc:aabf889b1d187dae58df0a17542b919ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator for all positions in the leading dimensions of <code>vType</code> up to the <code>targetRank</code>.  <a href="namespacemlir_1_1vector.html#aabf889b1d187dae58df0a17542b919ad">More...</a><br /></td></tr>
<tr class="separator:aabf889b1d187dae58df0a17542b919ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a5584142f33c4a2887d2e3131f7565"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#ad0a5584142f33c4a2887d2e3131f7565">makeVscaleConstantBuilder</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:ad0a5584142f33c4a2887d2e3131f7565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a functor (int64_t -&gt; <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>) which returns a constant vscale multiple.  <a href="namespacemlir_1_1vector.html#ad0a5584142f33c4a2887d2e3131f7565">More...</a><br /></td></tr>
<tr class="separator:ad0a5584142f33c4a2887d2e3131f7565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a96bb3f0e3f37f46743b34436f7b14d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a2a96bb3f0e3f37f46743b34436f7b14d">getDims</a> (VectorType vType)</td></tr>
<tr class="memdesc:a2a96bb3f0e3f37f46743b34436f7b14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range over the dims (size and scalability) of a VectorType.  <a href="namespacemlir_1_1vector.html#a2a96bb3f0e3f37f46743b34436f7b14d">More...</a><br /></td></tr>
<tr class="separator:a2a96bb3f0e3f37f46743b34436f7b14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad910c130857e946d9d30b58ffb708f3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#ad910c130857e946d9d30b58ffb708f3a">getMixedSizesXfer</a> (bool hasTensorSemantics, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *xfer, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter)</td></tr>
<tr class="memdesc:ad910c130857e946d9d30b58ffb708f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for getMixedSizes for vector.transfer_read and vector.transfer_write Ops (for source and destination, respectively).  <a href="namespacemlir_1_1vector.html#ad910c130857e946d9d30b58ffb708f3a">More...</a><br /></td></tr>
<tr class="separator:ad910c130857e946d9d30b58ffb708f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf9a8c7b9a914162f597bc6d1aa0633"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#abdf9a8c7b9a914162f597bc6d1aa0633">isLinearizableVector</a> (VectorType type)</td></tr>
<tr class="memdesc:abdf9a8c7b9a914162f597bc6d1aa0633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the input <a class="el" href="structVector.html">Vector</a> type can be linearized.  <a href="namespacemlir_1_1vector.html#abdf9a8c7b9a914162f597bc6d1aa0633">More...</a><br /></td></tr>
<tr class="separator:abdf9a8c7b9a914162f597bc6d1aa0633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0bde76343a10c5d14c61834c2008eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#acf0bde76343a10c5d14c61834c2008eb">createReadOrMaskedRead</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> source, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; readShape, <a class="el" href="classmlir_1_1Value.html">Value</a> padValue, bool useInBoundsInsteadOfMasking)</td></tr>
<tr class="memdesc:acf0bde76343a10c5d14c61834c2008eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a TransferReadOp from <code>source</code> with static shape <code>readShape</code>.  <a href="namespacemlir_1_1vector.html#acf0bde76343a10c5d14c61834c2008eb">More...</a><br /></td></tr>
<tr class="separator:acf0bde76343a10c5d14c61834c2008eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341516a4c95139534df7b424b2de2598"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a341516a4c95139534df7b424b2de2598">isValidMaskedInputVector</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inputVectorSizes)</td></tr>
<tr class="memdesc:a341516a4c95139534df7b424b2de2598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns success if <code>inputVectorSizes</code> is a valid masking configuraion for given <code>shape</code>, i.e., it meets:  <a href="namespacemlir_1_1vector.html#a341516a4c95139534df7b424b2de2598">More...</a><br /></td></tr>
<tr class="separator:a341516a4c95139534df7b424b2de2598"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a00e8e971c19fdf979d14a69ebbbb2c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e8e971c19fdf979d14a69ebbbb2c8d">&#9670;&nbsp;</a></span>ConstantOrScalableBound</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1vector.html#a00e8e971c19fdf979d14a69ebbbb2c8d">mlir::vector::ConstantOrScalableBound</a> = typedef <a class="el" href="structmlir_1_1vector_1_1ScalableValueBoundsConstraintSet_1_1ConstantOrScalableBound.html">ScalableValueBoundsConstraintSet::ConstantOrScalableBound</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalableValueBoundsConstraintSet_8h_source.html#l00103">103</a> of file <a class="el" href="ScalableValueBoundsConstraintSet_8h_source.html">ScalableValueBoundsConstraintSet.h</a>.</p>

</div>
</div>
<a id="ae3e87c5919acbac1e6dd95ffbdf7b588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e87c5919acbac1e6dd95ffbdf7b588">&#9670;&nbsp;</a></span>DistributionMapFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1vector.html#ae3e87c5919acbac1e6dd95ffbdf7b588">mlir::vector::DistributionMapFn</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorDistribution_8h_source.html#l00043">43</a> of file <a class="el" href="VectorDistribution_8h_source.html">VectorDistribution.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="acfee45e655b185bd625e2f7994dc2c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfee45e655b185bd625e2f7994dc2c50">&#9670;&nbsp;</a></span>BroadcastableToResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50">mlir::vector::BroadcastableToResult</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether <code>srcType</code> can be broadcast to <code>dstVectorType</code> under the semantics of the <code>vector.broadcast</code> op. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acfee45e655b185bd625e2f7994dc2c50a505a83f220c02df2f85c3810cd9ceb38"></a>Success&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acfee45e655b185bd625e2f7994dc2c50ac76fd47e5afe8e699733f0b655854c5a"></a>SourceRankHigher&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acfee45e655b185bd625e2f7994dc2c50a2664c241558d7674e8ed4d5f63d2e463"></a>DimensionMismatch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acfee45e655b185bd625e2f7994dc2c50a578636e914af1c61d9d43b36a2076248"></a>SourceTypeNotAVector&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="VectorOps_8h_source.html#l00068">68</a> of file <a class="el" href="VectorOps_8h_source.html">VectorOps.h</a>.</p>

</div>
</div>
<a id="a4ba6d4a825dbd36205be5322733056ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba6d4a825dbd36205be5322733056ef">&#9670;&nbsp;</a></span>ConstantMaskKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1vector.html#a4ba6d4a825dbd36205be5322733056ef">mlir::vector::ConstantMaskKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predefined constant_mask kinds. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4ba6d4a825dbd36205be5322733056efa5a26d218c82b9e4168d67628ecb0a0d1"></a>AllFalse&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4ba6d4a825dbd36205be5322733056efa822b19813c2556c566eec6864da1319f"></a>AllTrue&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="VectorOps_8h_source.html#l00060">60</a> of file <a class="el" href="VectorOps_8h_source.html">VectorOps.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2683abb4897d8bda306d12702ee2ca04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2683abb4897d8bda306d12702ee2ca04">&#9670;&nbsp;</a></span>buildTerminatedBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::buildTerminatedBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default callback to build a region with a 'vector.yield' terminator with no arguments. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00125">125</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>.</p>

</div>
</div>
<a id="a0c0b351193a1913c56e4f84f15e86f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0b351193a1913c56e4f84f15e86f6d">&#9670;&nbsp;</a></span>castAwayContractionLeadingOneDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::vector::castAwayContractionLeadingOneDim </td>
          <td>(</td>
          <td class="paramtype">vector::ContractionOp&#160;</td>
          <td class="paramname"><em>contractOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MaskingOpInterface&#160;</td>
          <td class="paramname"><em>maskingOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast away the leading unit dim, if exists, for the given contract op. </p>
<p>Return success if the transformation applies; return failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="VectorDropLeadUnitDim_8cpp_source.html#l00333">333</a> of file <a class="el" href="VectorDropLeadUnitDim_8cpp_source.html">VectorDropLeadUnitDim.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8h_source.html#l00528">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01240">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00395">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00349">mlir::Builder::getAffineMapArrayAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00297">mlir::Builder::getArrayAttr()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00410">mlir::Operation::getResults()</a>, <a class="el" href="VectorOps_8h_source.html#l00147">isParallelIterator()</a>, <a class="el" href="namespacemlir_1_1vector.html#a4f68d86708480673ecc59b2714973a65">maskOperation()</a>, and <a class="el" href="VectorDropLeadUnitDim_8cpp_source.html#l00049">splatZero()</a>.</p>

</div>
</div>
<a id="a3db9bda1f50ffdff9759b51bf49ddb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db9bda1f50ffdff9759b51bf49ddb86">&#9670;&nbsp;</a></span>checkSameValueRAW()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::vector::checkSameValueRAW </td>
          <td>(</td>
          <td class="paramtype">TransferWriteOp&#160;</td>
          <td class="paramname"><em>defWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TransferReadOp&#160;</td>
          <td class="paramname"><em>read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the transfer_write fully writes the data accessed by the transfer_read. </p>

</div>
</div>
<a id="a6f1125a16d0ba1e024d9b99d5b439a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1125a16d0ba1e024d9b99d5b439a0a">&#9670;&nbsp;</a></span>checkSameValueWAW()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::vector::checkSameValueWAW </td>
          <td>(</td>
          <td class="paramtype">TransferWriteOp&#160;</td>
          <td class="paramname"><em>write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TransferWriteOp&#160;</td>
          <td class="paramname"><em>priorWrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the write op fully over-write the priorWrite transfer_write op. </p>

</div>
</div>
<a id="a555cfa7abe7f1b002abcfff16083f064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555cfa7abe7f1b002abcfff16083f064">&#9670;&nbsp;</a></span>createLowerVectorMaskPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::vector::createLowerVectorMaskPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the <code>vector.mask</code> lowering pass. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorMask_8cpp_source.html#l00309">309</a> of file <a class="el" href="LowerVectorMask_8cpp_source.html">LowerVectorMask.cpp</a>.</p>

</div>
</div>
<a id="a26015b9a6577ffa18fb62c89008c20cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26015b9a6577ffa18fb62c89008c20cb">&#9670;&nbsp;</a></span>createLowerVectorMultiReductionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">Pass</a>&gt; mlir::vector::createLowerVectorMultiReductionPass </td>
          <td>(</td>
          <td class="paramtype">VectorMultiReductionLowering&#160;</td>
          <td class="paramname"><em>option</em> = <code>VectorMultiReductionLowering::InnerParallel</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the <code>vector.multi_reduction</code> lowering pass. </p>

</div>
</div>
<a id="aa7388851d413b45a98d71682285ce817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7388851d413b45a98d71682285ce817">&#9670;&nbsp;</a></span>createMaskOpRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::createMaskOpRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>maskableOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the vector.yield-ended region of a vector.mask op with <code>maskableOp</code> as masked operation. </p>

</div>
</div>
<a id="ab0bd96ceaaff937da9c8067138e02591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0bd96ceaaff937da9c8067138e02591">&#9670;&nbsp;</a></span>createOrFoldDimOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::vector::createOrFoldDimOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function that creates a memref::DimOp or tensor::DimOp depending on the type of <code>source</code>. </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00041">41</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00528">mlir::OpBuilder::createOrFold()</a>, and <a class="el" href="Value_8h_source.html#l00129">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="acf0bde76343a10c5d14c61834c2008eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf0bde76343a10c5d14c61834c2008eb">&#9670;&nbsp;</a></span>createReadOrMaskedRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::vector::createReadOrMaskedRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>readShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>padValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useInBoundsInsteadOfMasking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a TransferReadOp from <code>source</code> with static shape <code>readShape</code>. </p>
<p>If the vector type for the read is not the same as the type of <code>source</code>, then a mask is created on the read, if use of mask is specified or the bounds on a dimension are different.</p>
<p><code>useInBoundsInsteadOfMasking</code> if false, the inBoundsVal values are set properly, based on the rank dimensions of the source and destination tensors. And that is what determines if masking is done.</p>
<p>Note that the internal <code>vector::TransferReadOp</code> always read at indices zero for each dimension of the passed in tensor. </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00329">329</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00097">mlir::Builder::getI1Type()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00065">mlir::tensor::getMixedSizes()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00402">mlir::Operation::getResult()</a>, <a class="el" href="Value_8h_source.html#l00129">mlir::Value::getType()</a>, and <a class="el" href="namespacemlir_1_1vector.html#a4f68d86708480673ecc59b2714973a65">maskOperation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01534">vectorizeAsTensorPackOp()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01737">vectorizeAsTensorPadOp()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01609">vectorizeAsTensorUnpackOp()</a>.</p>

</div>
</div>
<a id="aabf889b1d187dae58df0a17542b919ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf889b1d187dae58df0a17542b919ad">&#9670;&nbsp;</a></span>createUnrollIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1StaticTileOffsetRange.html">StaticTileOffsetRange</a> &gt; mlir::vector::createUnrollIterator </td>
          <td>(</td>
          <td class="paramtype">VectorType&#160;</td>
          <td class="paramname"><em>vType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>targetRank</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator for all positions in the leading dimensions of <code>vType</code> up to the <code>targetRank</code>. </p>
<p>If any leading dimension before the <code>targetRank</code> is scalable (so cannot be unrolled), it will return an iterator for positions up to the first scalable dimension.</p>
<p>If no leading dimensions can be unrolled an empty optional will be returned.</p>
<p>Examples:</p>
<p>For vType = vector&lt;2x3x4&gt; and targetRank = 1</p>
<p>The resulting iterator will yield: [0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2]</p>
<p>For vType = vector&lt;3x[4]x5&gt; and targetRank = 0</p>
<p>The scalable dimension blocks unrolling so the iterator yields only: [0], [1], [2] </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00287">287</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

</div>
</div>
<a id="ad09a4c24cd4f1765fa613e5f4d3cbeee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09a4c24cd4f1765fa613e5f4d3cbeee">&#9670;&nbsp;</a></span>eliminateVectorMasks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::eliminateVectorMasks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IRRewriter.html">IRRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionOpInterface&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="structmlir_1_1vector_1_1VscaleRange.html">VscaleRange</a> &gt;&#160;</td>
          <td class="paramname"><em>vscaleRange</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to eliminate redundant vector masks by replacing them with all-true constants at the top of the function (which results in the masks folding away). </p>
<p>Note: Currently, this only runs for vector.create_mask ops and requires <code>vscaleRange</code>. If <code>vscaleRange</code> is not provided this transform does nothing. This is because these redundant masks are much more likely for scalable code which requires memref/tensor dynamic sizes, whereas fixed-size code has static sizes, so simpler folds remove the masks. </p>

<p class="definition">Definition at line <a class="el" href="VectorMaskElimination_8cpp_source.html#l00097">97</a> of file <a class="el" href="VectorMaskElimination_8cpp_source.html">VectorMaskElimination.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00439">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="af32acdf7a602e7b76f6784237c2f2fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32acdf7a602e7b76f6784237c2f2fa2">&#9670;&nbsp;</a></span>getAsIntegers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; mlir::vector::getAsIntegers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>foldResults</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the integer numbers in <code>foldResults</code>. </p>
<p><code>foldResults</code> are expected to be constant operations. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00326">326</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

</div>
</div>
<a id="a817b87f0647b2d105ddb4ee8331c6e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817b87f0647b2d105ddb4ee8331c6e74">&#9670;&nbsp;</a></span>getAsIntegers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; mlir::vector::getAsIntegers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the integer numbers in <code>values</code>. </p>
<p><code>values</code> are expected to be constant operations. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00314">314</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>.</p>

</div>
</div>
<a id="ab5c8f18ea2cde21d5f5585fe430d0494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c8f18ea2cde21d5f5585fe430d0494">&#9670;&nbsp;</a></span>getAsValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::vector::getAsValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>foldResults</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert <code>foldResults</code> into Values. </p>
<p>Integer attributes are converted to constant op. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00338">338</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>.</p>

</div>
</div>
<a id="a30a2f31604d067d92eed03a981b27cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a2f31604d067d92eed03a981b27cc5">&#9670;&nbsp;</a></span>getConstantVscaleMultiplier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; int64_t &gt; mlir::vector::getConstantVscaleMultiplier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>value</code> is a constant multiple of <code>vector.vscale</code> (e.g. </p>
<p><code>cst * vector.vscale</code>), return the multiplier (<code>cst</code>). Otherwise, return <code>std::nullopt</code>. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00354">354</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00105">mlir::getConstantIntValue()</a>, and <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>.</p>

</div>
</div>
<a id="a2a96bb3f0e3f37f46743b34436f7b14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a96bb3f0e3f37f46743b34436f7b14d">&#9670;&nbsp;</a></span>getDims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::vector::getDims </td>
          <td>(</td>
          <td class="paramtype">VectorType&#160;</td>
          <td class="paramname"><em>vType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range over the dims (size and scalability) of a VectorType. </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8h_source.html#l00124">124</a> of file <a class="el" href="VectorUtils_8h_source.html">VectorUtils.h</a>.</p>

</div>
</div>
<a id="ad910c130857e946d9d30b58ffb708f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad910c130857e946d9d30b58ffb708f3a">&#9670;&nbsp;</a></span>getMixedSizesXfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::vector::getMixedSizesXfer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hasTensorSemantics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>xfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wrapper for getMixedSizes for vector.transfer_read and vector.transfer_write Ops (for source and destination, respectively). </p>
<p>Tensor and MemRef types implement their own, very similar version of getMixedSizes. This method will call the appropriate version (depending on <code>hasTensorSemantics</code>). It will also automatically extract the operand for which to call it on (source for "read" and destination for "write" ops). </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00308">308</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00077">mlir::memref::getMixedSizes()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00065">mlir::tensor::getMixedSizes()</a>, and <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00694">mlir::bufferization::hasTensorSemantics()</a>.</p>

</div>
</div>
<a id="a3221aacef9029612ded6c1d7bef1791c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3221aacef9029612ded6c1d7bef1791c">&#9670;&nbsp;</a></span>getTransferMinorIdentityMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::vector::getTransferMinorIdentityMap </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>shapedType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType&#160;</td>
          <td class="paramname"><em>vectorType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the default minor identity map suitable for a vector transfer. </p>
<p>This also handles the case memref&lt;... x vector&lt;...&gt;&gt; -&gt; vector&lt;...&gt; in which the rank of the identity map must take the vector element type into account. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00153">153</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01240">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00631">mlir::getAffineConstantExpr()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00135">mlir::AffineMap::getMinorIdentityMap()</a>.</p>

</div>
</div>
<a id="abf88d2bf2999298f815f0bc9ba05f2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf88d2bf2999298f815f0bc9ba05f2a4">&#9670;&nbsp;</a></span>getVectorReductionOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::vector::getVectorReductionOp </td>
          <td>(</td>
          <td class="paramtype">arith::AtomicRMWKind&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value obtained by reducing the vector into a scalar using the operation kind associated with a binary AtomicRMWKind op. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00624">624</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

</div>
</div>
<a id="a0499bcd00b867b4665ddf0c939543cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0499bcd00b867b4665ddf0c939543cfb">&#9670;&nbsp;</a></span>getVectorSubscriptAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrayAttr mlir::vector::getVectorSubscriptAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an integer array attribute containing the given values using the integer type required for subscripts in the vector dialect. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00446">446</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00312">mlir::Builder::getI64ArrayAttr()</a>.</p>

</div>
</div>
<a id="ae3cb3b0a7edef27b564ca0603fedec4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3cb3b0a7edef27b564ca0603fedec4a">&#9670;&nbsp;</a></span>getVectorSubscriptType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntegerType mlir::vector::getVectorSubscriptType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the integer type required for subscripts in the vector dialect. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00442">442</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00111">mlir::Builder::getIntegerType()</a>.</p>

</div>
</div>
<a id="a561e2afa7c375df7a7dffe273c38b8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561e2afa7c375df7a7dffe273c38b8de">&#9670;&nbsp;</a></span>inferTransferOpMaskType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType mlir::vector::inferTransferOpMaskType </td>
          <td>(</td>
          <td class="paramtype">VectorType&#160;</td>
          <td class="paramname"><em>vecType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>permMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infers the mask type for a transfer op given its vector type and permutation map. </p>
<p>The mask in a transfer op operation applies to the tensor/buffer part of it and its type should match the vector shape <em>before</em> any permutation or broadcasting. For example,</p>
<p>vecType = vector&lt;1x2x3xf32&gt;, permMap = affine_map&lt;(d0, d1, d2) -&gt; (d1, d0)&gt;</p>
<p>Has inferred mask type:</p>
<p>maskType = vector&lt;2x1xi1&gt; </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l03973">3973</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00675">mlir::applyPermutationMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00556">mlir::AffineMap::compose()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00722">mlir::compressUnusedDims()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00343">mlir::AffineMap::getContext()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00791">mlir::inversePermutation()</a>.</p>

</div>
</div>
<a id="a5150a3f7aa4857a1863bd10fb551442a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5150a3f7aa4857a1863bd10fb551442a">&#9670;&nbsp;</a></span>isBroadcastableTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1vector.html#acfee45e655b185bd625e2f7994dc2c50">BroadcastableToResult</a> mlir::vector::isBroadcastableTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>srcType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType&#160;</td>
          <td class="paramname"><em>dstVectorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; <a class="el" href="structmlir_1_1vector_1_1VectorDim.html">VectorDim</a>, <a class="el" href="structmlir_1_1vector_1_1VectorDim.html">VectorDim</a> &gt; *&#160;</td>
          <td class="paramname"><em>mismatchingDims</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l02390">2390</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeUtilities_8cpp_source.html#l00023">mlir::getElementTypeOrSelf()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00131">mlir::Type::isIntOrIndexOrFloat()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00573">broadcastIfNeeded()</a>.</p>

</div>
</div>
<a id="a2098102a54883ea02ee203ebabb4012e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2098102a54883ea02ee203ebabb4012e">&#9670;&nbsp;</a></span>isContiguousSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::vector::isContiguousSlice </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>memrefType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType&#160;</td>
          <td class="paramname"><em>vectorType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if <code>vectorType</code> is a contiguous slice of <code>memrefType</code>. </p>
<p>Only the N = vectorType.getRank() trailing dims of <code>memrefType</code> are checked (the other dims are not relevant). Note that for <code>vectorType</code> to be a contiguous slice of <code>memrefType</code>, the trailing dims of the latter have to be contiguous - this is checked by looking at the corresponding strides.</p>
<p>There might be some restriction on the leading dim of <code>VectorType</code>:</p>
<p>Case 1. If all the trailing dims of <code>vectorType</code> match the trailing dims of <code>memrefType</code> then the leading dim of <code>vectorType</code> can be arbitrary.</p>
<p>Ex. 1.1 contiguous slice, perfect match vector&lt;4x3x2xi32&gt; from memref&lt;5x4x3x2xi32&gt; Ex. 1.2 contiguous slice, the leading dim does not match (2 != 4) vector&lt;2x3x2xi32&gt; from memref&lt;5x4x3x2xi32&gt;</p>
<p>Case 2. If an "internal" dim of <code>vectorType</code> does not match the corresponding trailing dim in <code>memrefType</code> then the remaining leading dims of <code>vectorType</code> have to be 1 (the first non-matching dim can be arbitrary).</p>
<p>Ex. 2.1 non-contiguous slice, 2 != 3 and the leading dim != &lt;1&gt; vector&lt;2x2x2xi32&gt; from memref&lt;5x4x3x2xi32&gt; Ex. 2.2 contiguous slice, 2 != 3 and the leading dim == &lt;1&gt; vector&lt;1x2x2xi32&gt; from memref&lt;5x4x3x2xi32&gt; Ex. 2.3. contiguous slice, 2 != 3 and the leading dims == &lt;1x1&gt; vector&lt;1x1x2x2xi32&gt; from memref&lt;5x4x3x2xi32&gt; Ex. 2.4. non-contiguous slice, 2 != 3 and the leading dims != &lt;1x1&gt; vector&lt;2x1x2x2xi32&gt; from memref&lt;5x4x3x2xi32&gt;) </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00257">257</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00987">mlir::trailingNDimsContiguous()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00052">vectorShape()</a>.</p>

</div>
</div>
<a id="a5fd4b030a7ece80ee86e9b6c41895b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd4b030a7ece80ee86e9b6c41895b82">&#9670;&nbsp;</a></span>isDisjointTransferIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::vector::isDisjointTransferIndices </td>
          <td>(</td>
          <td class="paramtype">VectorTransferOpInterface&#160;</td>
          <td class="paramname"><em>transferA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorTransferOpInterface&#160;</td>
          <td class="paramname"><em>transferB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>testDynamicValueUsingBounds</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if we can prove that the transfer operations access disjoint memory, without requring the accessed tensor/memref to be the same. </p>
<p>If <code>testDynamicValueUsingBounds</code> is true, tries to test dynamic values via ValueBoundsOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00219">219</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Fraction_8h_source.html#l00107">mlir::presburger::abs()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00766">mlir::ValueBoundsConstraintSet::areEqual()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00677">mlir::ValueBoundsConstraintSet::computeConstantDelta()</a>, <a class="el" href="Affine_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00107">mlir::affine::fullyComposeAndComputeConstantDelta()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00105">mlir::getConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l00283">isDisjointTransferSet()</a>.</p>

</div>
</div>
<a id="a629666d1e621e7ad850d28cecd82a263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629666d1e621e7ad850d28cecd82a263">&#9670;&nbsp;</a></span>isDisjointTransferSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::vector::isDisjointTransferSet </td>
          <td>(</td>
          <td class="paramtype">VectorTransferOpInterface&#160;</td>
          <td class="paramname"><em>transferA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorTransferOpInterface&#160;</td>
          <td class="paramname"><em>transferB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>testDynamicValueUsingBounds</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if we can prove that the transfer operations access disjoint memory, requiring the operations to access the same tensor/memref. </p>
<p>If <code>testDynamicValueUsingBounds</code> is true, tries to test dynamic values via ValueBoundsOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00283">283</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorOps_8cpp_source.html#l00219">isDisjointTransferIndices()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Hoisting_8cpp_source.html#l00202">mlir::linalg::hoistRedundantVectorTransfers()</a>.</p>

</div>
</div>
<a id="abdf9a8c7b9a914162f597bc6d1aa0633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf9a8c7b9a914162f597bc6d1aa0633">&#9670;&nbsp;</a></span>isLinearizableVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::vector::isLinearizableVector </td>
          <td>(</td>
          <td class="paramtype">VectorType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the input <a class="el" href="structVector.html">Vector</a> type can be linearized. </p>
<p>Linearization is meant in the sense of flattening vectors, e.g.:</p><ul>
<li>vector&lt;NxMxKxi32&gt; -&gt; vector&lt;N*M*Kxi32&gt; In this sense, Vectors that are either:</li>
<li>already linearized, or</li>
<li>contain more than 1 scalable dimensions, are not linearizable. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00325">325</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorLinearize_8cpp_source.html#l00464">populateVectorLinearizeTypeConversionsAndLegality()</a>.</p>

</div>
</div>
<a id="a75d40ea32eb46ab63ab75c1b568ce4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d40ea32eb46ab63ab75c1b568ce4ef">&#9670;&nbsp;</a></span>isParallelIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::vector::isParallelIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>attr</code> has "parallel" iterator type semantics. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8h_source.html#l00147">147</a> of file <a class="el" href="VectorOps_8h_source.html">VectorOps.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorDropLeadUnitDim_8cpp_source.html#l00333">castAwayContractionLeadingOneDim()</a>, and <a class="el" href="GPUTransformOps_8cpp_source.html#l00143">gpuMmaUnrollOrder()</a>.</p>

</div>
</div>
<a id="a2393c85f5a124d20d5299d422b29a140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2393c85f5a124d20d5299d422b29a140">&#9670;&nbsp;</a></span>isReductionIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::vector::isReductionIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>attr</code> has "reduction" iterator type semantics. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8h_source.html#l00152">152</a> of file <a class="el" href="VectorOps_8h_source.html">VectorOps.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerVectorContract_8cpp_source.html#l00173">getReductionIndex()</a>, and <a class="el" href="GPUTransformOps_8cpp_source.html#l00143">gpuMmaUnrollOrder()</a>.</p>

</div>
</div>
<a id="a87dd4973a2bd2cac230734188a21c995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87dd4973a2bd2cac230734188a21c995">&#9670;&nbsp;</a></span>isTranspose2DSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; std::pair&lt; int, int &gt; &gt; mlir::vector::isTranspose2DSlice </td>
          <td>(</td>
          <td class="paramtype">vector::TransposeOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns two dims that are greater than one if the transposition is applied on a 2D slice. </p>
<p>Otherwise, returns a failure. </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00084">84</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

</div>
</div>
<a id="a341516a4c95139534df7b424b2de2598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341516a4c95139534df7b424b2de2598">&#9670;&nbsp;</a></span>isValidMaskedInputVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::vector::isValidMaskedInputVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>inputVectorSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns success if <code>inputVectorSizes</code> is a valid masking configuraion for given <code>shape</code>, i.e., it meets: </p>
<ol type="1">
<li>The numbers of elements in both array are equal.</li>
<li><code>inputVectorSizes</code> does not have dynamic dimensions.</li>
<li>All the values in <code>inputVectorSizes</code> are greater than or equal to static sizes in <code>shape</code>. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00371">371</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorUtils_8cpp_source.html#l00035">LDBG</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01854">vectorizeLinalgOpPrecondition()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01922">vectorizePackOpPrecondition()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01955">vectorizePadOpPrecondition()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01834">vectorizeUnPackOpPrecondition()</a>.</p>

</div>
</div>
<a id="a015472323cadf1a87aa5281a682eb0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015472323cadf1a87aa5281a682eb0b9">&#9670;&nbsp;</a></span>makeArithReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::vector::makeArithReduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CombiningKind&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arith::FastMathFlagsAttr&#160;</td>
          <td class="paramname"><em>fastmath</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>mask</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result value of reducing two scalar/vector values with the corresponding arith operation. </p>

</div>
</div>
<a id="ad0a5584142f33c4a2887d2e3131f7565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a5584142f33c4a2887d2e3131f7565">&#9670;&nbsp;</a></span>makeVscaleConstantBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::vector::makeVscaleConstantBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a functor (int64_t -&gt; <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>) which returns a constant vscale multiple. </p>
<p>Example: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line"><span class="keyword">auto</span> createVscaleMultiple = <a class="code" href="namespacemlir_1_1vector.html#ad0a5584142f33c4a2887d2e3131f7565">makeVscaleConstantBuilder</a>(rewriter, loc);</div>
<div class="line"><span class="keyword">auto</span> c4Vscale = createVscaleMultiple(4); <span class="comment">// 4 * vector.vscale</span></div>
<div class="ttc" id="anamespacemlir_1_1vector_html_ad0a5584142f33c4a2887d2e3131f7565"><div class="ttname"><a href="namespacemlir_1_1vector.html#ad0a5584142f33c4a2887d2e3131f7565">mlir::vector::makeVscaleConstantBuilder</a></div><div class="ttdeci">auto makeVscaleConstantBuilder(PatternRewriter &amp;rewriter, Location loc)</div><div class="ttdoc">Returns a functor (int64_t -&gt; Value) which returns a constant vscale multiple.</div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8h_source.html#l00113">VectorUtils.h:113</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="VectorUtils_8h_source.html#l00113">113</a> of file <a class="el" href="VectorUtils_8h_source.html">VectorUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>.</p>

</div>
</div>
<a id="a4f68d86708480673ecc59b2714973a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f68d86708480673ecc59b2714973a65">&#9670;&nbsp;</a></span>maskOperation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a>* mlir::vector::maskOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>maskableOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>passthru</em> = <code><a class="el" href="classmlir_1_1Value.html">Value</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector.mask operation around a maskable operation. </p>
<p>Returns the vector.mask operation if the mask provided is valid. Otherwise, returns the maskable operation itself. </p>

<p class="reference">Referenced by <a class="el" href="VectorDropLeadUnitDim_8cpp_source.html#l00333">castAwayContractionLeadingOneDim()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00329">createReadOrMaskedRead()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01461">createWriteOrMaskedWrite()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00426">VectorizationState::maskOperation()</a>.</p>

</div>
</div>
<a id="a24725f068970593e59e43b897256c302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24725f068970593e59e43b897256c302">&#9670;&nbsp;</a></span>populateBreakDownVectorBitCastOpPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateBreakDownVectorBitCastOpPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(BitCastOp)&gt;&#160;</td>
          <td class="paramname"><em>controlFn</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate <code>patterns</code> with a pattern to break down 1-D vector.bitcast ops based on the destination vector shape. </p>
<p>Bitcasts from a lower bitwidth element type to a higher bitwidth one are extracted from the lower bitwidth based on the native destination vector shape and inserted based on the ratio of the bitwidths.</p>
<p>This acts as a last resort way to break down vector.bitcast ops to smaller vector sizes. Because this pattern composes until it is bitcasting to a single element of the higher bitwidth, the is an optional control function. If <code>controlFn</code> is not nullptr, the pattern will only apply to ops where <code>controlFn</code> returns true, otherwise applies to all bitcast ops. </p>

</div>
</div>
<a id="ad38f9aa565f0a664dc5bdcf208a0d1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38f9aa565f0a664dc5bdcf208a0d1d1">&#9670;&nbsp;</a></span>populateBreakDownVectorReductionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateBreakDownVectorReductionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxNumElementsToExtract</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to break down vector reductions into a series of arith reductions over vector elements. </p>
<p>This is intended to be simplify code with reductions over small vector types and avoid more specialized reduction lowering when possible.</p>
<p>Example: </p><div class="fragment"><div class="line">%a = vector.reduction &lt;add&gt; %x : vector&lt;2xf32&gt; into f32</div>
</div><!-- fragment --><p> is transformed into: </p><div class="fragment"><div class="line">%y = vector.extract %x[0] : f32 from vector&lt;2xf32&gt;</div>
<div class="line">%z = vector.extract %x[1] : f32 from vector&lt;2xf32&gt;</div>
<div class="line">%a = arith.addf %y, %z : f32</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02121">2121</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a5fa78aa2fd99a07cb2716707d79fc601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa78aa2fd99a07cb2716707d79fc601">&#9670;&nbsp;</a></span>populateBubbleVectorBitCastOpPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateBubbleVectorBitCastOpPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns that bubble up/down bitcast ops. </p>
<p>These patterns move vector.bitcast ops to be before insert ops or after extract ops where suitable. With them, bitcast will happen on smaller vectors and there are more chances to share extract/insert ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02069">2069</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="adfd091159bea6b87de599da44e4b7611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd091159bea6b87de599da44e4b7611">&#9670;&nbsp;</a></span>populateCastAwayVectorLeadingOneDimPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateCastAwayVectorLeadingOneDimPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of leading one dimension removal patterns. </p>
<p>These patterns insert vector.shape_cast to remove leading one dimensions to expose more canonical forms of read/write/insert/extract operations. With them, there are more chances that we can cancel out extract-insert pairs or forward write-read pairs. </p>

<p class="definition">Definition at line <a class="el" href="VectorDropLeadUnitDim_8cpp_source.html#l00572">572</a> of file <a class="el" href="VectorDropLeadUnitDim_8cpp_source.html">VectorDropLeadUnitDim.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02052">populateShapeCastFoldingPatterns()</a>.</p>

</div>
</div>
<a id="a5e660a087efe580b67b684a49acb83be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e660a087efe580b67b684a49acb83be">&#9670;&nbsp;</a></span>populateChainedVectorReductionFoldingPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateChainedVectorReductionFoldingPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns that fold chained vector reductions. </p>
<p>These patterns assume that elementwise operations (e.g., <code>arith.addf</code> with vector operands) are cheaper than vector reduction. Note that these patterns change the order of reduction which may not always produce bit-identical results on some floating point inputs.</p>
<p>Example: </p><div class="fragment"><div class="line">%a = vector.reduction &lt;add&gt; %x, %acc</div>
<div class="line">%b = vector.reduction &lt;add&gt; %y, %a</div>
</div><!-- fragment --><p> is transformed into: </p><div class="fragment"><div class="line">%a = arith.addf %x, %y</div>
<div class="line">%b = vector.reduction &lt;add&gt; %a, %acc</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02114">2114</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00027">mlir::PatternBenefit::getBenefit()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a152e1e5d3a703fe809ee1b23dfb8631c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152e1e5d3a703fe809ee1b23dfb8631c">&#9670;&nbsp;</a></span>populateDropUnitDimWithShapeCastPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateDropUnitDimWithShapeCastPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns that use vector.shape_cast to help fold unit dims. </p>
<p>These patterns use vector.shape_cast to remove unit dims from e.g. arithmetic operations on Vectors. The newly inserted shape_casts will either cancel each other out or will be folded away when combined with other patterns. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02057">2057</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00962">populateFlattenVectorTransferPatterns()</a>.</p>

</div>
</div>
<a id="a2bc60b182ad08ffab9aa924a74e78129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc60b182ad08ffab9aa924a74e78129">&#9670;&nbsp;</a></span>populateElementwiseToVectorOpsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateElementwiseToVectorOpsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns that fold elementwise op on vectors to the vector dialect. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02128">2128</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a1e5d23a414967805d3efa498da76ee9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5d23a414967805d3efa498da76ee9f">&#9670;&nbsp;</a></span>populateFlattenVectorTransferPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateFlattenVectorTransferPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>targetVectorBitwidth</em> = <code>std::numeric_limits&lt;unsigned&gt;::<a class="el" href="PolynomialApproximation_8cpp.html#acbcaffd2f4cbc4dd948549fd577631eb">max</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to flatten n-D vector transfers on contiguous memref. </p>
<p>These patterns insert memref.collapse_shape + vector.shape_cast patterns to transform multiple small n-D transfers into a larger 1-D transfer where the memref contiguity properties allow it.</p>
<p>Flattening is only applied if the bitwidth of the trailing vector dimension is smaller or equal to <code>targetVectorBitwidth</code>. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00962">962</a> of file <a class="el" href="VectorTransferOpTransforms_8cpp_source.html">VectorTransferOpTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02057">populateDropUnitDimWithShapeCastPatterns()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02052">populateShapeCastFoldingPatterns()</a>.</p>

</div>
</div>
<a id="a7ec9916655c82acca22bdeb882303f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec9916655c82acca22bdeb882303f0f">&#9670;&nbsp;</a></span>populateFoldArithExtensionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateFoldArithExtensionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns that fold arithmetic extension on floating point into vector contract for the backends with native support. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02035">2035</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="aa279bf22c17b61f1bf71e434dce3f158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa279bf22c17b61f1bf71e434dce3f158">&#9670;&nbsp;</a></span>populateScalarVectorTransferLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateScalarVectorTransferLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowMultipleUses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects patterns that lower scalar vector transfer ops to memref loads and stores when beneficial. </p>
<p>If <code>allowMultipleUses</code> is set to true, the patterns are applied to vector transfer reads with any number of uses. Otherwise, only vector transfer reads with a single use will be lowered. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00945">945</a> of file <a class="el" href="VectorTransferOpTransforms_8cpp_source.html">VectorTransferOpTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a39fbbc879aa374f81b77fec292c3ec33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39fbbc879aa374f81b77fec292c3ec33">&#9670;&nbsp;</a></span>populateShapeCastFoldingPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateShapeCastFoldingPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of vector.shape_cast folding patterns. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02052">2052</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorDropLeadUnitDim_8cpp_source.html#l00572">populateCastAwayVectorLeadingOneDimPatterns()</a>, <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00962">populateFlattenVectorTransferPatterns()</a>, and <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00954">populateVectorTransferDropUnitDimsPatterns()</a>.</p>

</div>
</div>
<a id="a848e82989f2072855d837185e7e7694a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848e82989f2072855d837185e7e7694a">&#9670;&nbsp;</a></span>populateSinkVectorOpsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateSinkVectorOpsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns that remove redundant <a class="el" href="structVector.html">Vector</a> Ops by re-ordering them with e.g. </p>
<p>elementwise Ops: </p><div class="fragment"><div class="line">%at = vector.transpose %a, [1, 0]: vector&lt;4x2xf32&gt; to vector&lt;2x4xf32&gt;</div>
<div class="line">%bt = vector.transpose %b, [1, 0]: vector&lt;4x2xf32&gt; to vector&lt;2x4xf32&gt;</div>
<div class="line">%r = arith.addf %at, %bt : vector&lt;2x4xf32&gt;</div>
</div><!-- fragment --><p> gets converted to: </p><div class="fragment"><div class="line">%0 = arith.addf %a, %b : vector&lt;4x2xf32&gt;</div>
<div class="line">%r = vector.transpose %0, [1, 0] : vector&lt;2x4xf32&gt;</div>
</div><!-- fragment --><p> At the moment, these patterns are limited to vector.broadcast and vector.transpose. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02107">2107</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a8cad1ef496d64e01a0d7aaa62432e1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cad1ef496d64e01a0d7aaa62432e1d9">&#9670;&nbsp;</a></span>populateVectorBitCastLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorBitCastLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>targetRank</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the pattern set with the following patterns: </p>
<p>[UnrollBitCastOp] A one-shot unrolling of BitCastOp to (one or more) ExtractOp + BitCastOp (of <code>targetRank</code>) + InsertOp. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorBitCast_8cpp_source.html#l00087">87</a> of file <a class="el" href="LowerVectorBitCast_8cpp_source.html">LowerVectorBitCast.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a88033aae0cb3a6e60cbca725c347676f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88033aae0cb3a6e60cbca725c347676f">&#9670;&nbsp;</a></span>populateVectorBroadcastLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorBroadcastLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[TransferReadToVectorLoadLowering] Progressive lowering of BroadcastOp to ExtractOp + InsertOp + lower-D BroadcastOp until dim 1. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorBroadcast_8cpp_source.html#l00156">156</a> of file <a class="el" href="LowerVectorBroadcast_8cpp_source.html">LowerVectorBroadcast.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a8461b000c4283d776959689802a7dea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8461b000c4283d776959689802a7dea7">&#9670;&nbsp;</a></span>populateVectorContractCanonicalizeMatmulToMMT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorContractCanonicalizeMatmulToMMT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; LogicalResult(vector::ContractionOp)&gt;&#160;</td>
          <td class="paramname"><em>constraint</em> = <code>[](vector::ContractionOp)&#160;{&#160;return&#160;success();&#160;}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalization of a <code>vector.contraction a, b, c</code> with row-major matmul semantics to a contraction with MMT semantics (matrix matrix multiplication with the RHS transposed). </p>
<p>This specific form is meant to have the vector operands are organized such that the reduction dimension is contiguous. Example: </p><div class="fragment"><div class="line">vector.contract {indexing_maps = [affine_map&lt;(m, n, k) -&gt; (m, k)&gt;,</div>
<div class="line">                                  affine_map&lt;(m, n, k) -&gt; (n, k)&gt;,</div>
<div class="line">                                  affine_map&lt;(m, n, k) -&gt; (m, n)&gt;],</div>
<div class="line">                 iterator_types = [<span class="stringliteral">&quot;parallel&quot;</span>, <span class="stringliteral">&quot;parallel&quot;</span>, <span class="stringliteral">&quot;reduction&quot;</span>],</div>
<div class="line">                 kind = #vector.kind&lt;add&gt;} %a, %b, %c : ...</div>
</div><!-- fragment --><p>The <code>constraint</code> predicate is used to decide which <code>vector.contraction</code> ops to filter out. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02084">2084</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorToGPU_8cpp_source.html#l01229">mlir::populatePrepareVectorToMMAPatterns()</a>.</p>

</div>
</div>
<a id="aae9b492143f4e66a332ea007fad57beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9b492143f4e66a332ea007fad57beb">&#9670;&nbsp;</a></span>populateVectorContractLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorContractLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disableOuterProductLowering</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[OuterProductOpLowering] Progressively lower a <code>vector.outerproduct</code> to linearized <code>vector.extract</code> + <code>vector.fma</code> + <code>vector.insert</code>.</p>
<p>[ContractionOpLowering] Progressive lowering of ContractionOp. One: x = vector.contract with at least one free/batch dimension is replaced by: a = vector.contract with one less free/batch dimension b = vector.contract with one less free/batch dimension</p>
<p>[ContractionOpToMatmulOpLowering] Progressively lower a <code>vector.contract</code> with row-major matmul semantics to linearized <code>vector.shape_cast</code> + <code>vector.matmul</code> on the way to <code>llvm.matrix.multiply</code>.</p>
<p>[ContractionOpToDotLowering] Progressively lower a <code>vector.contract</code> with row-major matmul semantics to linearized <code>vector.extract</code> + <code>vector.reduce</code> + <code>vector.insert</code>.</p>
<p>[ContractionOpToOuterProductOpLowering] Progressively lower a <code>vector.contract</code> with row-major matmul semantics to linearized <code>vector.extract</code> + <code>vector.outerproduct</code> + <code>vector.insert</code>. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorContract_8cpp_source.html#l01384">1384</a> of file <a class="el" href="LowerVectorContract_8cpp_source.html">LowerVectorContract.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a31240a19ebf99d76b171bf5740c2788f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31240a19ebf99d76b171bf5740c2788f">&#9670;&nbsp;</a></span>populateVectorExtractStridedSliceToExtractInsertChainPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorExtractStridedSliceToExtractInsertChainPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(ExtractStridedSliceOp)&gt;&#160;</td>
          <td class="paramname"><em>controlFn</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate <code>patterns</code> with a pattern to breaks down 1-D extract_strided_slice ops into a chain of Extract ops to extract each element from the source, and then a chain of Insert ops to insert to the target vector. </p>
<p>If <code>controlFn</code> is not nullptr, the pattern will only be invoked on ops that <code>controlFn</code> returns true. Otherwise runs on ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00338">338</a> of file <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html">VectorInsertExtractStridedSliceRewritePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a439f87d998fc217be9e760851e5c7a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439f87d998fc217be9e760851e5c7a63">&#9670;&nbsp;</a></span>populateVectorGatherLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorGatherLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[FlattenGather] Flattens 2 or more dimensional <code>vector.gather</code> ops by unrolling the outermost dimension.</p>
<p>[Gather1DToConditionalLoads] Turns 1-d <code>vector.gather</code> into a scalarized sequence of <code>vector.loads</code> or <code>tensor.extract</code>s. To avoid out-of-bounds memory accesses, these loads/extracts are made conditional using <code>scf.if</code> ops. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorGather_8cpp_source.html#l00268">268</a> of file <a class="el" href="LowerVectorGather_8cpp_source.html">LowerVectorGather.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="aa0a5f5c20fcd404c551461d5b178db40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a5f5c20fcd404c551461d5b178db40">&#9670;&nbsp;</a></span>populateVectorInsertExtractStridedSliceDecompositionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorInsertExtractStridedSliceDecompositionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate <code>patterns</code> with the following patterns. </p>
<h1><a class="anchor" id="autotoc_md31"></a>
[DecomposeDifferentRankInsertStridedSlice]</h1>
<p><a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements.">RewritePattern</a> for InsertStridedSliceOp where source and destination vectors have different ranks.</p>
<p>When ranks are different, InsertStridedSlice needs to extract a properly ranked vector from the destination vector into which to insert. This pattern only takes care of this extraction part and forwards the rest to [VectorInsertStridedSliceOpSameRankRewritePattern].</p>
<p>For a k-D source and n-D destination vector (k &lt; n), we emit:</p><ol type="1">
<li>ExtractOp to extract the (unique) (n-1)-D subvector into which to insert the k-D source.</li>
<li>k-D -&gt; (n-1)-D InsertStridedSlice op</li>
<li>InsertOp that is the reverse of 1.</li>
</ol>
<h1><a class="anchor" id="autotoc_md32"></a>
[DecomposeNDExtractStridedSlice]</h1>
<p>For such cases, we can rewrite it to ExtractOp/ExtractElementOp + lower rank ExtractStridedSliceOp + InsertOp/InsertElementOp for the n-D case. </p>

<p class="definition">Definition at line <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00332">332</a> of file <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html">VectorInsertExtractStridedSliceRewritePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00347">populateVectorInsertExtractStridedSliceTransforms()</a>.</p>

</div>
</div>
<a id="adfe6e410da8807fa4e5764fd09bd1f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe6e410da8807fa4e5764fd09bd1f8b">&#9670;&nbsp;</a></span>populateVectorInsertExtractStridedSliceTransforms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorInsertExtractStridedSliceTransforms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate <code>patterns</code> with the following patterns. </p>
<p>Populate the given list with patterns that convert from <a class="el" href="structVector.html">Vector</a> to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.</p>
<p>Patterns in <a class="el" href="namespacemlir_1_1vector.html#aa0a5f5c20fcd404c551461d5b178db40" title="Populate patterns with the following patterns.">populateVectorInsertExtractStridedSliceDecompositionPatterns()</a>;</p>
<h1><a class="anchor" id="autotoc_md33"></a>
[ConvertSameRankInsertStridedSliceIntoShuffle]</h1>
<p><a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements.">RewritePattern</a> for InsertStridedSliceOp where source and destination vectors have the same rank. For each outermost index in the slice: begin end stride [offset : offset+size*stride : stride]</p><ol type="1">
<li>ExtractOp one (k-1)-D source subvector and one (n-1)-D dest subvector.</li>
<li>InsertStridedSlice (k-1)-D into (n-1)-D</li>
<li>the destination subvector is inserted back in the proper place</li>
</ol>
<ol type="1">
<li>InsertOp that is the reverse of 1.</li>
</ol>
<h1><a class="anchor" id="autotoc_md34"></a>
[Convert1DExtractStridedSliceIntoShuffle]</h1>
<p>For such cases, we can lower it to a ShuffleOp. </p>

<p class="definition">Definition at line <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00347">347</a> of file <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html">VectorInsertExtractStridedSliceRewritePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00332">populateVectorInsertExtractStridedSliceDecompositionPatterns()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l01883">mlir::populateVectorToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="ad3c07e592cdd88b811669bd163b93378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c07e592cdd88b811669bd163b93378">&#9670;&nbsp;</a></span>populateVectorInterleaveLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorInterleaveLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>targetRank</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[UnrollInterleaveOp] A one-shot unrolling of InterleaveOp to (one or more) ExtractOp + InterleaveOp (of <code>targetRank</code>) + InsertOp. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorInterleave_8cpp_source.html#l00183">183</a> of file <a class="el" href="LowerVectorInterleave_8cpp_source.html">LowerVectorInterleave.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a33e5072e435d0da63d65e437f724e246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e5072e435d0da63d65e437f724e246">&#9670;&nbsp;</a></span>populateVectorInterleaveToShufflePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorInterleaveToShufflePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LowerVectorInterleave_8cpp_source.html#l00189">189</a> of file <a class="el" href="LowerVectorInterleave_8cpp_source.html">LowerVectorInterleave.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a29b7ac5247b3dc61df68ccd19bd7e854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b7ac5247b3dc61df68ccd19bd7e854">&#9670;&nbsp;</a></span>populateVectorLinearizeShuffleLikeOpsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorLinearizeShuffleLikeOpsPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>targetBitWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns for linearizing ND (N &gt;= 2) vector operations to 1D vector shuffle operations. </p>

</div>
</div>
<a id="aee2590b4049cfbe0675e37392dd7bc8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee2590b4049cfbe0675e37392dd7bc8f">&#9670;&nbsp;</a></span>populateVectorLinearizeTypeConversionsAndLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorLinearizeTypeConversionsAndLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>targetBitWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns for ND vectors (N &gt;= 2) linearization and sets up the provided <a class="el" href="classmlir_1_1ConversionTarget.html" title="This class describes a specific conversion target.">ConversionTarget</a> with the appropriate legality configuration for the ops to get converted properly. </p>

<p class="definition">Definition at line <a class="el" href="VectorLinearize_8cpp_source.html#l00464">464</a> of file <a class="el" href="VectorLinearize_8cpp_source.html">VectorLinearize.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00188">mlir::TypeConverter::addArgumentMaterialization()</a>, <a class="el" href="DialectConversion_8h_source.html#l00167">mlir::TypeConverter::addConversion()</a>, <a class="el" href="DialectConversion_8h_source.html#l00199">mlir::TypeConverter::addSourceMaterialization()</a>, <a class="el" href="DialectConversion_8h_source.html#l00208">mlir::TypeConverter::addTargetMaterialization()</a>, <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00325">isLinearizableVector()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00939">mlir::ConversionTarget::markUnknownOpDynamicallyLegal()</a>.</p>

</div>
</div>
<a id="a6d67a015516dec992613685a6bb1a20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d67a015516dec992613685a6bb1a20b">&#9670;&nbsp;</a></span>populateVectorMaskedLoadStoreEmulationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorMaskedLoadStoreEmulationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[VectorMaskedLoadOpConverter] Turns vector.maskedload to scf.if + memref.load</p>
<p>[VectorMaskedStoreOpConverter] Turns vector.maskedstore to scf.if + memref.store </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateMaskedLoadStore_8cpp_source.html#l00157">157</a> of file <a class="el" href="VectorEmulateMaskedLoadStore_8cpp_source.html">VectorEmulateMaskedLoadStore.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ad2010f10ca9e7f5df4aed9571180e3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2010f10ca9e7f5df4aed9571180e3c5">&#9670;&nbsp;</a></span>populateVectorMaskLoweringPatternsForSideEffectingOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorMaskLoweringPatternsForSideEffectingOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates instances of <code>MaskOpRewritePattern</code> to lower masked operations with <code>vector.mask</code>. </p>
<p>Patterns should rewrite the <code>vector.mask</code> operation and not its nested <code>MaskableOpInterface</code>. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorMask_8cpp_source.html#l00303">303</a> of file <a class="el" href="LowerVectorMask_8cpp_source.html">LowerVectorMask.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a956c19ab091edb09330a40669b46700e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956c19ab091edb09330a40669b46700e">&#9670;&nbsp;</a></span>populateVectorMaskMaterializationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorMaskMaterializationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force32BitVectorIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These patterns materialize masks for various vector ops such as transfers. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02042">2042</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a9ec71309405318dd0ed6b2b31ded892c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec71309405318dd0ed6b2b31ded892c">&#9670;&nbsp;</a></span>populateVectorMaskOpLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorMaskOpLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[CreateMaskOp] Progressive lowering of CreateMaskOp to lower-D CreateMaskOp until dim 1.</p>
<p>[ConstantMaskOp] Progressive lowering of ConstantMaskOp to lower-D ConstantMaskOp until dim 1. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorMask_8cpp_source.html#l00162">162</a> of file <a class="el" href="LowerVectorMask_8cpp_source.html">LowerVectorMask.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="aa136544741125dce255ad55a91f2067a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa136544741125dce255ad55a91f2067a">&#9670;&nbsp;</a></span>populateVectorMultiReductionLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorMultiReductionLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorMultiReductionLowering&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert vector.multi_reduction op into a sequence of vector.reduction ops. </p>
<p>The patterns comprise:</p>
<p>[InnerOuterDimReductionConversion] Rewrites vector.multi_reduction such that all reduction dimensions are either innermost or outermost, by adding the proper vector.transpose operations.</p>
<p>[ReduceMultiDimReductionRank] Once in innermost or outermost reduction form, rewrites n-D vector.multi_reduction into 2-D vector.multi_reduction, by introducing vector.shape_cast ops to collapse + multi-reduce + expand back.</p>
<p>[TwoDimMultiReductionToElementWise] Once in 2-D vector.multi_reduction form, with an <b>outermost</b> reduction dimension, unroll the outer dimension to obtain a sequence of 1-D vector ops. This also has an opportunity for tree-reduction (in the future).</p>
<p>[TwoDimMultiReductionToReduction] Once in 2-D vector.multi_reduction form, with an <b>innermost</b> reduction dimension, unroll the outer dimension to obtain a sequence of extract + vector.reduction + insert. This can further lower to horizontal reduction ops.</p>
<p>[OneDimMultiReductionToTwoDim] For cases that reduce to 1-D vector&lt;k&gt; reduction (and are thus missing either a parallel or a reduction), we lift them back up to 2-D with a simple vector.shape_cast to vector&lt;1xk&gt; so that the other patterns can kick in, thus fully exiting out of the vector.multi_reduction abstraction. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorMultiReduction_8cpp_source.html#l00501">501</a> of file <a class="el" href="LowerVectorMultiReduction_8cpp_source.html">LowerVectorMultiReduction.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a75b818b615e83ba52295ba49932a9564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b818b615e83ba52295ba49932a9564">&#9670;&nbsp;</a></span>populateVectorNarrowTypeEmulationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorNarrowTypeEmulationPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1arith_1_1NarrowTypeEmulationConverter.html">arith::NarrowTypeEmulationConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for emulating vector operations over narrow types with ops over wider types. </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l01236">1236</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a156930655d3fc40716c9264f1e74044e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156930655d3fc40716c9264f1e74044e">&#9670;&nbsp;</a></span>populateVectorNarrowTypeRewritePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorNarrowTypeRewritePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for rewriting vector operations over narrow types with ops over wider types. </p>
<p>Warning: these patterns currently only work for little endian targets. </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l01246">1246</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00027">mlir::PatternBenefit::getBenefit()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a991e613d3d19627fd75f7c874a8e0fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991e613d3d19627fd75f7c874a8e0fad">&#9670;&nbsp;</a></span>populateVectorOuterProductLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorOuterProductLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[OuterProductOpLowering] Progressively lower a <code>vector.outerproduct</code> to linearized <code>vector.extract</code> + <code>vector.fma</code> + <code>vector.insert</code>. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorContract_8cpp_source.html#l01394">1394</a> of file <a class="el" href="LowerVectorContract_8cpp_source.html">LowerVectorContract.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="aa2c39668001ee9e2ba767b172123f1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c39668001ee9e2ba767b172123f1d8">&#9670;&nbsp;</a></span>populateVectorReductionToContractPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorReductionToContractPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect patterns to convert reduction op to vector.contract and fold transpose/broadcast ops into the contract. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02092">2092</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="afbc33a6788e2401e592cce83b6c68c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc33a6788e2401e592cce83b6c68c42">&#9670;&nbsp;</a></span>populateVectorScanLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorScanLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[ScanToArithOps] Convert vector.scan op into arith ops and vector.insert_strided_slice / vector.extract_strided_slice. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorScan_8cpp_source.html#l00191">191</a> of file <a class="el" href="LowerVectorScan_8cpp_source.html">LowerVectorScan.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a43189fd7073752a0dc3e3ac6274a1513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43189fd7073752a0dc3e3ac6274a1513">&#9670;&nbsp;</a></span>populateVectorShapeCastLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorShapeCastLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[ShapeCastOp2DDownCastRewritePattern] ShapeOp 2D -&gt; 1D downcast serves the purpose of flattening 2-D to 1-D vectors progressively.</p>
<p>[ShapeCastOp2DUpCastRewritePattern] ShapeOp 1D -&gt; 2D upcast serves the purpose of unflattening 2-D from 1-D vectors progressively.</p>
<p>[ShapeCastOpRewritePattern] Reference lowering to fully unrolled sequences of single element ExtractOp + InsertOp. Note that applying this pattern can almost always be considered a performance bug. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorShapeCast_8cpp_source.html#l00353">353</a> of file <a class="el" href="LowerVectorShapeCast_8cpp_source.html">LowerVectorShapeCast.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a901dfffd46bc2f80e977fdea83adc180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901dfffd46bc2f80e977fdea83adc180">&#9670;&nbsp;</a></span>populateVectorToVectorCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorToVectorCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of vector-to-vector canonicalization patterns. </p>

</div>
</div>
<a id="aa29269f57c53624b09c7c7ffbb10cc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa29269f57c53624b09c7c7ffbb10cc85">&#9670;&nbsp;</a></span>populateVectorTransferCollapseInnerMostContiguousDimsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorTransferCollapseInnerMostContiguousDimsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to reduce the rank of the operands of vector transfer ops to operate on the largest contigious vector. </p>
<p>These patterns are useful when lowering to dialects with 1d vector type such as llvm and it will result fewer memory reads. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02099">2099</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a562524e33c5d6d7982e318c9b2cf20e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562524e33c5d6d7982e318c9b2cf20e0">&#9670;&nbsp;</a></span>populateVectorTransferDropUnitDimsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorTransferDropUnitDimsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of one dimension removal patterns. </p>
<p>These patterns insert rank-reducing memref.subview ops to remove one dimensions. With them, there are more chances that we can avoid potentially expensive vector.shape_cast operations. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00954">954</a> of file <a class="el" href="VectorTransferOpTransforms_8cpp_source.html">VectorTransferOpTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02052">populateShapeCastFoldingPatterns()</a>.</p>

</div>
</div>
<a id="ac789257ecc17a3ca9c07a9178fb530a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac789257ecc17a3ca9c07a9178fb530a3">&#9670;&nbsp;</a></span>populateVectorTransferFullPartialPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorTransferFullPartialPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate <code>patterns</code> with the following patterns. </p>
<ul>
<li>VectorTransferFullPartialRewriter</li>
</ul>
<p>Split a vector.transfer operation into an in-bounds (i.e., no out-of-bounds masking) fast path and a slow path.</p>
<p>Example (a 2-D vector.transfer_read): ``` %1 = vector.transfer_read %0[...], pad : memref&lt;A...&gt;, vector&lt;...&gt; ``` is transformed into: ``` %1:3 = scf.if (inBounds) { // fast path, direct cast memref.cast A: memref&lt;A...&gt; to compatibleMemRefType scf.yield view : compatibleMemRefType, index, index } else { // slow path, not in-bounds vector.transfer or linalg.copy. memref.cast alloc: memref&lt;B...&gt; to compatibleMemRefType scf.yield %4 : compatibleMemRefType, index, index */ // } /** %0 = vector.transfer_read %1#0[%1#1, %1#2] {in_bounds = [true ... true]} ``<code> where</code>alloc` is a top of the function alloca'ed buffer of one vector.</p>
<p>Preconditions:</p><ol type="1">
<li><code>xferOp.permutation_map()</code> must be a minor identity map</li>
<li>the rank of the <code>xferOp.memref()</code> and the rank of the <code>xferOp.vector()</code> must be equal. This will be relaxed in the future but requires rank-reducing subviews. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00671">671</a> of file <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html">VectorTransferSplitRewritePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a4c2dd6fac5a93d9d6808bf8737db1cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2dd6fac5a93d9d6808bf8737db1cbb">&#9670;&nbsp;</a></span>populateVectorTransferLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorTransferLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>maxTransferRank</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[TransferReadToVectorLoadLowering] Progressive lowering of transfer_read.This pattern supports lowering of <code>vector.transfer_read</code> to a combination of <code>vector.load</code> and <code>vector.broadcast</code></p>
<p>[TransferWriteToVectorStoreLowering] Progressive lowering of transfer_write. This pattern supports lowering of <code>vector.transfer_write</code> to <code>vector.store</code></p>
<p>[VectorLoadToMemrefLoadLowering] Replace a 0-d vector.load with a memref.load + vector.broadcast.</p>
<p>[VectorStoreToMemrefStoreLowering] Replace a 0-d vector.store with a vector.extractelement + memref.store.</p>
<p>These patterns lower transfer ops to simpler ops like <code>vector.load</code>, <code>vector.store</code> and <code>vector.broadcast</code>. Only transfers with a transfer rank of a most <code>maxTransferRank</code> are lowered. This is useful when combined with VectorToSCF, which reduces the rank of vector transfer ops. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorTransfer_8cpp_source.html#l00663">663</a> of file <a class="el" href="LowerVectorTransfer_8cpp_source.html">LowerVectorTransfer.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l01883">mlir::populateVectorToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a13c619a126f79a49fafb2f76bbc67606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c619a126f79a49fafb2f76bbc67606">&#9670;&nbsp;</a></span>populateVectorTransferPermutationMapLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorTransferPermutationMapLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of transfer read/write lowering patterns that simplify the permutation map (e.g., converting it to a minor identity map) by inserting broadcasts and transposes. </p>
<p>More specifically:</p>
<p>[TransferReadPermutationLowering] Lower transfer_read op with permutation into a transfer_read with a permutation map composed of leading zeros followed by a minor identity + vector.transpose op. Ex: vector.transfer_read ... permutation_map: (d0, d1, d2) -&gt; (0, d1) into: v = vector.transfer_read ... permutation_map: (d0, d1, d2) -&gt; (d1, 0) vector.transpose v, [1, 0]</p>
<p>vector.transfer_read ... permutation_map: (d0, d1, d2, d3) -&gt; (0, 0, 0, d1, d3) into: v = vector.transfer_read ... permutation_map: (d0, d1, d2, d3) -&gt; (0, 0, d1, 0, d3) vector.transpose v, [0, 1, 3, 2, 4] Note that an alternative is to transform it to linalg.transpose + vector.transfer_read to do the transpose in memory instead.</p>
<p>[TransferWritePermutationLowering] Lower transfer_write op with permutation into a transfer_write with a minor identity permutation map. (transfer_write ops cannot have broadcasts.) Ex: vector.transfer_write v ... permutation_map: (d0, d1, d2) -&gt; (d2, d0, d1) into: tmp = vector.transpose v, [2, 0, 1] vector.transfer_write tmp ... permutation_map: (d0, d1, d2) -&gt; (d0, d1, d2)</p>
<p>vector.transfer_write v ... permutation_map: (d0, d1, d2, d3) -&gt; (d3, d2) into: tmp = vector.transpose v, [1, 0] v = vector.transfer_write tmp ... permutation_map: (d0, d1, d2, d3) -&gt; (d2, d3)</p>
<p>[TransferOpReduceRank] Lower transfer_read op with broadcast in the leading dimensions into transfer_read of lower rank + vector.broadcast. Ex: vector.transfer_read ... permutation_map: (d0, d1, d2, d3) -&gt; (0, d1, 0, d3) into: v = vector.transfer_read ... permutation_map: (d0, d1, d2, d3) -&gt; (d1, 0, d3) vector.broadcast v </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorTransfer_8cpp_source.html#l00406">406</a> of file <a class="el" href="LowerVectorTransfer_8cpp_source.html">LowerVectorTransfer.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a161fa2534b0f4f3650c70dad7d14652d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161fa2534b0f4f3650c70dad7d14652d">&#9670;&nbsp;</a></span>populateVectorTransposeLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorTransposeLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[<a class="el" href="classTransposeOpLowering.html" title="Rewrite AVX2-specific vector.transpose, for the supported cases and depending on the TransposeLowerin...">TransposeOpLowering</a>]</p>
<p>[TransposeOp2DToShuffleLowering] </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorTranspose_8cpp_source.html#l00522">522</a> of file <a class="el" href="LowerVectorTranspose_8cpp_source.html">LowerVectorTranspose.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="ae1c67458578e96f16136e500f923de76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c67458578e96f16136e500f923de76">&#9670;&nbsp;</a></span>populateVectorTransposeNarrowTypeRewritePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorTransposeNarrowTypeRewritePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for emulating a sub-byte vector transpose. </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l01262">1262</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ac2e2c03cbbc4d9435b42777340ecefaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e2c03cbbc4d9435b42777340ecefaa">&#9670;&nbsp;</a></span>populateVectorUnrollPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorUnrollPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1vector_1_1UnrollVectorOptions.html">UnrollVectorOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of pattern to unroll vector operations to a smaller shapes. </p>
<p><code>options</code> structure controls which operations are unrolled and the target shape. <code>op</code> is unrolled to the <code>targetShape</code> as follows, for each of its operands:</p><ol type="1">
<li>the unrolled type <code>unrolledVectorType</code> and number of unrolled instances <code>numUnrolledInstances</code> are computed from the <code>targetShape</code>. For now it is assumed the unrolling factors divide the vector sizes.</li>
<li>ExtractStridedSlice are created to break-up the vector operands.</li>
<li>the original op is cloned <code>numUnrolledInstances</code> times, once for each result.</li>
<li>InsertStridedSlice are inserted to re-assemble the slices into the original vectore shape.</li>
</ol>
<p>Example:</p>
<p>opA(operand0, operand1) // numUnrolledInstances = 3 </p><pre class="fragment">    operand0                   operand1
       |                          |
     fork                       fork
&lt;----------gather all fork ops ---------&gt;
      /|\                        /|\
  f00 f01 f02                f10 f11 f12
&lt;---------- clone op 3 times ---------&gt;
  opA0(f00, f10), opA1(f01, f11), opA2(f02, f12)
         \            |            /
</pre><p> &lt;-----------------&mdash; join ----------------------&mdash;&gt;</p>
<p>Other local patterns then kick in iteratively (including DCE) and compose to combine the ExtractStridedSlice/InsertStridedSlice. </p>

<p class="definition">Definition at line <a class="el" href="VectorUnroll_8cpp_source.html#l00622">622</a> of file <a class="el" href="VectorUnroll_8cpp_source.html">VectorUnroll.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a6c711eddaf2b505fc007762dc805ecf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c711eddaf2b505fc007762dc805ecf0">&#9670;&nbsp;</a></span>populateWarpExecuteOnLane0OpToScfForPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateWarpExecuteOnLane0OpToScfForPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1vector_1_1WarpExecuteOnLane0LoweringOptions.html">WarpExecuteOnLane0LoweringOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorDistribute_8cpp_source.html#l01865">1865</a> of file <a class="el" href="VectorDistribute_8cpp_source.html">VectorDistribute.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00847">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00823">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a8c3d017bb3f90cb64c531e7b6a4b0606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3d017bb3f90cb64c531e7b6a4b0606">&#9670;&nbsp;</a></span>registerBufferizableOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::registerBufferizableOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Vector_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00318">318</a> of file <a class="el" href="Vector_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html">BufferizableOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00106">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a5e106dc1b48251f4b3e11566df14078a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e106dc1b48251f4b3e11566df14078a">&#9670;&nbsp;</a></span>registerSubsetOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::registerSubsetOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SubsetOpInterfaceImpl_8cpp_source.html#l00070">70</a> of file <a class="el" href="SubsetOpInterfaceImpl_8cpp_source.html">SubsetOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00106">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a6867327b882d46f26e5f318a023508b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6867327b882d46f26e5f318a023508b9">&#9670;&nbsp;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorTransformOps_8cpp_source.html#l00237">237</a> of file <a class="el" href="VectorTransformOps_8cpp_source.html">VectorTransformOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00217">mlir::DialectRegistry::addExtensions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllExtensions_8h_source.html#l00058">mlir::registerAllExtensions()</a>.</p>

</div>
</div>
<a id="aa5d301133c3ac8bc64957d0a9eb7006a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d301133c3ac8bc64957d0a9eb7006a">&#9670;&nbsp;</a></span>registerValueBoundsOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::registerValueBoundsOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Vector_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00045">45</a> of file <a class="el" href="Vector_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html">ValueBoundsOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00210">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00106">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a86a013aa5d2cfebec7af08d05b7c7a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a013aa5d2cfebec7af08d05b7c7a24">&#9670;&nbsp;</a></span>rewriteBitCastOfTruncI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; mlir::vector::rewriteBitCastOfTruncI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector::BitCastOp&#160;</td>
          <td class="paramname"><em>bitCastOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arith::TruncIOp&#160;</td>
          <td class="paramname"><em>truncOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector::BroadcastOp&#160;</td>
          <td class="paramname"><em>maybeBroadcastOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite a vector <code>bitcast(trunci)</code> to use a more efficient sequence of vector operations comprising <code>shuffle</code> and <code>bitwise</code> ops. </p>
<p>Warning: these patterns currently only work for little endian targets. </p>

</div>
</div>
<a id="aeca0b5d1e5bdaae4f8f5b6445c8302db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca0b5d1e5bdaae4f8f5b6445c8302db">&#9670;&nbsp;</a></span>rewriteExtOfBitCast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; mlir::vector::rewriteExtOfBitCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>extOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector::BitCastOp&#160;</td>
          <td class="paramname"><em>bitCastOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector::BroadcastOp&#160;</td>
          <td class="paramname"><em>maybeBroadcastOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite a vector <code>ext(bitcast)</code> to use a more efficient sequence of vector operations comprising <code>shuffle</code> and <code>bitwise</code> ops. </p>
<p>Warning: these patterns currently only work for little endian targets. </p>

</div>
</div>
<a id="a5af92ace2e0cbd151cca52cf528a500a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af92ace2e0cbd151cca52cf528a500a">&#9670;&nbsp;</a></span>selectPassthru()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::vector::selectPassthru </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>newValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>passthru</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector select operation that picks values from <code>newValue</code> or <code>passthru</code> for each result vector lane based on <code>mask</code>. </p>
<p>This utility is used to propagate the pass-thru value for masked-out or expeculatively executed lanes. VP intrinsics do not support pass-thru values and every mask-out lane is set to poison. <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> backends are usually able to match op + select patterns and fold them into a native target instructions. </p>

</div>
</div>
<a id="a1e81512618f45b287d46448b0089ff88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e81512618f45b287d46448b0089ff88">&#9670;&nbsp;</a></span>splitFullAndPartialTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::vector::splitFullAndPartialTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorTransferOpInterface&#160;</td>
          <td class="paramname"><em>xferOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::IfOp *&#160;</td>
          <td class="paramname"><em>ifOp</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a vector.transfer operation into an in-bounds (i.e., no out-of-bounds masking) fastpath and a slowpath. </p>
<p>If <code>ifOp</code> is not null and the result is <code>success, the</code>ifOp` points to the newly created conditional upon function return. To accomodate for the fact that the original vector.transfer indexing may be arbitrary and the slow path indexes @[0...0] in the temporary buffer, the scf.if op returns a view and values of type index. At this time, only vector.transfer_read case is implemented.</p>
<p>Example (a 2-D vector.transfer_read): ``` %1 = vector.transfer_read %0[...], pad : memref&lt;A...&gt;, vector&lt;...&gt; ``` is transformed into: ``` %1:3 = scf.if (inBounds) { // fastpath, direct cast memref.cast A: memref&lt;A...&gt; to compatibleMemRefType scf.yield view : compatibleMemRefType, index, index } else { // slowpath, not in-bounds vector.transfer or linalg.copy. memref.cast alloc: memref&lt;B...&gt; to compatibleMemRefType scf.yield %4 : compatibleMemRefType, index, index */ // } /** %0 = vector.transfer_read %1#0[%1#1, %1#2] {in_bounds = [true ... true]} ``<code> where</code>alloc` is a top of the function alloca'ed buffer of one vector.</p>
<p>Preconditions:</p><ol type="1">
<li><code>xferOp.permutation_map()</code> must be a minor identity map</li>
<li>the rank of the <code>xferOp.memref()</code> and the rank of the <code>xferOp.vector()</code> must be equal. This will be relaxed in the future but requires rank-reducing subviews.</li>
</ol>
<p>For vector.transfer_read: If <code>ifOp</code> is not null and the result is <code>success, the</code>ifOp` points to the newly created conditional upon function return. To accomodate for the fact that the original vector.transfer indexing may be arbitrary and the slow path indexes @[0...0] in the temporary buffer, the scf.if op returns a view and values of type index.</p>
<p>Example (a 2-D vector.transfer_read): ``` %1 = vector.transfer_read %0[...], pad : memref&lt;A...&gt;, vector&lt;...&gt; ``` is transformed into: ``` %1:3 = scf.if (inBounds) { // fastpath, direct cast memref.cast A: memref&lt;A...&gt; to compatibleMemRefType scf.yield view : compatibleMemRefType, index, index } else { // slowpath, not in-bounds vector.transfer or linalg.copy. memref.cast alloc: memref&lt;B...&gt; to compatibleMemRefType scf.yield %4 : compatibleMemRefType, index, index */ // } /** %0 = vector.transfer_read %1#0[%1#1, %1#2] {in_bounds = [true ... true]} ``<code> where</code>alloc` is a top of the function alloca'ed buffer of one vector.</p>
<p>For vector.transfer_write: There are 2 conditional blocks. First a block to decide which memref and indices to use for an unmasked, inbounds write. Then a conditional block to further copy a partial buffer into the final result in the slow path case.</p>
<p>Example (a 2-D vector.transfer_write): ``` vector.transfer_write arg, %0[...], pad : memref&lt;A...&gt;, vector&lt;...&gt; ``` is transformed into: ``` %1:3 = scf.if (inBounds) { memref.cast A: memref&lt;A...&gt; to compatibleMemRefType scf.yield view : compatibleMemRefType, index, index } else { memref.cast alloc: memref&lt;B...&gt; to compatibleMemRefType scf.yield %4 : compatibleMemRefType, index, index } %0 = vector.transfer_write arg, %1#0[%1#1, %1#2] {in_bounds = [true ... true]} scf.if (notInBounds) { // slowpath: not in-bounds vector.transfer or linalg.copy. } ``<code> where</code>alloc` is a top of the function alloca'ed buffer of one vector.</p>
<p>Preconditions:</p><ol type="1">
<li><code>xferOp.getPermutationMap()</code> must be a minor identity map</li>
<li>the rank of the <code>xferOp.getSource()</code> and the rank of the <code>xferOp.getVector()</code> must be equal. This will be relaxed in the future but requires rank-reducing subviews. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00519">519</a> of file <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html">VectorTransferSplitRewritePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00197">mlir::clone()</a>, <a class="el" href="Builders_8cpp_source.html#l00579">mlir::OpBuilder::clone()</a>, <a class="el" href="Builders_8cpp_source.html#l00488">mlir::OpBuilder::create()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00250">createFullPartialLinalgCopy()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00303">createFullPartialVectorTransferRead()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00422">createFullPartialVectorTransferWrite()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00043">createInBoundsCond()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00161">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00443">getAutomaticAllocationScope()</a>, <a class="el" href="Builders_8cpp_source.html#l00301">mlir::Builder::getBoolArrayAttr()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00141">getCastCompatibleMemRefType()</a>, <a class="el" href="Builders_8cpp_source.html#l00152">mlir::Builder::getI64IntegerAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00095">mlir::Builder::getIndexType()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00352">getLocationToWriteFullVec()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00669">mlir::Operation::getNumRegions()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00682">mlir::Operation::getRegion()</a>, <a class="el" href="Value_8h_source.html#l00129">mlir::Value::getType()</a>, <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>, <a class="el" href="PatternMatch_8h_source.html#l00630">mlir::RewriterBase::modifyOpInPlace()</a>, <a class="el" href="MlirTblgenMain_8cpp_source.html#l00028">None</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="IR_2Operation_8h_source.html#l00577">mlir::Operation::setAttr()</a>, <a class="el" href="Builders_8h_source.html#l00406">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00439">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00113">splitFullAndPartialTransferPrecondition()</a>.</p>

</div>
</div>
<a id="a86ac1b62d7c1228fac70b59c19a63b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ac1b62d7c1228fac70b59c19a63b58">&#9670;&nbsp;</a></span>transferOpflowOpt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::transferOpflowOpt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>rootOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements transfer op write to read forwarding and dead transfer write optimizations. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00928">928</a> of file <a class="el" href="VectorTransferOpTransforms_8cpp_source.html">VectorTransferOpTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00793">mlir::Operation::walk()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 7 2024 08:32:21 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
