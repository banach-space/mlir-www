<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'polynomial' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/PolynomialDialect/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&amp;list_id=177877&amp;order=changeddate%20DESC%2Cpriority%2Cbug_severity&amp;product=MLIR&amp;query_format=specific">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'polynomial' Dialect</h1><p>The Polynomial dialect defines single-variable polynomial types and
operations.</p><p>The simplest use of <code>polynomial</code> is to represent mathematical operations in
a polynomial ring <code>R[x]</code>, where <code>R</code> is another MLIR type like <code>i32</code>.</p><p>More generally, this dialect supports representing polynomial operations in a
quotient ring <code>R[X]/(f(x))</code> for some statically fixed polynomial <code>f(x)</code>.
Two polyomials <code>p(x), q(x)</code> are considered equal in this ring if they have the
same remainder when dividing by <code>f(x)</code>. When a modulus is given, ring operations
are performed with reductions modulo <code>f(x)</code> and relative to the coefficient ring
<code>R</code>.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// A constant polynomial in a ring with i32 coefficients and no polynomial modulus
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>#ring</span> <span class=p>=</span> <span class=nv>#polynomial.ring</span><span class=p>&lt;</span><span class=nl>coefficientType=</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%a</span> <span class=p>=</span> polynomial<span class=p>.</span><span class=kt>constant</span> <span class=p>&lt;</span><span class=m>1</span> <span class=err>+</span> <span class=p>x**</span><span class=m>2</span> <span class=err>-</span> <span class=m>3x</span><span class=p>**</span><span class=m>3</span><span class=p>&gt;</span> <span class=p>:</span> polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nv>#ring</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A constant polynomial in a ring with i32 coefficients, modulo (x^1024 + 1)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>#modulus</span> <span class=p>=</span> <span class=nv>#polynomial.int_polynomial</span><span class=p>&lt;</span><span class=m>1</span> <span class=err>+</span> <span class=p>x**</span><span class=m>1024</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>#ring</span> <span class=p>=</span> <span class=nv>#polynomial.ring</span><span class=p>&lt;</span><span class=nl>coefficientType=</span><span class=k>i32</span><span class=p>,</span> <span class=nl>polynomialModulus=</span><span class=nv>#modulus</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%a</span> <span class=p>=</span> polynomial<span class=p>.</span><span class=kt>constant</span> <span class=p>&lt;</span><span class=m>1</span> <span class=err>+</span> <span class=p>x**</span><span class=m>2</span> <span class=err>-</span> <span class=m>3x</span><span class=p>**</span><span class=m>3</span><span class=p>&gt;</span> <span class=p>:</span> polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nv>#ring</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A constant polynomial in a ring with i32 coefficients, with a polynomial
</span></span></span><span class=line><span class=cl><span class=c>// modulus of (x^1024 + 1) and a coefficient modulus of 17.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>#modulus</span> <span class=p>=</span> <span class=nv>#polynomial.int_polynomial</span><span class=p>&lt;</span><span class=m>1</span> <span class=err>+</span> <span class=p>x**</span><span class=m>1024</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>#ring</span> <span class=p>=</span> <span class=nv>#polynomial.ring</span><span class=p>&lt;</span><span class=nl>coefficientType=</span><span class=k>i32</span><span class=p>,</span> <span class=nl>coefficientModulus=</span><span class=m>17</span><span class=p>:</span><span class=k>i32</span><span class=p>,</span> <span class=nl>polynomialModulus=</span><span class=nv>#modulus</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%a</span> <span class=p>=</span> polynomial<span class=p>.</span><span class=kt>constant</span> <span class=p>&lt;</span><span class=m>1</span> <span class=err>+</span> <span class=p>x**</span><span class=m>2</span> <span class=err>-</span> <span class=m>3x</span><span class=p>**</span><span class=m>3</span><span class=p>&gt;</span> <span class=p>:</span> polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nv>#ring</span><span class=p>&gt;</span>
</span></span></code></pre></div><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#polynomialadd-polynomialaddop><code>polynomial.add</code> (polynomial::AddOp)</a></li><li><a href=#polynomialconstant-polynomialconstantop><code>polynomial.constant</code> (polynomial::ConstantOp)</a></li><li><a href=#polynomialfrom_tensor-polynomialfromtensorop><code>polynomial.from_tensor</code> (polynomial::FromTensorOp)</a></li><li><a href=#polynomialintt-polynomialinttop><code>polynomial.intt</code> (polynomial::INTTOp)</a></li><li><a href=#polynomialleading_term-polynomialleadingtermop><code>polynomial.leading_term</code> (polynomial::LeadingTermOp)</a></li><li><a href=#polynomialmonic_monomial_mul-polynomialmonicmonomialmulop><code>polynomial.monic_monomial_mul</code> (polynomial::MonicMonomialMulOp)</a></li><li><a href=#polynomialmonomial-polynomialmonomialop><code>polynomial.monomial</code> (polynomial::MonomialOp)</a></li><li><a href=#polynomialmul-polynomialmulop><code>polynomial.mul</code> (polynomial::MulOp)</a></li><li><a href=#polynomialmul_scalar-polynomialmulscalarop><code>polynomial.mul_scalar</code> (polynomial::MulScalarOp)</a></li><li><a href=#polynomialntt-polynomialnttop><code>polynomial.ntt</code> (polynomial::NTTOp)</a></li><li><a href=#polynomialsub-polynomialsubop><code>polynomial.sub</code> (polynomial::SubOp)</a></li><li><a href=#polynomialto_tensor-polynomialtotensorop><code>polynomial.to_tensor</code> (polynomial::ToTensorOp)</a></li></ul></li><li><a href=#attributes-3>Attributes</a><ul><li><a href=#floatpolynomialattr>FloatPolynomialAttr</a></li><li><a href=#intpolynomialattr>IntPolynomialAttr</a></li><li><a href=#primitiverootattr>PrimitiveRootAttr</a></li><li><a href=#ringattr>RingAttr</a></li><li><a href=#typedfloatpolynomialattr>TypedFloatPolynomialAttr</a></li><li><a href=#typedintpolynomialattr>TypedIntPolynomialAttr</a></li></ul></li><li><a href=#types>Types</a><ul><li><a href=#polynomialtype>PolynomialType</a></li></ul></li></ul></nav><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/Polynomial/IR/Polynomial.td>source</a></p><h3 id=polynomialadd-polynomialaddop><code>polynomial.add</code> (polynomial::AddOp)&nbsp;<a class=headline-hash href=#polynomialadd-polynomialaddop>¶</a></h3><p><em>Addition operation between polynomials.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.add` operands attr-dict `:` type($result)
</code></pre><p>Performs polynomial addition on the operands. The operands may be single
polynomials or containers of identically-typed polynomials, i.e., polynomials
from the same underlying ring with the same coefficient types.</p><p>Addition is defined to occur in the ring defined by the ring attribute of
the two operands, meaning the addition is taken modulo the coefficientModulus
and the polynomialModulus of the ring.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// add two polynomials modulo x^1024 - 1
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>#poly</span> <span class=p>=</span> <span class=nv>#polynomial.int_polynomial</span><span class=p>&lt;x**</span><span class=m>1024</span> <span class=err>-</span> <span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>#ring</span> <span class=p>=</span> <span class=nv>#polynomial.ring</span><span class=p>&lt;</span><span class=nl>coefficientType=</span><span class=k>i32</span><span class=p>,</span> <span class=nl>coefficientModulus=</span><span class=m>65536</span><span class=p>:</span><span class=k>i32</span><span class=p>,</span> <span class=nl>polynomialModulus=</span><span class=nv>#poly</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> polynomial<span class=p>.</span><span class=kt>constant</span> int<span class=p>&lt;</span><span class=m>1</span> <span class=err>+</span> <span class=p>x**</span><span class=m>2</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nv>#ring</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> polynomial<span class=p>.</span><span class=kt>constant</span> int<span class=p>&lt;x**</span><span class=m>5</span> <span class=err>-</span> <span class=p>x</span> <span class=err>+</span> <span class=m>1</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nv>#ring</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> polynomial<span class=p>.</span>add <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nv>#ring</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>polynomial-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>polynomial-like</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>polynomial-like</td></tr></tbody></table><h3 id=polynomialconstant-polynomialconstantop><code>polynomial.constant</code> (polynomial::ConstantOp)&nbsp;<a class=headline-hash href=#polynomialconstant-polynomialconstantop>¶</a></h3><p><em>Define a constant polynomial via an attribute.</em></p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=p>!</span><span class=nl>int_poly_ty =</span> <span class=p>!</span>polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nl>ring=</span><span class=p>&lt;</span><span class=nl>coefficientType=</span><span class=k>i32</span><span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> polynomial<span class=p>.</span><span class=kt>constant</span> int<span class=p>&lt;</span><span class=m>1</span> <span class=err>+</span> <span class=p>x**</span><span class=m>2</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>int_poly_ty
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>!</span><span class=nl>float_poly_ty =</span> <span class=p>!</span>polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nl>ring=</span><span class=p>&lt;</span><span class=nl>coefficientType=</span><span class=k>f32</span><span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> polynomial<span class=p>.</span><span class=kt>constant</span> float<span class=p>&lt;</span><span class=m>0.5</span> <span class=err>+</span> <span class=m>1.3e06</span> <span class=p>x**</span><span class=m>2</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>float_poly_ty
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferTypeOpAdaptor</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::Attribute</td><td>a typed float_polynomial or a typed int_polynomial</td></tr></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An element of a polynomial ring.</td></tr></tbody></table><h3 id=polynomialfrom_tensor-polynomialfromtensorop><code>polynomial.from_tensor</code> (polynomial::FromTensorOp)&nbsp;<a class=headline-hash href=#polynomialfrom_tensor-polynomialfromtensorop>¶</a></h3><p><em>Creates a polynomial from integer coefficients stored in a tensor.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.from_tensor` $input attr-dict `:` type($input) `-&gt;` type($output)
</code></pre><p><code>polynomial.from_tensor</code> creates a polynomial value from a tensor of coefficients.
The input tensor must list the coefficients in degree-increasing order.</p><p>The input one-dimensional tensor may have size at most the degree of the
ring&rsquo;s polynomialModulus generator polynomial, with smaller dimension implying that
all higher-degree terms have coefficient zero.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>#poly</span> <span class=p>=</span> <span class=nv>#polynomial.int_polynomial</span><span class=p>&lt;x**</span><span class=m>1024</span> <span class=err>-</span> <span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>#ring</span> <span class=p>=</span> <span class=nv>#polynomial.ring</span><span class=p>&lt;</span><span class=nl>coefficientType=</span><span class=k>i32</span><span class=p>,</span> <span class=nl>coefficientModulus=</span><span class=m>65536</span><span class=p>:</span><span class=k>i32</span><span class=p>,</span> <span class=nl>polynomialModulus=</span><span class=nv>#poly</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%two</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>2</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%five</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>5</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%coeffs</span> <span class=p>=</span> <span class=kt>tensor</span><span class=p>.</span>from_elements <span class=nv>%two</span><span class=p>,</span> <span class=nv>%two</span><span class=p>,</span> <span class=nv>%five</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%poly</span> <span class=p>=</span> polynomial<span class=p>.</span>from_tensor <span class=nv>%coeffs</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nv>#ring</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>ranked tensor of integer values</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An element of a polynomial ring.</td></tr></tbody></table><h3 id=polynomialintt-polynomialinttop><code>polynomial.intt</code> (polynomial::INTTOp)&nbsp;<a class=headline-hash href=#polynomialintt-polynomialinttop>¶</a></h3><p><em>Computes the reverse integer Number Theoretic Transform (NTT).</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.intt` $input attr-dict `:` qualified(type($input)) `-&gt;` type($output)
</code></pre><p><code>polynomial.intt</code> computes the reverse integer Number Theoretic Transform
(INTT) on the input tensor. This is the inverse operation of the
<code>polynomial.ntt</code> operation.</p><p>The input tensor is interpreted as a point-value representation of the
output polynomial at powers of a primitive <code>n</code>-th root of unity (see
<code>polynomial.ntt</code>). The ring of the polynomial is taken from the required
encoding attribute of the tensor.</p><p>The choice of primitive root may be optionally specified.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>root</code></td><td>::mlir::polynomial::PrimitiveRootAttr</td><td><details><summary>an attribute containing an integer and its degree as a root of unity</summary><pre><code>A primitive root attribute stores an integer root `value` and an integer
`degree`, corresponding to a primitive root of unity of the given degree in
an unspecified ring.
<p>This is used as an attribute on <code>polynomial.ntt</code> and <code>polynomial.intt</code> ops
to specify the root of unity used in lowering the transform.</p>
<p>Example:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>#poly</span> <span class=p>=</span> <span class=nv>#polynomial.primitive_root</span><span class=err>&amp;</span>lt<span class=err>;</span><span class=nl>value=</span><span class=m>123</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> degree <span class=p>:</span> <span class=m>7</span> <span class=k>index</span><span class=err>&amp;</span>gt<span class=err>;</span>
</span></span></code></pre></div><p></code></pre></p></details></td></tr></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>ranked tensor of integer values</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An element of a polynomial ring.</td></tr></tbody></table><h3 id=polynomialleading_term-polynomialleadingtermop><code>polynomial.leading_term</code> (polynomial::LeadingTermOp)&nbsp;<a class=headline-hash href=#polynomialleading_term-polynomialleadingtermop>¶</a></h3><p><em>Compute the leading term of the polynomial.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.leading_term` operands attr-dict `:` type($input) `-&gt;` `(` type($degree) `,` type($coefficient) `)`
</code></pre><p>The degree of a polynomial is the largest $k$ for which the coefficient
<code>a_k</code> of <code>x^k</code> is nonzero. The leading term is the term <code>a_k * x^k</code>, which
this op represents as a pair of results. The first is the degree <code>k</code> as an
index, and the second is the coefficient, whose type matches the
coefficient type of the polynomial&rsquo;s ring attribute.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>#poly</span> <span class=p>=</span> <span class=nv>#polynomial.int_polynomial</span><span class=p>&lt;x**</span><span class=m>1024</span> <span class=err>-</span> <span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>#ring</span> <span class=p>=</span> <span class=nv>#polynomial.ring</span><span class=p>&lt;</span><span class=nl>coefficientType=</span><span class=k>i32</span><span class=p>,</span> <span class=nl>coefficientModulus=</span><span class=m>65536</span><span class=p>:</span><span class=k>i32</span><span class=p>,</span> <span class=nl>polynomialModulus=</span><span class=nv>#poly</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> polynomial<span class=p>.</span><span class=kt>constant</span> int<span class=p>&lt;</span><span class=m>1</span> <span class=err>+</span> <span class=p>x**</span><span class=m>2</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nv>#ring</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>=</span> polynomial<span class=p>.</span>leading_term <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nv>#ring</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>An element of a polynomial ring.</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>degree</code></td><td>index</td></tr><tr><td style=text-align:center><code>coefficient</code></td><td>integer</td></tr></tbody></table><h3 id=polynomialmonic_monomial_mul-polynomialmonicmonomialmulop><code>polynomial.monic_monomial_mul</code> (polynomial::MonicMonomialMulOp)&nbsp;<a class=headline-hash href=#polynomialmonic_monomial_mul-polynomialmonicmonomialmulop>¶</a></h3><p><em>Multiply a polynomial by a monic monomial.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.monic_monomial_mul` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Multiply a polynomial by a monic monomial, meaning a polynomial of the form
<code>1 * x^k</code> for an index operand <code>k</code>.</p><p>In some special rings of polynomials, such as a ring of polynomials
modulo <code>x^n - 1</code>, <code>monomial_mul</code> can be interpreted as a cyclic shift of
the coefficients of the polynomial. For some rings, this results in
optimized lowerings that involve rotations and rescaling of the
coefficients of the input.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>polynomial-like</td></tr><tr><td style=text-align:center><code>monomialDegree</code></td><td>index</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>polynomial-like</td></tr></tbody></table><h3 id=polynomialmonomial-polynomialmonomialop><code>polynomial.monomial</code> (polynomial::MonomialOp)&nbsp;<a class=headline-hash href=#polynomialmonomial-polynomialmonomialop>¶</a></h3><p><em>Create a polynomial that consists of a single monomial.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.monomial` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Construct a polynomial that consists of a single monomial term, from its
degree and coefficient as dynamic inputs.</p><p>The coefficient type of the output polynomial&rsquo;s ring attribute must match
the <code>coefficient</code> input type.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>#poly</span> <span class=p>=</span> <span class=nv>#polynomial.int_polynomial</span><span class=p>&lt;x**</span><span class=m>1024</span> <span class=err>-</span> <span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>#ring</span> <span class=p>=</span> <span class=nv>#polynomial.ring</span><span class=p>&lt;</span><span class=nl>coefficientType=</span><span class=k>i32</span><span class=p>,</span> <span class=nl>coefficientModulus=</span><span class=m>65536</span><span class=p>:</span><span class=k>i32</span><span class=p>,</span> <span class=nl>polynomialModulus=</span><span class=nv>#poly</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%deg</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>1023</span> <span class=p>:</span> <span class=k>index</span>
</span></span><span class=line><span class=cl><span class=nv>%five</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>5</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> polynomial<span class=p>.</span>monomial <span class=nv>%five</span><span class=p>,</span> <span class=nv>%deg</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nv>#ring</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>coefficient</code></td><td>integer</td></tr><tr><td style=text-align:center><code>degree</code></td><td>index</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An element of a polynomial ring.</td></tr></tbody></table><h3 id=polynomialmul-polynomialmulop><code>polynomial.mul</code> (polynomial::MulOp)&nbsp;<a class=headline-hash href=#polynomialmul-polynomialmulop>¶</a></h3><p><em>Multiplication operation between polynomials.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.mul` operands attr-dict `:` type($result)
</code></pre><p>Performs polynomial multiplication on the operands. The operands may be single
polynomials or containers of identically-typed polynomials, i.e., polynomials
from the same underlying ring with the same coefficient types.</p><p>Multiplication is defined to occur in the ring defined by the ring attribute of
the two operands, meaning the multiplication is taken modulo the coefficientModulus
and the polynomialModulus of the ring.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// multiply two polynomials modulo x^1024 - 1
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>#poly</span> <span class=p>=</span> <span class=nv>#polynomial.int_polynomial</span><span class=p>&lt;x**</span><span class=m>1024</span> <span class=err>-</span> <span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>#ring</span> <span class=p>=</span> <span class=nv>#polynomial.ring</span><span class=p>&lt;</span><span class=nl>coefficientType=</span><span class=k>i32</span><span class=p>,</span> <span class=nl>coefficientModulus=</span><span class=m>65536</span><span class=p>:</span><span class=k>i32</span><span class=p>,</span> <span class=nl>polynomialModulus=</span><span class=nv>#poly</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> polynomial<span class=p>.</span><span class=kt>constant</span> int<span class=p>&lt;</span><span class=m>1</span> <span class=err>+</span> <span class=p>x**</span><span class=m>2</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nv>#ring</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> polynomial<span class=p>.</span><span class=kt>constant</span> int<span class=p>&lt;x**</span><span class=m>5</span> <span class=err>-</span> <span class=p>x</span> <span class=err>+</span> <span class=m>1</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nv>#ring</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> polynomial<span class=p>.</span>mul <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nv>#ring</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>polynomial-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>polynomial-like</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>polynomial-like</td></tr></tbody></table><h3 id=polynomialmul_scalar-polynomialmulscalarop><code>polynomial.mul_scalar</code> (polynomial::MulScalarOp)&nbsp;<a class=headline-hash href=#polynomialmul_scalar-polynomialmulscalarop>¶</a></h3><p><em>Multiplication by a scalar of the field.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.mul_scalar` operands attr-dict `:` type($polynomial) `,` type($scalar)
</code></pre><p>Multiplies the polynomial operand&rsquo;s coefficients by a given scalar value.
The operation is defined to occur in the ring defined by the ring attribute
of the two operands, meaning the multiplication is taken modulo the
coefficientModulus of the ring.</p><p>The <code>scalar</code> input must have the same type as the polynomial ring&rsquo;s
coefficientType.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// multiply two polynomials modulo x^1024 - 1
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>#poly</span> <span class=p>=</span> <span class=nv>#polynomial.int_polynomial</span><span class=p>&lt;x**</span><span class=m>1024</span> <span class=err>-</span> <span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>#ring</span> <span class=p>=</span> <span class=nv>#polynomial.ring</span><span class=p>&lt;</span><span class=nl>coefficientType=</span><span class=k>i32</span><span class=p>,</span> <span class=nl>coefficientModulus=</span><span class=m>65536</span><span class=p>:</span><span class=k>i32</span><span class=p>,</span> <span class=nl>polynomialModulus=</span><span class=nv>#poly</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> polynomial<span class=p>.</span><span class=kt>constant</span> int<span class=p>&lt;</span><span class=m>1</span> <span class=err>+</span> <span class=p>x**</span><span class=m>2</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nv>#ring</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>3</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> polynomial<span class=p>.</span>mul_scalar <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nv>#ring</span><span class=p>&gt;,</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>polynomial</code></td><td>polynomial-like</td></tr><tr><td style=text-align:center><code>scalar</code></td><td>integer</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>polynomial-like</td></tr></tbody></table><h3 id=polynomialntt-polynomialnttop><code>polynomial.ntt</code> (polynomial::NTTOp)&nbsp;<a class=headline-hash href=#polynomialntt-polynomialnttop>¶</a></h3><p><em>Computes point-value tensor representation of a polynomial.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.ntt` $input attr-dict `:` qualified(type($input)) `-&gt;` type($output)
</code></pre><p><code>polynomial.ntt</code> computes the forward integer Number Theoretic Transform
(NTT) on the input polynomial. It returns a tensor containing a point-value
representation of the input polynomial. The output tensor has shape equal
to the degree of the ring&rsquo;s <code>polynomialModulus</code>. The polynomial&rsquo;s RingAttr
is embedded as the encoding attribute of the output tensor.</p><p>Given an input polynomial <code>F(x)</code> over a ring whose <code>polynomialModulus</code> has
degree <code>n</code>, and a primitive <code>n</code>-th root of unity <code>omega_n</code>, the output is
the list of $n$ evaluations</p><p><code>f[k] = F(omega[n]^k) ; k = {0, ..., n-1}</code></p><p>The choice of primitive root may be optionally specified.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>root</code></td><td>::mlir::polynomial::PrimitiveRootAttr</td><td><details><summary>an attribute containing an integer and its degree as a root of unity</summary><pre><code>A primitive root attribute stores an integer root `value` and an integer
`degree`, corresponding to a primitive root of unity of the given degree in
an unspecified ring.
<p>This is used as an attribute on <code>polynomial.ntt</code> and <code>polynomial.intt</code> ops
to specify the root of unity used in lowering the transform.</p>
<p>Example:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>#poly</span> <span class=p>=</span> <span class=nv>#polynomial.primitive_root</span><span class=err>&amp;</span>lt<span class=err>;</span><span class=nl>value=</span><span class=m>123</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> degree <span class=p>:</span> <span class=m>7</span> <span class=k>index</span><span class=err>&amp;</span>gt<span class=err>;</span>
</span></span></code></pre></div><p></code></pre></p></details></td></tr></table><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>An element of a polynomial ring.</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ranked tensor of integer values</td></tr></tbody></table><h3 id=polynomialsub-polynomialsubop><code>polynomial.sub</code> (polynomial::SubOp)&nbsp;<a class=headline-hash href=#polynomialsub-polynomialsubop>¶</a></h3><p><em>Subtraction operation between polynomials.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.sub` operands attr-dict `:` type($result)
</code></pre><p>Performs polynomial subtraction on the operands. The operands may be single
polynomials or containers of identically-typed polynomials, i.e., polynomials
from the same underlying ring with the same coefficient types.</p><p>Subtraction is defined to occur in the ring defined by the ring attribute of
the two operands, meaning the subtraction is taken modulo the coefficientModulus
and the polynomialModulus of the ring.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// subtract two polynomials modulo x^1024 - 1
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>#poly</span> <span class=p>=</span> <span class=nv>#polynomial.int_polynomial</span><span class=p>&lt;x**</span><span class=m>1024</span> <span class=err>-</span> <span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>#ring</span> <span class=p>=</span> <span class=nv>#polynomial.ring</span><span class=p>&lt;</span><span class=nl>coefficientType=</span><span class=k>i32</span><span class=p>,</span> <span class=nl>coefficientModulus=</span><span class=m>65536</span><span class=p>:</span><span class=k>i32</span><span class=p>,</span> <span class=nl>polynomialModulus=</span><span class=nv>#poly</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> polynomial<span class=p>.</span><span class=kt>constant</span> int<span class=p>&lt;</span><span class=m>1</span> <span class=err>+</span> <span class=p>x**</span><span class=m>2</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nv>#ring</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> polynomial<span class=p>.</span><span class=kt>constant</span> int<span class=p>&lt;x**</span><span class=m>5</span> <span class=err>-</span> <span class=p>x</span> <span class=err>+</span> <span class=m>1</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nv>#ring</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> polynomial<span class=p>.</span>sub <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nv>#ring</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>polynomial-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>polynomial-like</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>polynomial-like</td></tr></tbody></table><h3 id=polynomialto_tensor-polynomialtotensorop><code>polynomial.to_tensor</code> (polynomial::ToTensorOp)&nbsp;<a class=headline-hash href=#polynomialto_tensor-polynomialtotensorop>¶</a></h3><p><em>Creates a tensor containing the coefficients of a polynomial.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.to_tensor` $input attr-dict `:` type($input) `-&gt;` type($output)
</code></pre><p><code>polynomial.to_tensor</code> creates a dense tensor value containing the
coefficients of the input polynomial. The output tensor contains the
coefficients in degree-increasing order.</p><p>Operations that act on the coefficients of a polynomial, such as extracting
a specific coefficient or extracting a range of coefficients, should be
implemented by composing <code>to_tensor</code> with the relevant <code>tensor</code> dialect
ops.</p><p>The output tensor has shape equal to the degree of the polynomial ring
attribute&rsquo;s polynomialModulus, including zeroes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>#poly</span> <span class=p>=</span> <span class=nv>#polynomial.int_polynomial</span><span class=p>&lt;x**</span><span class=m>1024</span> <span class=err>-</span> <span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>#ring</span> <span class=p>=</span> <span class=nv>#polynomial.ring</span><span class=p>&lt;</span><span class=nl>coefficientType=</span><span class=k>i32</span><span class=p>,</span> <span class=nl>coefficientModulus=</span><span class=m>65536</span><span class=p>:</span><span class=k>i32</span><span class=p>,</span> <span class=nl>polynomialModulus=</span><span class=nv>#poly</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%two</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>2</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%five</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>5</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%coeffs</span> <span class=p>=</span> <span class=kt>tensor</span><span class=p>.</span>from_elements <span class=nv>%two</span><span class=p>,</span> <span class=nv>%two</span><span class=p>,</span> <span class=nv>%five</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%poly</span> <span class=p>=</span> polynomial<span class=p>.</span>from_tensor <span class=nv>%coeffs</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nv>#ring</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%tensor</span> <span class=p>=</span> polynomial<span class=p>.</span>to_tensor <span class=nv>%poly</span> <span class=p>:</span> <span class=p>!</span>polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nv>#ring</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>1024x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>An element of a polynomial ring.</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ranked tensor of integer values</td></tr></tbody></table><h2 id=attributes-3>Attributes&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h2><h3 id=floatpolynomialattr>FloatPolynomialAttr&nbsp;<a class=headline-hash href=#floatpolynomialattr>¶</a></h3><p>an attribute containing a single-variable polynomial with double precision floating point coefficients</p><p>A polynomial attribute represents a single-variable polynomial with double
precision floating point coefficients.</p><p>The polynomial must be expressed as a list of monomial terms, with addition
or subtraction between them. The choice of variable name is arbitrary, but
must be consistent across all the monomials used to define a single
attribute. The order of monomial terms is arbitrary, each monomial degree
must occur at most once.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>#poly</span> <span class=p>=</span> <span class=nv>#polynomial.float_polynomial</span><span class=p>&lt;</span><span class=m>0.5</span> <span class=p>x**</span><span class=m>7</span> <span class=err>+</span> <span class=m>1.5</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>polynomial</td><td style=text-align:center><code>FloatPolynomial</code></td><td></td></tr></tbody></table><h3 id=intpolynomialattr>IntPolynomialAttr&nbsp;<a class=headline-hash href=#intpolynomialattr>¶</a></h3><p>an attribute containing a single-variable polynomial with integer coefficients</p><p>A polynomial attribute represents a single-variable polynomial with integer
coefficients, which is used to define the modulus of a <code>RingAttr</code>, as well
as to define constants and perform constant folding for <code>polynomial</code> ops.</p><p>The polynomial must be expressed as a list of monomial terms, with addition
or subtraction between them. The choice of variable name is arbitrary, but
must be consistent across all the monomials used to define a single
attribute. The order of monomial terms is arbitrary, each monomial degree
must occur at most once.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>#poly</span> <span class=p>=</span> <span class=nv>#polynomial.int_polynomial</span><span class=p>&lt;x**</span><span class=m>1024</span> <span class=err>+</span> <span class=m>1</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-1>Parameters:&nbsp;<a class=headline-hash href=#parameters-1>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>polynomial</td><td style=text-align:center><code>::mlir::polynomial::IntPolynomial</code></td><td></td></tr></tbody></table><h3 id=primitiverootattr>PrimitiveRootAttr&nbsp;<a class=headline-hash href=#primitiverootattr>¶</a></h3><p>an attribute containing an integer and its degree as a root of unity</p><p>Syntax:</p><pre tabindex=0><code>#polynomial.primitive_root&lt;
  ::mlir::IntegerAttr,   # value
  ::mlir::IntegerAttr   # degree
&gt;
</code></pre><p>A primitive root attribute stores an integer root <code>value</code> and an integer
<code>degree</code>, corresponding to a primitive root of unity of the given degree in
an unspecified ring.</p><p>This is used as an attribute on <code>polynomial.ntt</code> and <code>polynomial.intt</code> ops
to specify the root of unity used in lowering the transform.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>#poly</span> <span class=p>=</span> <span class=nv>#polynomial.primitive_root</span><span class=p>&lt;</span><span class=nl>value=</span><span class=m>123</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> degree <span class=p>:</span> <span class=m>7</span> <span class=k>index</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-2>Parameters:&nbsp;<a class=headline-hash href=#parameters-2>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::IntegerAttr</code></td><td></td></tr><tr><td style=text-align:center>degree</td><td style=text-align:center><code>::mlir::IntegerAttr</code></td><td></td></tr></tbody></table><h3 id=ringattr>RingAttr&nbsp;<a class=headline-hash href=#ringattr>¶</a></h3><p>an attribute specifying a polynomial ring</p><p>Syntax:</p><pre tabindex=0><code>#polynomial.ring&lt;
  Type,   # coefficientType
  ::mlir::IntegerAttr,   # coefficientModulus
  ::mlir::polynomial::IntPolynomialAttr   # polynomialModulus
&gt;
</code></pre><p>A ring describes the domain in which polynomial arithmetic occurs. The ring
attribute in <code>polynomial</code> represents the more specific case of polynomials
with a single indeterminate; whose coefficients can be represented by
another MLIR type (<code>coefficientType</code>); and, if the coefficient type is
integral, whose coefficients are taken modulo some statically known modulus
(<code>coefficientModulus</code>).</p><p>Additionally, a polynomial ring can specify a <em>polynomialModulus</em>, which converts
polynomial arithmetic to the analogue of modular integer arithmetic, where
each polynomial is represented as its remainder when dividing by the
modulus. For single-variable polynomials, an &ldquo;polynomialModulus&rdquo; is always specificed
via a single polynomial, which we call <code>polynomialModulus</code>.</p><p>An expressive example is polynomials with i32 coefficients, whose
coefficients are taken modulo <code>2**32 - 5</code>, with a polynomial modulus of
<code>x**1024 - 1</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>#poly_mod</span> <span class=p>=</span> <span class=nv>#polynomial.int_polynomial</span><span class=p>&lt;</span><span class=m>-1</span> <span class=err>+</span> <span class=p>x**</span><span class=m>1024</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>#ring</span> <span class=p>=</span> <span class=nv>#polynomial.ring</span><span class=p>&lt;</span><span class=nl>coefficientType=</span><span class=k>i32</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                         <span class=nl>coefficientModulus=</span><span class=m>4294967291</span><span class=p>:</span><span class=k>i32</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                         <span class=nl>polynomialModulus=</span><span class=nv>#poly_mod</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nv>#ring</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>In this case, the value of a polynomial is always &ldquo;converted&rdquo; to a
canonical form by applying repeated reductions by setting <code>x**1024 = 1</code>
and simplifying.</p><p>The coefficient and polynomial modulus parameters are optional, and the
coefficient modulus is only allowed if the coefficient type is integral.</p><p>The coefficient modulus, if specified, should be positive and not larger
than <code>2 ** width(coefficientType)</code>.</p><p>If the coefficient modulus is not specified, the handling of coefficients
overflows is determined by subsequent lowering passes, which may choose to
wrap around or widen the overflow at their discretion.</p><p>Note that coefficient modulus is contained in <code>i64</code> by default, which is signed.
To specify a 64 bit number without intepreting it as a negative number, its container
type should be manually specified like <code>coefficientModulus=18446744073709551615:i128</code>.</p><h4 id=parameters-3>Parameters:&nbsp;<a class=headline-hash href=#parameters-3>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>coefficientType</td><td style=text-align:center><code>Type</code></td><td></td></tr><tr><td style=text-align:center>coefficientModulus</td><td style=text-align:center><code>::mlir::IntegerAttr</code></td><td></td></tr><tr><td style=text-align:center>polynomialModulus</td><td style=text-align:center><code>::mlir::polynomial::IntPolynomialAttr</code></td><td></td></tr></tbody></table><h3 id=typedfloatpolynomialattr>TypedFloatPolynomialAttr&nbsp;<a class=headline-hash href=#typedfloatpolynomialattr>¶</a></h3><p>a typed float_polynomial</p><p>Syntax:</p><pre tabindex=0><code>#polynomial.typed_float_polynomial&lt;
  ::mlir::Type,   # type
  ::mlir::polynomial::FloatPolynomialAttr   # value
&gt;
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=p>!</span><span class=nl>poly_ty =</span> <span class=p>!</span>polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nl>ring=</span><span class=p>&lt;</span><span class=nl>coefficientType=</span><span class=k>f32</span><span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>#poly</span> <span class=p>=</span> float<span class=p>&lt;</span><span class=m>1.4</span> <span class=p>x**</span><span class=m>7</span> <span class=err>+</span> <span class=m>4.5</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>poly_ty
</span></span><span class=line><span class=cl><span class=nv>#poly_verbose</span> <span class=p>=</span> <span class=nv>#polynomial.typed_float_polynomial</span><span class=p>&lt;</span><span class=m>1.4</span> <span class=p>x**</span><span class=m>7</span> <span class=err>+</span> <span class=m>4.5</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>poly_ty
</span></span></code></pre></div><h4 id=parameters-4>Parameters:&nbsp;<a class=headline-hash href=#parameters-4>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::polynomial::FloatPolynomialAttr</code></td><td></td></tr></tbody></table><h3 id=typedintpolynomialattr>TypedIntPolynomialAttr&nbsp;<a class=headline-hash href=#typedintpolynomialattr>¶</a></h3><p>a typed int_polynomial</p><p>Syntax:</p><pre tabindex=0><code>#polynomial.typed_int_polynomial&lt;
  ::mlir::Type,   # type
  ::mlir::polynomial::IntPolynomialAttr   # value
&gt;
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=p>!</span><span class=nl>poly_ty =</span> <span class=p>!</span>polynomial<span class=p>.</span>polynomial<span class=p>&lt;</span><span class=nl>ring=</span><span class=p>&lt;</span><span class=nl>coefficientType=</span><span class=k>i32</span><span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>#poly</span> <span class=p>=</span> int<span class=p>&lt;</span><span class=m>1 x</span><span class=p>**</span><span class=m>7</span> <span class=err>+</span> <span class=m>4</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>poly_ty
</span></span><span class=line><span class=cl><span class=nv>#poly_verbose</span> <span class=p>=</span> <span class=nv>#polynomial.typed_int_polynomial</span><span class=p>&lt;</span><span class=m>1 x</span><span class=p>**</span><span class=m>7</span> <span class=err>+</span> <span class=m>4</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>poly_ty
</span></span></code></pre></div><h4 id=parameters-5>Parameters:&nbsp;<a class=headline-hash href=#parameters-5>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::polynomial::IntPolynomialAttr</code></td><td></td></tr></tbody></table><h2 id=types>Types&nbsp;<a class=headline-hash href=#types>¶</a></h2><h3 id=polynomialtype>PolynomialType&nbsp;<a class=headline-hash href=#polynomialtype>¶</a></h3><p>An element of a polynomial ring.</p><p>Syntax:</p><pre tabindex=0><code>!polynomial.polynomial&lt;
  ::mlir::polynomial::RingAttr   # ring
&gt;
</code></pre><p>A type for polynomials in a polynomial quotient ring.</p><h4 id=parameters-6>Parameters:&nbsp;<a class=headline-hash href=#parameters-6>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>ring</td><td style=text-align:center><code>::mlir::polynomial::RingAttr</code></td><td>an attribute specifying a polynomial ring</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/PDLOps/ title="'pdl' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'pdl' Dialect</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/PtrOps/ title="'ptr' Dialect">Next - 'ptr' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/QuantPasses/></a></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/DLTITransformOps/></a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Mesh/>'mesh' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/PolynomialDialect/>'polynomial' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>